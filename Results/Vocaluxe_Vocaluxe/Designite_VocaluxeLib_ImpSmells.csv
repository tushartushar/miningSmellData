Implementation smell,Namespace,Class,File,Method,Description
Long Method,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The method has 202 lines of code.
Long Method,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleMouse,The method has 151 lines of code.
Long Method,VocaluxeLib.Menu,CParticle,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticle.cs,Update,The method has 100 lines of code.
Long Method,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The method has 103 lines of code.
Long Method,VocaluxeLib.Menu,CPlaylist,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CPlaylist.cs,HandleInput,The method has 281 lines of code.
Long Method,VocaluxeLib.Menu,CPlaylist,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CPlaylist.cs,HandleMouse,The method has 223 lines of code.
Long Method,VocaluxeLib.Xml,CXmlDeserializer,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CXmlDeserializer.cs,_GetValue,The method has 105 lines of code.
Long Method,VocaluxeLib.Xml,CXmlDeserializer,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CXmlDeserializer.cs,_ReadChildNodes,The method has 103 lines of code.
Long Method,VocaluxeLib.Menu.SongMenu,CSongMenuList,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuList.cs,HandleInput,The method has 101 lines of code.
Long Method,VocaluxeLib.Menu.SongMenu,CSongMenuTileBoard,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuTileBoard.cs,HandleInput,The method has 101 lines of code.
Long Method,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ReadHeader,The method has 336 lines of code.
Long Method,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ReadNotes,The method has 226 lines of code.
Complex Method,VocaluxeLib.Menu,CBackground,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CBackground.cs,_DrawSlideShow,Cyclomatic complexity of the method is 9
Complex Method,VocaluxeLib.Menu,CEqualizer,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CEqualizer.cs,Update,Cyclomatic complexity of the method is 8
Complex Method,VocaluxeLib.Menu,CMenu,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenu.cs,LoadTheme,Cyclomatic complexity of the method is 18
Complex Method,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleMouse,Cyclomatic complexity of the method is 20
Complex Method,VocaluxeLib.Menu,CObjectInteractions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CObjectInteractions.cs,Draw,Cyclomatic complexity of the method is 8
Complex Method,VocaluxeLib.Menu,CObjectInteractions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CObjectInteractions.cs,_GetNextElement,Cyclomatic complexity of the method is 13
Complex Method,VocaluxeLib.Menu,CParticle,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticle.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,Cyclomatic complexity of the method is 11
Complex Method,VocaluxeLib.Menu,CPlaylist,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CPlaylist.cs,HandleMouse,Cyclomatic complexity of the method is 11
Complex Method,VocaluxeLib.Menu,CPlaylist,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CPlaylist.cs,_UpdateRect,Cyclomatic complexity of the method is 21
Complex Method,VocaluxeLib.Menu,CSelectSlide,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CSelectSlide.cs,_Revalidate,Cyclomatic complexity of the method is 9
Complex Method,VocaluxeLib.Menu,CSelectSlide,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CSelectSlide.cs,Draw,Cyclomatic complexity of the method is 9
Complex Method,VocaluxeLib.Menu,CSelectSlide,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CSelectSlide.cs,ResizeElement,Cyclomatic complexity of the method is 10
Complex Method,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,Draw,Cyclomatic complexity of the method is 14
Complex Method,VocaluxeLib.Menu,CStatic,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CStatic.cs,Draw,Cyclomatic complexity of the method is 8
Complex Method,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,Draw,Cyclomatic complexity of the method is 16
Complex Method,VocaluxeLib.Menu.SingNotes,CSingNotes,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CSingNotes.cs,Init,Cyclomatic complexity of the method is 8
Complex Method,VocaluxeLib.Xml,CTypeExtensions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CTypeExtensions.cs,_FillInfo,Cyclomatic complexity of the method is 10
Complex Method,VocaluxeLib.Xml,CXmlDeserializer,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CXmlDeserializer.cs,_GetValue,Cyclomatic complexity of the method is 26
Complex Method,VocaluxeLib.Xml,CXmlDeserializer,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CXmlDeserializer.cs,_ReadChildNodes,Cyclomatic complexity of the method is 15
Complex Method,VocaluxeLib.Menu.SongMenu,CSongMenuList,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuList.cs,HandleMouse,Cyclomatic complexity of the method is 11
Complex Method,VocaluxeLib.Menu.SongMenu,CSongMenuList,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuList.cs,Draw,Cyclomatic complexity of the method is 8
Complex Method,VocaluxeLib.Menu.SongMenu,CSongMenuTileBoard,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuTileBoard.cs,HandleMouse,Cyclomatic complexity of the method is 11
Complex Method,VocaluxeLib.Songs,CSong,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSong.cs,_GetSeries,Cyclomatic complexity of the method is 8
Complex Method,VocaluxeLib.Songs,CSong,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSong.cs,_CalcMedley,Cyclomatic complexity of the method is 11
Complex Method,VocaluxeLib.Songs,CSong,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSong.cs,_FindShortEnd,Cyclomatic complexity of the method is 8
Complex Method,VocaluxeLib.Songs,CSongWriter,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongWriter.cs,_WriteHeader,Cyclomatic complexity of the method is 13
Complex Method,VocaluxeLib.Songs,CSongWriter,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongWriter.cs,_WriteNotes,Cyclomatic complexity of the method is 8
Complex Method,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ReadHeader,Cyclomatic complexity of the method is 20
Complex Method,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ReadNotes,Cyclomatic complexity of the method is 11
Complex Method,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,Open,Cyclomatic complexity of the method is 11
Long Parameter List,VocaluxeLib,IDrawing,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\IBasic.cs,DrawTexture,The method has 6 parameters. Parameters: texture' rect' color' bounds' mirrored' allMonitors
Long Parameter List,VocaluxeLib,IDrawing,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\IBasic.cs,DrawTextureReflection,The method has 7 parameters. Parameters: texture' rect' color' bounds' reflectionSpace' reflectionHeight' allMonitors
Long Parameter List,VocaluxeLib,IFonts,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\IBasic.cs,DrawText,The method has 7 parameters. Parameters: text' font' x' y' z' color' allMonitors
Long Parameter List,VocaluxeLib,IFonts,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\IBasic.cs,DrawTextReflection,The method has 8 parameters. Parameters: text' font' x' y' z' color' reflectionSpace' reflectionHeight
Long Parameter List,VocaluxeLib,IFonts,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\IBasic.cs,DrawText,The method has 8 parameters. Parameters: text' font' x' y' z' color' begin' end
Long Parameter List,VocaluxeLib,ISongs,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\IBasic.cs,SortSongs,The method has 6 parameters. Parameters: sorting' tabs' ignoreArticles' searchString' duetOptions' playlistID
Long Parameter List,VocaluxeLib,IDataBase,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\IBasic.cs,GetDataBaseSongInfos,The method has 5 parameters. Parameters: artist' title' numPlayed' dateAdded' highscoreID
Long Parameter List,VocaluxeLib,CBase,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\CBasic.cs,Assign,The method has 19 parameters. Parameters: config' settings' themes' log' backgroundMusic' draw' graphics' fonts' language' game' profiles' record' songs' video' sound' cover' dataBase' controller' playlist
Long Parameter List,VocaluxeLib,SRectF,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Structs.cs,SRectF,The method has 5 parameters. Parameters: x' y' w' h' z
Long Parameter List,VocaluxeLib,SKeyEvent,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Structs.cs,SKeyEvent,The method has 7 parameters. Parameters: sender' alt' shift' ctrl' pressed' unicode' key
Long Parameter List,VocaluxeLib,SMouseEvent,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Structs.cs,SMouseEvent,The method has 12 parameters. Parameters: sender' mod' x' y' lb' ld' rb' wheel' lbh' rbh' mb' mbh
Long Parameter List,VocaluxeLib.Menu,CMenu,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenu.cs,GetNewText,The method has 10 parameters. Parameters: x' y' z' h' mw' align' style' font' col' text
Long Parameter List,VocaluxeLib.Menu,CMenu,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenu.cs,GetNewParticleEffect,The method has 6 parameters. Parameters: maxNumber' color' area' texture' size' type
Long Parameter List,VocaluxeLib.Menu,CParticle,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticle.cs,CParticle,The method has 13 parameters. Parameters: partyModeID' textureName' color' x' y' size' maxage' z' vx' vy' vr' vsize' type
Long Parameter List,VocaluxeLib.Menu,CParticle,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticle.cs,CParticle,The method has 13 parameters. Parameters: partyModeID' texture' color' x' y' size' maxage' z' vx' vy' vr' vsize' type
Long Parameter List,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,CParticleEffect,The method has 7 parameters. Parameters: partyModeID' maxNumber' color' rect' skin' size' type
Long Parameter List,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,CParticleEffect,The method has 7 parameters. Parameters: partyModeID' maxNumber' color' rect' texture' size' type
Long Parameter List,VocaluxeLib.Menu,CText,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CText.cs,CText,The method has 13 parameters. Parameters: x' y' z' h' mw' align' style' fontFamily' col' text' partyModeID' rheight' rspace
Long Parameter List,VocaluxeLib.Menu,CText,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CText.cs,DrawRelative,The method has 5 parameters. Parameters: rx' ry' reflectionHeight' reflectionSpace' rectHeight
Long Parameter List,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_DrawNote,The method has 6 parameters. Parameters: rect' color' noteBegin' noteMiddle' noteEnd' factor
Long Parameter List,VocaluxeLib.Xml,CXmlSerializer,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CXmlSerializer.cs,_WriteValue,The method has 7 parameters. Parameters: writer' name' type' value' isAttribute' arrayItemName' nameAttribute
Long Parameter List,VocaluxeLib.Songs,CSongNote,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongNote.cs,CSongNote,The method has 5 parameters. Parameters: startBeat' duration' tone' text' noteType
Long Parameter List,VocaluxeLib.Songs,CSungNote,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSungNote.cs,CSungNote,The method has 5 parameters. Parameters: startBeat' duration' tone' hitNote' points
Long Statement,VocaluxeLib,CHelper,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\CHelper.cs,TryParse,The length of the statement  "            return Single.TryParse(value' NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign' NumberFormatInfo.InvariantInfo' out result); " is 138.
Long Statement,VocaluxeLib.Menu,CBackground,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CBackground.cs,Draw,The length of the statement  "                if (CBase.Config.GetVideosToBackground() == EOffOn.TR_CONFIG_ON && CBase.BackgroundMusic.IsPlaying() && CBase.BackgroundMusic.SongHasVideo() && " is 143.
Long Statement,VocaluxeLib.Menu,CBackground,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CBackground.cs,AddSlideShowTexture,The length of the statement  "                CTextureRef texture = _SlideShowTextures.Count == 0 ? CBase.Drawing.AddTexture(image) : CBase.Drawing.EnqueueTexture(image); " is 124.
Long Statement,VocaluxeLib.Menu,CBackground,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CBackground.cs,_DrawSlideShow,The length of the statement  "                if (_SlideShowTimer.ElapsedMilliseconds >= (CBase.Settings.GetSlideShowFadeTime() + CBase.Settings.GetSlideShowImageTime())) " is 124.
Long Statement,VocaluxeLib.Menu,CBackground,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CBackground.cs,_DrawSlideShow,The length of the statement  "                        color.A = (_SlideShowTimer.ElapsedMilliseconds - CBase.Settings.GetSlideShowImageTime()) / CBase.Settings.GetSlideShowFadeTime(); " is 129.
Long Statement,VocaluxeLib.Menu,CLyric,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CLyric.cs,_DrawZoomOrJump,The length of the statement  "            // Draw the highlighted note after all others because we want it to be above those! (transparency won't work well otherwhise) " is 125.
Long Statement,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,Init,The length of the statement  "            _ThemeButtons = new string[] {_ButtonBack' _ButtonNext' _ButtonRandom' _ButtonIncreaseTeams' _ButtonDecreaseTeams' _ButtonIncreasePlayer' _ButtonDecreasePlayer}; " is 161.
Long Statement,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The length of the statement  "                    if (_ChangeTeamNumDynamic && numPressed < _PartyMode.MaxTeams && numPressed > _SelectSlides[_SelectSlideTeams].NumValues) " is 121.
Long Statement,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleMouse,The length of the statement  "                if (_SelectSlides[_SelectSlidePlayer].Selected && _TeamList[_CurrentTeam].Count > _SelectSlides[_SelectSlidePlayer].Selection) " is 126.
Long Statement,VocaluxeLib.Menu,CMenuPartySongSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartySongSelection.cs,Init,The length of the statement  "            _ThemeSelectSlides = new string[] { _SelectSlideSongMode' _SelectSlideSource' _SelectSlidePlaylist' _SelectSlideSorting' _SelectSlideCategory' _SelectSlideNumMedleySongs }; " is 172.
Long Statement,VocaluxeLib.Menu,CMenuPartySongSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartySongSelection.cs,_FillSlides,The length of the statement  "                string value = playlists[i] + " (" + CBase.Playlist.GetSongCount(i) + " " + CBase.Language.Translate("TR_SONGS"' PartyModeID) + ")"; " is 132.
Long Statement,VocaluxeLib.Menu,CMenuPartySongSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartySongSelection.cs,_FillCategorySlide,The length of the statement  "                string value = cat.Name + " (" + cat.GetNumSongsNotSung() + " " + CBase.Language.Translate("TR_SONGS"' PartyModeID) + ")"; " is 122.
Long Statement,VocaluxeLib.Menu,CNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CNameSelection.cs,Init,The length of the statement  "            _PlayerSelector = new CStatic(_PartyModeID' _TextureTileSelected' new SColorF()' new SRectF(0' 0' _Theme.Tiles.W + 6' _Theme.Tiles.H + 6' Rect.Z - 0.5f)) " is 153.
Long Statement,VocaluxeLib.Menu,CNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CNameSelection.cs,_PrepareTiles,The length of the statement  "                    var rect = new SRectF(MaxRect.X + j * (_Theme.Tiles.W + _Theme.Tiles.SpaceW)' MaxRect.Y + i * (_Theme.Tiles.H + _Theme.Tiles.SpaceH)' " is 133.
Long Statement,VocaluxeLib.Menu,CNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CNameSelection.cs,_PrepareTiles,The length of the statement  "                    var tileText = new CText(rect.X + rect.W / 2' rect.Y + rect.H + _Theme.Tiles.Name.Space' rect.Z' _Theme.Tiles.Name.Height' rect.W' EAlignment.Center' " is 149.
Long Statement,VocaluxeLib.Menu,CObjectInteractions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CObjectInteractions.cs,_GetDistanceDirect,The length of the statement  "                    if (!other.X.IsInRange(current.X' current.Right) && !other.Right.IsInRange(current.X' current.Right) && !current.X.IsInRange(other.X' other.Right)) " is 147.
Long Statement,VocaluxeLib.Menu,CObjectInteractions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CObjectInteractions.cs,_GetDistanceDirect,The length of the statement  "                    if (!other.Y.IsInRange(current.Y' current.Bottom) && !other.Bottom.IsInRange(current.Y' current.Bottom) && !current.Y.IsInRange(other.Y' other.Bottom)) " is 151.
Long Statement,VocaluxeLib.Menu,CParticle,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticle.cs,Draw,The length of the statement  "                CBase.Drawing.DrawTexture(CBase.Themes.GetSkinTexture(_TextureName' _PartyModeID)' _Rect' new SColorF(_Color.R' _Color.G' _Color.B' _Color.A * Alpha2 * _Alpha)' allMonitors); " is 174.
Long Statement,VocaluxeLib.Menu,CParticle,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticle.cs,Draw,The length of the statement  "                CBase.Drawing.DrawTexture(_Texture' _Rect' new SColorF(_Color.R' _Color.G' _Color.B' _Color.A * Alpha2 * _Alpha)' allMonitors); " is 127.
Long Statement,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The length of the statement  "            if (_Theme.Type == EParticleType.Flare || _Theme.Type == EParticleType.PerfNoteStar || _Theme.Type == EParticleType.Twinkle) " is 124.
Long Statement,VocaluxeLib.Menu,CPlaylist,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CPlaylist.cs,HandleInput,The length of the statement  "                                _PlaylistElementContents[_CurrentPlaylistElement + _Offset].Modes[_PlaylistElements[_CurrentPlaylistElement].SelectSlide.Selection]; " is 132.
Long Statement,VocaluxeLib.Menu,CPlaylist,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CPlaylist.cs,HandleInput,The length of the statement  "                                _PlaylistElementContents[_CurrentPlaylistElement + _Offset].Modes[_PlaylistElements[_CurrentPlaylistElement].SelectSlide.Selection]; " is 132.
Long Statement,VocaluxeLib.Menu,CPlaylist,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CPlaylist.cs,HandleMouse,The length of the statement  "                    if (CHelper.IsInBounds(_PlaylistElements[i].Background.Rect' mouseEvent) && mouseEvent.RB && _PlaylistElements[i].Content != -1) " is 128.
Long Statement,VocaluxeLib.Menu,CPlaylist,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CPlaylist.cs,HandleMouse,The length of the statement  "                                    _PlaylistElementContents[_CurrentPlaylistElement + _Offset].Modes[_PlaylistElements[_CurrentPlaylistElement].SelectSlide.Selection]; " is 132.
Long Statement,VocaluxeLib.Menu,CPlaylist,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CPlaylist.cs,_StartPlaylistSongs,The length of the statement  "                    CBase.Game.AddSong(CBase.Playlist.GetSong(ActivePlaylistID' i).SongID' CBase.Playlist.GetSong(ActivePlaylistID' i).GameMode); " is 125.
Long Statement,VocaluxeLib.Menu,CPlaylist,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CPlaylist.cs,_StartPlaylistSong,The length of the statement  "            CBase.Game.AddSong(CBase.Playlist.GetSong(ActivePlaylistID' selected).SongID' CBase.Playlist.GetSong(ActivePlaylistID' selected).GameMode); " is 139.
Long Statement,VocaluxeLib.Menu,CSelectSlide,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CSelectSlide.cs,_Revalidate,The length of the statement  "                        Text = new CText(0' 0' 0' _TextH' _MaxW' EAlignment.Center' _Theme.TextStyle' _Theme.TextFont' _TextColor' "T"' _PartyModeID)' " is 126.
Long Statement,VocaluxeLib.Menu,CSelectSlide,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CSelectSlide.cs,_Revalidate,The length of the statement  "                    _VisibleElements[i].Bounds = new SRectF(text.X - textBounds.Width / 2f' text.Y' textBounds.Width' textBounds.Height' Rect.Z); " is 125.
Long Statement,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,Draw,The length of the statement  "                        CBase.Drawing.DrawTextureReflection(_TextureBackground' Rect' color' Rect' ReflectionSpace' ReflectionHeight' AllMonitors); " is 123.
Long Statement,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,Draw,The length of the statement  "                color = new SColorF(_ColorProgressCurrent.R' _ColorProgressCurrent.G' _ColorProgressCurrent.B' _ColorProgressCurrent.A * Alpha); " is 128.
Long Statement,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,Draw,The length of the statement  "                        CBase.Drawing.DrawTextureReflection(_TextureProgressBegin' _RectProgressBegin' color' _RectProgressBegin' ReflectionSpace' ReflectionHeight' AllMonitors); " is 154.
Long Statement,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,Draw,The length of the statement  "                        CBase.Drawing.DrawTextureReflection(_TextureProgressMid' _RectProgressMid' color' _RectProgressMid' ReflectionSpace' ReflectionHeight' AllMonitors); " is 148.
Long Statement,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,Draw,The length of the statement  "                        CBase.Drawing.DrawTextureReflection(_TextureProgressEnd' _RectProgressEnd' color' _RectProgressEnd' ReflectionSpace' ReflectionHeight' AllMonitors); " is 148.
Long Statement,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,Draw,The length of the statement  "                        CBase.Drawing.DrawTextureReflection(_TextureForeground' Rect' color' Rect' ReflectionSpace' ReflectionHeight' AllMonitors); " is 123.
Long Statement,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,_CheckAnimation,The length of the statement  "                _ProgressCurrent = _ProgressLast + (_AnimTimer.ElapsedMilliseconds / _AnimDuration).Clamp(0' 1) * (_ProgressTarget - _ProgressLast); " is 132.
Long Statement,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,_UpdateProgressLeft,The length of the statement  "                        _RectProgressBegin = new SRectF(Rect.X' Rect.Y + Rect.H - Rect.W * _TextureProgressBegin.OrigAspect' Rect.W' Rect.W * _TextureProgressBegin.OrigAspect' Rect.Z); " is 160.
Long Statement,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,_UpdateProgressLeft,The length of the statement  "                        _RectProgressBegin = new SRectF(Rect.X + Rect.W - Rect.H * _TextureProgressBegin.OrigAspect' Rect.Y' Rect.H *_TextureProgressBegin.OrigAspect' Rect.H' Rect.Z); " is 159.
Long Statement,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,_UpdateProgressMid,The length of the statement  "                    _RectProgressMid = new SRectF(_RectProgressBegin.X + _RectProgressBegin.W' Rect.Y' (Rect.W - 2 * _RectProgressBegin.W) * _ProgressCurrent' Rect.H' Rect.Z); " is 155.
Long Statement,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,_UpdateProgressMid,The length of the statement  "                    _RectProgressMid = new SRectF(Rect.X' _RectProgressBegin.Y + _RectProgressBegin.H' (Rect.H - 2 * _RectProgressBegin.W) * _ProgressCurrent' Rect.W' Rect.Z); " is 155.
Long Statement,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,_UpdateProgressRight,The length of the statement  "                        _RectProgressEnd = new SRectF(_RectProgressMid.X + _RectProgressMid.W' Rect.Y' Rect.H * _TextureProgressBegin.OrigAspect' Rect.H' Rect.Z); " is 138.
Long Statement,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,_UpdateProgressRight,The length of the statement  "                        _RectProgressEnd = new SRectF(Rect.X' _RectProgressMid.Y + Rect.W' Rect.W' Rect.W * _TextureProgressBegin.OrigAspect' Rect.Z); " is 126.
Long Statement,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,_UpdateProgressRight,The length of the statement  "                        _RectProgressEnd = new SRectF(_RectProgressMid.X - Rect.H' Rect.Y' Rect.H * _TextureProgressBegin.OrigAspect' Rect.H' Rect.Z); " is 126.
Long Statement,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,_UpdateProgressRight,The length of the statement  "                        _RectProgressEnd = new SRectF(Rect.X' _RectProgressMid.Y + _RectProgressMid.H' Rect.W' Rect.W * _TextureProgressBegin.OrigAspect' Rect.Z); " is 138.
Long Statement,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_GetNoteRect,The length of the statement  "                Rect.Y + (CBase.Settings.GetNumNoteLines() - 1 - (note.Tone - line.BaseLine) / 2f) * _NoteLineHeight - _AddNoteHeight / 2' " is 122.
Long Statement,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_DrawNote,The length of the statement  "                CBase.Drawing.DrawTexture(noteMiddle' new SRectF(middleRect.X + (i * midW)' noteRect.Y' midW' noteRect.H' noteRect.Z)' color' false); " is 133.
Long Statement,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_DrawNote,The length of the statement  "            SRectF lastMidRect = new SRectF(middleRect.X + midCount * midW' noteRect.Y' middleRect.W - (midCount * midW)' noteRect.H' noteRect.Z); " is 134.
Long Statement,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_DrawNote,The length of the statement  "            CBase.Drawing.DrawTexture(noteMiddle' new SRectF(middleRect.X + (midCount * midW)' middleRect.Y' midW' middleRect.H' middleRect.Z)' color' lastMidRect' false' false); " is 166.
Long Statement,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_DrawNote,The length of the statement  "            CBase.Drawing.DrawTexture(noteEnd' new SRectF(noteRect.X + noteRect.W - endsW' noteRect.Y' endsW' noteRect.H' noteRect.Z)' color' false); " is 137.
Long Statement,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_AddGoldenNote,The length of the statement  "            var stars = new CParticleEffect(_PartyModeID' numstars' new SColorF(Color.Yellow)' noteRect' _Theme.SkinGoldenStar' 20' EParticleType.Star); " is 140.
Long Statement,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_AddFlare,The length of the statement  "            var flares = new CParticleEffect(_PartyModeID' 15' new SColorF(Color.White)' rect' _Theme.SkinGoldenStar' 20' EParticleType.Flare); " is 131.
Long Statement,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_AddPerfectNote,The length of the statement  "            var stars = new CParticleEffect(_PartyModeID' CBase.Game.GetRandom(2) + 1' new SColorF(Color.White)' r' _Theme.SkinPerfectNoteStart' 35' " is 136.
Long Statement,VocaluxeLib.Xml,CTypeExtensions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CTypeExtensions.cs,_FillInfo,The length of the statement  "                Debug.Assert(info.Type == typeof(float) || (info.IsNullable && info.SubType == typeof(float))' "Only floats can be normalized"); " is 128.
Long Statement,VocaluxeLib.Xml,CTypeExtensions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CTypeExtensions.cs,GetFieldInfos,The length of the statement  "                if (property.HasAttribute<XmlIgnoreAttribute>() || property.Name.EndsWith("Specified") || !property.CanRead || !property.CanWrite) " is 130.
Long Statement,VocaluxeLib.Xml,CXmlException,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CXmlDeserializer.cs,_FindElementIndex,The length of the statement  "                XmlNode[] siblings = parent.ChildNodes.Cast<XmlNode>().Where(candidate => candidate is XmlElement && candidate.Name == element.Name).ToArray(); " is 143.
Long Statement,VocaluxeLib.Xml,CXmlDeserializer,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CXmlDeserializer.cs,_GetValue,The length of the statement  "                            _ErrorHandler.HandleError(new CXmlException("Invalid list entry '" + subNode.Name + "' in %n; Expected: " + subName' node)); " is 124.
Long Statement,VocaluxeLib.Xml,CXmlDeserializer,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CXmlDeserializer.cs,_GetValue,The length of the statement  "                                _ErrorHandler.HandleError(new CXmlException("Invalid dictionary entry '" + subNode.Name + "' in %n; Expected: " + subName' node)); " is 130.
Long Statement,VocaluxeLib.Xml,CXmlDeserializer,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CXmlDeserializer.cs,_GetPrimitiveValue,The length of the statement  "                    _ErrorHandler.HandleError(new CXmlInvalidValueException("German number format converted to English in %n"' node' nodeVal' false)); " is 130.
Long Statement,VocaluxeLib.Xml,CXmlDeserializer,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CXmlDeserializer.cs,_GetPrimitiveValue,The length of the statement  "                _ErrorHandler.HandleError(new CXmlInvalidValueException("Invalid format in %n: '%v' (" + e.Message + ")"' node' nodeVal)); " is 122.
Long Statement,VocaluxeLib.Xml,CXmlDeserializer,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CXmlDeserializer.cs,_CreateList,The length of the statement  "            object list = type.IsArray ? Array.CreateInstance(type.GetElementType()' values.Count) : Activator.CreateInstance(type' new object[] {values.Count}); " is 149.
Long Statement,VocaluxeLib.Xml,CXmlDeserializer,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CXmlDeserializer.cs,_ReadChildNodes,The length of the statement  "                Dictionary<string' Tuple<SFieldInfo' List<object>>> embLists = new Dictionary<string' Tuple<SFieldInfo' List<object>>>(); " is 121.
Long Statement,VocaluxeLib.Xml,CXmlDeserializer,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CXmlDeserializer.cs,_ReadChildNodes,The length of the statement  "                        if (field.Name == node.Name || field.AltName == node.Name || (field.IsEmbeddedList && node.Name.StartsWith(field.Name))) " is 120.
Long Statement,VocaluxeLib.Xml,CXmlDeserializer,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CXmlDeserializer.cs,_ReadChildNodes,The length of the statement  "                        if (field.Ranged != null && value != null && !field.Ranged.IsValid(field.IsNullable ? field.SubType : field.Type' value)) " is 121.
Long Statement,VocaluxeLib.Xml,CXmlSerializer,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CXmlSerializer.cs,_WriteValue,The length of the statement  "                    throw new XmlException("Cannot convert value of type " + type.Name + " to string in node " + name + " (" + e.Message + ")"); " is 124.
Long Statement,VocaluxeLib.Menu.SongMenu,CSongMenuList,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuList.cs,_InitTiles,The length of the statement  "                var textRect = new SRectF(MaxRect.X + 2 * (_TileW + _SpaceW)' Rect.Y + i * (_TileH + _SpaceH)' _ListTextWidth' _TileH' Rect.Z); " is 127.
Long Statement,VocaluxeLib.Menu.SongMenu,CSongMenuList,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuList.cs,_InitTiles,The length of the statement  "                text.MaxRect = new SRectF(text.MaxRect.X' text.MaxRect.Y' MaxRect.W + MaxRect.X - text.Rect.X - 5f' text.MaxRect.H' text.MaxRect.Z); " is 132.
Long Statement,VocaluxeLib.Menu.SongMenu,CSongMenuList,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuList.cs,OnShow,The length of the statement  "                if ((CBase.Songs.GetTabs() == EOffOn.TR_CONFIG_OFF && CBase.Songs.GetNumCategories() > 0) || CBase.Songs.GetNumCategories() == 1) " is 129.
Long Statement,VocaluxeLib.Menu.SongMenu,CSongMenuList,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuList.cs,HandleInput,The length of the statement  "            bool moveAllowed = !options.Selection.RandomOnly || (options.Selection.CategoryChangeAllowed && !CBase.Songs.IsInCategory()); " is 125.
Long Statement,VocaluxeLib.Menu.SongMenu,CSongMenuList,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuList.cs,Draw,The length of the statement  "                CBase.Drawing.DrawTextureReflection(vidtex' rect' vidtex.Color' _CoverBig.Rect' _CoverBig.ReflectionSpace' _CoverBig.ReflectionHeight); " is 135.
Long Statement,VocaluxeLib.Menu.SongMenu,CSongMenuFramework,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuFramework.cs,OnHide,The length of the statement  "            else if (CBase.Graphics.GetNextScreenType() != EScreen.Names || CBase.Config.GetBackgroundMusicStatus() == EBackgroundMusicOffOn.TR_CONFIG_OFF) " is 143.
Long Statement,VocaluxeLib.Menu.SongMenu,CSongMenuFramework,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuFramework.cs,_ResetPreview,The length of the statement  "            //(e.g. leave a category with one song and set preview to 0 --> previewOld=previewNew=0 --> No change --> Old data shown " is 120.
Long Statement,VocaluxeLib.Menu.SongMenu,CSongMenuTileBoard,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuTileBoard.cs,_InitTiles,The length of the statement  "                    var rect = new SRectF(Rect.X + j * (_TileW + _Theme.SongMenuTileBoard.SpaceW)' Rect.Y + i * (_TileH + _Theme.SongMenuTileBoard.SpaceH)' _TileW' _TileH' Rect.Z); " is 160.
Long Statement,VocaluxeLib.Menu.SongMenu,CSongMenuTileBoard,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuTileBoard.cs,OnShow,The length of the statement  "                if ((CBase.Songs.GetTabs() == EOffOn.TR_CONFIG_OFF && CBase.Songs.GetNumCategories() > 0) || CBase.Songs.GetNumCategories() == 1) " is 129.
Long Statement,VocaluxeLib.Menu.SongMenu,CSongMenuTileBoard,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuTileBoard.cs,HandleInput,The length of the statement  "            bool moveAllowed = !options.Selection.RandomOnly || (options.Selection.CategoryChangeAllowed && !CBase.Songs.IsInCategory()); " is 125.
Long Statement,VocaluxeLib.Menu.SongMenu,CSongMenuTileBoard,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuTileBoard.cs,Draw,The length of the statement  "                CBase.Drawing.DrawTextureReflection(vidtex' rect' vidtex.Color' _CoverBig.Rect' _CoverBig.ReflectionSpace' _CoverBig.ReflectionHeight); " is 135.
Long Statement,VocaluxeLib.Menu.SongMenu,CSongMenuTileBoard,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuTileBoard.cs,_UpdateList,The length of the statement  "                    _Tiles[i].Texture = isInCategory ? CBase.Songs.GetVisibleSong(i + offset).CoverTextureSmall : CBase.Songs.GetCategory(i + offset).CoverTextureSmall; " is 148.
Long Statement,VocaluxeLib.Profile,CProfile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Profile\CProfile.cs,SaveProfile,The length of the statement  "                FilePath = CHelper.GetUniqueFileName(Path.Combine(CBase.Settings.GetDataPath()' CBase.Settings.GetFolderProfiles())' filename + ".xml"); " is 136.
Long Statement,VocaluxeLib.Songs,CSong,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSong.cs,_CalcMedley,The length of the statement  "                bool foundEnd = CBase.Game.GetTimeFromBeats(Medley.EndBeat' BPM) - CBase.Game.GetTimeFromBeats(Medley.StartBeat' BPM) < CBase.Settings.GetMedleyMinDuration(); " is 158.
Long Statement,VocaluxeLib.Songs,CSong,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSong.cs,_CalcMedley,The length of the statement  "                        if (CBase.Game.GetTimeFromBeats(voice.Lines[i].LastNoteBeat' BPM) - CBase.Game.GetTimeFromBeats(Medley.StartBeat' BPM) < " is 120.
Long Statement,VocaluxeLib.Songs,CSong,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSong.cs,_FindShortEnd,The length of the statement  "            int stop = (voice.Lines[voice.Lines.Length - 1].LastNoteBeat - voice.Lines[0].FirstNote.StartBeat) / 2 + voice.Lines[0].FirstNote.StartBeat; " is 140.
Long Statement,VocaluxeLib.Songs,CSong,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSong.cs,_FindShortEnd,The length of the statement  "                    if (stop < (voice.Lines[series[i].Start].FirstNoteBeat + ((voice.Lines[series[i].End].LastNoteBeat - voice.Lines[series[i].Start].FirstNoteBeat) / 2))) " is 151.
Long Statement,VocaluxeLib.Songs,CSongWriter,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongWriter.cs,_WriteHeader,The length of the statement  "                    _WriteHeaderEntry("ENDSHORT"' (int)(CBase.Game.GetTimeFromBeats(_Song.ShortEnd.EndBeat' _Song.BPM) + _Song.Gap) * 1000); " is 120.
Long Statement,VocaluxeLib.Songs,CVoice,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CVoice.cs,AddNote,The length of the statement  "            if (lineIndex + 1 < _Lines.Count && _Lines[lineIndex + 1].FirstNoteBeat < note.EndBeat) //First note in next line starts before this one ends " is 141.
Long Statement,VocaluxeLib.Songs,CVoice,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CVoice.cs,UpdateTimings,The length of the statement  "            _Lines[_Lines.Count - 1].EndBeat = Math.Max(_Lines[_Lines.Count - 1].LastNoteBeat' _Lines[_Lines.Count - 1].StartBeat); //Use note or (when not set) start beat " is 159.
Long Statement,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ReadHeader,The length of the statement  "                        _Song.Preview.StartTime = (headerFlags & EHeaderFlags.MedleyStartBeat) != 0 ? CBase.Game.GetTimeFromBeats(_Song.Medley.StartBeat' _Song.BPM) : 0f; " is 146.
Long Statement,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ReadHeader,The length of the statement  "                CBase.DataBase.GetDataBaseSongInfos(_Song.Artist' _Song.Title' out _Song.NumPlayed' out _Song.DateAdded' out _Song.DataBaseSongID); " is 131.
Long Statement,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ReadNotes,The length of the statement  "                                if (!int.TryParse(noteData[0]' out beat) || !int.TryParse(noteData[1]' out length) || !int.TryParse(noteData[2]' out tone)) " is 123.
Long Statement,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ReadNotes,The length of the statement  "                                    if (_CurrentReadMode == ENoteReadMode.Normal && changesMade.ZeroLengthNoteCt > _MaxZeroNoteCt && changesMade.OverlapNoteCt <= _MaxOverlapNoteCt) " is 144.
Long Statement,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ReadNotes,The length of the statement  "                            _LogWarning("Removed " + emptyLines + " empty lines from P" + ". This often indicates a problem with the line breaks in the file"' false); " is 138.
Long Statement,VocaluxeLib.Songs,CAutoChanges,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ToString,The length of the statement  "                        result += "Skipped " + skippedNotesCt + " notes (0-Length: " + ZeroLengthNoteCt + "' Overlapping: " + OverlapNoteCt + "' No text: " + NoTextNoteCt + ")\r\n"; " is 157.
Long Statement,VocaluxeLib.Songs,CAutoChanges,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ToString,The length of the statement  "                        result += "Adjusted " + adjustedBreakCt + " line breaks (Overlapping previous note: " + AjustedBreakCt + "' No length: " + NoLengthBreakCt + ")\r\n"; " is 149.
Complex Conditional,VocaluxeLib.Menu,CBackground,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CBackground.cs,Draw,The conditional expression  "CBase.Config.GetVideosToBackground() == EOffOn.TR_CONFIG_ON && CBase.BackgroundMusic.IsPlaying() && CBase.BackgroundMusic.SongHasVideo() &&                      CBase.BackgroundMusic.VideoEnabled()"  is complex.
Complex Conditional,VocaluxeLib.Menu,CPlaylist,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CPlaylist.cs,HandleMouse,The conditional expression  "mouseEvent.LBH && _CurrentPlaylistElement != -1 && _PlaylistElementContents.Count > 0 && DragAndDropSongID == -1"  is complex.
Complex Conditional,VocaluxeLib.Xml,CTypeExtensions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CTypeExtensions.cs,GetFieldInfos,The conditional expression  "property.HasAttribute<XmlIgnoreAttribute>() || property.Name.EndsWith("Specified") || !property.CanRead || !property.CanWrite"  is complex.
Complex Conditional,VocaluxeLib.Xml,CXmlDeserializer,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CXmlDeserializer.cs,_ReadChildNodes,The conditional expression  "field.Name == node.Name || field.AltName == node.Name || (field.IsEmbeddedList && node.Name.StartsWith(field.Name))"  is complex.
Complex Conditional,VocaluxeLib.Menu.SongMenu,CSongMenuList,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuList.cs,HandleMouse,The conditional expression  "CBase.Songs.IsInCategory() && CBase.Songs.GetNumCategories() > 0 && CBase.Songs.GetTabs() == EOffOn.TR_CONFIG_ON &&                      songOptions.Selection.CategoryChangeAllowed"  is complex.
Complex Conditional,VocaluxeLib.Menu.SongMenu,CSongMenuTileBoard,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuTileBoard.cs,HandleMouse,The conditional expression  "CBase.Songs.IsInCategory() && CBase.Songs.GetNumCategories() > 0 && CBase.Songs.GetTabs() == EOffOn.TR_CONFIG_ON &&                      songOptions.Selection.CategoryChangeAllowed"  is complex.
Complex Conditional,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,WriteSamples,The conditional expression  "!_IsWritable || channel < 0 || channel > NumChannels || BitsPerSample != 8"  is complex.
Complex Conditional,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,Write16BitSamples,The conditional expression  "!_IsWritable || channel < 0 || channel > NumChannels || BitsPerSample != 16"  is complex.
Empty Catch Block,VocaluxeLib,CHelper,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\CHelper.cs,ListFiles,The method has an empty catch block.
Empty Catch Block,VocaluxeLib,CHelper,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\CHelper.cs,TryParse,The method has an empty catch block.
Magic Number,VocaluxeLib,CEncoding,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\CEncoding.cs,GetEncoding,The following statement contains a magic number: switch (encodingName)              {                  case "AUTO":                      return Encoding.Default;                  case "CP1250":                      return Encoding.GetEncoding(1250);                  case "CP1252":                      return Encoding.GetEncoding(1252);                  case "LOCALE":                      return Encoding.Default;                  case "UTF8":                      return Encoding.UTF8;                  default:                      return Encoding.Default;              }
Magic Number,VocaluxeLib,CEncoding,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\CEncoding.cs,GetEncoding,The following statement contains a magic number: switch (encodingName)              {                  case "AUTO":                      return Encoding.Default;                  case "CP1250":                      return Encoding.GetEncoding(1250);                  case "CP1252":                      return Encoding.GetEncoding(1252);                  case "LOCALE":                      return Encoding.Default;                  case "UTF8":                      return Encoding.UTF8;                  default:                      return Encoding.Default;              }
Magic Number,VocaluxeLib,CEncoding,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\CEncoding.cs,GetEncodingName,The following statement contains a magic number: if (enc.CodePage == 1250)                  result = "CP1250";
Magic Number,VocaluxeLib,CEncoding,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\CEncoding.cs,GetEncodingName,The following statement contains a magic number: if (enc.CodePage == 1252)                  result = "CP1252";
Magic Number,VocaluxeLib,CExtensions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Extensions.cs,Scale,The following statement contains a magic number: return new SRectF(                  rect.X - rect.W * (scale - 1f)'                  rect.Y - rect.H * (scale - 1f)'                  rect.W + 2 * rect.W * (scale - 1f)'                  rect.H + 2 * rect.H * (scale - 1f)'                  rect.Z);
Magic Number,VocaluxeLib,CExtensions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Extensions.cs,Scale,The following statement contains a magic number: return new SRectF(                  rect.X - rect.W * (scale - 1f)'                  rect.Y - rect.H * (scale - 1f)'                  rect.W + 2 * rect.W * (scale - 1f)'                  rect.H + 2 * rect.H * (scale - 1f)'                  rect.Z);
Magic Number,VocaluxeLib,CHelper,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\CHelper.cs,CombinationCount,The following statement contains a magic number: if (k * 2 > n)                  k = n - k;
Magic Number,VocaluxeLib,CHelper,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\CHelper.cs,FitInBounds,The following statement contains a magic number: float left = (bounds.W - scaledWidth) / 2 + bounds.X;
Magic Number,VocaluxeLib,CHelper,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\CHelper.cs,FitInBounds,The following statement contains a magic number: float top = (bounds.H - scaledHeight) / 2 + bounds.Y;
Magic Number,VocaluxeLib,CHelper,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\CHelper.cs,Sum,The following statement contains a magic number: return (n * n + n) / 2;
Magic Number,VocaluxeLib,SColorF,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Structs.cs,AsColor,The following statement contains a magic number: return Color.FromArgb((int)(A * 255)' (int)(R * 255)' (int)(G * 255)' (int)(B * 255));
Magic Number,VocaluxeLib,SColorF,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Structs.cs,AsColor,The following statement contains a magic number: return Color.FromArgb((int)(A * 255)' (int)(R * 255)' (int)(G * 255)' (int)(B * 255));
Magic Number,VocaluxeLib,SColorF,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Structs.cs,AsColor,The following statement contains a magic number: return Color.FromArgb((int)(A * 255)' (int)(R * 255)' (int)(G * 255)' (int)(B * 255));
Magic Number,VocaluxeLib,SColorF,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Structs.cs,AsColor,The following statement contains a magic number: return Color.FromArgb((int)(A * 255)' (int)(R * 255)' (int)(G * 255)' (int)(B * 255));
Magic Number,VocaluxeLib.Menu,CEqualizer,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CEqualizer.cs,Update,The following statement contains a magic number: if (volume < 0.001)              {                  for (int i = 0; i < _Bars.Length; i++)                      _Bars[i] = 0f;                  return;              }
Magic Number,VocaluxeLib.Menu,CLyric,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CLyric.cs,GetCurrentLyricPosX,The following statement contains a magic number: return X - _Width / 2;
Magic Number,VocaluxeLib.Menu,CLyric,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CLyric.cs,_DrawSlide,The following statement contains a magic number: float x = X - _Width / 2;
Magic Number,VocaluxeLib.Menu,CLyric,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CLyric.cs,_DrawFill,The following statement contains a magic number: float x = X - _Width / 2;
Magic Number,VocaluxeLib.Menu,CLyric,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CLyric.cs,_DrawJumpingNode,The following statement contains a magic number: if (p < 0.001)                  _Text.Draw();              else              {                  float y = _Text.Y;                  _Text.Y -= _Text.Font.Height * 0.1f * p;                  _Text.Draw();                  _Text.Y = y;              }
Magic Number,VocaluxeLib.Menu,CLyric,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CLyric.cs,_DrawZoomOrJump,The following statement contains a magic number: float x = X - _Width / 2;
Magic Number,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The following statement contains a magic number: if (_SelectingKeyboardActive)              {                  //Handle left/right/up/down                  _NameSelections[_NameSelection].HandleInput(keyEvent);                  int numPressed = -1;                  bool resetSelection = false;                  switch (keyEvent.Key)                  {                      case Keys.Enter:                          //Check' if a player is selected                          if (_NameSelections[_NameSelection].SelectedID != Guid.Empty)                          {                              _SelectedProfileID = _NameSelections[_NameSelection].SelectedID;                                if (!CBase.Profiles.IsProfileIDValid(_SelectedProfileID))                                  return true;                                _AddPlayer(_CurrentTeam' _SelectedProfileID);                          }                          //Started selecting with 'P'                          if (_SelectingFast)                          {                              if (!_ChangePlayerNumDynamic && _TeamList[_CurrentTeam].Count == _NumPlayerTeams[_CurrentTeam])                                  resetSelection = true;                              else if (_TeamList[_CurrentTeam].Count == _PartyMode.MaxPlayersPerTeam)                                  resetSelection = true;                          }                          else if (!_SelectingFast)                              resetSelection = true;                          break;                        case Keys.Escape:                      case Keys.Back:                          resetSelection = true;                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                  }                  if (numPressed > 0 || resetSelection)                  {                      if (numPressed == _SelectingFastPlayerNr || resetSelection)                      {                          //Reset all values                          _SelectingFastPlayerNr = 0;                          _SelectingKeyboardActive = false;                          _NameSelections[_NameSelection].FastSelection(false' -1);                      }                      else if (numPressed <= _NumPlayerTeams[_CurrentTeam])                      {                          _SelectingFastPlayerNr = numPressed;                          _NameSelections[_NameSelection].FastSelection(true' numPressed);                      }                      _SelectingFast = false;                  }              }              else              {                  base.HandleInput(keyEvent);                    int numPressed = 0;                    switch (keyEvent.Key)                  {                      case Keys.Back:                      case Keys.Escape:                          Back();                          break;                        case Keys.Enter:                          if (_Buttons[_ButtonBack].Selected)                              Back();                            if (_Buttons[_ButtonNext].Selected)                              Next();                            if (_Buttons[_ButtonRandom].Selected)                              _SelectRandom();                            if (_Buttons[_ButtonIncreaseTeams].Selected)                              IncreaseTeamNum();                            if (_Buttons[_ButtonDecreaseTeams].Selected)                              DecreaseTeamNum();                            if (_Buttons[_ButtonIncreasePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                            if (_Buttons[_ButtonDecreasePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                            break;                        case Keys.Delete:                          if (_SelectSlides[_SelectSlidePlayer].Selected && _SelectSlides[_SelectSlidePlayer].NumValues > 0)                          {                              int index = _SelectSlides[_SelectSlidePlayer].Selection;                              _RemovePlayerByIndex(_CurrentTeam' index);                              _UpdatePlayerSlide();                          }                          break;                        case Keys.Left:                      case Keys.Right:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              _OnChangeTeamSlide();                          break;                        case Keys.P:                          if (!_SelectingKeyboardActive)                          {                              _SelectingFastPlayerNr = (_CurrentTeam + 1);                              _SelectingFast = true;                              //_ResetPlayerSelections();                          }                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                        case Keys.Subtract:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              DecreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                          break;                        case Keys.Add:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              IncreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                          break;                  }                    if (numPressed > 0)                  {                      if (_ChangeTeamNumDynamic && numPressed < _PartyMode.MaxTeams && numPressed > _SelectSlides[_SelectSlideTeams].NumValues)                      {                          while (numPressed < _PartyMode.MaxTeams)                              IncreaseTeamNum();                      }                      if (numPressed <= _SelectSlides[_SelectSlideTeams].NumValues)                          _SelectSlides[_SelectSlideTeams].SelectedTag = numPressed;                  }              }
Magic Number,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The following statement contains a magic number: if (_SelectingKeyboardActive)              {                  //Handle left/right/up/down                  _NameSelections[_NameSelection].HandleInput(keyEvent);                  int numPressed = -1;                  bool resetSelection = false;                  switch (keyEvent.Key)                  {                      case Keys.Enter:                          //Check' if a player is selected                          if (_NameSelections[_NameSelection].SelectedID != Guid.Empty)                          {                              _SelectedProfileID = _NameSelections[_NameSelection].SelectedID;                                if (!CBase.Profiles.IsProfileIDValid(_SelectedProfileID))                                  return true;                                _AddPlayer(_CurrentTeam' _SelectedProfileID);                          }                          //Started selecting with 'P'                          if (_SelectingFast)                          {                              if (!_ChangePlayerNumDynamic && _TeamList[_CurrentTeam].Count == _NumPlayerTeams[_CurrentTeam])                                  resetSelection = true;                              else if (_TeamList[_CurrentTeam].Count == _PartyMode.MaxPlayersPerTeam)                                  resetSelection = true;                          }                          else if (!_SelectingFast)                              resetSelection = true;                          break;                        case Keys.Escape:                      case Keys.Back:                          resetSelection = true;                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                  }                  if (numPressed > 0 || resetSelection)                  {                      if (numPressed == _SelectingFastPlayerNr || resetSelection)                      {                          //Reset all values                          _SelectingFastPlayerNr = 0;                          _SelectingKeyboardActive = false;                          _NameSelections[_NameSelection].FastSelection(false' -1);                      }                      else if (numPressed <= _NumPlayerTeams[_CurrentTeam])                      {                          _SelectingFastPlayerNr = numPressed;                          _NameSelections[_NameSelection].FastSelection(true' numPressed);                      }                      _SelectingFast = false;                  }              }              else              {                  base.HandleInput(keyEvent);                    int numPressed = 0;                    switch (keyEvent.Key)                  {                      case Keys.Back:                      case Keys.Escape:                          Back();                          break;                        case Keys.Enter:                          if (_Buttons[_ButtonBack].Selected)                              Back();                            if (_Buttons[_ButtonNext].Selected)                              Next();                            if (_Buttons[_ButtonRandom].Selected)                              _SelectRandom();                            if (_Buttons[_ButtonIncreaseTeams].Selected)                              IncreaseTeamNum();                            if (_Buttons[_ButtonDecreaseTeams].Selected)                              DecreaseTeamNum();                            if (_Buttons[_ButtonIncreasePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                            if (_Buttons[_ButtonDecreasePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                            break;                        case Keys.Delete:                          if (_SelectSlides[_SelectSlidePlayer].Selected && _SelectSlides[_SelectSlidePlayer].NumValues > 0)                          {                              int index = _SelectSlides[_SelectSlidePlayer].Selection;                              _RemovePlayerByIndex(_CurrentTeam' index);                              _UpdatePlayerSlide();                          }                          break;                        case Keys.Left:                      case Keys.Right:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              _OnChangeTeamSlide();                          break;                        case Keys.P:                          if (!_SelectingKeyboardActive)                          {                              _SelectingFastPlayerNr = (_CurrentTeam + 1);                              _SelectingFast = true;                              //_ResetPlayerSelections();                          }                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                        case Keys.Subtract:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              DecreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                          break;                        case Keys.Add:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              IncreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                          break;                  }                    if (numPressed > 0)                  {                      if (_ChangeTeamNumDynamic && numPressed < _PartyMode.MaxTeams && numPressed > _SelectSlides[_SelectSlideTeams].NumValues)                      {                          while (numPressed < _PartyMode.MaxTeams)                              IncreaseTeamNum();                      }                      if (numPressed <= _SelectSlides[_SelectSlideTeams].NumValues)                          _SelectSlides[_SelectSlideTeams].SelectedTag = numPressed;                  }              }
Magic Number,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The following statement contains a magic number: if (_SelectingKeyboardActive)              {                  //Handle left/right/up/down                  _NameSelections[_NameSelection].HandleInput(keyEvent);                  int numPressed = -1;                  bool resetSelection = false;                  switch (keyEvent.Key)                  {                      case Keys.Enter:                          //Check' if a player is selected                          if (_NameSelections[_NameSelection].SelectedID != Guid.Empty)                          {                              _SelectedProfileID = _NameSelections[_NameSelection].SelectedID;                                if (!CBase.Profiles.IsProfileIDValid(_SelectedProfileID))                                  return true;                                _AddPlayer(_CurrentTeam' _SelectedProfileID);                          }                          //Started selecting with 'P'                          if (_SelectingFast)                          {                              if (!_ChangePlayerNumDynamic && _TeamList[_CurrentTeam].Count == _NumPlayerTeams[_CurrentTeam])                                  resetSelection = true;                              else if (_TeamList[_CurrentTeam].Count == _PartyMode.MaxPlayersPerTeam)                                  resetSelection = true;                          }                          else if (!_SelectingFast)                              resetSelection = true;                          break;                        case Keys.Escape:                      case Keys.Back:                          resetSelection = true;                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                  }                  if (numPressed > 0 || resetSelection)                  {                      if (numPressed == _SelectingFastPlayerNr || resetSelection)                      {                          //Reset all values                          _SelectingFastPlayerNr = 0;                          _SelectingKeyboardActive = false;                          _NameSelections[_NameSelection].FastSelection(false' -1);                      }                      else if (numPressed <= _NumPlayerTeams[_CurrentTeam])                      {                          _SelectingFastPlayerNr = numPressed;                          _NameSelections[_NameSelection].FastSelection(true' numPressed);                      }                      _SelectingFast = false;                  }              }              else              {                  base.HandleInput(keyEvent);                    int numPressed = 0;                    switch (keyEvent.Key)                  {                      case Keys.Back:                      case Keys.Escape:                          Back();                          break;                        case Keys.Enter:                          if (_Buttons[_ButtonBack].Selected)                              Back();                            if (_Buttons[_ButtonNext].Selected)                              Next();                            if (_Buttons[_ButtonRandom].Selected)                              _SelectRandom();                            if (_Buttons[_ButtonIncreaseTeams].Selected)                              IncreaseTeamNum();                            if (_Buttons[_ButtonDecreaseTeams].Selected)                              DecreaseTeamNum();                            if (_Buttons[_ButtonIncreasePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                            if (_Buttons[_ButtonDecreasePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                            break;                        case Keys.Delete:                          if (_SelectSlides[_SelectSlidePlayer].Selected && _SelectSlides[_SelectSlidePlayer].NumValues > 0)                          {                              int index = _SelectSlides[_SelectSlidePlayer].Selection;                              _RemovePlayerByIndex(_CurrentTeam' index);                              _UpdatePlayerSlide();                          }                          break;                        case Keys.Left:                      case Keys.Right:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              _OnChangeTeamSlide();                          break;                        case Keys.P:                          if (!_SelectingKeyboardActive)                          {                              _SelectingFastPlayerNr = (_CurrentTeam + 1);                              _SelectingFast = true;                              //_ResetPlayerSelections();                          }                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                        case Keys.Subtract:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              DecreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                          break;                        case Keys.Add:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              IncreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                          break;                  }                    if (numPressed > 0)                  {                      if (_ChangeTeamNumDynamic && numPressed < _PartyMode.MaxTeams && numPressed > _SelectSlides[_SelectSlideTeams].NumValues)                      {                          while (numPressed < _PartyMode.MaxTeams)                              IncreaseTeamNum();                      }                      if (numPressed <= _SelectSlides[_SelectSlideTeams].NumValues)                          _SelectSlides[_SelectSlideTeams].SelectedTag = numPressed;                  }              }
Magic Number,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The following statement contains a magic number: if (_SelectingKeyboardActive)              {                  //Handle left/right/up/down                  _NameSelections[_NameSelection].HandleInput(keyEvent);                  int numPressed = -1;                  bool resetSelection = false;                  switch (keyEvent.Key)                  {                      case Keys.Enter:                          //Check' if a player is selected                          if (_NameSelections[_NameSelection].SelectedID != Guid.Empty)                          {                              _SelectedProfileID = _NameSelections[_NameSelection].SelectedID;                                if (!CBase.Profiles.IsProfileIDValid(_SelectedProfileID))                                  return true;                                _AddPlayer(_CurrentTeam' _SelectedProfileID);                          }                          //Started selecting with 'P'                          if (_SelectingFast)                          {                              if (!_ChangePlayerNumDynamic && _TeamList[_CurrentTeam].Count == _NumPlayerTeams[_CurrentTeam])                                  resetSelection = true;                              else if (_TeamList[_CurrentTeam].Count == _PartyMode.MaxPlayersPerTeam)                                  resetSelection = true;                          }                          else if (!_SelectingFast)                              resetSelection = true;                          break;                        case Keys.Escape:                      case Keys.Back:                          resetSelection = true;                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                  }                  if (numPressed > 0 || resetSelection)                  {                      if (numPressed == _SelectingFastPlayerNr || resetSelection)                      {                          //Reset all values                          _SelectingFastPlayerNr = 0;                          _SelectingKeyboardActive = false;                          _NameSelections[_NameSelection].FastSelection(false' -1);                      }                      else if (numPressed <= _NumPlayerTeams[_CurrentTeam])                      {                          _SelectingFastPlayerNr = numPressed;                          _NameSelections[_NameSelection].FastSelection(true' numPressed);                      }                      _SelectingFast = false;                  }              }              else              {                  base.HandleInput(keyEvent);                    int numPressed = 0;                    switch (keyEvent.Key)                  {                      case Keys.Back:                      case Keys.Escape:                          Back();                          break;                        case Keys.Enter:                          if (_Buttons[_ButtonBack].Selected)                              Back();                            if (_Buttons[_ButtonNext].Selected)                              Next();                            if (_Buttons[_ButtonRandom].Selected)                              _SelectRandom();                            if (_Buttons[_ButtonIncreaseTeams].Selected)                              IncreaseTeamNum();                            if (_Buttons[_ButtonDecreaseTeams].Selected)                              DecreaseTeamNum();                            if (_Buttons[_ButtonIncreasePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                            if (_Buttons[_ButtonDecreasePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                            break;                        case Keys.Delete:                          if (_SelectSlides[_SelectSlidePlayer].Selected && _SelectSlides[_SelectSlidePlayer].NumValues > 0)                          {                              int index = _SelectSlides[_SelectSlidePlayer].Selection;                              _RemovePlayerByIndex(_CurrentTeam' index);                              _UpdatePlayerSlide();                          }                          break;                        case Keys.Left:                      case Keys.Right:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              _OnChangeTeamSlide();                          break;                        case Keys.P:                          if (!_SelectingKeyboardActive)                          {                              _SelectingFastPlayerNr = (_CurrentTeam + 1);                              _SelectingFast = true;                              //_ResetPlayerSelections();                          }                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                        case Keys.Subtract:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              DecreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                          break;                        case Keys.Add:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              IncreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                          break;                  }                    if (numPressed > 0)                  {                      if (_ChangeTeamNumDynamic && numPressed < _PartyMode.MaxTeams && numPressed > _SelectSlides[_SelectSlideTeams].NumValues)                      {                          while (numPressed < _PartyMode.MaxTeams)                              IncreaseTeamNum();                      }                      if (numPressed <= _SelectSlides[_SelectSlideTeams].NumValues)                          _SelectSlides[_SelectSlideTeams].SelectedTag = numPressed;                  }              }
Magic Number,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The following statement contains a magic number: if (_SelectingKeyboardActive)              {                  //Handle left/right/up/down                  _NameSelections[_NameSelection].HandleInput(keyEvent);                  int numPressed = -1;                  bool resetSelection = false;                  switch (keyEvent.Key)                  {                      case Keys.Enter:                          //Check' if a player is selected                          if (_NameSelections[_NameSelection].SelectedID != Guid.Empty)                          {                              _SelectedProfileID = _NameSelections[_NameSelection].SelectedID;                                if (!CBase.Profiles.IsProfileIDValid(_SelectedProfileID))                                  return true;                                _AddPlayer(_CurrentTeam' _SelectedProfileID);                          }                          //Started selecting with 'P'                          if (_SelectingFast)                          {                              if (!_ChangePlayerNumDynamic && _TeamList[_CurrentTeam].Count == _NumPlayerTeams[_CurrentTeam])                                  resetSelection = true;                              else if (_TeamList[_CurrentTeam].Count == _PartyMode.MaxPlayersPerTeam)                                  resetSelection = true;                          }                          else if (!_SelectingFast)                              resetSelection = true;                          break;                        case Keys.Escape:                      case Keys.Back:                          resetSelection = true;                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                  }                  if (numPressed > 0 || resetSelection)                  {                      if (numPressed == _SelectingFastPlayerNr || resetSelection)                      {                          //Reset all values                          _SelectingFastPlayerNr = 0;                          _SelectingKeyboardActive = false;                          _NameSelections[_NameSelection].FastSelection(false' -1);                      }                      else if (numPressed <= _NumPlayerTeams[_CurrentTeam])                      {                          _SelectingFastPlayerNr = numPressed;                          _NameSelections[_NameSelection].FastSelection(true' numPressed);                      }                      _SelectingFast = false;                  }              }              else              {                  base.HandleInput(keyEvent);                    int numPressed = 0;                    switch (keyEvent.Key)                  {                      case Keys.Back:                      case Keys.Escape:                          Back();                          break;                        case Keys.Enter:                          if (_Buttons[_ButtonBack].Selected)                              Back();                            if (_Buttons[_ButtonNext].Selected)                              Next();                            if (_Buttons[_ButtonRandom].Selected)                              _SelectRandom();                            if (_Buttons[_ButtonIncreaseTeams].Selected)                              IncreaseTeamNum();                            if (_Buttons[_ButtonDecreaseTeams].Selected)                              DecreaseTeamNum();                            if (_Buttons[_ButtonIncreasePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                            if (_Buttons[_ButtonDecreasePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                            break;                        case Keys.Delete:                          if (_SelectSlides[_SelectSlidePlayer].Selected && _SelectSlides[_SelectSlidePlayer].NumValues > 0)                          {                              int index = _SelectSlides[_SelectSlidePlayer].Selection;                              _RemovePlayerByIndex(_CurrentTeam' index);                              _UpdatePlayerSlide();                          }                          break;                        case Keys.Left:                      case Keys.Right:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              _OnChangeTeamSlide();                          break;                        case Keys.P:                          if (!_SelectingKeyboardActive)                          {                              _SelectingFastPlayerNr = (_CurrentTeam + 1);                              _SelectingFast = true;                              //_ResetPlayerSelections();                          }                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                        case Keys.Subtract:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              DecreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                          break;                        case Keys.Add:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              IncreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                          break;                  }                    if (numPressed > 0)                  {                      if (_ChangeTeamNumDynamic && numPressed < _PartyMode.MaxTeams && numPressed > _SelectSlides[_SelectSlideTeams].NumValues)                      {                          while (numPressed < _PartyMode.MaxTeams)                              IncreaseTeamNum();                      }                      if (numPressed <= _SelectSlides[_SelectSlideTeams].NumValues)                          _SelectSlides[_SelectSlideTeams].SelectedTag = numPressed;                  }              }
Magic Number,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The following statement contains a magic number: if (_SelectingKeyboardActive)              {                  //Handle left/right/up/down                  _NameSelections[_NameSelection].HandleInput(keyEvent);                  int numPressed = -1;                  bool resetSelection = false;                  switch (keyEvent.Key)                  {                      case Keys.Enter:                          //Check' if a player is selected                          if (_NameSelections[_NameSelection].SelectedID != Guid.Empty)                          {                              _SelectedProfileID = _NameSelections[_NameSelection].SelectedID;                                if (!CBase.Profiles.IsProfileIDValid(_SelectedProfileID))                                  return true;                                _AddPlayer(_CurrentTeam' _SelectedProfileID);                          }                          //Started selecting with 'P'                          if (_SelectingFast)                          {                              if (!_ChangePlayerNumDynamic && _TeamList[_CurrentTeam].Count == _NumPlayerTeams[_CurrentTeam])                                  resetSelection = true;                              else if (_TeamList[_CurrentTeam].Count == _PartyMode.MaxPlayersPerTeam)                                  resetSelection = true;                          }                          else if (!_SelectingFast)                              resetSelection = true;                          break;                        case Keys.Escape:                      case Keys.Back:                          resetSelection = true;                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                  }                  if (numPressed > 0 || resetSelection)                  {                      if (numPressed == _SelectingFastPlayerNr || resetSelection)                      {                          //Reset all values                          _SelectingFastPlayerNr = 0;                          _SelectingKeyboardActive = false;                          _NameSelections[_NameSelection].FastSelection(false' -1);                      }                      else if (numPressed <= _NumPlayerTeams[_CurrentTeam])                      {                          _SelectingFastPlayerNr = numPressed;                          _NameSelections[_NameSelection].FastSelection(true' numPressed);                      }                      _SelectingFast = false;                  }              }              else              {                  base.HandleInput(keyEvent);                    int numPressed = 0;                    switch (keyEvent.Key)                  {                      case Keys.Back:                      case Keys.Escape:                          Back();                          break;                        case Keys.Enter:                          if (_Buttons[_ButtonBack].Selected)                              Back();                            if (_Buttons[_ButtonNext].Selected)                              Next();                            if (_Buttons[_ButtonRandom].Selected)                              _SelectRandom();                            if (_Buttons[_ButtonIncreaseTeams].Selected)                              IncreaseTeamNum();                            if (_Buttons[_ButtonDecreaseTeams].Selected)                              DecreaseTeamNum();                            if (_Buttons[_ButtonIncreasePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                            if (_Buttons[_ButtonDecreasePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                            break;                        case Keys.Delete:                          if (_SelectSlides[_SelectSlidePlayer].Selected && _SelectSlides[_SelectSlidePlayer].NumValues > 0)                          {                              int index = _SelectSlides[_SelectSlidePlayer].Selection;                              _RemovePlayerByIndex(_CurrentTeam' index);                              _UpdatePlayerSlide();                          }                          break;                        case Keys.Left:                      case Keys.Right:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              _OnChangeTeamSlide();                          break;                        case Keys.P:                          if (!_SelectingKeyboardActive)                          {                              _SelectingFastPlayerNr = (_CurrentTeam + 1);                              _SelectingFast = true;                              //_ResetPlayerSelections();                          }                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                        case Keys.Subtract:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              DecreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                          break;                        case Keys.Add:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              IncreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                          break;                  }                    if (numPressed > 0)                  {                      if (_ChangeTeamNumDynamic && numPressed < _PartyMode.MaxTeams && numPressed > _SelectSlides[_SelectSlideTeams].NumValues)                      {                          while (numPressed < _PartyMode.MaxTeams)                              IncreaseTeamNum();                      }                      if (numPressed <= _SelectSlides[_SelectSlideTeams].NumValues)                          _SelectSlides[_SelectSlideTeams].SelectedTag = numPressed;                  }              }
Magic Number,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The following statement contains a magic number: if (_SelectingKeyboardActive)              {                  //Handle left/right/up/down                  _NameSelections[_NameSelection].HandleInput(keyEvent);                  int numPressed = -1;                  bool resetSelection = false;                  switch (keyEvent.Key)                  {                      case Keys.Enter:                          //Check' if a player is selected                          if (_NameSelections[_NameSelection].SelectedID != Guid.Empty)                          {                              _SelectedProfileID = _NameSelections[_NameSelection].SelectedID;                                if (!CBase.Profiles.IsProfileIDValid(_SelectedProfileID))                                  return true;                                _AddPlayer(_CurrentTeam' _SelectedProfileID);                          }                          //Started selecting with 'P'                          if (_SelectingFast)                          {                              if (!_ChangePlayerNumDynamic && _TeamList[_CurrentTeam].Count == _NumPlayerTeams[_CurrentTeam])                                  resetSelection = true;                              else if (_TeamList[_CurrentTeam].Count == _PartyMode.MaxPlayersPerTeam)                                  resetSelection = true;                          }                          else if (!_SelectingFast)                              resetSelection = true;                          break;                        case Keys.Escape:                      case Keys.Back:                          resetSelection = true;                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                  }                  if (numPressed > 0 || resetSelection)                  {                      if (numPressed == _SelectingFastPlayerNr || resetSelection)                      {                          //Reset all values                          _SelectingFastPlayerNr = 0;                          _SelectingKeyboardActive = false;                          _NameSelections[_NameSelection].FastSelection(false' -1);                      }                      else if (numPressed <= _NumPlayerTeams[_CurrentTeam])                      {                          _SelectingFastPlayerNr = numPressed;                          _NameSelections[_NameSelection].FastSelection(true' numPressed);                      }                      _SelectingFast = false;                  }              }              else              {                  base.HandleInput(keyEvent);                    int numPressed = 0;                    switch (keyEvent.Key)                  {                      case Keys.Back:                      case Keys.Escape:                          Back();                          break;                        case Keys.Enter:                          if (_Buttons[_ButtonBack].Selected)                              Back();                            if (_Buttons[_ButtonNext].Selected)                              Next();                            if (_Buttons[_ButtonRandom].Selected)                              _SelectRandom();                            if (_Buttons[_ButtonIncreaseTeams].Selected)                              IncreaseTeamNum();                            if (_Buttons[_ButtonDecreaseTeams].Selected)                              DecreaseTeamNum();                            if (_Buttons[_ButtonIncreasePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                            if (_Buttons[_ButtonDecreasePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                            break;                        case Keys.Delete:                          if (_SelectSlides[_SelectSlidePlayer].Selected && _SelectSlides[_SelectSlidePlayer].NumValues > 0)                          {                              int index = _SelectSlides[_SelectSlidePlayer].Selection;                              _RemovePlayerByIndex(_CurrentTeam' index);                              _UpdatePlayerSlide();                          }                          break;                        case Keys.Left:                      case Keys.Right:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              _OnChangeTeamSlide();                          break;                        case Keys.P:                          if (!_SelectingKeyboardActive)                          {                              _SelectingFastPlayerNr = (_CurrentTeam + 1);                              _SelectingFast = true;                              //_ResetPlayerSelections();                          }                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                        case Keys.Subtract:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              DecreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                          break;                        case Keys.Add:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              IncreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                          break;                  }                    if (numPressed > 0)                  {                      if (_ChangeTeamNumDynamic && numPressed < _PartyMode.MaxTeams && numPressed > _SelectSlides[_SelectSlideTeams].NumValues)                      {                          while (numPressed < _PartyMode.MaxTeams)                              IncreaseTeamNum();                      }                      if (numPressed <= _SelectSlides[_SelectSlideTeams].NumValues)                          _SelectSlides[_SelectSlideTeams].SelectedTag = numPressed;                  }              }
Magic Number,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The following statement contains a magic number: if (_SelectingKeyboardActive)              {                  //Handle left/right/up/down                  _NameSelections[_NameSelection].HandleInput(keyEvent);                  int numPressed = -1;                  bool resetSelection = false;                  switch (keyEvent.Key)                  {                      case Keys.Enter:                          //Check' if a player is selected                          if (_NameSelections[_NameSelection].SelectedID != Guid.Empty)                          {                              _SelectedProfileID = _NameSelections[_NameSelection].SelectedID;                                if (!CBase.Profiles.IsProfileIDValid(_SelectedProfileID))                                  return true;                                _AddPlayer(_CurrentTeam' _SelectedProfileID);                          }                          //Started selecting with 'P'                          if (_SelectingFast)                          {                              if (!_ChangePlayerNumDynamic && _TeamList[_CurrentTeam].Count == _NumPlayerTeams[_CurrentTeam])                                  resetSelection = true;                              else if (_TeamList[_CurrentTeam].Count == _PartyMode.MaxPlayersPerTeam)                                  resetSelection = true;                          }                          else if (!_SelectingFast)                              resetSelection = true;                          break;                        case Keys.Escape:                      case Keys.Back:                          resetSelection = true;                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                  }                  if (numPressed > 0 || resetSelection)                  {                      if (numPressed == _SelectingFastPlayerNr || resetSelection)                      {                          //Reset all values                          _SelectingFastPlayerNr = 0;                          _SelectingKeyboardActive = false;                          _NameSelections[_NameSelection].FastSelection(false' -1);                      }                      else if (numPressed <= _NumPlayerTeams[_CurrentTeam])                      {                          _SelectingFastPlayerNr = numPressed;                          _NameSelections[_NameSelection].FastSelection(true' numPressed);                      }                      _SelectingFast = false;                  }              }              else              {                  base.HandleInput(keyEvent);                    int numPressed = 0;                    switch (keyEvent.Key)                  {                      case Keys.Back:                      case Keys.Escape:                          Back();                          break;                        case Keys.Enter:                          if (_Buttons[_ButtonBack].Selected)                              Back();                            if (_Buttons[_ButtonNext].Selected)                              Next();                            if (_Buttons[_ButtonRandom].Selected)                              _SelectRandom();                            if (_Buttons[_ButtonIncreaseTeams].Selected)                              IncreaseTeamNum();                            if (_Buttons[_ButtonDecreaseTeams].Selected)                              DecreaseTeamNum();                            if (_Buttons[_ButtonIncreasePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                            if (_Buttons[_ButtonDecreasePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                            break;                        case Keys.Delete:                          if (_SelectSlides[_SelectSlidePlayer].Selected && _SelectSlides[_SelectSlidePlayer].NumValues > 0)                          {                              int index = _SelectSlides[_SelectSlidePlayer].Selection;                              _RemovePlayerByIndex(_CurrentTeam' index);                              _UpdatePlayerSlide();                          }                          break;                        case Keys.Left:                      case Keys.Right:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              _OnChangeTeamSlide();                          break;                        case Keys.P:                          if (!_SelectingKeyboardActive)                          {                              _SelectingFastPlayerNr = (_CurrentTeam + 1);                              _SelectingFast = true;                              //_ResetPlayerSelections();                          }                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                        case Keys.Subtract:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              DecreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                          break;                        case Keys.Add:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              IncreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                          break;                  }                    if (numPressed > 0)                  {                      if (_ChangeTeamNumDynamic && numPressed < _PartyMode.MaxTeams && numPressed > _SelectSlides[_SelectSlideTeams].NumValues)                      {                          while (numPressed < _PartyMode.MaxTeams)                              IncreaseTeamNum();                      }                      if (numPressed <= _SelectSlides[_SelectSlideTeams].NumValues)                          _SelectSlides[_SelectSlideTeams].SelectedTag = numPressed;                  }              }
Magic Number,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The following statement contains a magic number: if (_SelectingKeyboardActive)              {                  //Handle left/right/up/down                  _NameSelections[_NameSelection].HandleInput(keyEvent);                  int numPressed = -1;                  bool resetSelection = false;                  switch (keyEvent.Key)                  {                      case Keys.Enter:                          //Check' if a player is selected                          if (_NameSelections[_NameSelection].SelectedID != Guid.Empty)                          {                              _SelectedProfileID = _NameSelections[_NameSelection].SelectedID;                                if (!CBase.Profiles.IsProfileIDValid(_SelectedProfileID))                                  return true;                                _AddPlayer(_CurrentTeam' _SelectedProfileID);                          }                          //Started selecting with 'P'                          if (_SelectingFast)                          {                              if (!_ChangePlayerNumDynamic && _TeamList[_CurrentTeam].Count == _NumPlayerTeams[_CurrentTeam])                                  resetSelection = true;                              else if (_TeamList[_CurrentTeam].Count == _PartyMode.MaxPlayersPerTeam)                                  resetSelection = true;                          }                          else if (!_SelectingFast)                              resetSelection = true;                          break;                        case Keys.Escape:                      case Keys.Back:                          resetSelection = true;                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                  }                  if (numPressed > 0 || resetSelection)                  {                      if (numPressed == _SelectingFastPlayerNr || resetSelection)                      {                          //Reset all values                          _SelectingFastPlayerNr = 0;                          _SelectingKeyboardActive = false;                          _NameSelections[_NameSelection].FastSelection(false' -1);                      }                      else if (numPressed <= _NumPlayerTeams[_CurrentTeam])                      {                          _SelectingFastPlayerNr = numPressed;                          _NameSelections[_NameSelection].FastSelection(true' numPressed);                      }                      _SelectingFast = false;                  }              }              else              {                  base.HandleInput(keyEvent);                    int numPressed = 0;                    switch (keyEvent.Key)                  {                      case Keys.Back:                      case Keys.Escape:                          Back();                          break;                        case Keys.Enter:                          if (_Buttons[_ButtonBack].Selected)                              Back();                            if (_Buttons[_ButtonNext].Selected)                              Next();                            if (_Buttons[_ButtonRandom].Selected)                              _SelectRandom();                            if (_Buttons[_ButtonIncreaseTeams].Selected)                              IncreaseTeamNum();                            if (_Buttons[_ButtonDecreaseTeams].Selected)                              DecreaseTeamNum();                            if (_Buttons[_ButtonIncreasePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                            if (_Buttons[_ButtonDecreasePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                            break;                        case Keys.Delete:                          if (_SelectSlides[_SelectSlidePlayer].Selected && _SelectSlides[_SelectSlidePlayer].NumValues > 0)                          {                              int index = _SelectSlides[_SelectSlidePlayer].Selection;                              _RemovePlayerByIndex(_CurrentTeam' index);                              _UpdatePlayerSlide();                          }                          break;                        case Keys.Left:                      case Keys.Right:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              _OnChangeTeamSlide();                          break;                        case Keys.P:                          if (!_SelectingKeyboardActive)                          {                              _SelectingFastPlayerNr = (_CurrentTeam + 1);                              _SelectingFast = true;                              //_ResetPlayerSelections();                          }                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                        case Keys.Subtract:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              DecreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                          break;                        case Keys.Add:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              IncreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                          break;                  }                    if (numPressed > 0)                  {                      if (_ChangeTeamNumDynamic && numPressed < _PartyMode.MaxTeams && numPressed > _SelectSlides[_SelectSlideTeams].NumValues)                      {                          while (numPressed < _PartyMode.MaxTeams)                              IncreaseTeamNum();                      }                      if (numPressed <= _SelectSlides[_SelectSlideTeams].NumValues)                          _SelectSlides[_SelectSlideTeams].SelectedTag = numPressed;                  }              }
Magic Number,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The following statement contains a magic number: if (_SelectingKeyboardActive)              {                  //Handle left/right/up/down                  _NameSelections[_NameSelection].HandleInput(keyEvent);                  int numPressed = -1;                  bool resetSelection = false;                  switch (keyEvent.Key)                  {                      case Keys.Enter:                          //Check' if a player is selected                          if (_NameSelections[_NameSelection].SelectedID != Guid.Empty)                          {                              _SelectedProfileID = _NameSelections[_NameSelection].SelectedID;                                if (!CBase.Profiles.IsProfileIDValid(_SelectedProfileID))                                  return true;                                _AddPlayer(_CurrentTeam' _SelectedProfileID);                          }                          //Started selecting with 'P'                          if (_SelectingFast)                          {                              if (!_ChangePlayerNumDynamic && _TeamList[_CurrentTeam].Count == _NumPlayerTeams[_CurrentTeam])                                  resetSelection = true;                              else if (_TeamList[_CurrentTeam].Count == _PartyMode.MaxPlayersPerTeam)                                  resetSelection = true;                          }                          else if (!_SelectingFast)                              resetSelection = true;                          break;                        case Keys.Escape:                      case Keys.Back:                          resetSelection = true;                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                  }                  if (numPressed > 0 || resetSelection)                  {                      if (numPressed == _SelectingFastPlayerNr || resetSelection)                      {                          //Reset all values                          _SelectingFastPlayerNr = 0;                          _SelectingKeyboardActive = false;                          _NameSelections[_NameSelection].FastSelection(false' -1);                      }                      else if (numPressed <= _NumPlayerTeams[_CurrentTeam])                      {                          _SelectingFastPlayerNr = numPressed;                          _NameSelections[_NameSelection].FastSelection(true' numPressed);                      }                      _SelectingFast = false;                  }              }              else              {                  base.HandleInput(keyEvent);                    int numPressed = 0;                    switch (keyEvent.Key)                  {                      case Keys.Back:                      case Keys.Escape:                          Back();                          break;                        case Keys.Enter:                          if (_Buttons[_ButtonBack].Selected)                              Back();                            if (_Buttons[_ButtonNext].Selected)                              Next();                            if (_Buttons[_ButtonRandom].Selected)                              _SelectRandom();                            if (_Buttons[_ButtonIncreaseTeams].Selected)                              IncreaseTeamNum();                            if (_Buttons[_ButtonDecreaseTeams].Selected)                              DecreaseTeamNum();                            if (_Buttons[_ButtonIncreasePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                            if (_Buttons[_ButtonDecreasePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                            break;                        case Keys.Delete:                          if (_SelectSlides[_SelectSlidePlayer].Selected && _SelectSlides[_SelectSlidePlayer].NumValues > 0)                          {                              int index = _SelectSlides[_SelectSlidePlayer].Selection;                              _RemovePlayerByIndex(_CurrentTeam' index);                              _UpdatePlayerSlide();                          }                          break;                        case Keys.Left:                      case Keys.Right:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              _OnChangeTeamSlide();                          break;                        case Keys.P:                          if (!_SelectingKeyboardActive)                          {                              _SelectingFastPlayerNr = (_CurrentTeam + 1);                              _SelectingFast = true;                              //_ResetPlayerSelections();                          }                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                        case Keys.Subtract:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              DecreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                          break;                        case Keys.Add:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              IncreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                          break;                  }                    if (numPressed > 0)                  {                      if (_ChangeTeamNumDynamic && numPressed < _PartyMode.MaxTeams && numPressed > _SelectSlides[_SelectSlideTeams].NumValues)                      {                          while (numPressed < _PartyMode.MaxTeams)                              IncreaseTeamNum();                      }                      if (numPressed <= _SelectSlides[_SelectSlideTeams].NumValues)                          _SelectSlides[_SelectSlideTeams].SelectedTag = numPressed;                  }              }
Magic Number,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The following statement contains a magic number: if (_SelectingKeyboardActive)              {                  //Handle left/right/up/down                  _NameSelections[_NameSelection].HandleInput(keyEvent);                  int numPressed = -1;                  bool resetSelection = false;                  switch (keyEvent.Key)                  {                      case Keys.Enter:                          //Check' if a player is selected                          if (_NameSelections[_NameSelection].SelectedID != Guid.Empty)                          {                              _SelectedProfileID = _NameSelections[_NameSelection].SelectedID;                                if (!CBase.Profiles.IsProfileIDValid(_SelectedProfileID))                                  return true;                                _AddPlayer(_CurrentTeam' _SelectedProfileID);                          }                          //Started selecting with 'P'                          if (_SelectingFast)                          {                              if (!_ChangePlayerNumDynamic && _TeamList[_CurrentTeam].Count == _NumPlayerTeams[_CurrentTeam])                                  resetSelection = true;                              else if (_TeamList[_CurrentTeam].Count == _PartyMode.MaxPlayersPerTeam)                                  resetSelection = true;                          }                          else if (!_SelectingFast)                              resetSelection = true;                          break;                        case Keys.Escape:                      case Keys.Back:                          resetSelection = true;                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                  }                  if (numPressed > 0 || resetSelection)                  {                      if (numPressed == _SelectingFastPlayerNr || resetSelection)                      {                          //Reset all values                          _SelectingFastPlayerNr = 0;                          _SelectingKeyboardActive = false;                          _NameSelections[_NameSelection].FastSelection(false' -1);                      }                      else if (numPressed <= _NumPlayerTeams[_CurrentTeam])                      {                          _SelectingFastPlayerNr = numPressed;                          _NameSelections[_NameSelection].FastSelection(true' numPressed);                      }                      _SelectingFast = false;                  }              }              else              {                  base.HandleInput(keyEvent);                    int numPressed = 0;                    switch (keyEvent.Key)                  {                      case Keys.Back:                      case Keys.Escape:                          Back();                          break;                        case Keys.Enter:                          if (_Buttons[_ButtonBack].Selected)                              Back();                            if (_Buttons[_ButtonNext].Selected)                              Next();                            if (_Buttons[_ButtonRandom].Selected)                              _SelectRandom();                            if (_Buttons[_ButtonIncreaseTeams].Selected)                              IncreaseTeamNum();                            if (_Buttons[_ButtonDecreaseTeams].Selected)                              DecreaseTeamNum();                            if (_Buttons[_ButtonIncreasePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                            if (_Buttons[_ButtonDecreasePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                            break;                        case Keys.Delete:                          if (_SelectSlides[_SelectSlidePlayer].Selected && _SelectSlides[_SelectSlidePlayer].NumValues > 0)                          {                              int index = _SelectSlides[_SelectSlidePlayer].Selection;                              _RemovePlayerByIndex(_CurrentTeam' index);                              _UpdatePlayerSlide();                          }                          break;                        case Keys.Left:                      case Keys.Right:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              _OnChangeTeamSlide();                          break;                        case Keys.P:                          if (!_SelectingKeyboardActive)                          {                              _SelectingFastPlayerNr = (_CurrentTeam + 1);                              _SelectingFast = true;                              //_ResetPlayerSelections();                          }                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                        case Keys.Subtract:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              DecreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                          break;                        case Keys.Add:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              IncreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                          break;                  }                    if (numPressed > 0)                  {                      if (_ChangeTeamNumDynamic && numPressed < _PartyMode.MaxTeams && numPressed > _SelectSlides[_SelectSlideTeams].NumValues)                      {                          while (numPressed < _PartyMode.MaxTeams)                              IncreaseTeamNum();                      }                      if (numPressed <= _SelectSlides[_SelectSlideTeams].NumValues)                          _SelectSlides[_SelectSlideTeams].SelectedTag = numPressed;                  }              }
Magic Number,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The following statement contains a magic number: if (_SelectingKeyboardActive)              {                  //Handle left/right/up/down                  _NameSelections[_NameSelection].HandleInput(keyEvent);                  int numPressed = -1;                  bool resetSelection = false;                  switch (keyEvent.Key)                  {                      case Keys.Enter:                          //Check' if a player is selected                          if (_NameSelections[_NameSelection].SelectedID != Guid.Empty)                          {                              _SelectedProfileID = _NameSelections[_NameSelection].SelectedID;                                if (!CBase.Profiles.IsProfileIDValid(_SelectedProfileID))                                  return true;                                _AddPlayer(_CurrentTeam' _SelectedProfileID);                          }                          //Started selecting with 'P'                          if (_SelectingFast)                          {                              if (!_ChangePlayerNumDynamic && _TeamList[_CurrentTeam].Count == _NumPlayerTeams[_CurrentTeam])                                  resetSelection = true;                              else if (_TeamList[_CurrentTeam].Count == _PartyMode.MaxPlayersPerTeam)                                  resetSelection = true;                          }                          else if (!_SelectingFast)                              resetSelection = true;                          break;                        case Keys.Escape:                      case Keys.Back:                          resetSelection = true;                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                  }                  if (numPressed > 0 || resetSelection)                  {                      if (numPressed == _SelectingFastPlayerNr || resetSelection)                      {                          //Reset all values                          _SelectingFastPlayerNr = 0;                          _SelectingKeyboardActive = false;                          _NameSelections[_NameSelection].FastSelection(false' -1);                      }                      else if (numPressed <= _NumPlayerTeams[_CurrentTeam])                      {                          _SelectingFastPlayerNr = numPressed;                          _NameSelections[_NameSelection].FastSelection(true' numPressed);                      }                      _SelectingFast = false;                  }              }              else              {                  base.HandleInput(keyEvent);                    int numPressed = 0;                    switch (keyEvent.Key)                  {                      case Keys.Back:                      case Keys.Escape:                          Back();                          break;                        case Keys.Enter:                          if (_Buttons[_ButtonBack].Selected)                              Back();                            if (_Buttons[_ButtonNext].Selected)                              Next();                            if (_Buttons[_ButtonRandom].Selected)                              _SelectRandom();                            if (_Buttons[_ButtonIncreaseTeams].Selected)                              IncreaseTeamNum();                            if (_Buttons[_ButtonDecreaseTeams].Selected)                              DecreaseTeamNum();                            if (_Buttons[_ButtonIncreasePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                            if (_Buttons[_ButtonDecreasePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                            break;                        case Keys.Delete:                          if (_SelectSlides[_SelectSlidePlayer].Selected && _SelectSlides[_SelectSlidePlayer].NumValues > 0)                          {                              int index = _SelectSlides[_SelectSlidePlayer].Selection;                              _RemovePlayerByIndex(_CurrentTeam' index);                              _UpdatePlayerSlide();                          }                          break;                        case Keys.Left:                      case Keys.Right:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              _OnChangeTeamSlide();                          break;                        case Keys.P:                          if (!_SelectingKeyboardActive)                          {                              _SelectingFastPlayerNr = (_CurrentTeam + 1);                              _SelectingFast = true;                              //_ResetPlayerSelections();                          }                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                        case Keys.Subtract:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              DecreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                          break;                        case Keys.Add:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              IncreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                          break;                  }                    if (numPressed > 0)                  {                      if (_ChangeTeamNumDynamic && numPressed < _PartyMode.MaxTeams && numPressed > _SelectSlides[_SelectSlideTeams].NumValues)                      {                          while (numPressed < _PartyMode.MaxTeams)                              IncreaseTeamNum();                      }                      if (numPressed <= _SelectSlides[_SelectSlideTeams].NumValues)                          _SelectSlides[_SelectSlideTeams].SelectedTag = numPressed;                  }              }
Magic Number,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The following statement contains a magic number: if (_SelectingKeyboardActive)              {                  //Handle left/right/up/down                  _NameSelections[_NameSelection].HandleInput(keyEvent);                  int numPressed = -1;                  bool resetSelection = false;                  switch (keyEvent.Key)                  {                      case Keys.Enter:                          //Check' if a player is selected                          if (_NameSelections[_NameSelection].SelectedID != Guid.Empty)                          {                              _SelectedProfileID = _NameSelections[_NameSelection].SelectedID;                                if (!CBase.Profiles.IsProfileIDValid(_SelectedProfileID))                                  return true;                                _AddPlayer(_CurrentTeam' _SelectedProfileID);                          }                          //Started selecting with 'P'                          if (_SelectingFast)                          {                              if (!_ChangePlayerNumDynamic && _TeamList[_CurrentTeam].Count == _NumPlayerTeams[_CurrentTeam])                                  resetSelection = true;                              else if (_TeamList[_CurrentTeam].Count == _PartyMode.MaxPlayersPerTeam)                                  resetSelection = true;                          }                          else if (!_SelectingFast)                              resetSelection = true;                          break;                        case Keys.Escape:                      case Keys.Back:                          resetSelection = true;                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                  }                  if (numPressed > 0 || resetSelection)                  {                      if (numPressed == _SelectingFastPlayerNr || resetSelection)                      {                          //Reset all values                          _SelectingFastPlayerNr = 0;                          _SelectingKeyboardActive = false;                          _NameSelections[_NameSelection].FastSelection(false' -1);                      }                      else if (numPressed <= _NumPlayerTeams[_CurrentTeam])                      {                          _SelectingFastPlayerNr = numPressed;                          _NameSelections[_NameSelection].FastSelection(true' numPressed);                      }                      _SelectingFast = false;                  }              }              else              {                  base.HandleInput(keyEvent);                    int numPressed = 0;                    switch (keyEvent.Key)                  {                      case Keys.Back:                      case Keys.Escape:                          Back();                          break;                        case Keys.Enter:                          if (_Buttons[_ButtonBack].Selected)                              Back();                            if (_Buttons[_ButtonNext].Selected)                              Next();                            if (_Buttons[_ButtonRandom].Selected)                              _SelectRandom();                            if (_Buttons[_ButtonIncreaseTeams].Selected)                              IncreaseTeamNum();                            if (_Buttons[_ButtonDecreaseTeams].Selected)                              DecreaseTeamNum();                            if (_Buttons[_ButtonIncreasePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                            if (_Buttons[_ButtonDecreasePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                            break;                        case Keys.Delete:                          if (_SelectSlides[_SelectSlidePlayer].Selected && _SelectSlides[_SelectSlidePlayer].NumValues > 0)                          {                              int index = _SelectSlides[_SelectSlidePlayer].Selection;                              _RemovePlayerByIndex(_CurrentTeam' index);                              _UpdatePlayerSlide();                          }                          break;                        case Keys.Left:                      case Keys.Right:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              _OnChangeTeamSlide();                          break;                        case Keys.P:                          if (!_SelectingKeyboardActive)                          {                              _SelectingFastPlayerNr = (_CurrentTeam + 1);                              _SelectingFast = true;                              //_ResetPlayerSelections();                          }                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                        case Keys.Subtract:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              DecreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                          break;                        case Keys.Add:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              IncreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                          break;                  }                    if (numPressed > 0)                  {                      if (_ChangeTeamNumDynamic && numPressed < _PartyMode.MaxTeams && numPressed > _SelectSlides[_SelectSlideTeams].NumValues)                      {                          while (numPressed < _PartyMode.MaxTeams)                              IncreaseTeamNum();                      }                      if (numPressed <= _SelectSlides[_SelectSlideTeams].NumValues)                          _SelectSlides[_SelectSlideTeams].SelectedTag = numPressed;                  }              }
Magic Number,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The following statement contains a magic number: if (_SelectingKeyboardActive)              {                  //Handle left/right/up/down                  _NameSelections[_NameSelection].HandleInput(keyEvent);                  int numPressed = -1;                  bool resetSelection = false;                  switch (keyEvent.Key)                  {                      case Keys.Enter:                          //Check' if a player is selected                          if (_NameSelections[_NameSelection].SelectedID != Guid.Empty)                          {                              _SelectedProfileID = _NameSelections[_NameSelection].SelectedID;                                if (!CBase.Profiles.IsProfileIDValid(_SelectedProfileID))                                  return true;                                _AddPlayer(_CurrentTeam' _SelectedProfileID);                          }                          //Started selecting with 'P'                          if (_SelectingFast)                          {                              if (!_ChangePlayerNumDynamic && _TeamList[_CurrentTeam].Count == _NumPlayerTeams[_CurrentTeam])                                  resetSelection = true;                              else if (_TeamList[_CurrentTeam].Count == _PartyMode.MaxPlayersPerTeam)                                  resetSelection = true;                          }                          else if (!_SelectingFast)                              resetSelection = true;                          break;                        case Keys.Escape:                      case Keys.Back:                          resetSelection = true;                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                  }                  if (numPressed > 0 || resetSelection)                  {                      if (numPressed == _SelectingFastPlayerNr || resetSelection)                      {                          //Reset all values                          _SelectingFastPlayerNr = 0;                          _SelectingKeyboardActive = false;                          _NameSelections[_NameSelection].FastSelection(false' -1);                      }                      else if (numPressed <= _NumPlayerTeams[_CurrentTeam])                      {                          _SelectingFastPlayerNr = numPressed;                          _NameSelections[_NameSelection].FastSelection(true' numPressed);                      }                      _SelectingFast = false;                  }              }              else              {                  base.HandleInput(keyEvent);                    int numPressed = 0;                    switch (keyEvent.Key)                  {                      case Keys.Back:                      case Keys.Escape:                          Back();                          break;                        case Keys.Enter:                          if (_Buttons[_ButtonBack].Selected)                              Back();                            if (_Buttons[_ButtonNext].Selected)                              Next();                            if (_Buttons[_ButtonRandom].Selected)                              _SelectRandom();                            if (_Buttons[_ButtonIncreaseTeams].Selected)                              IncreaseTeamNum();                            if (_Buttons[_ButtonDecreaseTeams].Selected)                              DecreaseTeamNum();                            if (_Buttons[_ButtonIncreasePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                            if (_Buttons[_ButtonDecreasePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                            break;                        case Keys.Delete:                          if (_SelectSlides[_SelectSlidePlayer].Selected && _SelectSlides[_SelectSlidePlayer].NumValues > 0)                          {                              int index = _SelectSlides[_SelectSlidePlayer].Selection;                              _RemovePlayerByIndex(_CurrentTeam' index);                              _UpdatePlayerSlide();                          }                          break;                        case Keys.Left:                      case Keys.Right:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              _OnChangeTeamSlide();                          break;                        case Keys.P:                          if (!_SelectingKeyboardActive)                          {                              _SelectingFastPlayerNr = (_CurrentTeam + 1);                              _SelectingFast = true;                              //_ResetPlayerSelections();                          }                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                        case Keys.Subtract:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              DecreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                          break;                        case Keys.Add:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              IncreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                          break;                  }                    if (numPressed > 0)                  {                      if (_ChangeTeamNumDynamic && numPressed < _PartyMode.MaxTeams && numPressed > _SelectSlides[_SelectSlideTeams].NumValues)                      {                          while (numPressed < _PartyMode.MaxTeams)                              IncreaseTeamNum();                      }                      if (numPressed <= _SelectSlides[_SelectSlideTeams].NumValues)                          _SelectSlides[_SelectSlideTeams].SelectedTag = numPressed;                  }              }
Magic Number,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The following statement contains a magic number: if (_SelectingKeyboardActive)              {                  //Handle left/right/up/down                  _NameSelections[_NameSelection].HandleInput(keyEvent);                  int numPressed = -1;                  bool resetSelection = false;                  switch (keyEvent.Key)                  {                      case Keys.Enter:                          //Check' if a player is selected                          if (_NameSelections[_NameSelection].SelectedID != Guid.Empty)                          {                              _SelectedProfileID = _NameSelections[_NameSelection].SelectedID;                                if (!CBase.Profiles.IsProfileIDValid(_SelectedProfileID))                                  return true;                                _AddPlayer(_CurrentTeam' _SelectedProfileID);                          }                          //Started selecting with 'P'                          if (_SelectingFast)                          {                              if (!_ChangePlayerNumDynamic && _TeamList[_CurrentTeam].Count == _NumPlayerTeams[_CurrentTeam])                                  resetSelection = true;                              else if (_TeamList[_CurrentTeam].Count == _PartyMode.MaxPlayersPerTeam)                                  resetSelection = true;                          }                          else if (!_SelectingFast)                              resetSelection = true;                          break;                        case Keys.Escape:                      case Keys.Back:                          resetSelection = true;                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                  }                  if (numPressed > 0 || resetSelection)                  {                      if (numPressed == _SelectingFastPlayerNr || resetSelection)                      {                          //Reset all values                          _SelectingFastPlayerNr = 0;                          _SelectingKeyboardActive = false;                          _NameSelections[_NameSelection].FastSelection(false' -1);                      }                      else if (numPressed <= _NumPlayerTeams[_CurrentTeam])                      {                          _SelectingFastPlayerNr = numPressed;                          _NameSelections[_NameSelection].FastSelection(true' numPressed);                      }                      _SelectingFast = false;                  }              }              else              {                  base.HandleInput(keyEvent);                    int numPressed = 0;                    switch (keyEvent.Key)                  {                      case Keys.Back:                      case Keys.Escape:                          Back();                          break;                        case Keys.Enter:                          if (_Buttons[_ButtonBack].Selected)                              Back();                            if (_Buttons[_ButtonNext].Selected)                              Next();                            if (_Buttons[_ButtonRandom].Selected)                              _SelectRandom();                            if (_Buttons[_ButtonIncreaseTeams].Selected)                              IncreaseTeamNum();                            if (_Buttons[_ButtonDecreaseTeams].Selected)                              DecreaseTeamNum();                            if (_Buttons[_ButtonIncreasePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                            if (_Buttons[_ButtonDecreasePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                            break;                        case Keys.Delete:                          if (_SelectSlides[_SelectSlidePlayer].Selected && _SelectSlides[_SelectSlidePlayer].NumValues > 0)                          {                              int index = _SelectSlides[_SelectSlidePlayer].Selection;                              _RemovePlayerByIndex(_CurrentTeam' index);                              _UpdatePlayerSlide();                          }                          break;                        case Keys.Left:                      case Keys.Right:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              _OnChangeTeamSlide();                          break;                        case Keys.P:                          if (!_SelectingKeyboardActive)                          {                              _SelectingFastPlayerNr = (_CurrentTeam + 1);                              _SelectingFast = true;                              //_ResetPlayerSelections();                          }                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                        case Keys.Subtract:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              DecreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                          break;                        case Keys.Add:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              IncreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                          break;                  }                    if (numPressed > 0)                  {                      if (_ChangeTeamNumDynamic && numPressed < _PartyMode.MaxTeams && numPressed > _SelectSlides[_SelectSlideTeams].NumValues)                      {                          while (numPressed < _PartyMode.MaxTeams)                              IncreaseTeamNum();                      }                      if (numPressed <= _SelectSlides[_SelectSlideTeams].NumValues)                          _SelectSlides[_SelectSlideTeams].SelectedTag = numPressed;                  }              }
Magic Number,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The following statement contains a magic number: if (_SelectingKeyboardActive)              {                  //Handle left/right/up/down                  _NameSelections[_NameSelection].HandleInput(keyEvent);                  int numPressed = -1;                  bool resetSelection = false;                  switch (keyEvent.Key)                  {                      case Keys.Enter:                          //Check' if a player is selected                          if (_NameSelections[_NameSelection].SelectedID != Guid.Empty)                          {                              _SelectedProfileID = _NameSelections[_NameSelection].SelectedID;                                if (!CBase.Profiles.IsProfileIDValid(_SelectedProfileID))                                  return true;                                _AddPlayer(_CurrentTeam' _SelectedProfileID);                          }                          //Started selecting with 'P'                          if (_SelectingFast)                          {                              if (!_ChangePlayerNumDynamic && _TeamList[_CurrentTeam].Count == _NumPlayerTeams[_CurrentTeam])                                  resetSelection = true;                              else if (_TeamList[_CurrentTeam].Count == _PartyMode.MaxPlayersPerTeam)                                  resetSelection = true;                          }                          else if (!_SelectingFast)                              resetSelection = true;                          break;                        case Keys.Escape:                      case Keys.Back:                          resetSelection = true;                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                  }                  if (numPressed > 0 || resetSelection)                  {                      if (numPressed == _SelectingFastPlayerNr || resetSelection)                      {                          //Reset all values                          _SelectingFastPlayerNr = 0;                          _SelectingKeyboardActive = false;                          _NameSelections[_NameSelection].FastSelection(false' -1);                      }                      else if (numPressed <= _NumPlayerTeams[_CurrentTeam])                      {                          _SelectingFastPlayerNr = numPressed;                          _NameSelections[_NameSelection].FastSelection(true' numPressed);                      }                      _SelectingFast = false;                  }              }              else              {                  base.HandleInput(keyEvent);                    int numPressed = 0;                    switch (keyEvent.Key)                  {                      case Keys.Back:                      case Keys.Escape:                          Back();                          break;                        case Keys.Enter:                          if (_Buttons[_ButtonBack].Selected)                              Back();                            if (_Buttons[_ButtonNext].Selected)                              Next();                            if (_Buttons[_ButtonRandom].Selected)                              _SelectRandom();                            if (_Buttons[_ButtonIncreaseTeams].Selected)                              IncreaseTeamNum();                            if (_Buttons[_ButtonDecreaseTeams].Selected)                              DecreaseTeamNum();                            if (_Buttons[_ButtonIncreasePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                            if (_Buttons[_ButtonDecreasePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                            break;                        case Keys.Delete:                          if (_SelectSlides[_SelectSlidePlayer].Selected && _SelectSlides[_SelectSlidePlayer].NumValues > 0)                          {                              int index = _SelectSlides[_SelectSlidePlayer].Selection;                              _RemovePlayerByIndex(_CurrentTeam' index);                              _UpdatePlayerSlide();                          }                          break;                        case Keys.Left:                      case Keys.Right:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              _OnChangeTeamSlide();                          break;                        case Keys.P:                          if (!_SelectingKeyboardActive)                          {                              _SelectingFastPlayerNr = (_CurrentTeam + 1);                              _SelectingFast = true;                              //_ResetPlayerSelections();                          }                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                        case Keys.Subtract:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              DecreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                          break;                        case Keys.Add:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              IncreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                          break;                  }                    if (numPressed > 0)                  {                      if (_ChangeTeamNumDynamic && numPressed < _PartyMode.MaxTeams && numPressed > _SelectSlides[_SelectSlideTeams].NumValues)                      {                          while (numPressed < _PartyMode.MaxTeams)                              IncreaseTeamNum();                      }                      if (numPressed <= _SelectSlides[_SelectSlideTeams].NumValues)                          _SelectSlides[_SelectSlideTeams].SelectedTag = numPressed;                  }              }
Magic Number,VocaluxeLib.Menu,CNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CNameSelection.cs,Init,The following statement contains a magic number: _PlayerSelector = new CStatic(_PartyModeID' _TextureTileSelected' new SColorF()' new SRectF(0' 0' _Theme.Tiles.W + 6' _Theme.Tiles.H + 6' Rect.Z - 0.5f))                  {                      Visible = false                  };
Magic Number,VocaluxeLib.Menu,CNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CNameSelection.cs,Init,The following statement contains a magic number: _PlayerSelector = new CStatic(_PartyModeID' _TextureTileSelected' new SColorF()' new SRectF(0' 0' _Theme.Tiles.W + 6' _Theme.Tiles.H + 6' Rect.Z - 0.5f))                  {                      Visible = false                  };
Magic Number,VocaluxeLib.Menu,CNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CNameSelection.cs,Draw,The following statement contains a magic number: foreach (CTile tile in _Tiles)              {                  tile.Avatar.Draw();                  tile.Name.Draw();                    if (_PlayerSelector.Visible)                  {                      //Update PlayerSelector-Coords                      if (_Player > -1 && _ActualSelection == i)                      {                          _PlayerSelector.X = tile.Avatar.Rect.X - 3;                          _PlayerSelector.Y = tile.Avatar.Rect.Y - 3;                      }                  }                    i++;              }
Magic Number,VocaluxeLib.Menu,CNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CNameSelection.cs,Draw,The following statement contains a magic number: foreach (CTile tile in _Tiles)              {                  tile.Avatar.Draw();                  tile.Name.Draw();                    if (_PlayerSelector.Visible)                  {                      //Update PlayerSelector-Coords                      if (_Player > -1 && _ActualSelection == i)                      {                          _PlayerSelector.X = tile.Avatar.Rect.X - 3;                          _PlayerSelector.Y = tile.Avatar.Rect.Y - 3;                      }                  }                    i++;              }
Magic Number,VocaluxeLib.Menu,CNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CNameSelection.cs,_PrepareTiles,The following statement contains a magic number: for (int i = 0; i < _Theme.Tiles.NumH; i++)              {                  for (int j = 0; j < _Theme.Tiles.NumW; j++)                  {                      var rect = new SRectF(MaxRect.X + j * (_Theme.Tiles.W + _Theme.Tiles.SpaceW)' MaxRect.Y + i * (_Theme.Tiles.H + _Theme.Tiles.SpaceH)'                                            _Theme.Tiles.W' _Theme.Tiles.H' MaxRect.Z);                      var tileStatic = new CStatic(_PartyModeID' _TextureEmptyTile' _ColorEmptyTile' rect) {Aspect = EAspect.Crop};                      var tileText = new CText(rect.X + rect.W / 2' rect.Y + rect.H + _Theme.Tiles.Name.Space' rect.Z' _Theme.Tiles.Name.Height' rect.W' EAlignment.Center'                                               _Theme.Tiles.Name.Style' _Theme.Tiles.Name.Font' _ColorNameTile' "");                      _Tiles.Add(new CTile(tileStatic' tileText' Guid.Empty));                  }              }
Magic Number,VocaluxeLib.Menu,CObjectInteractions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CObjectInteractions.cs,HandleInputThemeEditor,The following statement contains a magic number: if ((keyEvent.Mod & EModifier.Ctrl) != EModifier.Ctrl)              {                  dx *= 5;                  dy *= 5;              }
Magic Number,VocaluxeLib.Menu,CObjectInteractions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CObjectInteractions.cs,HandleInputThemeEditor,The following statement contains a magic number: if ((keyEvent.Mod & EModifier.Ctrl) != EModifier.Ctrl)              {                  dx *= 5;                  dy *= 5;              }
Magic Number,VocaluxeLib.Menu,CObjectInteractions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CObjectInteractions.cs,HandleMouseThemeEditor,The following statement contains a magic number: if ((mouseEvent.Mod & EModifier.Ctrl) != EModifier.Ctrl)              {                  // Clip to raster                  mouse.X = (int)(Math.Round((double)mouse.X / 5) * 5);                  mouse.Y = (int)(Math.Round((double)mouse.Y / 5) * 5);              }
Magic Number,VocaluxeLib.Menu,CObjectInteractions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CObjectInteractions.cs,HandleMouseThemeEditor,The following statement contains a magic number: if ((mouseEvent.Mod & EModifier.Ctrl) != EModifier.Ctrl)              {                  // Clip to raster                  mouse.X = (int)(Math.Round((double)mouse.X / 5) * 5);                  mouse.Y = (int)(Math.Round((double)mouse.Y / 5) * 5);              }
Magic Number,VocaluxeLib.Menu,CObjectInteractions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CObjectInteractions.cs,HandleMouseThemeEditor,The following statement contains a magic number: if ((mouseEvent.Mod & EModifier.Ctrl) != EModifier.Ctrl)              {                  // Clip to raster                  mouse.X = (int)(Math.Round((double)mouse.X / 5) * 5);                  mouse.Y = (int)(Math.Round((double)mouse.Y / 5) * 5);              }
Magic Number,VocaluxeLib.Menu,CObjectInteractions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CObjectInteractions.cs,HandleMouseThemeEditor,The following statement contains a magic number: if ((mouseEvent.Mod & EModifier.Ctrl) != EModifier.Ctrl)              {                  // Clip to raster                  mouse.X = (int)(Math.Round((double)mouse.X / 5) * 5);                  mouse.Y = (int)(Math.Round((double)mouse.Y / 5) * 5);              }
Magic Number,VocaluxeLib.Menu,CParticle,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticle.cs,CParticle,The following statement contains a magic number: _Rotation = (float)(CBase.Game.GetRandomDouble() * 360.0);
Magic Number,VocaluxeLib.Menu,CParticle,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticle.cs,CParticle,The following statement contains a magic number: _Rotation = (float)(CBase.Game.GetRandomDouble() * 360.0);
Magic Number,VocaluxeLib.Menu,CParticle,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticle.cs,Update,The following statement contains a magic number: if (_MaxAge > 0f)              {                  switch (_Type)                  {                      case EParticleType.Twinkle:                          _Alpha = 1f - _Age / _MaxAge;                          break;                        case EParticleType.Star:                          _Alpha = 1f - _Age / _MaxAge;                          break;                        case EParticleType.Snow:                          _Alpha = (float)Math.Sqrt((Math.Sin(_Age / _MaxAge * Math.PI * 2 - 0.5 * Math.PI) + 1) / 2);                          break;                        case EParticleType.Flare:                          _Alpha = 1f - _Age / _MaxAge;                          break;                        case EParticleType.PerfNoteStar:                          _Alpha = 1f - _Age / _MaxAge;                          break;                  }              }
Magic Number,VocaluxeLib.Menu,CParticle,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticle.cs,Update,The following statement contains a magic number: if (_MaxAge > 0f)              {                  switch (_Type)                  {                      case EParticleType.Twinkle:                          _Alpha = 1f - _Age / _MaxAge;                          break;                        case EParticleType.Star:                          _Alpha = 1f - _Age / _MaxAge;                          break;                        case EParticleType.Snow:                          _Alpha = (float)Math.Sqrt((Math.Sin(_Age / _MaxAge * Math.PI * 2 - 0.5 * Math.PI) + 1) / 2);                          break;                        case EParticleType.Flare:                          _Alpha = 1f - _Age / _MaxAge;                          break;                        case EParticleType.PerfNoteStar:                          _Alpha = 1f - _Age / _MaxAge;                          break;                  }              }
Magic Number,VocaluxeLib.Menu,CParticle,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticle.cs,Update,The following statement contains a magic number: if (_MaxAge > 0f)              {                  switch (_Type)                  {                      case EParticleType.Twinkle:                          _Alpha = 1f - _Age / _MaxAge;                          break;                        case EParticleType.Star:                          _Alpha = 1f - _Age / _MaxAge;                          break;                        case EParticleType.Snow:                          _Alpha = (float)Math.Sqrt((Math.Sin(_Age / _MaxAge * Math.PI * 2 - 0.5 * Math.PI) + 1) / 2);                          break;                        case EParticleType.Flare:                          _Alpha = 1f - _Age / _MaxAge;                          break;                        case EParticleType.PerfNoteStar:                          _Alpha = 1f - _Age / _MaxAge;                          break;                  }              }
Magic Number,VocaluxeLib.Menu,CParticle,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticle.cs,Update,The following statement contains a magic number: if (Math.Abs(_Vsize) > float.Epsilon)              {                  float size = _Size;                  switch (_Type)                  {                      case EParticleType.Twinkle:                          size = _Size * (1f - currentTime / _Vsize);                          break;                        case EParticleType.Star:                          size = _Size * (1f - currentTime / _Vsize);                          break;                        case EParticleType.Snow:                          size = _Size * (float)Math.Sqrt((Math.Sin(currentTime / _Vsize * Math.PI * 2 - 0.5 * Math.PI) + 1) / 2);                          break;                        case EParticleType.Flare:                          size = _Size * (1f - currentTime / _Vsize);                          break;                        case EParticleType.PerfNoteStar:                          size = _Size * (1f - currentTime / _Vsize);                          break;                  }                    _Rect.X += (_Rect.W - size) / 2f;                  _Rect.Y += (_Rect.H - size) / 2f;                  _Rect.W = size;                  _Rect.H = size;              }
Magic Number,VocaluxeLib.Menu,CParticle,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticle.cs,Update,The following statement contains a magic number: if (Math.Abs(_Vsize) > float.Epsilon)              {                  float size = _Size;                  switch (_Type)                  {                      case EParticleType.Twinkle:                          size = _Size * (1f - currentTime / _Vsize);                          break;                        case EParticleType.Star:                          size = _Size * (1f - currentTime / _Vsize);                          break;                        case EParticleType.Snow:                          size = _Size * (float)Math.Sqrt((Math.Sin(currentTime / _Vsize * Math.PI * 2 - 0.5 * Math.PI) + 1) / 2);                          break;                        case EParticleType.Flare:                          size = _Size * (1f - currentTime / _Vsize);                          break;                        case EParticleType.PerfNoteStar:                          size = _Size * (1f - currentTime / _Vsize);                          break;                  }                    _Rect.X += (_Rect.W - size) / 2f;                  _Rect.Y += (_Rect.H - size) / 2f;                  _Rect.W = size;                  _Rect.H = size;              }
Magic Number,VocaluxeLib.Menu,CParticle,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticle.cs,Update,The following statement contains a magic number: if (Math.Abs(_Vsize) > float.Epsilon)              {                  float size = _Size;                  switch (_Type)                  {                      case EParticleType.Twinkle:                          size = _Size * (1f - currentTime / _Vsize);                          break;                        case EParticleType.Star:                          size = _Size * (1f - currentTime / _Vsize);                          break;                        case EParticleType.Snow:                          size = _Size * (float)Math.Sqrt((Math.Sin(currentTime / _Vsize * Math.PI * 2 - 0.5 * Math.PI) + 1) / 2);                          break;                        case EParticleType.Flare:                          size = _Size * (1f - currentTime / _Vsize);                          break;                        case EParticleType.PerfNoteStar:                          size = _Size * (1f - currentTime / _Vsize);                          break;                  }                    _Rect.X += (_Rect.W - size) / 2f;                  _Rect.Y += (_Rect.H - size) / 2f;                  _Rect.W = size;                  _Rect.H = size;              }
Magic Number,VocaluxeLib.Menu,CParticle,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticle.cs,Update,The following statement contains a magic number: if (Math.Abs(_Vr) > 0.01)              {                  float r = currentTime * _Vr / 60f;                  _Angle = _Rotation + 360f * (r - (float)Math.Floor(r));                  _Rect.Rotation = _Angle;              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following statement contains a magic number: while (_Stars.Count < _Theme.MaxNumber && doSpawn)              {                  float size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                  float lifetime = 0f;                  float vx = 0f;                  float vy = 0f;                  float vr = 0f;                  float vsize = 0f;                  _NextSpawnTime = 0f;                    switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }                    var w = (int)(Rect.W - size / 4f);                  var h = (int)(Rect.H - size / 4f);                    if (w < 0)                      w = 0;                    if (h < 0)                      h = 0;                    CParticle star;                  if (!String.IsNullOrEmpty(_Theme.Skin))                  {                      star = new CParticle(_PartyModeID' _Theme.Skin' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                  else                  {                      star = new CParticle(_PartyModeID' Texture' Color'                                           CBase.Game.GetRandom(w) + Rect.X - size / 4f'                                           CBase.Game.GetRandom(h) + Rect.Y - size / 4f'                                           size' lifetime' Rect.Z' vx' vy' vr' vsize' _Theme.Type);                  }                    _Stars.Add(star);              }
Magic Number,VocaluxeLib.Menu,CPlaylist,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CPlaylist.cs,HandleInput,The following statement contains a magic number: if (_CurrentPlaylistElement == -1 || _PlaylistElementContents.Count == 0)              {                  //no song is selected                  bool handled = base.HandleInput(keyEvent);                  _CurrentPlaylistElement = _GetSelectedElementNr();                    if (_CurrentPlaylistElement != -1 || handled)                      return true;              }              else if (_CurrentPlaylistElement != -1)              {                  //a song is selected                  int scrollLimit = _PlaylistElements.Count / 2;                    //special actions if a song is selected                  switch (keyEvent.Key)                  {                      case Keys.Up:                          if (keyEvent.ModShift)                          {                              _SelectElement(_PlaylistElements[0].SelectSlide);                              base.HandleInput(keyEvent);                              _CurrentPlaylistElement = _GetSelectedElementNr();                          }                          else if (_CurrentPlaylistElement > scrollLimit || _PlaylistElementContents.Count == 0)                          {                              base.HandleInput(keyEvent);                              _CurrentPlaylistElement = _GetSelectedElementNr();                          }                          else if (_CurrentPlaylistElement <= scrollLimit)                          {                              if (_Offset > 0)                              {                                  _Offset--;                                  _Update();                              }                              else                              {                                  base.HandleInput(keyEvent);                                  _CurrentPlaylistElement = _GetSelectedElementNr();                              }                          }                          break;                        case Keys.Down:                          if (keyEvent.ModShift)                          {                              for (int i = _PlaylistElements.Count - 1; i >= 0; i--)                              {                                  if (_PlaylistElements[i].SelectSlide.Visible)                                  {                                      _SelectElement(_PlaylistElements[0].SelectSlide);                                      base.HandleInput(keyEvent);                                      _CurrentPlaylistElement = _GetSelectedElementNr();                                  }                              }                          }                          else if (_CurrentPlaylistElement >= scrollLimit)                          {                              if (_Offset < _PlaylistElementContents.Count - _PlaylistElements.Count)                              {                                  _Offset++;                                  _Update();                              }                              else                              {                                  base.HandleInput(keyEvent);                                  _CurrentPlaylistElement = _GetSelectedElementNr();                              }                          }                          else if (_CurrentPlaylistElement < scrollLimit)                          {                              base.HandleInput(keyEvent);                              _CurrentPlaylistElement = _GetSelectedElementNr();                          }                          break;                        case Keys.Delete:                          CBase.Playlist.DeleteSong(ActivePlaylistID' _PlaylistElements[_CurrentPlaylistElement].Content);                          UpdatePlaylist();                            if (_Offset > 0)                              _Offset--;                            _Update();                            if (_PlaylistElementContents.Count - 1 < _CurrentPlaylistElement)                              _CurrentPlaylistElement = _PlaylistElementContents.Count - 1;                            if (_CurrentPlaylistElement != -1)                              _SelectElement(_PlaylistElements[_CurrentPlaylistElement].SelectSlide);                          break;                        case Keys.Back:                          ClosePlaylist(); //really? or better global?                          break;                        case Keys.Enter:                          _StartPlaylistSong(_CurrentPlaylistElement);                          break;                        case Keys.Add: //move the selected song up                          if (_PlaylistElementContents.Count > 1 && (_CurrentPlaylistElement > 0 || _Offset > 0))                          {                              CBase.Playlist.MoveSongUp(ActivePlaylistID' _CurrentPlaylistElement + _Offset);                              UpdatePlaylist();                                var key = new SKeyEvent {Key = Keys.Up};                                if (_CurrentPlaylistElement > scrollLimit)                              {                                  base.HandleInput(key);                                  _CurrentPlaylistElement = _GetSelectedElementNr();                              }                              else if (_CurrentPlaylistElement <= scrollLimit)                              {                                  if (_Offset > 0)                                  {                                      _Offset--;                                      _Update();                                  }                                  else                                  {                                      base.HandleInput(key);                                      _CurrentPlaylistElement = _GetSelectedElementNr();                                  }                              }                          }                          break;                        case Keys.Subtract: //move the selected song down                          if (_PlaylistElementContents.Count > 1 && _CurrentPlaylistElement + _Offset < _PlaylistElementContents.Count - 1)                          {                              CBase.Playlist.MoveSongDown(ActivePlaylistID' _CurrentPlaylistElement + _Offset);                              UpdatePlaylist();                                var key = new SKeyEvent {Key = Keys.Down};                                if (_CurrentPlaylistElement >= scrollLimit)                              {                                  if (_Offset < _PlaylistElementContents.Count - _PlaylistElements.Count)                                  {                                      _Offset++;                                      _Update();                                  }                                  else                                  {                                      base.HandleInput(key);                                      _CurrentPlaylistElement = _GetSelectedElementNr();                                  }                              }                              else if (_CurrentPlaylistElement < scrollLimit)                              {                                  base.HandleInput(key);                                  _CurrentPlaylistElement = _GetSelectedElementNr();                              }                          }                          break;                        case Keys.PageUp: //scroll up                          if (_PlaylistElementContents.Count > 0)                          {                              _Offset -= _PlaylistElements.Count;                                if (_Offset < 0)                                  _Offset = 0;                                _Update();                              _CurrentPlaylistElement = 0;                          }                          break;                        case Keys.PageDown: //scroll down                          if (_PlaylistElementContents.Count > 0)                          {                              _Offset += _PlaylistElements.Count;                                if (_Offset > _PlaylistElementContents.Count - _PlaylistElements.Count)                                  _Offset = _PlaylistElementContents.Count - _PlaylistElements.Count;                                if (_Offset < 0)                                  _Offset = 0;                                _Update();                                for (int i = _PlaylistElements.Count - 1; i >= 0; i--)                              {                                  if (_PlaylistElements[i].SelectSlide.Visible)                                  {                                      _CurrentPlaylistElement = i;                                      break;                                  }                              }                          }                          break;                        case Keys.Left:                          base.HandleInput(keyEvent);                          _CurrentPlaylistElement = _GetSelectedElementNr();                            if (_CurrentPlaylistElement != -1)                          {                              CBase.Playlist.GetSong(ActivePlaylistID' _CurrentPlaylistElement + _Offset).GameMode =                                  _PlaylistElementContents[_CurrentPlaylistElement + _Offset].Modes[_PlaylistElements[_CurrentPlaylistElement].SelectSlide.Selection];                              UpdatePlaylist();                          }                          break;                        case Keys.Right:                          base.HandleInput(keyEvent);                          _CurrentPlaylistElement = _GetSelectedElementNr();                            if (_CurrentPlaylistElement != -1)                          {                              CBase.Playlist.GetSong(ActivePlaylistID' _CurrentPlaylistElement + _Offset).GameMode =                                  _PlaylistElementContents[_CurrentPlaylistElement + _Offset].Modes[_PlaylistElements[_CurrentPlaylistElement].SelectSlide.Selection];                              UpdatePlaylist();                          }                          break;                      default:                          return false;                  }                  return true;              }
Magic Number,VocaluxeLib.Menu,CSelectSlide,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CSelectSlide.cs,_GetCurOffset,The following statement contains a magic number: int offset = _Selection - _NumVisible / 2;
Magic Number,VocaluxeLib.Menu,CSelectSlide,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CSelectSlide.cs,_Revalidate,The following statement contains a magic number: float elWidth = (Rect.W - _TextRelativeX * 2) / numvis;
Magic Number,VocaluxeLib.Menu,CSelectSlide,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CSelectSlide.cs,_Revalidate,The following statement contains a magic number: for (int i = 0; i < numvis; i++)              {                  CText text = _VisibleElements[i].Text;                  RectangleF textBounds;                  float curX = xStart + elWidth * i;                  if (String.IsNullOrEmpty(_Values[i + offset].Text))                  {                      text.Visible = false;                      textBounds = new RectangleF();                  }                  else                  {                      text.Visible = true;                      text.Text = _Values[i + offset].Text;                      text.TranslationID = _Values[i + offset].TranslationId;                      text.Color = (i + offset == Selection) ? _SelTextColor : _TextColor;                      textBounds = CBase.Fonts.GetTextBounds(text);                      text.X = curX;                      text.Z = Rect.Z;                  }                    CStatic img = _VisibleElements[i].Img;                  if (!DrawTextures || _Values[i + offset].Texture == null)                  {                      if (text.Visible)                          text.Y = Rect.Y + (Rect.H - textBounds.Height) / 2 - _TextRelativeY;                      img.Visible = false;                      _VisibleElements[i].Bounds = new SRectF(text.X - textBounds.Width / 2f' text.Y' textBounds.Width' textBounds.Height' Rect.Z);                  }                  else                  {                      text.Y = (int)(Rect.Y + Rect.H - textBounds.Height - _TextRelativeY);                      img.Texture = _Values[i + offset].Texture;                      float alpha = (i + offset == _Selection) ? 1f : 0.35f;                      img.Color = new SColorF(1f' 1f' 1f' alpha);                      float size = Rect.H - textBounds.Height - 2 * _TextRelativeY;                      if (size > elWidth)                          size = elWidth;                      var imgRect = new SRectF(curX - size / 2' Rect.Y + _TextRelativeY' size' size' Rect.Z);                      img.MaxRect = imgRect;                      _VisibleElements[i].Bounds = imgRect;                  }              }
Magic Number,VocaluxeLib.Menu,CSelectSlide,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CSelectSlide.cs,_Revalidate,The following statement contains a magic number: for (int i = 0; i < numvis; i++)              {                  CText text = _VisibleElements[i].Text;                  RectangleF textBounds;                  float curX = xStart + elWidth * i;                  if (String.IsNullOrEmpty(_Values[i + offset].Text))                  {                      text.Visible = false;                      textBounds = new RectangleF();                  }                  else                  {                      text.Visible = true;                      text.Text = _Values[i + offset].Text;                      text.TranslationID = _Values[i + offset].TranslationId;                      text.Color = (i + offset == Selection) ? _SelTextColor : _TextColor;                      textBounds = CBase.Fonts.GetTextBounds(text);                      text.X = curX;                      text.Z = Rect.Z;                  }                    CStatic img = _VisibleElements[i].Img;                  if (!DrawTextures || _Values[i + offset].Texture == null)                  {                      if (text.Visible)                          text.Y = Rect.Y + (Rect.H - textBounds.Height) / 2 - _TextRelativeY;                      img.Visible = false;                      _VisibleElements[i].Bounds = new SRectF(text.X - textBounds.Width / 2f' text.Y' textBounds.Width' textBounds.Height' Rect.Z);                  }                  else                  {                      text.Y = (int)(Rect.Y + Rect.H - textBounds.Height - _TextRelativeY);                      img.Texture = _Values[i + offset].Texture;                      float alpha = (i + offset == _Selection) ? 1f : 0.35f;                      img.Color = new SColorF(1f' 1f' 1f' alpha);                      float size = Rect.H - textBounds.Height - 2 * _TextRelativeY;                      if (size > elWidth)                          size = elWidth;                      var imgRect = new SRectF(curX - size / 2' Rect.Y + _TextRelativeY' size' size' Rect.Z);                      img.MaxRect = imgRect;                      _VisibleElements[i].Bounds = imgRect;                  }              }
Magic Number,VocaluxeLib.Menu,CSelectSlide,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CSelectSlide.cs,_Revalidate,The following statement contains a magic number: for (int i = 0; i < numvis; i++)              {                  CText text = _VisibleElements[i].Text;                  RectangleF textBounds;                  float curX = xStart + elWidth * i;                  if (String.IsNullOrEmpty(_Values[i + offset].Text))                  {                      text.Visible = false;                      textBounds = new RectangleF();                  }                  else                  {                      text.Visible = true;                      text.Text = _Values[i + offset].Text;                      text.TranslationID = _Values[i + offset].TranslationId;                      text.Color = (i + offset == Selection) ? _SelTextColor : _TextColor;                      textBounds = CBase.Fonts.GetTextBounds(text);                      text.X = curX;                      text.Z = Rect.Z;                  }                    CStatic img = _VisibleElements[i].Img;                  if (!DrawTextures || _Values[i + offset].Texture == null)                  {                      if (text.Visible)                          text.Y = Rect.Y + (Rect.H - textBounds.Height) / 2 - _TextRelativeY;                      img.Visible = false;                      _VisibleElements[i].Bounds = new SRectF(text.X - textBounds.Width / 2f' text.Y' textBounds.Width' textBounds.Height' Rect.Z);                  }                  else                  {                      text.Y = (int)(Rect.Y + Rect.H - textBounds.Height - _TextRelativeY);                      img.Texture = _Values[i + offset].Texture;                      float alpha = (i + offset == _Selection) ? 1f : 0.35f;                      img.Color = new SColorF(1f' 1f' 1f' alpha);                      float size = Rect.H - textBounds.Height - 2 * _TextRelativeY;                      if (size > elWidth)                          size = elWidth;                      var imgRect = new SRectF(curX - size / 2' Rect.Y + _TextRelativeY' size' size' Rect.Z);                      img.MaxRect = imgRect;                      _VisibleElements[i].Bounds = imgRect;                  }              }
Magic Number,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,_CheckAnimation,The following statement contains a magic number: if (_AnimateColoring == EOffOn.TR_CONFIG_ON || _AnimateMovement == EOffOn.TR_CONFIG_ON)              {                  if (!_AnimTimer.IsRunning)                  {                      _AnimTimer.Restart();                      //Calc animation duration in ms based on rect size and progress change                      if (_Direction == EDirection.Left || _Direction == EDirection.Right)                          _AnimDuration = Math.Max(100f' (Rect.W * 0.015f * 1000) * Math.Abs(_ProgressTarget - _ProgressCurrent));                      else                          _AnimDuration = Math.Max(100f' (Rect.H * 0.015f * 1000) * Math.Abs(_ProgressTarget - _ProgressCurrent));                  }               }
Magic Number,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,_CheckAnimation,The following statement contains a magic number: if (_AnimateColoring == EOffOn.TR_CONFIG_ON || _AnimateMovement == EOffOn.TR_CONFIG_ON)              {                  if (!_AnimTimer.IsRunning)                  {                      _AnimTimer.Restart();                      //Calc animation duration in ms based on rect size and progress change                      if (_Direction == EDirection.Left || _Direction == EDirection.Right)                          _AnimDuration = Math.Max(100f' (Rect.W * 0.015f * 1000) * Math.Abs(_ProgressTarget - _ProgressCurrent));                      else                          _AnimDuration = Math.Max(100f' (Rect.H * 0.015f * 1000) * Math.Abs(_ProgressTarget - _ProgressCurrent));                  }               }
Magic Number,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,_UpdateProgressMid,The following statement contains a magic number: switch (_Direction)              {                  case EDirection.Right:                      _RectProgressMid = new SRectF(_RectProgressBegin.X + _RectProgressBegin.W' Rect.Y' (Rect.W - 2 * _RectProgressBegin.W) * _ProgressCurrent' Rect.H' Rect.Z);                      break;                    case EDirection.Up:                      float newHeight = (Rect.H - 2 * _RectProgressBegin.H) * _ProgressCurrent;                      _RectProgressMid = new SRectF(Rect.X' _RectProgressBegin.Y - newHeight' Rect.W' newHeight' Rect.Z);                      break;                    case EDirection.Left:                      float newWidth = (Rect.W - 2 * _RectProgressBegin.H) * _ProgressCurrent;                      _RectProgressMid = new SRectF(_RectProgressBegin.X - newWidth' Rect.Y' newWidth' Rect.H' Rect.Z);                      break;                    case EDirection.Down:                      _RectProgressMid = new SRectF(Rect.X' _RectProgressBegin.Y + _RectProgressBegin.H' (Rect.H - 2 * _RectProgressBegin.W) * _ProgressCurrent' Rect.W' Rect.Z);                      break;              }
Magic Number,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,_UpdateProgressMid,The following statement contains a magic number: switch (_Direction)              {                  case EDirection.Right:                      _RectProgressMid = new SRectF(_RectProgressBegin.X + _RectProgressBegin.W' Rect.Y' (Rect.W - 2 * _RectProgressBegin.W) * _ProgressCurrent' Rect.H' Rect.Z);                      break;                    case EDirection.Up:                      float newHeight = (Rect.H - 2 * _RectProgressBegin.H) * _ProgressCurrent;                      _RectProgressMid = new SRectF(Rect.X' _RectProgressBegin.Y - newHeight' Rect.W' newHeight' Rect.Z);                      break;                    case EDirection.Left:                      float newWidth = (Rect.W - 2 * _RectProgressBegin.H) * _ProgressCurrent;                      _RectProgressMid = new SRectF(_RectProgressBegin.X - newWidth' Rect.Y' newWidth' Rect.H' Rect.Z);                      break;                    case EDirection.Down:                      _RectProgressMid = new SRectF(Rect.X' _RectProgressBegin.Y + _RectProgressBegin.H' (Rect.H - 2 * _RectProgressBegin.W) * _ProgressCurrent' Rect.W' Rect.Z);                      break;              }
Magic Number,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,_UpdateProgressMid,The following statement contains a magic number: switch (_Direction)              {                  case EDirection.Right:                      _RectProgressMid = new SRectF(_RectProgressBegin.X + _RectProgressBegin.W' Rect.Y' (Rect.W - 2 * _RectProgressBegin.W) * _ProgressCurrent' Rect.H' Rect.Z);                      break;                    case EDirection.Up:                      float newHeight = (Rect.H - 2 * _RectProgressBegin.H) * _ProgressCurrent;                      _RectProgressMid = new SRectF(Rect.X' _RectProgressBegin.Y - newHeight' Rect.W' newHeight' Rect.Z);                      break;                    case EDirection.Left:                      float newWidth = (Rect.W - 2 * _RectProgressBegin.H) * _ProgressCurrent;                      _RectProgressMid = new SRectF(_RectProgressBegin.X - newWidth' Rect.Y' newWidth' Rect.H' Rect.Z);                      break;                    case EDirection.Down:                      _RectProgressMid = new SRectF(Rect.X' _RectProgressBegin.Y + _RectProgressBegin.H' (Rect.H - 2 * _RectProgressBegin.W) * _ProgressCurrent' Rect.W' Rect.Z);                      break;              }
Magic Number,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,_UpdateProgressMid,The following statement contains a magic number: switch (_Direction)              {                  case EDirection.Right:                      _RectProgressMid = new SRectF(_RectProgressBegin.X + _RectProgressBegin.W' Rect.Y' (Rect.W - 2 * _RectProgressBegin.W) * _ProgressCurrent' Rect.H' Rect.Z);                      break;                    case EDirection.Up:                      float newHeight = (Rect.H - 2 * _RectProgressBegin.H) * _ProgressCurrent;                      _RectProgressMid = new SRectF(Rect.X' _RectProgressBegin.Y - newHeight' Rect.W' newHeight' Rect.Z);                      break;                    case EDirection.Left:                      float newWidth = (Rect.W - 2 * _RectProgressBegin.H) * _ProgressCurrent;                      _RectProgressMid = new SRectF(_RectProgressBegin.X - newWidth' Rect.Y' newWidth' Rect.H' Rect.Z);                      break;                    case EDirection.Down:                      _RectProgressMid = new SRectF(Rect.X' _RectProgressBegin.Y + _RectProgressBegin.H' (Rect.H - 2 * _RectProgressBegin.W) * _ProgressCurrent' Rect.W' Rect.Z);                      break;              }
Magic Number,VocaluxeLib.Menu,CText,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CText.cs,DrawRelative,The following statement contains a magic number: if (reflectionHeight > 0)              {                  _ReflectionSpace = (rectHeight - Rect.Y - Rect.H) * 2 + reflectionSpace;                  _ReflectionHeight = reflectionHeight - (rectHeight - Rect.Y) + Rect.H;              }              else                  _ReflectionHeight = 0;
Magic Number,VocaluxeLib.Menu,CText,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CText.cs,_UpdateTextPosition,The following statement contains a magic number: switch (Align)              {                  case EAlignment.Center:                      x = X - bounds.Width / 2;                      break;                  case EAlignment.Right:                      x = X - bounds.Width;                      break;              }
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_GetNoteRect,The following statement contains a magic number: var noteRect = new SRectF(                  Rect.X + (note.StartBeat - line.FirstNoteBeat) * Rect.W / beats'                  Rect.Y + (CBase.Settings.GetNumNoteLines() - 1 - (note.Tone - line.BaseLine) / 2f) * _NoteLineHeight - _AddNoteHeight / 2'                  width'                  _NoteLineHeight + _AddNoteHeight'                  Rect.Z                  );
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_DrawNoteLines,The following statement contains a magic number: for (int i = 0; i < CBase.Settings.GetNumNoteLines(); i++)              {                  lineRect.Y = (Rect.Y + Rect.H / CBase.Settings.GetNumNoteLines() * (i + 1)) - (lineRect.H / 2);                  CBase.Drawing.DrawRect(color' lineRect' false);              }
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_DrawToneHelper,The following statement contains a magic number: while (tonePlayer - baseLine < 0)                  tonePlayer += 12;
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_DrawToneHelper,The following statement contains a magic number: while (tonePlayer - baseLine > 12)                  tonePlayer -= 12;
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_DrawToneHelper,The following statement contains a magic number: while (tonePlayer - baseLine > 12)                  tonePlayer -= 12;
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_DrawNote,The following statement contains a magic number: int dh = (int)((1f - factor) * rect.H / 2);
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_DrawNote,The following statement contains a magic number: int dw = (int)Math.Min(dh' rect.W / 2);
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_DrawNote,The following statement contains a magic number: var noteRect = new SRectF(rect.X + dw' rect.Y + dh' rect.W - 2 * dw' rect.H - 2 * dh' rect.Z);
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_DrawNote,The following statement contains a magic number: var noteRect = new SRectF(rect.X + dw' rect.Y + dh' rect.W - 2 * dw' rect.H - 2 * dh' rect.Z);
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_DrawNote,The following statement contains a magic number: int endsW = (int)Math.Min(noteRect.H * noteBegin.OrigAspect' noteRect.W / 2);
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_DrawNote,The following statement contains a magic number: SRectF middleRect = new SRectF(noteRect.X + endsW' noteRect.Y' noteRect.W - 2 * endsW' noteRect.H' noteRect.Z);
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_DrawNoteBG,The following statement contains a magic number: const float period = 1500;
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_DrawNoteBG,The following statement contains a magic number: float alpha = (float)(Math.Cos(_Timer.ElapsedMilliseconds / period * Math.PI * 2) + 1) / 4 + 0.5f;
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_DrawNoteBG,The following statement contains a magic number: float alpha = (float)(Math.Cos(_Timer.ElapsedMilliseconds / period * Math.PI * 2) + 1) / 4 + 0.5f;
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_AddGoldenNote,The following statement contains a magic number: var stars = new CParticleEffect(_PartyModeID' numstars' new SColorF(Color.Yellow)' noteRect' _Theme.SkinGoldenStar' 20' EParticleType.Star);
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_AddFlare,The following statement contains a magic number: var flares = new CParticleEffect(_PartyModeID' 15' new SColorF(Color.White)' rect' _Theme.SkinGoldenStar' 20' EParticleType.Flare);
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_AddFlare,The following statement contains a magic number: var flares = new CParticleEffect(_PartyModeID' 15' new SColorF(Color.White)' rect' _Theme.SkinGoldenStar' 20' EParticleType.Flare);
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_AddPerfectNote,The following statement contains a magic number: if (2 * dx > noteRect.W)                  dx = noteRect.W / 2;
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_AddPerfectNote,The following statement contains a magic number: if (2 * dx > noteRect.W)                  dx = noteRect.W / 2;
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_AddPerfectNote,The following statement contains a magic number: var stars = new CParticleEffect(_PartyModeID' CBase.Game.GetRandom(2) + 1' new SColorF(Color.White)' r' _Theme.SkinPerfectNoteStart' 35'                                              EParticleType.PerfNoteStar);
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_AddPerfectNote,The following statement contains a magic number: var stars = new CParticleEffect(_PartyModeID' CBase.Game.GetRandom(2) + 1' new SColorF(Color.White)' r' _Theme.SkinPerfectNoteStart' 35'                                              EParticleType.PerfNoteStar);
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_AddPerfectLine,The following statement contains a magic number: var twinkle = new CParticleEffect(_PartyModeID' 200' _Color' Rect' _Theme.SkinGoldenStar' 25' EParticleType.Twinkle);
Magic Number,VocaluxeLib.Menu.SingNotes,CNoteBars,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CNoteBars.cs,_AddPerfectLine,The following statement contains a magic number: var twinkle = new CParticleEffect(_PartyModeID' 200' _Color' Rect' _Theme.SkinGoldenStar' 25' EParticleType.Twinkle);
Magic Number,VocaluxeLib.Menu.SingNotes,CSingNotes,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SingNotes\CSingNotes.cs,LoadSkin,The following statement contains a magic number: foreach (SBarPosition bp in _Theme.BarPos)              {                  int n = Int32.Parse(bp.Name.Substring(3' 1)) - 1;                  int p = Int32.Parse(bp.Name.Substring(1' 1)) - 1;                  for (int s = 0; s < CBase.Settings.GetMaxNumScreens(); s++)                  {                      _BarPos[s' p' n] = bp.Rect;                      _BarPos[s' p' n].X += s * CBase.Settings.GetRenderW();                  }              }
Magic Number,VocaluxeLib.Xml,CXmlDeserializer,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Xml\CXmlDeserializer.cs,_GetPrimitiveValue,The following statement contains a magic number: try              {                  int p = nodeVal.IndexOf(''');                  if (p > 0 && p >= nodeVal.Length - 3)                  {                      _ErrorHandler.HandleError(new CXmlInvalidValueException("German number format converted to English in %n"' node' nodeVal' false));                      char[] tmp = nodeVal.ToCharArray();                      tmp[p] = '.';                      nodeVal = new string(tmp);                  }                  value = Convert.ChangeType(nodeVal' type' CultureInfo.InvariantCulture);              }              catch (FormatException e)              {                  _ErrorHandler.HandleError(new CXmlInvalidValueException("Invalid format in %n: '%v' (" + e.Message + ")"' node' nodeVal));                  return null;              }              catch (InvalidCastException e)              {                  _ErrorHandler.HandleError(new CXmlInvalidValueException(e.Message + " in %n: '%v'"' node' nodeVal));                  return null;              }
Magic Number,VocaluxeLib.Menu.SongMenu,CSongMenuList,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuList.cs,_InitTiles,The following statement contains a magic number: for (int i = 0; i < _ListLength; i++)              {                  //Create Cover                  var rect = new SRectF(Rect.X + (_TileW + _SpaceW)' Rect.Y + i * (_TileH + _SpaceH)' _TileW' _TileH' Rect.Z);                  var tile = new CStatic(_PartyModeID' _CoverBGTexture' _Color' rect);                  _Tiles.Add(tile);                    //Create text                  var textRect = new SRectF(MaxRect.X + 2 * (_TileW + _SpaceW)' Rect.Y + i * (_TileH + _SpaceH)' _ListTextWidth' _TileH' Rect.Z);                  CText text = new CText(textRect.X' textRect.Y' textRect.Z'                                         textRect.H' textRect.W' EAlignment.Left' EStyle.Normal'                                         "Normal"' _Artist.Color' "");                  text.MaxRect = new SRectF(text.MaxRect.X' text.MaxRect.Y' MaxRect.W + MaxRect.X - text.Rect.X - 5f' text.MaxRect.H' text.MaxRect.Z);                  text.ResizeAlign = EHAlignment.Center;                    _Texts.Add(text);              }
Magic Number,VocaluxeLib.Menu.SongMenu,CSongMenuList,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuList.cs,_UpdateLength,The following statement contains a magic number: if (Math.Abs(song.Finish) > 0.001)                  time = song.Finish;
Magic Number,VocaluxeLib.Menu.SongMenu,CSongMenuFramework,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuFramework.cs,Draw,The following statement contains a magic number: if (CBase.BackgroundMusic.IsPlaying())                  CBase.Drawing.DrawTexture(CBase.BackgroundMusic.GetVideoTexture()' new SRectF(0' 0' 1280' 720' 0));
Magic Number,VocaluxeLib.Menu.SongMenu,CSongMenuFramework,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuFramework.cs,Draw,The following statement contains a magic number: if (CBase.BackgroundMusic.IsPlaying())                  CBase.Drawing.DrawTexture(CBase.BackgroundMusic.GetVideoTexture()' new SRectF(0' 0' 1280' 720' 0));
Magic Number,VocaluxeLib.Menu.SongMenu,CSongMenuFramework,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuFramework.cs,ResizeElement,The following statement contains a magic number: if (W < 100)                  W = 100;
Magic Number,VocaluxeLib.Menu.SongMenu,CSongMenuFramework,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuFramework.cs,ResizeElement,The following statement contains a magic number: if (W < 100)                  W = 100;
Magic Number,VocaluxeLib.Menu.SongMenu,CSongMenuFramework,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuFramework.cs,ResizeElement,The following statement contains a magic number: if (H < 100)                  H = 100;
Magic Number,VocaluxeLib.Menu.SongMenu,CSongMenuFramework,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuFramework.cs,ResizeElement,The following statement contains a magic number: if (H < 100)                  H = 100;
Magic Number,VocaluxeLib.Menu.SongMenu,CSongMenuTileBoard,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuTileBoard.cs,_UpdateLength,The following statement contains a magic number: if (Math.Abs(song.Finish) > 0.001)                  time = song.Finish;
Magic Number,VocaluxeLib.Songs,CLineBase<T>,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CLineBase.cs,FindPreviousNote,The following statement contains a magic number: while (end - start > 1)              {                  int mid = (start + end) / 2;                  if (_Notes[mid].StartBeat <= beat)                      start = mid;                  else                      end = mid;              }
Magic Number,VocaluxeLib.Songs,CSong,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSong.cs,_FindShortEnd,The following statement contains a magic number: int stop = (voice.Lines[voice.Lines.Length - 1].LastNoteBeat - voice.Lines[0].FirstNote.StartBeat) / 2 + voice.Lines[0].FirstNote.StartBeat;
Magic Number,VocaluxeLib.Songs,CSong,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSong.cs,_FindShortEnd,The following statement contains a magic number: for (int i = 0; i < series.Count; i++)              {                  if (voice.Lines[series[i].Start].FirstNoteBeat < stop && voice.Lines[series[i].End].LastNoteBeat > stop)                  {                      if (stop < (voice.Lines[series[i].Start].FirstNoteBeat + ((voice.Lines[series[i].End].LastNoteBeat - voice.Lines[series[i].Start].FirstNoteBeat) / 2)))                      {                          ShortEnd.EndBeat = voice.Lines[series[i].Start - 1].LastNote.EndBeat;                          ShortEnd.Source = EDataSource.Calculated;                          return;                      }                      ShortEnd.EndBeat = voice.Lines[series[i].End].LastNote.EndBeat;                      ShortEnd.Source = EDataSource.Calculated;                      return;                  }              }
Magic Number,VocaluxeLib.Songs,CSongWriter,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongWriter.cs,_WriteHeaderEntry,The following statement contains a magic number: if (Math.Abs(value - def) > 0.0001)                      _WriteHeaderEntry(id' value.ToInvariantString());
Magic Number,VocaluxeLib.Songs,CSongWriter,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongWriter.cs,_WriteHeader,The following statement contains a magic number: if (_Song.ShortEnd.Source == EDataSource.Tag)                      _WriteHeaderEntry("ENDSHORT"' (int)(CBase.Game.GetTimeFromBeats(_Song.ShortEnd.EndBeat' _Song.BPM) + _Song.Gap) * 1000);
Magic Number,VocaluxeLib.Songs,CSongWriter,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongWriter.cs,_GetBreakBeat,The following statement contains a magic number: if (timeDiff > 4f)                      breakBeat = firstPossibleBeat + (int)CBase.Game.GetBeatFromTime(2f' _Song.BPM' 0f);                  else if (timeDiff > 2f)                      breakBeat = firstPossibleBeat + (int)CBase.Game.GetBeatFromTime(1f' _Song.BPM' 0f);                  else if (diff < 2)                      breakBeat = firstPossibleBeat;                  else if (diff < 9)                      breakBeat = firstNoteBeat - 2;                  else if (diff < 13)                      breakBeat = firstNoteBeat - 3;                  else if (diff < 17)                      breakBeat = firstNoteBeat - 4;                  else                      breakBeat = firstPossibleBeat + 12;
Magic Number,VocaluxeLib.Songs,CSongWriter,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongWriter.cs,_GetBreakBeat,The following statement contains a magic number: if (timeDiff > 4f)                      breakBeat = firstPossibleBeat + (int)CBase.Game.GetBeatFromTime(2f' _Song.BPM' 0f);                  else if (timeDiff > 2f)                      breakBeat = firstPossibleBeat + (int)CBase.Game.GetBeatFromTime(1f' _Song.BPM' 0f);                  else if (diff < 2)                      breakBeat = firstPossibleBeat;                  else if (diff < 9)                      breakBeat = firstNoteBeat - 2;                  else if (diff < 13)                      breakBeat = firstNoteBeat - 3;                  else if (diff < 17)                      breakBeat = firstNoteBeat - 4;                  else                      breakBeat = firstPossibleBeat + 12;
Magic Number,VocaluxeLib.Songs,CSongWriter,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongWriter.cs,_GetBreakBeat,The following statement contains a magic number: if (timeDiff > 4f)                      breakBeat = firstPossibleBeat + (int)CBase.Game.GetBeatFromTime(2f' _Song.BPM' 0f);                  else if (timeDiff > 2f)                      breakBeat = firstPossibleBeat + (int)CBase.Game.GetBeatFromTime(1f' _Song.BPM' 0f);                  else if (diff < 2)                      breakBeat = firstPossibleBeat;                  else if (diff < 9)                      breakBeat = firstNoteBeat - 2;                  else if (diff < 13)                      breakBeat = firstNoteBeat - 3;                  else if (diff < 17)                      breakBeat = firstNoteBeat - 4;                  else                      breakBeat = firstPossibleBeat + 12;
Magic Number,VocaluxeLib.Songs,CSongWriter,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongWriter.cs,_GetBreakBeat,The following statement contains a magic number: if (timeDiff > 4f)                      breakBeat = firstPossibleBeat + (int)CBase.Game.GetBeatFromTime(2f' _Song.BPM' 0f);                  else if (timeDiff > 2f)                      breakBeat = firstPossibleBeat + (int)CBase.Game.GetBeatFromTime(1f' _Song.BPM' 0f);                  else if (diff < 2)                      breakBeat = firstPossibleBeat;                  else if (diff < 9)                      breakBeat = firstNoteBeat - 2;                  else if (diff < 13)                      breakBeat = firstNoteBeat - 3;                  else if (diff < 17)                      breakBeat = firstNoteBeat - 4;                  else                      breakBeat = firstPossibleBeat + 12;
Magic Number,VocaluxeLib.Songs,CSongWriter,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongWriter.cs,_GetBreakBeat,The following statement contains a magic number: if (timeDiff > 4f)                      breakBeat = firstPossibleBeat + (int)CBase.Game.GetBeatFromTime(2f' _Song.BPM' 0f);                  else if (timeDiff > 2f)                      breakBeat = firstPossibleBeat + (int)CBase.Game.GetBeatFromTime(1f' _Song.BPM' 0f);                  else if (diff < 2)                      breakBeat = firstPossibleBeat;                  else if (diff < 9)                      breakBeat = firstNoteBeat - 2;                  else if (diff < 13)                      breakBeat = firstNoteBeat - 3;                  else if (diff < 17)                      breakBeat = firstNoteBeat - 4;                  else                      breakBeat = firstPossibleBeat + 12;
Magic Number,VocaluxeLib.Songs,CSongWriter,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongWriter.cs,_GetBreakBeat,The following statement contains a magic number: if (timeDiff > 4f)                      breakBeat = firstPossibleBeat + (int)CBase.Game.GetBeatFromTime(2f' _Song.BPM' 0f);                  else if (timeDiff > 2f)                      breakBeat = firstPossibleBeat + (int)CBase.Game.GetBeatFromTime(1f' _Song.BPM' 0f);                  else if (diff < 2)                      breakBeat = firstPossibleBeat;                  else if (diff < 9)                      breakBeat = firstNoteBeat - 2;                  else if (diff < 13)                      breakBeat = firstNoteBeat - 3;                  else if (diff < 17)                      breakBeat = firstNoteBeat - 4;                  else                      breakBeat = firstPossibleBeat + 12;
Magic Number,VocaluxeLib.Songs,CSongWriter,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongWriter.cs,_GetBreakBeat,The following statement contains a magic number: if (timeDiff > 4f)                      breakBeat = firstPossibleBeat + (int)CBase.Game.GetBeatFromTime(2f' _Song.BPM' 0f);                  else if (timeDiff > 2f)                      breakBeat = firstPossibleBeat + (int)CBase.Game.GetBeatFromTime(1f' _Song.BPM' 0f);                  else if (diff < 2)                      breakBeat = firstPossibleBeat;                  else if (diff < 9)                      breakBeat = firstNoteBeat - 2;                  else if (diff < 13)                      breakBeat = firstNoteBeat - 3;                  else if (diff < 17)                      breakBeat = firstNoteBeat - 4;                  else                      breakBeat = firstPossibleBeat + 12;
Magic Number,VocaluxeLib.Songs,CSongWriter,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongWriter.cs,_GetBreakBeat,The following statement contains a magic number: if (timeDiff > 4f)                      breakBeat = firstPossibleBeat + (int)CBase.Game.GetBeatFromTime(2f' _Song.BPM' 0f);                  else if (timeDiff > 2f)                      breakBeat = firstPossibleBeat + (int)CBase.Game.GetBeatFromTime(1f' _Song.BPM' 0f);                  else if (diff < 2)                      breakBeat = firstPossibleBeat;                  else if (diff < 9)                      breakBeat = firstNoteBeat - 2;                  else if (diff < 13)                      breakBeat = firstNoteBeat - 3;                  else if (diff < 17)                      breakBeat = firstNoteBeat - 4;                  else                      breakBeat = firstPossibleBeat + 12;
Magic Number,VocaluxeLib.Songs,CSongWriter,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongWriter.cs,_WriteNotes,The following statement contains a magic number: for (int i = 0; i < _Song.Notes.VoiceCount; i++)                  {                      CVoice voice = _Song.Notes.GetVoice(i);                      if (_Song.Notes.VoiceCount > 1)                          _Tw.WriteLine("P" + Math.Pow(2' i));                      int currentBeat = 0;                      CSongLine lastLine = null;                      foreach (CSongLine line in voice.Lines)                      {                          if (lastLine != null)                          {                              string lineTxt = "- " + (_GetBreakBeat(lastLine.EndBeat + 1' line.FirstNoteBeat) - currentBeat);                              if (_Song.Relative)                              {                                  lineTxt += " " + (line.FirstNoteBeat - currentBeat);                                  currentBeat = line.FirstNoteBeat;                              }                              _Tw.WriteLine(lineTxt);                          }                          foreach (CSongNote note in line.Notes)                          {                              string tag;                              switch (note.Type)                              {                                  case ENoteType.Normal:                                      tag = ":";                                      break;                                  case ENoteType.Golden:                                      tag = "*";                                      break;                                  case ENoteType.Freestyle:                                      tag = "F";                                      break;                                  default:                                      throw new NotImplementedException("Note type " + note.Type);                              }                              _Tw.WriteLine(tag + " " + (note.StartBeat - currentBeat) + " " + note.Duration + " " + note.Tone + " " + note.Text);                          }                          lastLine = line;                      }                  }
Magic Number,VocaluxeLib.Songs,CVoice,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CVoice.cs,FindPreviousLine,The following statement contains a magic number: while (end - start > 1)              {                  int mid = (start + end) / 2;                  if (_Lines[mid].StartBeat <= beat)                      start = mid;                  else                      end = mid;              }
Magic Number,VocaluxeLib.Songs,CVoice,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CVoice.cs,UpdateTimings,The following statement contains a magic number: _Lines[0].StartBeat = -10000;
Magic Number,VocaluxeLib.Songs,CVoice,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CVoice.cs,UpdateTimings,The following statement contains a magic number: for (int i = 1; i < _Lines.Count; i++)              {                  CSongNote lastNote = _Lines[i - 1].LastNote;                  CSongNote firstNote = _Lines[i].FirstNote;                    if ((lastNote != null) && (firstNote != null))                  {                      int min = lastNote.EndBeat;                      int max = firstNote.StartBeat;                        int s;                      switch (max - min)                      {                          case 0:                              s = max;                              break;                          case 1:                              s = max;                              break;                          case 2:                              s = max - 1;                              break;                          case 3:                              s = max - 2;                              break;                          default:                              s = min + 2;                              break;                      }                        _Lines[i].StartBeat = s;                      _Lines[i - 1].EndBeat = min;                  }                  else if (firstNote != null)                  {                      _Lines[i - 1].EndBeat = Math.Min(_Lines[i - 1].StartBeat' firstNote.StartBeat - 2);                      _Lines[i].StartBeat = Math.Max(_Lines[i - 1].EndBeat' firstNote.StartBeat - 2);                  }                  else if (lastNote != null)                  {                      _Lines[i - 1].EndBeat = lastNote.EndBeat;                      _Lines[i].StartBeat = Math.Max(lastNote.EndBeat' _Lines[i].StartBeat); //Prefer current setting                  }                  else                  {                      //No note                      _Lines[i - 1].EndBeat = _Lines[i - 1].StartBeat; //Assume at least startbeats were set right                  }              }
Magic Number,VocaluxeLib.Songs,CVoice,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CVoice.cs,UpdateTimings,The following statement contains a magic number: for (int i = 1; i < _Lines.Count; i++)              {                  CSongNote lastNote = _Lines[i - 1].LastNote;                  CSongNote firstNote = _Lines[i].FirstNote;                    if ((lastNote != null) && (firstNote != null))                  {                      int min = lastNote.EndBeat;                      int max = firstNote.StartBeat;                        int s;                      switch (max - min)                      {                          case 0:                              s = max;                              break;                          case 1:                              s = max;                              break;                          case 2:                              s = max - 1;                              break;                          case 3:                              s = max - 2;                              break;                          default:                              s = min + 2;                              break;                      }                        _Lines[i].StartBeat = s;                      _Lines[i - 1].EndBeat = min;                  }                  else if (firstNote != null)                  {                      _Lines[i - 1].EndBeat = Math.Min(_Lines[i - 1].StartBeat' firstNote.StartBeat - 2);                      _Lines[i].StartBeat = Math.Max(_Lines[i - 1].EndBeat' firstNote.StartBeat - 2);                  }                  else if (lastNote != null)                  {                      _Lines[i - 1].EndBeat = lastNote.EndBeat;                      _Lines[i].StartBeat = Math.Max(lastNote.EndBeat' _Lines[i].StartBeat); //Prefer current setting                  }                  else                  {                      //No note                      _Lines[i - 1].EndBeat = _Lines[i - 1].StartBeat; //Assume at least startbeats were set right                  }              }
Magic Number,VocaluxeLib.Songs,CVoice,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CVoice.cs,UpdateTimings,The following statement contains a magic number: for (int i = 1; i < _Lines.Count; i++)              {                  CSongNote lastNote = _Lines[i - 1].LastNote;                  CSongNote firstNote = _Lines[i].FirstNote;                    if ((lastNote != null) && (firstNote != null))                  {                      int min = lastNote.EndBeat;                      int max = firstNote.StartBeat;                        int s;                      switch (max - min)                      {                          case 0:                              s = max;                              break;                          case 1:                              s = max;                              break;                          case 2:                              s = max - 1;                              break;                          case 3:                              s = max - 2;                              break;                          default:                              s = min + 2;                              break;                      }                        _Lines[i].StartBeat = s;                      _Lines[i - 1].EndBeat = min;                  }                  else if (firstNote != null)                  {                      _Lines[i - 1].EndBeat = Math.Min(_Lines[i - 1].StartBeat' firstNote.StartBeat - 2);                      _Lines[i].StartBeat = Math.Max(_Lines[i - 1].EndBeat' firstNote.StartBeat - 2);                  }                  else if (lastNote != null)                  {                      _Lines[i - 1].EndBeat = lastNote.EndBeat;                      _Lines[i].StartBeat = Math.Max(lastNote.EndBeat' _Lines[i].StartBeat); //Prefer current setting                  }                  else                  {                      //No note                      _Lines[i - 1].EndBeat = _Lines[i - 1].StartBeat; //Assume at least startbeats were set right                  }              }
Magic Number,VocaluxeLib.Songs,CVoice,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CVoice.cs,UpdateTimings,The following statement contains a magic number: for (int i = 1; i < _Lines.Count; i++)              {                  CSongNote lastNote = _Lines[i - 1].LastNote;                  CSongNote firstNote = _Lines[i].FirstNote;                    if ((lastNote != null) && (firstNote != null))                  {                      int min = lastNote.EndBeat;                      int max = firstNote.StartBeat;                        int s;                      switch (max - min)                      {                          case 0:                              s = max;                              break;                          case 1:                              s = max;                              break;                          case 2:                              s = max - 1;                              break;                          case 3:                              s = max - 2;                              break;                          default:                              s = min + 2;                              break;                      }                        _Lines[i].StartBeat = s;                      _Lines[i - 1].EndBeat = min;                  }                  else if (firstNote != null)                  {                      _Lines[i - 1].EndBeat = Math.Min(_Lines[i - 1].StartBeat' firstNote.StartBeat - 2);                      _Lines[i].StartBeat = Math.Max(_Lines[i - 1].EndBeat' firstNote.StartBeat - 2);                  }                  else if (lastNote != null)                  {                      _Lines[i - 1].EndBeat = lastNote.EndBeat;                      _Lines[i].StartBeat = Math.Max(lastNote.EndBeat' _Lines[i].StartBeat); //Prefer current setting                  }                  else                  {                      //No note                      _Lines[i - 1].EndBeat = _Lines[i - 1].StartBeat; //Assume at least startbeats were set right                  }              }
Magic Number,VocaluxeLib.Songs,CVoice,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CVoice.cs,UpdateTimings,The following statement contains a magic number: for (int i = 1; i < _Lines.Count; i++)              {                  CSongNote lastNote = _Lines[i - 1].LastNote;                  CSongNote firstNote = _Lines[i].FirstNote;                    if ((lastNote != null) && (firstNote != null))                  {                      int min = lastNote.EndBeat;                      int max = firstNote.StartBeat;                        int s;                      switch (max - min)                      {                          case 0:                              s = max;                              break;                          case 1:                              s = max;                              break;                          case 2:                              s = max - 1;                              break;                          case 3:                              s = max - 2;                              break;                          default:                              s = min + 2;                              break;                      }                        _Lines[i].StartBeat = s;                      _Lines[i - 1].EndBeat = min;                  }                  else if (firstNote != null)                  {                      _Lines[i - 1].EndBeat = Math.Min(_Lines[i - 1].StartBeat' firstNote.StartBeat - 2);                      _Lines[i].StartBeat = Math.Max(_Lines[i - 1].EndBeat' firstNote.StartBeat - 2);                  }                  else if (lastNote != null)                  {                      _Lines[i - 1].EndBeat = lastNote.EndBeat;                      _Lines[i].StartBeat = Math.Max(lastNote.EndBeat' _Lines[i].StartBeat); //Prefer current setting                  }                  else                  {                      //No note                      _Lines[i - 1].EndBeat = _Lines[i - 1].StartBeat; //Assume at least startbeats were set right                  }              }
Magic Number,VocaluxeLib.Songs,CVoice,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CVoice.cs,UpdateTimings,The following statement contains a magic number: for (int i = 1; i < _Lines.Count; i++)              {                  CSongNote lastNote = _Lines[i - 1].LastNote;                  CSongNote firstNote = _Lines[i].FirstNote;                    if ((lastNote != null) && (firstNote != null))                  {                      int min = lastNote.EndBeat;                      int max = firstNote.StartBeat;                        int s;                      switch (max - min)                      {                          case 0:                              s = max;                              break;                          case 1:                              s = max;                              break;                          case 2:                              s = max - 1;                              break;                          case 3:                              s = max - 2;                              break;                          default:                              s = min + 2;                              break;                      }                        _Lines[i].StartBeat = s;                      _Lines[i - 1].EndBeat = min;                  }                  else if (firstNote != null)                  {                      _Lines[i - 1].EndBeat = Math.Min(_Lines[i - 1].StartBeat' firstNote.StartBeat - 2);                      _Lines[i].StartBeat = Math.Max(_Lines[i - 1].EndBeat' firstNote.StartBeat - 2);                  }                  else if (lastNote != null)                  {                      _Lines[i - 1].EndBeat = lastNote.EndBeat;                      _Lines[i].StartBeat = Math.Max(lastNote.EndBeat' _Lines[i].StartBeat); //Prefer current setting                  }                  else                  {                      //No note                      _Lines[i - 1].EndBeat = _Lines[i - 1].StartBeat; //Assume at least startbeats were set right                  }              }
Magic Number,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ReadHeader,The following statement contains a magic number: try                  {                      sr = new StreamReader(filePath' _Song.Encoding' true);                      while (!sr.EndOfStream)                      {                          string line = sr.ReadLine();                          _LineNr++;                          if (line == "")                              continue;                          if (!line[0].Equals('#'))                              break;                            int pos = line.IndexOf(":"' StringComparison.Ordinal);                            if (pos <= 1)                          {                              _Song.UnknownTags.Add(line);                              continue;                          }                          string identifier = line.Substring(1' pos - 1).Trim().ToUpper();                          if (identifier.Contains(" "))                          {                              _Song.UnknownTags.Add(line);                              continue;                          }                          string value = line.Substring(pos + 1).Trim();                            if (value == "")                          {                              _Song.UnknownTags.Add(line);                              _LogWarning("Empty value skipped");                              continue;                          }                            switch (identifier)                          {                              case "ENCODING":                                  Encoding newEncoding = value.GetEncoding();                                  _Song.ManualEncoding = true;                                  if (!newEncoding.Equals(sr.CurrentEncoding))                                  {                                      if (useSetEncoding)                                      {                                          _LogWarning("Duplicate encoding ignored");                                          continue;                                      }                                      sr.Dispose();                                      sr = null;                                      _Song.Encoding = newEncoding;                                      return ReadHeader(true);                                  }                                  break;                              case "TITLE":                                  _Song.Title = value;                                  headerFlags |= EHeaderFlags.Title;                                  break;                              case "ARTIST":                                  _Song.Artist = value;                                  headerFlags |= EHeaderFlags.Artist;                                  break;                              case "TITLE-ON-SORTING":                                  _Song.TitleSorting = value;                                  break;                              case "ARTIST-ON-SORTING":                                  _Song.ArtistSorting = value;                                  break;                              case "CREATOR":                              case "AUTHOR":                              case "AUTOR":                                  _Song.Creator = value;                                  break;                              case "VERSION":                                  _Song.Version = value;                                  break;                              case "SOURCE":                              case "YOUTUBE":                                  _Song.Source = value;                                  break;                              case "LENGTH":                                  _Song.Length = value;                                  break;                              case "MP3":                                  if (File.Exists(Path.Combine(_Song.Folder' value)))                                  {                                      _Song.MP3FileName = value;                                      headerFlags |= EHeaderFlags.MP3;                                  }                                  else                                  {                                      _LogError("Can't find audio file: " + Path.Combine(_Song.Folder' value));                                      return false;                                  }                                  break;                              case "BPM":                                  if (CHelper.TryParse(value' out _Song.BPM))                                  {                                      _Song.BPM *= _BPMFactor;                                      headerFlags |= EHeaderFlags.BPM;                                  }                                  else                                      _LogWarning("Invalid BPM value");                                  break;                              case "EDITION":                                  if (value.Length > 1)                                      _Song.Editions.Add(value);                                  else                                      _LogWarning("Invalid edition");                                  break;                              case "GENRE":                                  if (value.Length > 1)                                      _Song.Genres.Add(value);                                  else                                      _LogWarning("Invalid genre");                                  break;                              case "ALBUM":                                  _Song.Album = value;                                  break;                              case "YEAR":                                  int num;                                  if (value.Length == 4 && int.TryParse(value' out num) && num > 0)                                      _Song.Year = value;                                  else                                      _LogWarning("Invalid year");                                  break;                              case "LANGUAGE":                                  if (value.Length > 1)                                      _Song.Languages.Add(_UnifyLanguage(value));                                  else                                      _LogWarning("Invalid language");                                  break;                              case "COMMENT":                                  if (!String.IsNullOrEmpty(_Song._Comment))                                      _Song._Comment += "\r\n";                                  _Song._Comment += value;                                  break;                              case "GAP":                                  if (CHelper.TryParse(value' out _Song.Gap))                                      _Song.Gap /= 1000f;                                  else                                      _LogWarning("Invalid gap");                                  break;                              case "COVER":                                  if (File.Exists(Path.Combine(_Song.Folder' value)))                                      _Song.CoverFileName = value;                                  else                                      _LogWarning("Can't find cover file: " + Path.Combine(_Song.Folder' value));                                  break;                              case "BACKGROUND":                                  if (File.Exists(Path.Combine(_Song.Folder' value)))                                      _Song.BackgroundFileNames.Add(value);                                  else                                      _LogWarning("Can't find background file: " + Path.Combine(_Song.Folder' value));                                  break;                              case "VIDEO":                                  if (File.Exists(Path.Combine(_Song.Folder' value)))                                      _Song.VideoFileName = value;                                  else                                      _LogWarning("Can't find video file: " + Path.Combine(_Song.Folder' value));                                  break;                              case "VIDEOGAP":                                  if (!CHelper.TryParse(value' out _Song.VideoGap))                                      _LogWarning("Invalid videogap");                                  break;                              case "VIDEOASPECT":                                  if (!CHelper.TryParse(value' out _Song.VideoAspect' true))                                      _LogWarning("Invalid videoaspect");                                  break;                              case "START":                                  if (!CHelper.TryParse(value' out _Song.Start))                                      _LogWarning("Invalid start");                                  break;                              case "END":                                  if (CHelper.TryParse(value' out _Song.Finish))                                      _Song.Finish /= 1000f;                                  else                                      _LogWarning("Invalid end");                                  break;                              case "PREVIEWSTART":                                  if (CHelper.TryParse(value' out _Song.Preview.StartTime) && _Song.Preview.StartTime >= 0f)                                      _Song.Preview.Source = EDataSource.Tag;                                  else                                      _LogWarning("Invalid previewstart");                                  break;                              case "PREVIEW":                                  if (CHelper.TryParse(value' out _Song.Preview.StartTime) && _Song.Preview.StartTime >= 0f)                                  {                                      //This is stored in ms not like PREVIEWSTART!                                      _Song.Preview.StartTime /= 1000f;                                      _Song.Preview.Source = EDataSource.Tag;                                  }                                  else                                      _LogWarning("Invalid previewstart");                                  break;                              case "MEDLEYSTARTBEAT":                                  if (int.TryParse(value' out _Song.Medley.StartBeat))                                      headerFlags |= EHeaderFlags.MedleyStartBeat;                                  else                                      _LogWarning("Invalid medleystartbeat");                                  break;                              case "MEDLEYENDBEAT":                                  if (int.TryParse(value' out _Song.Medley.EndBeat))                                      headerFlags |= EHeaderFlags.MedleyEndBeat;                                  else                                      _LogWarning("Invalid medleyendbeat");                                  break;                              case "ENDSHORT":                                  if ((headerFlags & EHeaderFlags.BPM) != 0)                                  {                                      int endTime;                                      if (int.TryParse(value' out endTime) || endTime < 0)                                      {                                          _Song.ShortEnd.EndBeat = (int)CBase.Game.GetBeatFromTime(endTime / 1000f' _Song.BPM' _Song.Gap);                                          _Song.ShortEnd.Source = EDataSource.Tag;                                      }                                      else                                          _LogWarning("Invalid shortendbeat");                                  }                                  break;                              case "CALCMEDLEY":                                  if (value.ToUpper() == "OFF")                                      _Song._CalculateMedley = false;                                  break;                              case "RELATIVE":                                  if (value.ToUpper() == "YES")                                      _Song.Relative = true;                                  break;                              case "RESOLUTION":                              case "NOTESGAP":                                  //Outdated/not used                                  _Song.UnknownTags.Add(line);                                  break;                              default:                                  if (identifier.StartsWith("DUETSINGER"))                                  {                                      identifier = identifier.Substring(10);                                      if (!identifier.StartsWith("P")) // fix for missing "P"                                          identifier = "P" + identifier;                                  }                                  if (identifier.StartsWith("P"))                                  {                                      int player;                                      if (int.TryParse(identifier.Substring(1).Trim()' out player))                                      {                                          foreach (int curPlayer in player.GetSetBits())                                              _Song.Notes.VoiceNames[curPlayer] = value;                                      }                                  }                                  else                                  {                                      _Song.UnknownTags.Add(line);                                      _LogWarning("Unknown tag: #" + identifier);                                  }                                    break;                          }                      } //end of while                        if (sr.EndOfStream)                      {                          //No other data then header                          _LogError("Lyrics/Notes missing"' false);                          return false;                      }                        if ((headerFlags & EHeaderFlags.Title) == 0)                      {                          _LogError("Title tag missing"' false);                          return false;                      }                        if ((headerFlags & EHeaderFlags.Artist) == 0)                      {                          _LogError("Artist tag missing"' false);                          return false;                      }                        if ((headerFlags & EHeaderFlags.MP3) == 0)                      {                          _LogError("MP3 tag missing"' false);                          return false;                      }                        if ((headerFlags & EHeaderFlags.BPM) == 0)                      {                          _LogError("BPM tag missing"' false);                          return false;                      }                        #region check medley tags                      if ((headerFlags & EHeaderFlags.MedleyStartBeat) != 0 && (headerFlags & EHeaderFlags.MedleyEndBeat) != 0)                      {                          if (_Song.Medley.StartBeat > _Song.Medley.EndBeat)                          {                              _LogError("MedleyStartBeat is bigger than MedleyEndBeat in file"' false);                              headerFlags = headerFlags - EHeaderFlags.MedleyStartBeat - EHeaderFlags.MedleyEndBeat;                          }                      }                        if (_Song.Preview.Source == EDataSource.None)                      {                          //PreviewStart is not set or <=0                          _Song.Preview.StartTime = (headerFlags & EHeaderFlags.MedleyStartBeat) != 0 ? CBase.Game.GetTimeFromBeats(_Song.Medley.StartBeat' _Song.BPM) : 0f;                          // ReSharper disable CompareOfFloatsByEqualityOperator                          _Song.Preview.Source = _Song.Preview.StartTime == 0 ? EDataSource.None : EDataSource.Calculated;                          // ReSharper restore CompareOfFloatsByEqualityOperator                      }                        if ((headerFlags & EHeaderFlags.MedleyStartBeat) != 0 && (headerFlags & EHeaderFlags.MedleyEndBeat) != 0)                      {                          _Song.Medley.Source = EDataSource.Tag;                          _Song.Medley.FadeInTime = CBase.Settings.GetDefaultMedleyFadeInTime();                          _Song.Medley.FadeOutTime = CBase.Settings.GetDefaultMedleyFadeOutTime();                      }                      #endregion check medley tags                  }                  catch (Exception e)                  {                      if (sr != null)                          sr.Dispose();                      _LogError("Error reading txt header" + e.Message' false);                      return false;                  }
Magic Number,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ReadHeader,The following statement contains a magic number: try                  {                      sr = new StreamReader(filePath' _Song.Encoding' true);                      while (!sr.EndOfStream)                      {                          string line = sr.ReadLine();                          _LineNr++;                          if (line == "")                              continue;                          if (!line[0].Equals('#'))                              break;                            int pos = line.IndexOf(":"' StringComparison.Ordinal);                            if (pos <= 1)                          {                              _Song.UnknownTags.Add(line);                              continue;                          }                          string identifier = line.Substring(1' pos - 1).Trim().ToUpper();                          if (identifier.Contains(" "))                          {                              _Song.UnknownTags.Add(line);                              continue;                          }                          string value = line.Substring(pos + 1).Trim();                            if (value == "")                          {                              _Song.UnknownTags.Add(line);                              _LogWarning("Empty value skipped");                              continue;                          }                            switch (identifier)                          {                              case "ENCODING":                                  Encoding newEncoding = value.GetEncoding();                                  _Song.ManualEncoding = true;                                  if (!newEncoding.Equals(sr.CurrentEncoding))                                  {                                      if (useSetEncoding)                                      {                                          _LogWarning("Duplicate encoding ignored");                                          continue;                                      }                                      sr.Dispose();                                      sr = null;                                      _Song.Encoding = newEncoding;                                      return ReadHeader(true);                                  }                                  break;                              case "TITLE":                                  _Song.Title = value;                                  headerFlags |= EHeaderFlags.Title;                                  break;                              case "ARTIST":                                  _Song.Artist = value;                                  headerFlags |= EHeaderFlags.Artist;                                  break;                              case "TITLE-ON-SORTING":                                  _Song.TitleSorting = value;                                  break;                              case "ARTIST-ON-SORTING":                                  _Song.ArtistSorting = value;                                  break;                              case "CREATOR":                              case "AUTHOR":                              case "AUTOR":                                  _Song.Creator = value;                                  break;                              case "VERSION":                                  _Song.Version = value;                                  break;                              case "SOURCE":                              case "YOUTUBE":                                  _Song.Source = value;                                  break;                              case "LENGTH":                                  _Song.Length = value;                                  break;                              case "MP3":                                  if (File.Exists(Path.Combine(_Song.Folder' value)))                                  {                                      _Song.MP3FileName = value;                                      headerFlags |= EHeaderFlags.MP3;                                  }                                  else                                  {                                      _LogError("Can't find audio file: " + Path.Combine(_Song.Folder' value));                                      return false;                                  }                                  break;                              case "BPM":                                  if (CHelper.TryParse(value' out _Song.BPM))                                  {                                      _Song.BPM *= _BPMFactor;                                      headerFlags |= EHeaderFlags.BPM;                                  }                                  else                                      _LogWarning("Invalid BPM value");                                  break;                              case "EDITION":                                  if (value.Length > 1)                                      _Song.Editions.Add(value);                                  else                                      _LogWarning("Invalid edition");                                  break;                              case "GENRE":                                  if (value.Length > 1)                                      _Song.Genres.Add(value);                                  else                                      _LogWarning("Invalid genre");                                  break;                              case "ALBUM":                                  _Song.Album = value;                                  break;                              case "YEAR":                                  int num;                                  if (value.Length == 4 && int.TryParse(value' out num) && num > 0)                                      _Song.Year = value;                                  else                                      _LogWarning("Invalid year");                                  break;                              case "LANGUAGE":                                  if (value.Length > 1)                                      _Song.Languages.Add(_UnifyLanguage(value));                                  else                                      _LogWarning("Invalid language");                                  break;                              case "COMMENT":                                  if (!String.IsNullOrEmpty(_Song._Comment))                                      _Song._Comment += "\r\n";                                  _Song._Comment += value;                                  break;                              case "GAP":                                  if (CHelper.TryParse(value' out _Song.Gap))                                      _Song.Gap /= 1000f;                                  else                                      _LogWarning("Invalid gap");                                  break;                              case "COVER":                                  if (File.Exists(Path.Combine(_Song.Folder' value)))                                      _Song.CoverFileName = value;                                  else                                      _LogWarning("Can't find cover file: " + Path.Combine(_Song.Folder' value));                                  break;                              case "BACKGROUND":                                  if (File.Exists(Path.Combine(_Song.Folder' value)))                                      _Song.BackgroundFileNames.Add(value);                                  else                                      _LogWarning("Can't find background file: " + Path.Combine(_Song.Folder' value));                                  break;                              case "VIDEO":                                  if (File.Exists(Path.Combine(_Song.Folder' value)))                                      _Song.VideoFileName = value;                                  else                                      _LogWarning("Can't find video file: " + Path.Combine(_Song.Folder' value));                                  break;                              case "VIDEOGAP":                                  if (!CHelper.TryParse(value' out _Song.VideoGap))                                      _LogWarning("Invalid videogap");                                  break;                              case "VIDEOASPECT":                                  if (!CHelper.TryParse(value' out _Song.VideoAspect' true))                                      _LogWarning("Invalid videoaspect");                                  break;                              case "START":                                  if (!CHelper.TryParse(value' out _Song.Start))                                      _LogWarning("Invalid start");                                  break;                              case "END":                                  if (CHelper.TryParse(value' out _Song.Finish))                                      _Song.Finish /= 1000f;                                  else                                      _LogWarning("Invalid end");                                  break;                              case "PREVIEWSTART":                                  if (CHelper.TryParse(value' out _Song.Preview.StartTime) && _Song.Preview.StartTime >= 0f)                                      _Song.Preview.Source = EDataSource.Tag;                                  else                                      _LogWarning("Invalid previewstart");                                  break;                              case "PREVIEW":                                  if (CHelper.TryParse(value' out _Song.Preview.StartTime) && _Song.Preview.StartTime >= 0f)                                  {                                      //This is stored in ms not like PREVIEWSTART!                                      _Song.Preview.StartTime /= 1000f;                                      _Song.Preview.Source = EDataSource.Tag;                                  }                                  else                                      _LogWarning("Invalid previewstart");                                  break;                              case "MEDLEYSTARTBEAT":                                  if (int.TryParse(value' out _Song.Medley.StartBeat))                                      headerFlags |= EHeaderFlags.MedleyStartBeat;                                  else                                      _LogWarning("Invalid medleystartbeat");                                  break;                              case "MEDLEYENDBEAT":                                  if (int.TryParse(value' out _Song.Medley.EndBeat))                                      headerFlags |= EHeaderFlags.MedleyEndBeat;                                  else                                      _LogWarning("Invalid medleyendbeat");                                  break;                              case "ENDSHORT":                                  if ((headerFlags & EHeaderFlags.BPM) != 0)                                  {                                      int endTime;                                      if (int.TryParse(value' out endTime) || endTime < 0)                                      {                                          _Song.ShortEnd.EndBeat = (int)CBase.Game.GetBeatFromTime(endTime / 1000f' _Song.BPM' _Song.Gap);                                          _Song.ShortEnd.Source = EDataSource.Tag;                                      }                                      else                                          _LogWarning("Invalid shortendbeat");                                  }                                  break;                              case "CALCMEDLEY":                                  if (value.ToUpper() == "OFF")                                      _Song._CalculateMedley = false;                                  break;                              case "RELATIVE":                                  if (value.ToUpper() == "YES")                                      _Song.Relative = true;                                  break;                              case "RESOLUTION":                              case "NOTESGAP":                                  //Outdated/not used                                  _Song.UnknownTags.Add(line);                                  break;                              default:                                  if (identifier.StartsWith("DUETSINGER"))                                  {                                      identifier = identifier.Substring(10);                                      if (!identifier.StartsWith("P")) // fix for missing "P"                                          identifier = "P" + identifier;                                  }                                  if (identifier.StartsWith("P"))                                  {                                      int player;                                      if (int.TryParse(identifier.Substring(1).Trim()' out player))                                      {                                          foreach (int curPlayer in player.GetSetBits())                                              _Song.Notes.VoiceNames[curPlayer] = value;                                      }                                  }                                  else                                  {                                      _Song.UnknownTags.Add(line);                                      _LogWarning("Unknown tag: #" + identifier);                                  }                                    break;                          }                      } //end of while                        if (sr.EndOfStream)                      {                          //No other data then header                          _LogError("Lyrics/Notes missing"' false);                          return false;                      }                        if ((headerFlags & EHeaderFlags.Title) == 0)                      {                          _LogError("Title tag missing"' false);                          return false;                      }                        if ((headerFlags & EHeaderFlags.Artist) == 0)                      {                          _LogError("Artist tag missing"' false);                          return false;                      }                        if ((headerFlags & EHeaderFlags.MP3) == 0)                      {                          _LogError("MP3 tag missing"' false);                          return false;                      }                        if ((headerFlags & EHeaderFlags.BPM) == 0)                      {                          _LogError("BPM tag missing"' false);                          return false;                      }                        #region check medley tags                      if ((headerFlags & EHeaderFlags.MedleyStartBeat) != 0 && (headerFlags & EHeaderFlags.MedleyEndBeat) != 0)                      {                          if (_Song.Medley.StartBeat > _Song.Medley.EndBeat)                          {                              _LogError("MedleyStartBeat is bigger than MedleyEndBeat in file"' false);                              headerFlags = headerFlags - EHeaderFlags.MedleyStartBeat - EHeaderFlags.MedleyEndBeat;                          }                      }                        if (_Song.Preview.Source == EDataSource.None)                      {                          //PreviewStart is not set or <=0                          _Song.Preview.StartTime = (headerFlags & EHeaderFlags.MedleyStartBeat) != 0 ? CBase.Game.GetTimeFromBeats(_Song.Medley.StartBeat' _Song.BPM) : 0f;                          // ReSharper disable CompareOfFloatsByEqualityOperator                          _Song.Preview.Source = _Song.Preview.StartTime == 0 ? EDataSource.None : EDataSource.Calculated;                          // ReSharper restore CompareOfFloatsByEqualityOperator                      }                        if ((headerFlags & EHeaderFlags.MedleyStartBeat) != 0 && (headerFlags & EHeaderFlags.MedleyEndBeat) != 0)                      {                          _Song.Medley.Source = EDataSource.Tag;                          _Song.Medley.FadeInTime = CBase.Settings.GetDefaultMedleyFadeInTime();                          _Song.Medley.FadeOutTime = CBase.Settings.GetDefaultMedleyFadeOutTime();                      }                      #endregion check medley tags                  }                  catch (Exception e)                  {                      if (sr != null)                          sr.Dispose();                      _LogError("Error reading txt header" + e.Message' false);                      return false;                  }
Magic Number,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ReadNotes,The following statement contains a magic number: try                  {                      sr = new StreamReader(filePath' _Song.Encoding' true);                        _Song.Notes.Reset();                        //Search for Note Beginning                      while (!sr.EndOfStream && !endFound)                      {                          string line = sr.ReadLine();                          _LineNr++;                            if (String.IsNullOrEmpty(line))                              continue;                            char tag = line[0];                          //Remove tag and potential space                          line = (line.Length >= 2 && line[1] == ' ') ? line.Substring(2) : line.Substring(1);                            int beat' length;                          switch (tag)                          {                              case '#':                                  continue;                              case 'E':                                  endFound = true;                                  break;                              case 'P':                                  line = line.Trim(trimChars);                                    if (!int.TryParse(line' out player))                                  {                                      _LogError("Wrong or missing number after \"P\"");                                      return false;                                  }                                  currentBeat = 0;                                  lastNote = null;                                  break;                              case ':':                              case '*':                              case 'F':                                  string[] noteData = line.Split(splitChars' 4);                                  if (noteData.Length < 4)                                  {                                      if (noteData.Length == 3)                                      {                                          _LogWarning("Ignored note without text");                                          changesMade.NoTextNoteCt++;                                          continue;                                      }                                      _LogError("Invalid note found");                                      sr.Dispose();                                      return false;                                  }                                  int tone;                                  if (!int.TryParse(noteData[0]' out beat) || !int.TryParse(noteData[1]' out length) || !int.TryParse(noteData[2]' out tone))                                  {                                      _LogError("Invalid note found (non-numeric values)");                                      sr.Dispose();                                      return false;                                  }                                  string text = noteData[3].TrimMultipleWs();                                  if (text == "")                                  {                                      _LogWarning("Ignored note without text");                                      changesMade.NoTextNoteCt++;                                      continue;                                  }                                  if (_CurrentReadMode == ENoteReadMode.ZeroBased)                                      length++;                                  if (length < 1)                                  {                                      changesMade.ZeroLengthNoteCt++;                                      if (_CurrentReadMode == ENoteReadMode.Normal && changesMade.ZeroLengthNoteCt > _MaxZeroNoteCt && changesMade.OverlapNoteCt <= _MaxOverlapNoteCt)                                      {                                          _LogWarning("Found more than " + _MaxZeroNoteCt + " note with length < 1. Trying alternative read mode.");                                          _CurrentReadMode = ENoteReadMode.ZeroBased;                                          sr.Dispose();                                          return ReadNotes(true);                                      }                                      _LogWarning("Ignored note with length < 1");                                  }                                  else                                  {                                      ENoteType noteType;                                        if (tag.Equals('*'))                                          noteType = ENoteType.Golden;                                      else if (tag.Equals('F'))                                          noteType = ENoteType.Freestyle;                                      else                                          noteType = ENoteType.Normal;                                        if (_Song.Relative)                                          beat += currentBeat;                                        bool ignored = false;                                      foreach (int curPlayer in player.GetSetBits())                                      {                                          //Create the note here as we want independent instances in the lines. Otherwhise we can't modify them later                                          lastNote = new CSongNote(beat' length' tone' text' noteType);                                          if (!_AddNote(curPlayer' lastNote))                                          {                                              if (!ignored)                                              {                                                  ignored = true;                                                  changesMade.OverlapNoteCt++;                                                  if (changesMade.OverlapNoteCt > _MaxOverlapNoteCt && _CurrentReadMode == ENoteReadMode.ZeroBased)                                                  {                                                      _LogWarning("Found more than " + _MaxOverlapNoteCt + " overlapping notes. Using standard mode.");                                                      _CurrentReadMode = ENoteReadMode.OneBased;                                                      sr.Dispose();                                                      return ReadNotes(true);                                                  }                                              }                                              _LogWarning("Ignored note for player " + (curPlayer + 1) + " because it overlaps with other note");                                          }                                      }                                  }                                  break;                              case '-':                                  string[] lineBreakData = line.Split(splitChars);                                  if (lineBreakData.Length < 1)                                  {                                      _LogError("Invalid line break found (No beat)");                                      sr.Dispose();                                      return false;                                  }                                  if (!int.TryParse(lineBreakData[0]' out beat))                                  {                                      _LogError("Invalid line break found (Non-numeric value)");                                      sr.Dispose();                                      return false;                                  }                                    if (_Song.Relative)                                  {                                      beat += currentBeat;                                      if (lineBreakData.Length < 2 || !int.TryParse(lineBreakData[1]' out length))                                      {                                          _LogWarning("Missing line break length");                                          changesMade.NoLengthBreakCt++;                                          currentBeat = beat;                                      }                                      else                                          currentBeat += length;                                  }                                    if (lastNote != null && beat <= lastNote.EndBeat)                                  {                                      _LogWarning("Line break is before previous note end. Adjusted.");                                      changesMade.AjustedBreakCt++;                                      if (_Song.Relative)                                          currentBeat += lastNote.EndBeat - beat + 1;                                      beat = lastNote.EndBeat + 1;                                  }                                    if (beat < 1)                                  {                                      _LogWarning("Ignored line break because position is < 1");                                      changesMade.InvalidPosBreakCt++;                                  }                                  else                                  {                                      foreach (int curPlayer in player.GetSetBits())                                      {                                          if (!_NewSentence(curPlayer' beat))                                              _LogWarning("Ignored line break for player " + (curPlayer + 1) + " (Overlapping or duplicate)");                                      }                                  }                                  break;                              default:                                  _LogError("Unexpected or missing character (" + tag + ")");                                  return false;                          }                      }                        for (int i = 0; i < _Song.Notes.VoiceCount; i++)                      {                          CVoice voice = _Song.Notes.GetVoice(i);                          int emptyLines = voice.RemoveEmptyLines();                          if (emptyLines > 0)                              _LogWarning("Removed " + emptyLines + " empty lines from P" + ". This often indicates a problem with the line breaks in the file"' false);                          voice.UpdateTimings();                      }                  }                  catch (Exception e)                  {                      _LogError("An unhandled exception occured (" + e.Message + ")");                      if (sr != null)                          sr.Dispose();                      return false;                  }
Magic Number,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ReadNotes,The following statement contains a magic number: try                  {                      sr = new StreamReader(filePath' _Song.Encoding' true);                        _Song.Notes.Reset();                        //Search for Note Beginning                      while (!sr.EndOfStream && !endFound)                      {                          string line = sr.ReadLine();                          _LineNr++;                            if (String.IsNullOrEmpty(line))                              continue;                            char tag = line[0];                          //Remove tag and potential space                          line = (line.Length >= 2 && line[1] == ' ') ? line.Substring(2) : line.Substring(1);                            int beat' length;                          switch (tag)                          {                              case '#':                                  continue;                              case 'E':                                  endFound = true;                                  break;                              case 'P':                                  line = line.Trim(trimChars);                                    if (!int.TryParse(line' out player))                                  {                                      _LogError("Wrong or missing number after \"P\"");                                      return false;                                  }                                  currentBeat = 0;                                  lastNote = null;                                  break;                              case ':':                              case '*':                              case 'F':                                  string[] noteData = line.Split(splitChars' 4);                                  if (noteData.Length < 4)                                  {                                      if (noteData.Length == 3)                                      {                                          _LogWarning("Ignored note without text");                                          changesMade.NoTextNoteCt++;                                          continue;                                      }                                      _LogError("Invalid note found");                                      sr.Dispose();                                      return false;                                  }                                  int tone;                                  if (!int.TryParse(noteData[0]' out beat) || !int.TryParse(noteData[1]' out length) || !int.TryParse(noteData[2]' out tone))                                  {                                      _LogError("Invalid note found (non-numeric values)");                                      sr.Dispose();                                      return false;                                  }                                  string text = noteData[3].TrimMultipleWs();                                  if (text == "")                                  {                                      _LogWarning("Ignored note without text");                                      changesMade.NoTextNoteCt++;                                      continue;                                  }                                  if (_CurrentReadMode == ENoteReadMode.ZeroBased)                                      length++;                                  if (length < 1)                                  {                                      changesMade.ZeroLengthNoteCt++;                                      if (_CurrentReadMode == ENoteReadMode.Normal && changesMade.ZeroLengthNoteCt > _MaxZeroNoteCt && changesMade.OverlapNoteCt <= _MaxOverlapNoteCt)                                      {                                          _LogWarning("Found more than " + _MaxZeroNoteCt + " note with length < 1. Trying alternative read mode.");                                          _CurrentReadMode = ENoteReadMode.ZeroBased;                                          sr.Dispose();                                          return ReadNotes(true);                                      }                                      _LogWarning("Ignored note with length < 1");                                  }                                  else                                  {                                      ENoteType noteType;                                        if (tag.Equals('*'))                                          noteType = ENoteType.Golden;                                      else if (tag.Equals('F'))                                          noteType = ENoteType.Freestyle;                                      else                                          noteType = ENoteType.Normal;                                        if (_Song.Relative)                                          beat += currentBeat;                                        bool ignored = false;                                      foreach (int curPlayer in player.GetSetBits())                                      {                                          //Create the note here as we want independent instances in the lines. Otherwhise we can't modify them later                                          lastNote = new CSongNote(beat' length' tone' text' noteType);                                          if (!_AddNote(curPlayer' lastNote))                                          {                                              if (!ignored)                                              {                                                  ignored = true;                                                  changesMade.OverlapNoteCt++;                                                  if (changesMade.OverlapNoteCt > _MaxOverlapNoteCt && _CurrentReadMode == ENoteReadMode.ZeroBased)                                                  {                                                      _LogWarning("Found more than " + _MaxOverlapNoteCt + " overlapping notes. Using standard mode.");                                                      _CurrentReadMode = ENoteReadMode.OneBased;                                                      sr.Dispose();                                                      return ReadNotes(true);                                                  }                                              }                                              _LogWarning("Ignored note for player " + (curPlayer + 1) + " because it overlaps with other note");                                          }                                      }                                  }                                  break;                              case '-':                                  string[] lineBreakData = line.Split(splitChars);                                  if (lineBreakData.Length < 1)                                  {                                      _LogError("Invalid line break found (No beat)");                                      sr.Dispose();                                      return false;                                  }                                  if (!int.TryParse(lineBreakData[0]' out beat))                                  {                                      _LogError("Invalid line break found (Non-numeric value)");                                      sr.Dispose();                                      return false;                                  }                                    if (_Song.Relative)                                  {                                      beat += currentBeat;                                      if (lineBreakData.Length < 2 || !int.TryParse(lineBreakData[1]' out length))                                      {                                          _LogWarning("Missing line break length");                                          changesMade.NoLengthBreakCt++;                                          currentBeat = beat;                                      }                                      else                                          currentBeat += length;                                  }                                    if (lastNote != null && beat <= lastNote.EndBeat)                                  {                                      _LogWarning("Line break is before previous note end. Adjusted.");                                      changesMade.AjustedBreakCt++;                                      if (_Song.Relative)                                          currentBeat += lastNote.EndBeat - beat + 1;                                      beat = lastNote.EndBeat + 1;                                  }                                    if (beat < 1)                                  {                                      _LogWarning("Ignored line break because position is < 1");                                      changesMade.InvalidPosBreakCt++;                                  }                                  else                                  {                                      foreach (int curPlayer in player.GetSetBits())                                      {                                          if (!_NewSentence(curPlayer' beat))                                              _LogWarning("Ignored line break for player " + (curPlayer + 1) + " (Overlapping or duplicate)");                                      }                                  }                                  break;                              default:                                  _LogError("Unexpected or missing character (" + tag + ")");                                  return false;                          }                      }                        for (int i = 0; i < _Song.Notes.VoiceCount; i++)                      {                          CVoice voice = _Song.Notes.GetVoice(i);                          int emptyLines = voice.RemoveEmptyLines();                          if (emptyLines > 0)                              _LogWarning("Removed " + emptyLines + " empty lines from P" + ". This often indicates a problem with the line breaks in the file"' false);                          voice.UpdateTimings();                      }                  }                  catch (Exception e)                  {                      _LogError("An unhandled exception occured (" + e.Message + ")");                      if (sr != null)                          sr.Dispose();                      return false;                  }
Magic Number,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ReadNotes,The following statement contains a magic number: try                  {                      sr = new StreamReader(filePath' _Song.Encoding' true);                        _Song.Notes.Reset();                        //Search for Note Beginning                      while (!sr.EndOfStream && !endFound)                      {                          string line = sr.ReadLine();                          _LineNr++;                            if (String.IsNullOrEmpty(line))                              continue;                            char tag = line[0];                          //Remove tag and potential space                          line = (line.Length >= 2 && line[1] == ' ') ? line.Substring(2) : line.Substring(1);                            int beat' length;                          switch (tag)                          {                              case '#':                                  continue;                              case 'E':                                  endFound = true;                                  break;                              case 'P':                                  line = line.Trim(trimChars);                                    if (!int.TryParse(line' out player))                                  {                                      _LogError("Wrong or missing number after \"P\"");                                      return false;                                  }                                  currentBeat = 0;                                  lastNote = null;                                  break;                              case ':':                              case '*':                              case 'F':                                  string[] noteData = line.Split(splitChars' 4);                                  if (noteData.Length < 4)                                  {                                      if (noteData.Length == 3)                                      {                                          _LogWarning("Ignored note without text");                                          changesMade.NoTextNoteCt++;                                          continue;                                      }                                      _LogError("Invalid note found");                                      sr.Dispose();                                      return false;                                  }                                  int tone;                                  if (!int.TryParse(noteData[0]' out beat) || !int.TryParse(noteData[1]' out length) || !int.TryParse(noteData[2]' out tone))                                  {                                      _LogError("Invalid note found (non-numeric values)");                                      sr.Dispose();                                      return false;                                  }                                  string text = noteData[3].TrimMultipleWs();                                  if (text == "")                                  {                                      _LogWarning("Ignored note without text");                                      changesMade.NoTextNoteCt++;                                      continue;                                  }                                  if (_CurrentReadMode == ENoteReadMode.ZeroBased)                                      length++;                                  if (length < 1)                                  {                                      changesMade.ZeroLengthNoteCt++;                                      if (_CurrentReadMode == ENoteReadMode.Normal && changesMade.ZeroLengthNoteCt > _MaxZeroNoteCt && changesMade.OverlapNoteCt <= _MaxOverlapNoteCt)                                      {                                          _LogWarning("Found more than " + _MaxZeroNoteCt + " note with length < 1. Trying alternative read mode.");                                          _CurrentReadMode = ENoteReadMode.ZeroBased;                                          sr.Dispose();                                          return ReadNotes(true);                                      }                                      _LogWarning("Ignored note with length < 1");                                  }                                  else                                  {                                      ENoteType noteType;                                        if (tag.Equals('*'))                                          noteType = ENoteType.Golden;                                      else if (tag.Equals('F'))                                          noteType = ENoteType.Freestyle;                                      else                                          noteType = ENoteType.Normal;                                        if (_Song.Relative)                                          beat += currentBeat;                                        bool ignored = false;                                      foreach (int curPlayer in player.GetSetBits())                                      {                                          //Create the note here as we want independent instances in the lines. Otherwhise we can't modify them later                                          lastNote = new CSongNote(beat' length' tone' text' noteType);                                          if (!_AddNote(curPlayer' lastNote))                                          {                                              if (!ignored)                                              {                                                  ignored = true;                                                  changesMade.OverlapNoteCt++;                                                  if (changesMade.OverlapNoteCt > _MaxOverlapNoteCt && _CurrentReadMode == ENoteReadMode.ZeroBased)                                                  {                                                      _LogWarning("Found more than " + _MaxOverlapNoteCt + " overlapping notes. Using standard mode.");                                                      _CurrentReadMode = ENoteReadMode.OneBased;                                                      sr.Dispose();                                                      return ReadNotes(true);                                                  }                                              }                                              _LogWarning("Ignored note for player " + (curPlayer + 1) + " because it overlaps with other note");                                          }                                      }                                  }                                  break;                              case '-':                                  string[] lineBreakData = line.Split(splitChars);                                  if (lineBreakData.Length < 1)                                  {                                      _LogError("Invalid line break found (No beat)");                                      sr.Dispose();                                      return false;                                  }                                  if (!int.TryParse(lineBreakData[0]' out beat))                                  {                                      _LogError("Invalid line break found (Non-numeric value)");                                      sr.Dispose();                                      return false;                                  }                                    if (_Song.Relative)                                  {                                      beat += currentBeat;                                      if (lineBreakData.Length < 2 || !int.TryParse(lineBreakData[1]' out length))                                      {                                          _LogWarning("Missing line break length");                                          changesMade.NoLengthBreakCt++;                                          currentBeat = beat;                                      }                                      else                                          currentBeat += length;                                  }                                    if (lastNote != null && beat <= lastNote.EndBeat)                                  {                                      _LogWarning("Line break is before previous note end. Adjusted.");                                      changesMade.AjustedBreakCt++;                                      if (_Song.Relative)                                          currentBeat += lastNote.EndBeat - beat + 1;                                      beat = lastNote.EndBeat + 1;                                  }                                    if (beat < 1)                                  {                                      _LogWarning("Ignored line break because position is < 1");                                      changesMade.InvalidPosBreakCt++;                                  }                                  else                                  {                                      foreach (int curPlayer in player.GetSetBits())                                      {                                          if (!_NewSentence(curPlayer' beat))                                              _LogWarning("Ignored line break for player " + (curPlayer + 1) + " (Overlapping or duplicate)");                                      }                                  }                                  break;                              default:                                  _LogError("Unexpected or missing character (" + tag + ")");                                  return false;                          }                      }                        for (int i = 0; i < _Song.Notes.VoiceCount; i++)                      {                          CVoice voice = _Song.Notes.GetVoice(i);                          int emptyLines = voice.RemoveEmptyLines();                          if (emptyLines > 0)                              _LogWarning("Removed " + emptyLines + " empty lines from P" + ". This often indicates a problem with the line breaks in the file"' false);                          voice.UpdateTimings();                      }                  }                  catch (Exception e)                  {                      _LogError("An unhandled exception occured (" + e.Message + ")");                      if (sr != null)                          sr.Dispose();                      return false;                  }
Magic Number,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ReadNotes,The following statement contains a magic number: try                  {                      sr = new StreamReader(filePath' _Song.Encoding' true);                        _Song.Notes.Reset();                        //Search for Note Beginning                      while (!sr.EndOfStream && !endFound)                      {                          string line = sr.ReadLine();                          _LineNr++;                            if (String.IsNullOrEmpty(line))                              continue;                            char tag = line[0];                          //Remove tag and potential space                          line = (line.Length >= 2 && line[1] == ' ') ? line.Substring(2) : line.Substring(1);                            int beat' length;                          switch (tag)                          {                              case '#':                                  continue;                              case 'E':                                  endFound = true;                                  break;                              case 'P':                                  line = line.Trim(trimChars);                                    if (!int.TryParse(line' out player))                                  {                                      _LogError("Wrong or missing number after \"P\"");                                      return false;                                  }                                  currentBeat = 0;                                  lastNote = null;                                  break;                              case ':':                              case '*':                              case 'F':                                  string[] noteData = line.Split(splitChars' 4);                                  if (noteData.Length < 4)                                  {                                      if (noteData.Length == 3)                                      {                                          _LogWarning("Ignored note without text");                                          changesMade.NoTextNoteCt++;                                          continue;                                      }                                      _LogError("Invalid note found");                                      sr.Dispose();                                      return false;                                  }                                  int tone;                                  if (!int.TryParse(noteData[0]' out beat) || !int.TryParse(noteData[1]' out length) || !int.TryParse(noteData[2]' out tone))                                  {                                      _LogError("Invalid note found (non-numeric values)");                                      sr.Dispose();                                      return false;                                  }                                  string text = noteData[3].TrimMultipleWs();                                  if (text == "")                                  {                                      _LogWarning("Ignored note without text");                                      changesMade.NoTextNoteCt++;                                      continue;                                  }                                  if (_CurrentReadMode == ENoteReadMode.ZeroBased)                                      length++;                                  if (length < 1)                                  {                                      changesMade.ZeroLengthNoteCt++;                                      if (_CurrentReadMode == ENoteReadMode.Normal && changesMade.ZeroLengthNoteCt > _MaxZeroNoteCt && changesMade.OverlapNoteCt <= _MaxOverlapNoteCt)                                      {                                          _LogWarning("Found more than " + _MaxZeroNoteCt + " note with length < 1. Trying alternative read mode.");                                          _CurrentReadMode = ENoteReadMode.ZeroBased;                                          sr.Dispose();                                          return ReadNotes(true);                                      }                                      _LogWarning("Ignored note with length < 1");                                  }                                  else                                  {                                      ENoteType noteType;                                        if (tag.Equals('*'))                                          noteType = ENoteType.Golden;                                      else if (tag.Equals('F'))                                          noteType = ENoteType.Freestyle;                                      else                                          noteType = ENoteType.Normal;                                        if (_Song.Relative)                                          beat += currentBeat;                                        bool ignored = false;                                      foreach (int curPlayer in player.GetSetBits())                                      {                                          //Create the note here as we want independent instances in the lines. Otherwhise we can't modify them later                                          lastNote = new CSongNote(beat' length' tone' text' noteType);                                          if (!_AddNote(curPlayer' lastNote))                                          {                                              if (!ignored)                                              {                                                  ignored = true;                                                  changesMade.OverlapNoteCt++;                                                  if (changesMade.OverlapNoteCt > _MaxOverlapNoteCt && _CurrentReadMode == ENoteReadMode.ZeroBased)                                                  {                                                      _LogWarning("Found more than " + _MaxOverlapNoteCt + " overlapping notes. Using standard mode.");                                                      _CurrentReadMode = ENoteReadMode.OneBased;                                                      sr.Dispose();                                                      return ReadNotes(true);                                                  }                                              }                                              _LogWarning("Ignored note for player " + (curPlayer + 1) + " because it overlaps with other note");                                          }                                      }                                  }                                  break;                              case '-':                                  string[] lineBreakData = line.Split(splitChars);                                  if (lineBreakData.Length < 1)                                  {                                      _LogError("Invalid line break found (No beat)");                                      sr.Dispose();                                      return false;                                  }                                  if (!int.TryParse(lineBreakData[0]' out beat))                                  {                                      _LogError("Invalid line break found (Non-numeric value)");                                      sr.Dispose();                                      return false;                                  }                                    if (_Song.Relative)                                  {                                      beat += currentBeat;                                      if (lineBreakData.Length < 2 || !int.TryParse(lineBreakData[1]' out length))                                      {                                          _LogWarning("Missing line break length");                                          changesMade.NoLengthBreakCt++;                                          currentBeat = beat;                                      }                                      else                                          currentBeat += length;                                  }                                    if (lastNote != null && beat <= lastNote.EndBeat)                                  {                                      _LogWarning("Line break is before previous note end. Adjusted.");                                      changesMade.AjustedBreakCt++;                                      if (_Song.Relative)                                          currentBeat += lastNote.EndBeat - beat + 1;                                      beat = lastNote.EndBeat + 1;                                  }                                    if (beat < 1)                                  {                                      _LogWarning("Ignored line break because position is < 1");                                      changesMade.InvalidPosBreakCt++;                                  }                                  else                                  {                                      foreach (int curPlayer in player.GetSetBits())                                      {                                          if (!_NewSentence(curPlayer' beat))                                              _LogWarning("Ignored line break for player " + (curPlayer + 1) + " (Overlapping or duplicate)");                                      }                                  }                                  break;                              default:                                  _LogError("Unexpected or missing character (" + tag + ")");                                  return false;                          }                      }                        for (int i = 0; i < _Song.Notes.VoiceCount; i++)                      {                          CVoice voice = _Song.Notes.GetVoice(i);                          int emptyLines = voice.RemoveEmptyLines();                          if (emptyLines > 0)                              _LogWarning("Removed " + emptyLines + " empty lines from P" + ". This often indicates a problem with the line breaks in the file"' false);                          voice.UpdateTimings();                      }                  }                  catch (Exception e)                  {                      _LogError("An unhandled exception occured (" + e.Message + ")");                      if (sr != null)                          sr.Dispose();                      return false;                  }
Magic Number,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ReadNotes,The following statement contains a magic number: try                  {                      sr = new StreamReader(filePath' _Song.Encoding' true);                        _Song.Notes.Reset();                        //Search for Note Beginning                      while (!sr.EndOfStream && !endFound)                      {                          string line = sr.ReadLine();                          _LineNr++;                            if (String.IsNullOrEmpty(line))                              continue;                            char tag = line[0];                          //Remove tag and potential space                          line = (line.Length >= 2 && line[1] == ' ') ? line.Substring(2) : line.Substring(1);                            int beat' length;                          switch (tag)                          {                              case '#':                                  continue;                              case 'E':                                  endFound = true;                                  break;                              case 'P':                                  line = line.Trim(trimChars);                                    if (!int.TryParse(line' out player))                                  {                                      _LogError("Wrong or missing number after \"P\"");                                      return false;                                  }                                  currentBeat = 0;                                  lastNote = null;                                  break;                              case ':':                              case '*':                              case 'F':                                  string[] noteData = line.Split(splitChars' 4);                                  if (noteData.Length < 4)                                  {                                      if (noteData.Length == 3)                                      {                                          _LogWarning("Ignored note without text");                                          changesMade.NoTextNoteCt++;                                          continue;                                      }                                      _LogError("Invalid note found");                                      sr.Dispose();                                      return false;                                  }                                  int tone;                                  if (!int.TryParse(noteData[0]' out beat) || !int.TryParse(noteData[1]' out length) || !int.TryParse(noteData[2]' out tone))                                  {                                      _LogError("Invalid note found (non-numeric values)");                                      sr.Dispose();                                      return false;                                  }                                  string text = noteData[3].TrimMultipleWs();                                  if (text == "")                                  {                                      _LogWarning("Ignored note without text");                                      changesMade.NoTextNoteCt++;                                      continue;                                  }                                  if (_CurrentReadMode == ENoteReadMode.ZeroBased)                                      length++;                                  if (length < 1)                                  {                                      changesMade.ZeroLengthNoteCt++;                                      if (_CurrentReadMode == ENoteReadMode.Normal && changesMade.ZeroLengthNoteCt > _MaxZeroNoteCt && changesMade.OverlapNoteCt <= _MaxOverlapNoteCt)                                      {                                          _LogWarning("Found more than " + _MaxZeroNoteCt + " note with length < 1. Trying alternative read mode.");                                          _CurrentReadMode = ENoteReadMode.ZeroBased;                                          sr.Dispose();                                          return ReadNotes(true);                                      }                                      _LogWarning("Ignored note with length < 1");                                  }                                  else                                  {                                      ENoteType noteType;                                        if (tag.Equals('*'))                                          noteType = ENoteType.Golden;                                      else if (tag.Equals('F'))                                          noteType = ENoteType.Freestyle;                                      else                                          noteType = ENoteType.Normal;                                        if (_Song.Relative)                                          beat += currentBeat;                                        bool ignored = false;                                      foreach (int curPlayer in player.GetSetBits())                                      {                                          //Create the note here as we want independent instances in the lines. Otherwhise we can't modify them later                                          lastNote = new CSongNote(beat' length' tone' text' noteType);                                          if (!_AddNote(curPlayer' lastNote))                                          {                                              if (!ignored)                                              {                                                  ignored = true;                                                  changesMade.OverlapNoteCt++;                                                  if (changesMade.OverlapNoteCt > _MaxOverlapNoteCt && _CurrentReadMode == ENoteReadMode.ZeroBased)                                                  {                                                      _LogWarning("Found more than " + _MaxOverlapNoteCt + " overlapping notes. Using standard mode.");                                                      _CurrentReadMode = ENoteReadMode.OneBased;                                                      sr.Dispose();                                                      return ReadNotes(true);                                                  }                                              }                                              _LogWarning("Ignored note for player " + (curPlayer + 1) + " because it overlaps with other note");                                          }                                      }                                  }                                  break;                              case '-':                                  string[] lineBreakData = line.Split(splitChars);                                  if (lineBreakData.Length < 1)                                  {                                      _LogError("Invalid line break found (No beat)");                                      sr.Dispose();                                      return false;                                  }                                  if (!int.TryParse(lineBreakData[0]' out beat))                                  {                                      _LogError("Invalid line break found (Non-numeric value)");                                      sr.Dispose();                                      return false;                                  }                                    if (_Song.Relative)                                  {                                      beat += currentBeat;                                      if (lineBreakData.Length < 2 || !int.TryParse(lineBreakData[1]' out length))                                      {                                          _LogWarning("Missing line break length");                                          changesMade.NoLengthBreakCt++;                                          currentBeat = beat;                                      }                                      else                                          currentBeat += length;                                  }                                    if (lastNote != null && beat <= lastNote.EndBeat)                                  {                                      _LogWarning("Line break is before previous note end. Adjusted.");                                      changesMade.AjustedBreakCt++;                                      if (_Song.Relative)                                          currentBeat += lastNote.EndBeat - beat + 1;                                      beat = lastNote.EndBeat + 1;                                  }                                    if (beat < 1)                                  {                                      _LogWarning("Ignored line break because position is < 1");                                      changesMade.InvalidPosBreakCt++;                                  }                                  else                                  {                                      foreach (int curPlayer in player.GetSetBits())                                      {                                          if (!_NewSentence(curPlayer' beat))                                              _LogWarning("Ignored line break for player " + (curPlayer + 1) + " (Overlapping or duplicate)");                                      }                                  }                                  break;                              default:                                  _LogError("Unexpected or missing character (" + tag + ")");                                  return false;                          }                      }                        for (int i = 0; i < _Song.Notes.VoiceCount; i++)                      {                          CVoice voice = _Song.Notes.GetVoice(i);                          int emptyLines = voice.RemoveEmptyLines();                          if (emptyLines > 0)                              _LogWarning("Removed " + emptyLines + " empty lines from P" + ". This often indicates a problem with the line breaks in the file"' false);                          voice.UpdateTimings();                      }                  }                  catch (Exception e)                  {                      _LogError("An unhandled exception occured (" + e.Message + ")");                      if (sr != null)                          sr.Dispose();                      return false;                  }
Magic Number,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ReadNotes,The following statement contains a magic number: try                  {                      sr = new StreamReader(filePath' _Song.Encoding' true);                        _Song.Notes.Reset();                        //Search for Note Beginning                      while (!sr.EndOfStream && !endFound)                      {                          string line = sr.ReadLine();                          _LineNr++;                            if (String.IsNullOrEmpty(line))                              continue;                            char tag = line[0];                          //Remove tag and potential space                          line = (line.Length >= 2 && line[1] == ' ') ? line.Substring(2) : line.Substring(1);                            int beat' length;                          switch (tag)                          {                              case '#':                                  continue;                              case 'E':                                  endFound = true;                                  break;                              case 'P':                                  line = line.Trim(trimChars);                                    if (!int.TryParse(line' out player))                                  {                                      _LogError("Wrong or missing number after \"P\"");                                      return false;                                  }                                  currentBeat = 0;                                  lastNote = null;                                  break;                              case ':':                              case '*':                              case 'F':                                  string[] noteData = line.Split(splitChars' 4);                                  if (noteData.Length < 4)                                  {                                      if (noteData.Length == 3)                                      {                                          _LogWarning("Ignored note without text");                                          changesMade.NoTextNoteCt++;                                          continue;                                      }                                      _LogError("Invalid note found");                                      sr.Dispose();                                      return false;                                  }                                  int tone;                                  if (!int.TryParse(noteData[0]' out beat) || !int.TryParse(noteData[1]' out length) || !int.TryParse(noteData[2]' out tone))                                  {                                      _LogError("Invalid note found (non-numeric values)");                                      sr.Dispose();                                      return false;                                  }                                  string text = noteData[3].TrimMultipleWs();                                  if (text == "")                                  {                                      _LogWarning("Ignored note without text");                                      changesMade.NoTextNoteCt++;                                      continue;                                  }                                  if (_CurrentReadMode == ENoteReadMode.ZeroBased)                                      length++;                                  if (length < 1)                                  {                                      changesMade.ZeroLengthNoteCt++;                                      if (_CurrentReadMode == ENoteReadMode.Normal && changesMade.ZeroLengthNoteCt > _MaxZeroNoteCt && changesMade.OverlapNoteCt <= _MaxOverlapNoteCt)                                      {                                          _LogWarning("Found more than " + _MaxZeroNoteCt + " note with length < 1. Trying alternative read mode.");                                          _CurrentReadMode = ENoteReadMode.ZeroBased;                                          sr.Dispose();                                          return ReadNotes(true);                                      }                                      _LogWarning("Ignored note with length < 1");                                  }                                  else                                  {                                      ENoteType noteType;                                        if (tag.Equals('*'))                                          noteType = ENoteType.Golden;                                      else if (tag.Equals('F'))                                          noteType = ENoteType.Freestyle;                                      else                                          noteType = ENoteType.Normal;                                        if (_Song.Relative)                                          beat += currentBeat;                                        bool ignored = false;                                      foreach (int curPlayer in player.GetSetBits())                                      {                                          //Create the note here as we want independent instances in the lines. Otherwhise we can't modify them later                                          lastNote = new CSongNote(beat' length' tone' text' noteType);                                          if (!_AddNote(curPlayer' lastNote))                                          {                                              if (!ignored)                                              {                                                  ignored = true;                                                  changesMade.OverlapNoteCt++;                                                  if (changesMade.OverlapNoteCt > _MaxOverlapNoteCt && _CurrentReadMode == ENoteReadMode.ZeroBased)                                                  {                                                      _LogWarning("Found more than " + _MaxOverlapNoteCt + " overlapping notes. Using standard mode.");                                                      _CurrentReadMode = ENoteReadMode.OneBased;                                                      sr.Dispose();                                                      return ReadNotes(true);                                                  }                                              }                                              _LogWarning("Ignored note for player " + (curPlayer + 1) + " because it overlaps with other note");                                          }                                      }                                  }                                  break;                              case '-':                                  string[] lineBreakData = line.Split(splitChars);                                  if (lineBreakData.Length < 1)                                  {                                      _LogError("Invalid line break found (No beat)");                                      sr.Dispose();                                      return false;                                  }                                  if (!int.TryParse(lineBreakData[0]' out beat))                                  {                                      _LogError("Invalid line break found (Non-numeric value)");                                      sr.Dispose();                                      return false;                                  }                                    if (_Song.Relative)                                  {                                      beat += currentBeat;                                      if (lineBreakData.Length < 2 || !int.TryParse(lineBreakData[1]' out length))                                      {                                          _LogWarning("Missing line break length");                                          changesMade.NoLengthBreakCt++;                                          currentBeat = beat;                                      }                                      else                                          currentBeat += length;                                  }                                    if (lastNote != null && beat <= lastNote.EndBeat)                                  {                                      _LogWarning("Line break is before previous note end. Adjusted.");                                      changesMade.AjustedBreakCt++;                                      if (_Song.Relative)                                          currentBeat += lastNote.EndBeat - beat + 1;                                      beat = lastNote.EndBeat + 1;                                  }                                    if (beat < 1)                                  {                                      _LogWarning("Ignored line break because position is < 1");                                      changesMade.InvalidPosBreakCt++;                                  }                                  else                                  {                                      foreach (int curPlayer in player.GetSetBits())                                      {                                          if (!_NewSentence(curPlayer' beat))                                              _LogWarning("Ignored line break for player " + (curPlayer + 1) + " (Overlapping or duplicate)");                                      }                                  }                                  break;                              default:                                  _LogError("Unexpected or missing character (" + tag + ")");                                  return false;                          }                      }                        for (int i = 0; i < _Song.Notes.VoiceCount; i++)                      {                          CVoice voice = _Song.Notes.GetVoice(i);                          int emptyLines = voice.RemoveEmptyLines();                          if (emptyLines > 0)                              _LogWarning("Removed " + emptyLines + " empty lines from P" + ". This often indicates a problem with the line breaks in the file"' false);                          voice.UpdateTimings();                      }                  }                  catch (Exception e)                  {                      _LogError("An unhandled exception occured (" + e.Message + ")");                      if (sr != null)                          sr.Dispose();                      return false;                  }
Magic Number,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ReadNotes,The following statement contains a magic number: try                  {                      sr = new StreamReader(filePath' _Song.Encoding' true);                        _Song.Notes.Reset();                        //Search for Note Beginning                      while (!sr.EndOfStream && !endFound)                      {                          string line = sr.ReadLine();                          _LineNr++;                            if (String.IsNullOrEmpty(line))                              continue;                            char tag = line[0];                          //Remove tag and potential space                          line = (line.Length >= 2 && line[1] == ' ') ? line.Substring(2) : line.Substring(1);                            int beat' length;                          switch (tag)                          {                              case '#':                                  continue;                              case 'E':                                  endFound = true;                                  break;                              case 'P':                                  line = line.Trim(trimChars);                                    if (!int.TryParse(line' out player))                                  {                                      _LogError("Wrong or missing number after \"P\"");                                      return false;                                  }                                  currentBeat = 0;                                  lastNote = null;                                  break;                              case ':':                              case '*':                              case 'F':                                  string[] noteData = line.Split(splitChars' 4);                                  if (noteData.Length < 4)                                  {                                      if (noteData.Length == 3)                                      {                                          _LogWarning("Ignored note without text");                                          changesMade.NoTextNoteCt++;                                          continue;                                      }                                      _LogError("Invalid note found");                                      sr.Dispose();                                      return false;                                  }                                  int tone;                                  if (!int.TryParse(noteData[0]' out beat) || !int.TryParse(noteData[1]' out length) || !int.TryParse(noteData[2]' out tone))                                  {                                      _LogError("Invalid note found (non-numeric values)");                                      sr.Dispose();                                      return false;                                  }                                  string text = noteData[3].TrimMultipleWs();                                  if (text == "")                                  {                                      _LogWarning("Ignored note without text");                                      changesMade.NoTextNoteCt++;                                      continue;                                  }                                  if (_CurrentReadMode == ENoteReadMode.ZeroBased)                                      length++;                                  if (length < 1)                                  {                                      changesMade.ZeroLengthNoteCt++;                                      if (_CurrentReadMode == ENoteReadMode.Normal && changesMade.ZeroLengthNoteCt > _MaxZeroNoteCt && changesMade.OverlapNoteCt <= _MaxOverlapNoteCt)                                      {                                          _LogWarning("Found more than " + _MaxZeroNoteCt + " note with length < 1. Trying alternative read mode.");                                          _CurrentReadMode = ENoteReadMode.ZeroBased;                                          sr.Dispose();                                          return ReadNotes(true);                                      }                                      _LogWarning("Ignored note with length < 1");                                  }                                  else                                  {                                      ENoteType noteType;                                        if (tag.Equals('*'))                                          noteType = ENoteType.Golden;                                      else if (tag.Equals('F'))                                          noteType = ENoteType.Freestyle;                                      else                                          noteType = ENoteType.Normal;                                        if (_Song.Relative)                                          beat += currentBeat;                                        bool ignored = false;                                      foreach (int curPlayer in player.GetSetBits())                                      {                                          //Create the note here as we want independent instances in the lines. Otherwhise we can't modify them later                                          lastNote = new CSongNote(beat' length' tone' text' noteType);                                          if (!_AddNote(curPlayer' lastNote))                                          {                                              if (!ignored)                                              {                                                  ignored = true;                                                  changesMade.OverlapNoteCt++;                                                  if (changesMade.OverlapNoteCt > _MaxOverlapNoteCt && _CurrentReadMode == ENoteReadMode.ZeroBased)                                                  {                                                      _LogWarning("Found more than " + _MaxOverlapNoteCt + " overlapping notes. Using standard mode.");                                                      _CurrentReadMode = ENoteReadMode.OneBased;                                                      sr.Dispose();                                                      return ReadNotes(true);                                                  }                                              }                                              _LogWarning("Ignored note for player " + (curPlayer + 1) + " because it overlaps with other note");                                          }                                      }                                  }                                  break;                              case '-':                                  string[] lineBreakData = line.Split(splitChars);                                  if (lineBreakData.Length < 1)                                  {                                      _LogError("Invalid line break found (No beat)");                                      sr.Dispose();                                      return false;                                  }                                  if (!int.TryParse(lineBreakData[0]' out beat))                                  {                                      _LogError("Invalid line break found (Non-numeric value)");                                      sr.Dispose();                                      return false;                                  }                                    if (_Song.Relative)                                  {                                      beat += currentBeat;                                      if (lineBreakData.Length < 2 || !int.TryParse(lineBreakData[1]' out length))                                      {                                          _LogWarning("Missing line break length");                                          changesMade.NoLengthBreakCt++;                                          currentBeat = beat;                                      }                                      else                                          currentBeat += length;                                  }                                    if (lastNote != null && beat <= lastNote.EndBeat)                                  {                                      _LogWarning("Line break is before previous note end. Adjusted.");                                      changesMade.AjustedBreakCt++;                                      if (_Song.Relative)                                          currentBeat += lastNote.EndBeat - beat + 1;                                      beat = lastNote.EndBeat + 1;                                  }                                    if (beat < 1)                                  {                                      _LogWarning("Ignored line break because position is < 1");                                      changesMade.InvalidPosBreakCt++;                                  }                                  else                                  {                                      foreach (int curPlayer in player.GetSetBits())                                      {                                          if (!_NewSentence(curPlayer' beat))                                              _LogWarning("Ignored line break for player " + (curPlayer + 1) + " (Overlapping or duplicate)");                                      }                                  }                                  break;                              default:                                  _LogError("Unexpected or missing character (" + tag + ")");                                  return false;                          }                      }                        for (int i = 0; i < _Song.Notes.VoiceCount; i++)                      {                          CVoice voice = _Song.Notes.GetVoice(i);                          int emptyLines = voice.RemoveEmptyLines();                          if (emptyLines > 0)                              _LogWarning("Removed " + emptyLines + " empty lines from P" + ". This often indicates a problem with the line breaks in the file"' false);                          voice.UpdateTimings();                      }                  }                  catch (Exception e)                  {                      _LogError("An unhandled exception occured (" + e.Message + ")");                      if (sr != null)                          sr.Dispose();                      return false;                  }
Magic Number,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,ReadNotes,The following statement contains a magic number: try                  {                      sr = new StreamReader(filePath' _Song.Encoding' true);                        _Song.Notes.Reset();                        //Search for Note Beginning                      while (!sr.EndOfStream && !endFound)                      {                          string line = sr.ReadLine();                          _LineNr++;                            if (String.IsNullOrEmpty(line))                              continue;                            char tag = line[0];                          //Remove tag and potential space                          line = (line.Length >= 2 && line[1] == ' ') ? line.Substring(2) : line.Substring(1);                            int beat' length;                          switch (tag)                          {                              case '#':                                  continue;                              case 'E':                                  endFound = true;                                  break;                              case 'P':                                  line = line.Trim(trimChars);                                    if (!int.TryParse(line' out player))                                  {                                      _LogError("Wrong or missing number after \"P\"");                                      return false;                                  }                                  currentBeat = 0;                                  lastNote = null;                                  break;                              case ':':                              case '*':                              case 'F':                                  string[] noteData = line.Split(splitChars' 4);                                  if (noteData.Length < 4)                                  {                                      if (noteData.Length == 3)                                      {                                          _LogWarning("Ignored note without text");                                          changesMade.NoTextNoteCt++;                                          continue;                                      }                                      _LogError("Invalid note found");                                      sr.Dispose();                                      return false;                                  }                                  int tone;                                  if (!int.TryParse(noteData[0]' out beat) || !int.TryParse(noteData[1]' out length) || !int.TryParse(noteData[2]' out tone))                                  {                                      _LogError("Invalid note found (non-numeric values)");                                      sr.Dispose();                                      return false;                                  }                                  string text = noteData[3].TrimMultipleWs();                                  if (text == "")                                  {                                      _LogWarning("Ignored note without text");                                      changesMade.NoTextNoteCt++;                                      continue;                                  }                                  if (_CurrentReadMode == ENoteReadMode.ZeroBased)                                      length++;                                  if (length < 1)                                  {                                      changesMade.ZeroLengthNoteCt++;                                      if (_CurrentReadMode == ENoteReadMode.Normal && changesMade.ZeroLengthNoteCt > _MaxZeroNoteCt && changesMade.OverlapNoteCt <= _MaxOverlapNoteCt)                                      {                                          _LogWarning("Found more than " + _MaxZeroNoteCt + " note with length < 1. Trying alternative read mode.");                                          _CurrentReadMode = ENoteReadMode.ZeroBased;                                          sr.Dispose();                                          return ReadNotes(true);                                      }                                      _LogWarning("Ignored note with length < 1");                                  }                                  else                                  {                                      ENoteType noteType;                                        if (tag.Equals('*'))                                          noteType = ENoteType.Golden;                                      else if (tag.Equals('F'))                                          noteType = ENoteType.Freestyle;                                      else                                          noteType = ENoteType.Normal;                                        if (_Song.Relative)                                          beat += currentBeat;                                        bool ignored = false;                                      foreach (int curPlayer in player.GetSetBits())                                      {                                          //Create the note here as we want independent instances in the lines. Otherwhise we can't modify them later                                          lastNote = new CSongNote(beat' length' tone' text' noteType);                                          if (!_AddNote(curPlayer' lastNote))                                          {                                              if (!ignored)                                              {                                                  ignored = true;                                                  changesMade.OverlapNoteCt++;                                                  if (changesMade.OverlapNoteCt > _MaxOverlapNoteCt && _CurrentReadMode == ENoteReadMode.ZeroBased)                                                  {                                                      _LogWarning("Found more than " + _MaxOverlapNoteCt + " overlapping notes. Using standard mode.");                                                      _CurrentReadMode = ENoteReadMode.OneBased;                                                      sr.Dispose();                                                      return ReadNotes(true);                                                  }                                              }                                              _LogWarning("Ignored note for player " + (curPlayer + 1) + " because it overlaps with other note");                                          }                                      }                                  }                                  break;                              case '-':                                  string[] lineBreakData = line.Split(splitChars);                                  if (lineBreakData.Length < 1)                                  {                                      _LogError("Invalid line break found (No beat)");                                      sr.Dispose();                                      return false;                                  }                                  if (!int.TryParse(lineBreakData[0]' out beat))                                  {                                      _LogError("Invalid line break found (Non-numeric value)");                                      sr.Dispose();                                      return false;                                  }                                    if (_Song.Relative)                                  {                                      beat += currentBeat;                                      if (lineBreakData.Length < 2 || !int.TryParse(lineBreakData[1]' out length))                                      {                                          _LogWarning("Missing line break length");                                          changesMade.NoLengthBreakCt++;                                          currentBeat = beat;                                      }                                      else                                          currentBeat += length;                                  }                                    if (lastNote != null && beat <= lastNote.EndBeat)                                  {                                      _LogWarning("Line break is before previous note end. Adjusted.");                                      changesMade.AjustedBreakCt++;                                      if (_Song.Relative)                                          currentBeat += lastNote.EndBeat - beat + 1;                                      beat = lastNote.EndBeat + 1;                                  }                                    if (beat < 1)                                  {                                      _LogWarning("Ignored line break because position is < 1");                                      changesMade.InvalidPosBreakCt++;                                  }                                  else                                  {                                      foreach (int curPlayer in player.GetSetBits())                                      {                                          if (!_NewSentence(curPlayer' beat))                                              _LogWarning("Ignored line break for player " + (curPlayer + 1) + " (Overlapping or duplicate)");                                      }                                  }                                  break;                              default:                                  _LogError("Unexpected or missing character (" + tag + ")");                                  return false;                          }                      }                        for (int i = 0; i < _Song.Notes.VoiceCount; i++)                      {                          CVoice voice = _Song.Notes.GetVoice(i);                          int emptyLines = voice.RemoveEmptyLines();                          if (emptyLines > 0)                              _LogWarning("Removed " + emptyLines + " empty lines from P" + ". This often indicates a problem with the line breaks in the file"' false);                          voice.UpdateTimings();                      }                  }                  catch (Exception e)                  {                      _LogError("An unhandled exception occured (" + e.Message + ")");                      if (sr != null)                          sr.Dispose();                      return false;                  }
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,Close,The following statement contains a magic number: if (_IsWritable)              {                  BinaryWriter writer = new BinaryWriter(_File);                  writer.Seek(4' SeekOrigin.Begin);                  writer.Write((int)_File.Length - 8);                  writer.Seek(_DataPos - 4' SeekOrigin.Begin);                  writer.Write(DataSize);              }
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,Close,The following statement contains a magic number: if (_IsWritable)              {                  BinaryWriter writer = new BinaryWriter(_File);                  writer.Seek(4' SeekOrigin.Begin);                  writer.Write((int)_File.Length - 8);                  writer.Seek(_DataPos - 4' SeekOrigin.Begin);                  writer.Write(DataSize);              }
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,Close,The following statement contains a magic number: if (_IsWritable)              {                  BinaryWriter writer = new BinaryWriter(_File);                  writer.Seek(4' SeekOrigin.Begin);                  writer.Write((int)_File.Length - 8);                  writer.Seek(_DataPos - 4' SeekOrigin.Begin);                  writer.Write(DataSize);              }
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,Open,The following statement contains a magic number: try              {                  BinaryReader reader = new BinaryReader(_File);                  if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "RIFF")                      return false;                  reader.ReadInt32(); //Chunksize (file)                  if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "WAVE")                      return false;                  long curPos = _File.Position;                  if (_SeekTo(reader' "fmt ") < 0)                      return false;                  short audioFormat = reader.ReadInt16();                  if (audioFormat != 1) //PCM                      return false;                  NumChannels = reader.ReadInt16();                  SampleRate = reader.ReadInt32();                  int bytesPerSec = reader.ReadInt32();                  short blockAlign = reader.ReadInt16();                  BitsPerSample = reader.ReadInt16();                  if (BitsPerSample != 8 && BitsPerSample != 16)                      return false;                  if (blockAlign != NumChannels * (BitsPerSample / 8))                      return false;                  if (bytesPerSec != blockAlign * SampleRate)                      return false;                  _File.Position = curPos;                  DataSize = _SeekTo(reader' "data");                  if (DataSize <= 0)                      return false;                  _DataPos = (int)_File.Position;                  DataSize = Math.Min(DataSize' (int)_File.Length - _DataPos);                  NumSamplesLeft = NumSamples;              }              catch (Exception)              {                  _File.Dispose();                  throw;              }
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,Open,The following statement contains a magic number: try              {                  BinaryReader reader = new BinaryReader(_File);                  if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "RIFF")                      return false;                  reader.ReadInt32(); //Chunksize (file)                  if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "WAVE")                      return false;                  long curPos = _File.Position;                  if (_SeekTo(reader' "fmt ") < 0)                      return false;                  short audioFormat = reader.ReadInt16();                  if (audioFormat != 1) //PCM                      return false;                  NumChannels = reader.ReadInt16();                  SampleRate = reader.ReadInt32();                  int bytesPerSec = reader.ReadInt32();                  short blockAlign = reader.ReadInt16();                  BitsPerSample = reader.ReadInt16();                  if (BitsPerSample != 8 && BitsPerSample != 16)                      return false;                  if (blockAlign != NumChannels * (BitsPerSample / 8))                      return false;                  if (bytesPerSec != blockAlign * SampleRate)                      return false;                  _File.Position = curPos;                  DataSize = _SeekTo(reader' "data");                  if (DataSize <= 0)                      return false;                  _DataPos = (int)_File.Position;                  DataSize = Math.Min(DataSize' (int)_File.Length - _DataPos);                  NumSamplesLeft = NumSamples;              }              catch (Exception)              {                  _File.Dispose();                  throw;              }
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,Open,The following statement contains a magic number: try              {                  BinaryReader reader = new BinaryReader(_File);                  if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "RIFF")                      return false;                  reader.ReadInt32(); //Chunksize (file)                  if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "WAVE")                      return false;                  long curPos = _File.Position;                  if (_SeekTo(reader' "fmt ") < 0)                      return false;                  short audioFormat = reader.ReadInt16();                  if (audioFormat != 1) //PCM                      return false;                  NumChannels = reader.ReadInt16();                  SampleRate = reader.ReadInt32();                  int bytesPerSec = reader.ReadInt32();                  short blockAlign = reader.ReadInt16();                  BitsPerSample = reader.ReadInt16();                  if (BitsPerSample != 8 && BitsPerSample != 16)                      return false;                  if (blockAlign != NumChannels * (BitsPerSample / 8))                      return false;                  if (bytesPerSec != blockAlign * SampleRate)                      return false;                  _File.Position = curPos;                  DataSize = _SeekTo(reader' "data");                  if (DataSize <= 0)                      return false;                  _DataPos = (int)_File.Position;                  DataSize = Math.Min(DataSize' (int)_File.Length - _DataPos);                  NumSamplesLeft = NumSamples;              }              catch (Exception)              {                  _File.Dispose();                  throw;              }
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,Open,The following statement contains a magic number: try              {                  BinaryReader reader = new BinaryReader(_File);                  if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "RIFF")                      return false;                  reader.ReadInt32(); //Chunksize (file)                  if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "WAVE")                      return false;                  long curPos = _File.Position;                  if (_SeekTo(reader' "fmt ") < 0)                      return false;                  short audioFormat = reader.ReadInt16();                  if (audioFormat != 1) //PCM                      return false;                  NumChannels = reader.ReadInt16();                  SampleRate = reader.ReadInt32();                  int bytesPerSec = reader.ReadInt32();                  short blockAlign = reader.ReadInt16();                  BitsPerSample = reader.ReadInt16();                  if (BitsPerSample != 8 && BitsPerSample != 16)                      return false;                  if (blockAlign != NumChannels * (BitsPerSample / 8))                      return false;                  if (bytesPerSec != blockAlign * SampleRate)                      return false;                  _File.Position = curPos;                  DataSize = _SeekTo(reader' "data");                  if (DataSize <= 0)                      return false;                  _DataPos = (int)_File.Position;                  DataSize = Math.Min(DataSize' (int)_File.Length - _DataPos);                  NumSamplesLeft = NumSamples;              }              catch (Exception)              {                  _File.Dispose();                  throw;              }
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,Open,The following statement contains a magic number: try              {                  BinaryReader reader = new BinaryReader(_File);                  if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "RIFF")                      return false;                  reader.ReadInt32(); //Chunksize (file)                  if (Encoding.ASCII.GetString(reader.ReadBytes(4)) != "WAVE")                      return false;                  long curPos = _File.Position;                  if (_SeekTo(reader' "fmt ") < 0)                      return false;                  short audioFormat = reader.ReadInt16();                  if (audioFormat != 1) //PCM                      return false;                  NumChannels = reader.ReadInt16();                  SampleRate = reader.ReadInt32();                  int bytesPerSec = reader.ReadInt32();                  short blockAlign = reader.ReadInt16();                  BitsPerSample = reader.ReadInt16();                  if (BitsPerSample != 8 && BitsPerSample != 16)                      return false;                  if (blockAlign != NumChannels * (BitsPerSample / 8))                      return false;                  if (bytesPerSec != blockAlign * SampleRate)                      return false;                  _File.Position = curPos;                  DataSize = _SeekTo(reader' "data");                  if (DataSize <= 0)                      return false;                  _DataPos = (int)_File.Position;                  DataSize = Math.Min(DataSize' (int)_File.Length - _DataPos);                  NumSamplesLeft = NumSamples;              }              catch (Exception)              {                  _File.Dispose();                  throw;              }
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,GetNextSamples8Bit,The following statement contains a magic number: if (channel < 0 || channel > NumChannels || BitsPerSample != 8)                  return null;
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,GetNextSamples16Bit,The following statement contains a magic number: if (channel < 0 || channel > NumChannels || BitsPerSample != 16)                  return null;
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,GetNextSamples16Bit,The following statement contains a magic number: try              {                  if (channel == 0 || NumChannels == 1)                  {                      result = new short[numSamples * NumChannels];                      for (int i = 0; i < numSamples * NumChannels; i++)                          result[i] = reader.ReadInt16();                  }                  else                  {                      result = new short[numSamples];                      for (int i = 0; i < numSamples; i++)                      {                          _File.Seek((channel - 1) * 2' SeekOrigin.Current);                          result[i] = reader.ReadInt16();                          _File.Seek((NumChannels - channel) * 2' SeekOrigin.Current);                      }                  }                  NumSamplesLeft -= numSamples;              }              catch (EndOfStreamException e)              {                  Console.WriteLine("Error: " + e);                  return null;              }
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,GetNextSamples16Bit,The following statement contains a magic number: try              {                  if (channel == 0 || NumChannels == 1)                  {                      result = new short[numSamples * NumChannels];                      for (int i = 0; i < numSamples * NumChannels; i++)                          result[i] = reader.ReadInt16();                  }                  else                  {                      result = new short[numSamples];                      for (int i = 0; i < numSamples; i++)                      {                          _File.Seek((channel - 1) * 2' SeekOrigin.Current);                          result[i] = reader.ReadInt16();                          _File.Seek((NumChannels - channel) * 2' SeekOrigin.Current);                      }                  }                  NumSamplesLeft -= numSamples;              }              catch (EndOfStreamException e)              {                  Console.WriteLine("Error: " + e);                  return null;              }
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,GetNextSamples16BitAsBytes,The following statement contains a magic number: byte[] samplesByte = new byte[samples.Length * 2];
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,WriteSamples,The following statement contains a magic number: if (!_IsWritable || channel < 0 || channel > NumChannels || BitsPerSample != 8)                  return false;
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,Write16BitSamples,The following statement contains a magic number: if (!_IsWritable || channel < 0 || channel > NumChannels || BitsPerSample != 16)                  return false;
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,Write16BitSamples,The following statement contains a magic number: if (channel == 0 || NumChannels == 1)              {                  foreach (short sample in samples)                      writer.Write(sample);              }              else              {                  foreach (short sample in samples)                  {                      _File.Seek((channel - 1) * 2' SeekOrigin.Current);                      writer.Write(sample);                      _File.Seek((NumChannels - channel) * 2' SeekOrigin.Current);                  }              }
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,Write16BitSamples,The following statement contains a magic number: if (channel == 0 || NumChannels == 1)              {                  foreach (short sample in samples)                      writer.Write(sample);              }              else              {                  foreach (short sample in samples)                  {                      _File.Seek((channel - 1) * 2' SeekOrigin.Current);                      writer.Write(sample);                      _File.Seek((NumChannels - channel) * 2' SeekOrigin.Current);                  }              }
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,Write16BitSamples,The following statement contains a magic number: DataSize += samples.Length * 2;
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,Write16BitSamples,The following statement contains a magic number: short[] samplesShort = new short[samples.Length / 2];
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,_WriteHeader,The following statement contains a magic number: writer.Write(16);
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,_WriteHeader,The following statement contains a magic number: writer.Write(SampleRate * NumChannels * (BitsPerSample / 8));
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,_WriteHeader,The following statement contains a magic number: writer.Write((short)((BitsPerSample / 8) * NumChannels));
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,_WriteHeader,The following statement contains a magic number: writer.Seek(4' SeekOrigin.Begin);
Magic Number,VocaluxeLib.Utils,CWavFile,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\CWavFile.cs,_SeekTo,The following statement contains a magic number: do              {                  string curChunkId = Encoding.ASCII.GetString(reader.ReadBytes(4));                  int chunkSize = reader.ReadInt32();                  if (curChunkId == chunkId)                      return chunkSize;                  reader.BaseStream.Seek(chunkSize' SeekOrigin.Current);              } while (reader.BaseStream.Position < reader.BaseStream.Length);
Magic Number,VocaluxeLib.Utils.Player,CSoundPlayer,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Utils\Player\CSoundPlayer.cs,Play,The following statement contains a magic number: CBase.Sound.Fade(_StreamID' 100' _FadeTime);
Duplicate Code,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The method contains a code clone-set at the following line numbers (starting from the method definition): ((37' 82)' (160' 205))
Missing Default,VocaluxeLib.Menu,CMenu,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenu.cs,HandleInputThemeEditor,The following switch statement is missing a default case: switch (keyEvent.Key)                  {                      case Keys.S:                          CBase.Graphics.SaveTheme();                          return true;                      case Keys.R:                          _ReloadThemeEditMode();                          return true;                  }
Missing Default,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The following switch statement is missing a default case: switch (keyEvent.Key)                  {                      case Keys.Enter:                          //Check' if a player is selected                          if (_NameSelections[_NameSelection].SelectedID != Guid.Empty)                          {                              _SelectedProfileID = _NameSelections[_NameSelection].SelectedID;                                if (!CBase.Profiles.IsProfileIDValid(_SelectedProfileID))                                  return true;                                _AddPlayer(_CurrentTeam' _SelectedProfileID);                          }                          //Started selecting with 'P'                          if (_SelectingFast)                          {                              if (!_ChangePlayerNumDynamic && _TeamList[_CurrentTeam].Count == _NumPlayerTeams[_CurrentTeam])                                  resetSelection = true;                              else if (_TeamList[_CurrentTeam].Count == _PartyMode.MaxPlayersPerTeam)                                  resetSelection = true;                          }                          else if (!_SelectingFast)                              resetSelection = true;                          break;                        case Keys.Escape:                      case Keys.Back:                          resetSelection = true;                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                  }
Missing Default,VocaluxeLib.Menu,CMenuPartyNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartyNameSelection.cs,HandleInput,The following switch statement is missing a default case: switch (keyEvent.Key)                  {                      case Keys.Back:                      case Keys.Escape:                          Back();                          break;                        case Keys.Enter:                          if (_Buttons[_ButtonBack].Selected)                              Back();                            if (_Buttons[_ButtonNext].Selected)                              Next();                            if (_Buttons[_ButtonRandom].Selected)                              _SelectRandom();                            if (_Buttons[_ButtonIncreaseTeams].Selected)                              IncreaseTeamNum();                            if (_Buttons[_ButtonDecreaseTeams].Selected)                              DecreaseTeamNum();                            if (_Buttons[_ButtonIncreasePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                            if (_Buttons[_ButtonDecreasePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                            break;                        case Keys.Delete:                          if (_SelectSlides[_SelectSlidePlayer].Selected && _SelectSlides[_SelectSlidePlayer].NumValues > 0)                          {                              int index = _SelectSlides[_SelectSlidePlayer].Selection;                              _RemovePlayerByIndex(_CurrentTeam' index);                              _UpdatePlayerSlide();                          }                          break;                        case Keys.Left:                      case Keys.Right:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              _OnChangeTeamSlide();                          break;                        case Keys.P:                          if (!_SelectingKeyboardActive)                          {                              _SelectingFastPlayerNr = (_CurrentTeam + 1);                              _SelectingFast = true;                              //_ResetPlayerSelections();                          }                          break;                        case Keys.D1:                      case Keys.NumPad1:                          numPressed = 1;                          break;                        case Keys.D2:                      case Keys.NumPad2:                          numPressed = 2;                          break;                        case Keys.D3:                      case Keys.NumPad3:                          numPressed = 3;                          break;                        case Keys.D4:                      case Keys.NumPad4:                          numPressed = 4;                          break;                        case Keys.D5:                      case Keys.NumPad5:                          numPressed = 5;                          break;                        case Keys.D6:                      case Keys.NumPad6:                          numPressed = 6;                          break;                        case Keys.D7:                      case Keys.NumPad7:                          numPressed = 7;                          break;                        case Keys.D8:                      case Keys.NumPad8:                          numPressed = 8;                          break;                        case Keys.D9:                      case Keys.NumPad9:                          numPressed = 9;                          break;                        case Keys.Subtract:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              DecreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              DecreasePlayerNum(_CurrentTeam);                          break;                        case Keys.Add:                          if (_SelectSlides[_SelectSlideTeams].Selected)                              IncreaseTeamNum();                          else if (_SelectSlides[_SelectSlidePlayer].Selected)                              IncreasePlayerNum(_CurrentTeam);                          break;                  }
Missing Default,VocaluxeLib.Menu,CMenuPartySongSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CMenuPartySongSelection.cs,HandleInput,The following switch statement is missing a default case: switch (keyEvent.Key)              {                  case Keys.Back:                  case Keys.Escape:                      Back();                      break;                  case Keys.Enter:                      if (_Buttons[_ButtonNext].Selected)                          Next();                      else if (_Buttons[_ButtonBack].Selected)                          Back();                      break;                    case Keys.Left:                  case Keys.Right:                      _GetSelectedOptions();                      _UpdateSelectSlideVisibility();                      break;              }
Missing Default,VocaluxeLib.Menu,CNameSelection,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CNameSelection.cs,HandleInput,The following switch statement is missing a default case: switch (kevent.Key)              {                  case Keys.Right:                      if (_ActualSelection + 1 < _Tiles.Count)                      {                          if (_Tiles[_ActualSelection + 1].ProfileID != Guid.Empty)                              _ActualSelection++;                      }                      else                      {                          int offset = Offset;                          UpdateList(Offset + 1);                          if (offset != Offset)                              _ActualSelection -= _Theme.Tiles.NumW - 1;                      }                      break;                    case Keys.Left:                      if (_ActualSelection - 1 > -1)                          _ActualSelection--;                      else if (Offset > 0)                      {                          UpdateList(Offset - 1);                          _ActualSelection += _Theme.Tiles.NumW - 1;                      }                      break;                    case Keys.Up:                      if (_ActualSelection - _Theme.Tiles.NumW > -1)                          _ActualSelection -= _Theme.Tiles.NumW;                      else if (Offset > 0)                      {                          UpdateList(Offset - 1);                      }                      break;                    case Keys.Down:                      if (_ActualSelection + _Theme.Tiles.NumW < _Tiles.Count)                      {                          if (_Tiles[_ActualSelection + _Theme.Tiles.NumW].ProfileID != Guid.Empty)                              _ActualSelection += _Theme.Tiles.NumW;                      }                      else                      {                          int offset = Offset;                          UpdateList(Offset + 1);                      }                      if (_Tiles[_ActualSelection].ProfileID == Guid.Empty)                      {                          _ActualSelection = _Tiles.Count - _Theme.Tiles.NumW;                          while(_Tiles[_ActualSelection + 1].ProfileID != Guid.Empty)                          {                              _ActualSelection++;                          }                      }                      break;              }
Missing Default,VocaluxeLib.Menu,CObjectInteractions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CObjectInteractions.cs,_GetElement,The following switch statement is missing a default case: switch (element.Type)              {                  case EType.Background:                      return _Backgrounds[element.Num];                  case EType.Button:                      return _Buttons[element.Num];                  case EType.SelectSlide:                      return _SelectSlides[element.Num];                  case EType.Text:                      return _Texts[element.Num];                  case EType.Static:                      return _Statics[element.Num];                  case EType.SongMenu:                      return _SongMenus[element.Num];                  case EType.Lyric:                      return _Lyrics[element.Num];                  case EType.SingNote:                      return _SingNotes[element.Num];                  case EType.NameSelection:                      return _NameSelections[element.Num];                  case EType.Equalizer:                      return _Equalizers[element.Num];                  case EType.Playlist:                      return _Playlists[element.Num];                  case EType.ParticleEffect:                      return _ParticleEffects[element.Num];                  case EType.ProgressBar:                      return _ProgressBars[element.Num];              }
Missing Default,VocaluxeLib.Menu,CObjectInteractions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CObjectInteractions.cs,_GetNextElement,The following switch statement is missing a default case: switch (direction)              {                  case EDirection.Up:                      currentRect = new SRectF(currentRect.X' CBase.Settings.GetRenderH()' 1' 1' currentRect.Z);                      break;                  case EDirection.Down:                      currentRect = new SRectF(currentRect.X' 0' 1' 1' currentRect.Z);                      break;                  case EDirection.Left:                      currentRect = new SRectF(CBase.Settings.GetRenderW()' currentRect.Y' 1' 1' currentRect.Z);                      break;                  case EDirection.Right:                      currentRect = new SRectF(0' currentRect.Y' 1' 1' currentRect.Z);                      break;              }
Missing Default,VocaluxeLib.Menu,CObjectInteractions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CObjectInteractions.cs,_GetDistanceDirect,The following switch statement is missing a default case: switch (direction)              {                  case EDirection.Up:                  case EDirection.Down:                      if (!other.X.IsInRange(current.X' current.Right) && !other.Right.IsInRange(current.X' current.Right) && !current.X.IsInRange(other.X' other.Right))                          return float.MaxValue;                      break;                    case EDirection.Left:                  case EDirection.Right:                      if (!other.Y.IsInRange(current.Y' current.Bottom) && !other.Bottom.IsInRange(current.Y' current.Bottom) && !current.Y.IsInRange(other.Y' other.Bottom))                          return float.MaxValue;                      break;              }
Missing Default,VocaluxeLib.Menu,CObjectInteractions,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CObjectInteractions.cs,_GetDistance180,The following switch statement is missing a default case: switch (direction)              {                  case EDirection.Up:                      if (vector.Y < 0f)                          return distance;                      break;                    case EDirection.Down:                      if (vector.Y > 0f)                          return distance;                      break;                    case EDirection.Left:                      if (vector.X < 0f)                          return distance;                      break;                    case EDirection.Right:                      if (vector.X > 0f)                          return distance;                      break;              }
Missing Default,VocaluxeLib.Menu,CParticle,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticle.cs,Update,The following switch statement is missing a default case: switch (_Type)                  {                      case EParticleType.Twinkle:                          _Alpha = 1f - _Age / _MaxAge;                          break;                        case EParticleType.Star:                          _Alpha = 1f - _Age / _MaxAge;                          break;                        case EParticleType.Snow:                          _Alpha = (float)Math.Sqrt((Math.Sin(_Age / _MaxAge * Math.PI * 2 - 0.5 * Math.PI) + 1) / 2);                          break;                        case EParticleType.Flare:                          _Alpha = 1f - _Age / _MaxAge;                          break;                        case EParticleType.PerfNoteStar:                          _Alpha = 1f - _Age / _MaxAge;                          break;                  }
Missing Default,VocaluxeLib.Menu,CParticle,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticle.cs,Update,The following switch statement is missing a default case: switch (_Type)              {                  case EParticleType.Twinkle:                      X += _Vx * timediff;                      Y += _Vy * timediff;                      break;                    case EParticleType.Star:                      X += _Vx * timediff;                      Y += _Vy * timediff;                      break;                    case EParticleType.Snow:                      var maxy = (int)Math.Round(CBase.Settings.GetRenderH() - _Size * 0.4f);                        if (Math.Round(Y) < maxy)                      {                          float vdx = 0f;                          if (Math.Abs(_Vx) > float.Epsilon)                              vdx = (float)Math.Sin(currentTime / _Vx * Math.PI);                            X += _Vx * timediff * (0.5f + vdx);                            Y += _Vy * timediff * (vdx * vdx / 2f + 0.5f);                          if (Y >= maxy)                              Y = maxy;                      }                      break;                    case EParticleType.Flare:                      X += _Vx * timediff;                      Y += _Vy * timediff;                      break;                    case EParticleType.PerfNoteStar:                      X += _Vx * timediff;                      Y += _Vy * timediff;                      break;              }
Missing Default,VocaluxeLib.Menu,CParticle,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticle.cs,Update,The following switch statement is missing a default case: switch (_Type)                  {                      case EParticleType.Twinkle:                          size = _Size * (1f - currentTime / _Vsize);                          break;                        case EParticleType.Star:                          size = _Size * (1f - currentTime / _Vsize);                          break;                        case EParticleType.Snow:                          size = _Size * (float)Math.Sqrt((Math.Sin(currentTime / _Vsize * Math.PI * 2 - 0.5 * Math.PI) + 1) / 2);                          break;                        case EParticleType.Flare:                          size = _Size * (1f - currentTime / _Vsize);                          break;                        case EParticleType.PerfNoteStar:                          size = _Size * (1f - currentTime / _Vsize);                          break;                  }
Missing Default,VocaluxeLib.Menu,CParticleEffect,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CParticleEffect.cs,Update,The following switch statement is missing a default case: switch (_Theme.Type)                  {                      case EParticleType.Twinkle:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.5f;                          vx = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vy = -CBase.Game.GetRandom(10000) / 50f + 100f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Star:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 0.2f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vr = -CBase.Game.GetRandom(500) / 100f + 2.5f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.Snow:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(5000) / 50f + 10f;                          vx = -CBase.Game.GetRandom(1000) / 50f + 10f;                          vy = CBase.Game.GetRandom(1000) / 50f + Math.Abs(vx) + 10f;                          vr = -CBase.Game.GetRandom(200) / 50f + 2f;                          vsize = lifetime * 2f;                            _NextSpawnTime = lifetime / _Theme.MaxNumber;                          doSpawn = false;                          break;                        case EParticleType.Flare:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(500) / 1000f + 0.1f;                          vx = -CBase.Game.GetRandom(2000) / 50f;                          vy = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vr = -CBase.Game.GetRandom(2000) / 50f + 20f;                          vsize = lifetime * 2f;                          break;                        case EParticleType.PerfNoteStar:                          size = CBase.Game.GetRandom((int)_Theme.Size / 2) + _Theme.Size / 2;                          lifetime = CBase.Game.GetRandom(1000) / 500f + 1.2f;                          vx = 0f;                          vy = 0f;                          vr = CBase.Game.GetRandom(500) / 50f + 10f;                          vsize = lifetime * 2f;                          break;                  }
Missing Default,VocaluxeLib.Menu,CPlaylist,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CPlaylist.cs,HandleMouse,The following switch statement is missing a default case: switch (_EditMode)                  {                          //Normal mode                      case EEditMode.None:                            //LB actions                          if (mouseEvent.LB)                          {                              if (_CurrentPlaylistElement != -1)                              {                                  CBase.Playlist.GetSong(ActivePlaylistID' _CurrentPlaylistElement + _Offset).GameMode =                                      _PlaylistElementContents[_CurrentPlaylistElement + _Offset].Modes[_PlaylistElements[_CurrentPlaylistElement].SelectSlide.Selection];                                  UpdatePlaylist();                              }                              if (_ButtonPlaylistClose.Selected)                              {                                  ClosePlaylist();                                  return true;                              }                              if (_ButtonPlaylistSing.Selected)                              {                                  _StartPlaylistSongs();                                  return true;                              }                              if (_ButtonPlaylistSave.Selected)                              {                                  CBase.Playlist.Save(ActivePlaylistID);                                  return true;                              }                              if (_ButtonPlaylistDelete.Selected)                              {                                  CBase.Playlist.Delete(ActivePlaylistID);                                  ClosePlaylist();                                  return true;                              }                              if (_ButtonPlaylistName.Selected)                              {                                  _EditMode = EEditMode.PlaylistName;                                  _ButtonPlaylistName.EditMode = true;                                  return true;                              }                          }                            //Start selected song with double click                          if (mouseEvent.LD && _CurrentPlaylistElement != -1)                              _StartPlaylistSong(_CurrentPlaylistElement);                            //Change order with holding LB                          if (mouseEvent.LBH && _CurrentPlaylistElement != -1 && _PlaylistElementContents.Count > 0 && DragAndDropSongID == -1)                          {                              _ChangeOrderSource = _CurrentPlaylistElement + _Offset;                                //Update of Drag/Drop-Texture                              if (_ChangeOrderSource >= _PlaylistElementContents.Count)                                  return true;                                _ChangeOrderElement = new CPlaylistElement(_PlaylistElements[_CurrentPlaylistElement])                                  {                                      Background = {Z = CBase.Settings.GetZNear()}'                                      Cover = {Z = CBase.Settings.GetZNear()}'                                      SelectSlide = {Z = CBase.Settings.GetZNear()}'                                      Text1 = {Z = CBase.Settings.GetZNear()}                                  };                                _ChangeOrderElement.Background.Texture = CBase.Themes.GetSkinTexture(_Theme.SkinBackground' _PartyModeID);                              _ChangeOrderElement.Background.Color = _BackgroundColor;                                _OldMousePosX = mouseEvent.X;                              _OldMousePosY = mouseEvent.Y;                                _EditMode = EEditMode.ChangeOrder;                          }                            if (!mouseEvent.LBH && DragAndDropSongID != -1)                          {                              CSong song = CBase.Songs.GetSongByID(DragAndDropSongID);                                if (song != null)                              {                                  var gm = EGameMode.TR_GAMEMODE_NORMAL;                                  if (song.IsDuet)                                      gm = EGameMode.TR_GAMEMODE_DUET;                                    if (_CurrentPlaylistElement != -1)                                  {                                      CBase.Playlist.InsertSong(ActivePlaylistID' _CurrentPlaylistElement + _Offset' DragAndDropSongID' gm);                                      UpdatePlaylist();                                  }                                  else                                  {                                      if (mouseEvent.Y < _PlaylistElements[0].Background.Rect.Y && _Offset == 0)                                      {                                          CBase.Playlist.InsertSong(ActivePlaylistID' 0' DragAndDropSongID' gm);                                          UpdatePlaylist();                                      }                                      else                                      {                                          if (_PlaylistElements.Count + _Offset >= _PlaylistElementContents.Count)                                          {                                              float min = 0f;                                              for (int i = _PlaylistElements.Count - 1; i >= 0; i--)                                              {                                                  if (_PlaylistElements[i].SelectSlide.Visible)                                                  {                                                      min = _PlaylistElements[i].SelectSlide.Rect.Y + _PlaylistElements[i].SelectSlide.Rect.H;                                                      break;                                                  }                                              }                                                if (mouseEvent.Y > min)                                              {                                                  CBase.Playlist.AddSong(ActivePlaylistID' DragAndDropSongID' gm);                                                  UpdatePlaylist();                                                  ScrollToBottom();                                              }                                          }                                      }                                      DragAndDropSongID = -1;                                      UpdatePlaylist();                                  }                              }                          }                            break;                        case EEditMode.PlaylistName:                          _SelectElement(_ButtonPlaylistName);                          _CurrentPlaylistElement = -1;                          if (mouseEvent.LB)                          {                              if (_ButtonPlaylistName.Selected)                              {                                  CBase.Playlist.SetName(ActivePlaylistID' _ButtonPlaylistName.Text.Text);                                  CBase.Playlist.Save(ActivePlaylistID);                                  _EditMode = EEditMode.None;                                  return true;                              }                          }                          else if (mouseEvent.RB)                          {                              if (_ButtonPlaylistName.Selected)                              {                                  _ButtonPlaylistName.Text.Text = CBase.Playlist.GetName(ActivePlaylistID);                                  _EditMode = EEditMode.None;                                  _ButtonPlaylistName.EditMode = false;                                  return true;                              }                          }                          break;                        case EEditMode.ChangeOrder:                          //Actions according to playlist-element                            //Update coords for Drag/Drop-Texture                          _ChangeOrderElement.MouseMove(mouseEvent.X' mouseEvent.Y' _OldMousePosX' _OldMousePosY);                          _OldMousePosX = mouseEvent.X;                          _OldMousePosY = mouseEvent.Y;                            if (!mouseEvent.LBH)                          {                              if (_CurrentPlaylistElement != -1 && _CurrentPlaylistElement + _Offset != _ChangeOrderSource)                              {                                  CBase.Playlist.MoveSong(ActivePlaylistID' _ChangeOrderSource' _CurrentPlaylistElement + _Offset);                                  UpdatePlaylist();                              }                              else if (_CurrentPlaylistElement == -1)                              {                                  if (mouseEvent.Y < _PlaylistElements[0].Background.Rect.Y && _Offset == 0)                                      CBase.Playlist.MoveSong(ActivePlaylistID' _ChangeOrderSource' 0);                                  else                                  {                                      if (_PlaylistElements.Count + _Offset >= _PlaylistElementContents.Count)                                      {                                          float min = 0f;                                          for (int i = _PlaylistElements.Count - 1; i >= 0; i--)                                          {                                              if (_PlaylistElements[i].SelectSlide.Visible)                                              {                                                  min = _PlaylistElements[i].SelectSlide.Rect.Y + _PlaylistElements[i].SelectSlide.Rect.H;                                                  break;                                              }                                          }                                            if (mouseEvent.Y > min)                                              CBase.Playlist.MoveSong(ActivePlaylistID' _ChangeOrderSource' _PlaylistElementContents.Count - 1);                                      }                                  }                                    UpdatePlaylist();                              }                              _EditMode = EEditMode.None;                              _ChangeOrderElement = null;                          }                          break;                  }
Missing Default,VocaluxeLib.Menu,CScreenSetting,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CScreenSetting.cs,GetValue,The following switch statement is missing a default case: switch (_Theme.Type)              {                  case ESettingType.Int:                      return _GetIntValue();                    case ESettingType.String:                      return _Theme.Value;                    case ESettingType.Color:                      return _GetColorValue();                    case ESettingType.Texture:                      return _GetTextureValue();              }
Missing Default,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,_UpdateProgressLeft,The following switch statement is missing a default case: switch (_Direction)              {                  case EDirection.Right:                      _TextureProgressBegin = TextureProgressLeft;                      if (_TextureProgressBegin == null)                          _RectProgressBegin = new SRectF(Rect.X' Rect.Y' 0' 0' Rect.Z);                      else                          _RectProgressBegin = new SRectF(Rect.X' Rect.Y' Rect.H * _TextureProgressBegin.OrigAspect' Rect.H' Rect.Z);                      break;                    case EDirection.Up:                      _TextureProgressBegin = TextureProgressRight;                      if (_TextureProgressBegin == null)                          _RectProgressBegin = new SRectF(Rect.X' Rect.Y + Rect.H' 0' 0' Rect.Z);                      else                          _RectProgressBegin = new SRectF(Rect.X' Rect.Y + Rect.H - Rect.W * _TextureProgressBegin.OrigAspect' Rect.W' Rect.W * _TextureProgressBegin.OrigAspect' Rect.Z);                      break;                    case EDirection.Left:                      _TextureProgressBegin = TextureProgressRight;                      if (_TextureProgressBegin == null)                          _RectProgressBegin = new SRectF(Rect.X + Rect.W' Rect.Y' 0' 0' Rect.Z);                      else                          _RectProgressBegin = new SRectF(Rect.X + Rect.W - Rect.H * _TextureProgressBegin.OrigAspect' Rect.Y' Rect.H *_TextureProgressBegin.OrigAspect' Rect.H' Rect.Z);                      break;                    case EDirection.Down:                      _TextureProgressBegin = TextureProgressLeft;                      if (_TextureProgressBegin == null)                          _RectProgressBegin = new SRectF(Rect.X' Rect.Y' 0' 0' Rect.Z);                      else                          _RectProgressBegin = new SRectF(Rect.X' Rect.Y' Rect.W' Rect.W * _TextureProgressBegin.OrigAspect' Rect.Z);                      break;              }
Missing Default,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,_UpdateProgressMid,The following switch statement is missing a default case: switch (_Direction)              {                  case EDirection.Right:                      _RectProgressMid = new SRectF(_RectProgressBegin.X + _RectProgressBegin.W' Rect.Y' (Rect.W - 2 * _RectProgressBegin.W) * _ProgressCurrent' Rect.H' Rect.Z);                      break;                    case EDirection.Up:                      float newHeight = (Rect.H - 2 * _RectProgressBegin.H) * _ProgressCurrent;                      _RectProgressMid = new SRectF(Rect.X' _RectProgressBegin.Y - newHeight' Rect.W' newHeight' Rect.Z);                      break;                    case EDirection.Left:                      float newWidth = (Rect.W - 2 * _RectProgressBegin.H) * _ProgressCurrent;                      _RectProgressMid = new SRectF(_RectProgressBegin.X - newWidth' Rect.Y' newWidth' Rect.H' Rect.Z);                      break;                    case EDirection.Down:                      _RectProgressMid = new SRectF(Rect.X' _RectProgressBegin.Y + _RectProgressBegin.H' (Rect.H - 2 * _RectProgressBegin.W) * _ProgressCurrent' Rect.W' Rect.Z);                      break;              }
Missing Default,VocaluxeLib.Menu,CProgressBar,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CProgressBar.cs,_UpdateProgressRight,The following switch statement is missing a default case: switch (_Direction)              {                  case EDirection.Right:                      _TextureProgressEnd = _TextureProgressRight;                      if (_TextureProgressEnd == null)                          _RectProgressEnd = new SRectF(_RectProgressMid.X + _RectProgressMid.W' Rect.Y' 0' 0' Rect.Z);                      else                          _RectProgressEnd = new SRectF(_RectProgressMid.X + _RectProgressMid.W' Rect.Y' Rect.H * _TextureProgressBegin.OrigAspect' Rect.H' Rect.Z);                      break;                    case EDirection.Up:                      _TextureProgressEnd = _TextureProgressLeft;                      if (_TextureProgressEnd == null)                          _RectProgressEnd = new SRectF(Rect.X' _RectProgressMid.Y + Rect.W' 0' 0' Rect.Z);                      else                          _RectProgressEnd = new SRectF(Rect.X' _RectProgressMid.Y + Rect.W' Rect.W' Rect.W * _TextureProgressBegin.OrigAspect' Rect.Z);                      break;                    case EDirection.Left:                      _TextureProgressEnd = _TextureProgressLeft;                      if (_TextureProgressEnd == null)                          _RectProgressEnd = new SRectF(_RectProgressMid.X - Rect.H' Rect.Y' 0' 0' Rect.Z);                      else                          _RectProgressEnd = new SRectF(_RectProgressMid.X - Rect.H' Rect.Y' Rect.H * _TextureProgressBegin.OrigAspect' Rect.H' Rect.Z);                      break;                    case EDirection.Down:                      _TextureProgressEnd = _TextureProgressRight;                      if (_TextureProgressEnd == null)                          _RectProgressEnd = new SRectF(Rect.X' _RectProgressMid.Y + _RectProgressMid.H' 0' 0' Rect.Z);                      else                          _RectProgressEnd = new SRectF(Rect.X' _RectProgressMid.Y + _RectProgressMid.H' Rect.W' Rect.W * _TextureProgressBegin.OrigAspect' Rect.Z);                      break;              }
Missing Default,VocaluxeLib.Menu,CText,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CText.cs,_UpdateTextPosition,The following switch statement is missing a default case: switch (ResizeAlign)                  {                      case EHAlignment.Top:                          y += step * 0.25f;                          break;                      case EHAlignment.Center:                          y += step * 0.50f;                          break;                      case EHAlignment.Bottom:                          y += step * 0.75f;                          break;                  }
Missing Default,VocaluxeLib.Menu,CText,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\CText.cs,_UpdateTextPosition,The following switch statement is missing a default case: switch (Align)              {                  case EAlignment.Center:                      x = X - bounds.Width / 2;                      break;                  case EAlignment.Right:                      x = X - bounds.Width;                      break;              }
Missing Default,VocaluxeLib.Menu.SongMenu,CSongMenuList,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuList.cs,HandleInput,The following switch statement is missing a default case: switch (keyEvent.Key)              {                  case Keys.Enter:                      if (CBase.Songs.IsInCategory())                      {                          if (_SelectionNr >= 0 && _PreviewNr != _SelectionNr)                          {                              _PreviewSelectedSong();                              keyEvent.Handled = true;                          }                      }                      else                      {                          _EnterCategory(_PreviewNr);                          keyEvent.Handled = true;                      }                      break;                    case Keys.Escape:                  case Keys.Back:                      if (CBase.Songs.IsInCategory() && catChangePossible)                      {                          _LeaveCategory();                          keyEvent.Handled = true;                      }                      break;                    case Keys.PageUp:                      if (catChangePossible)                      {                          _PrevCategory();                          keyEvent.Handled = true;                      }                      break;                    case Keys.PageDown:                      if (catChangePossible)                      {                          _NextCategory();                          keyEvent.Handled = true;                      }                      break;                    case Keys.Left:                      //Check for >0 so we do not allow selection of nothing (-1)                      if (_SelectionNr > 0 && moveAllowed)                      {                          _SelectionNr--;                          _AutoplayPreviewIfEnabled();                          keyEvent.Handled = true;                      }                      break;                    case Keys.Right:                      if (moveAllowed)                      {                          _SelectionNr++;                          _AutoplayPreviewIfEnabled();                          keyEvent.Handled = true;                      }                      break;                    case Keys.Up:                      if (keyEvent.ModShift)                      {                          if (catChangePossible)                          {                              _PrevCategory();                              keyEvent.Handled = true;                          }                      }                      else if (_SelectionNr >= 1 && moveAllowed)                      {                          _SelectionNr -= 1;                          _AutoplayPreviewIfEnabled();                          keyEvent.Handled = true;                      }                      break;                    case Keys.Down:                      if (keyEvent.ModShift)                      {                          if (catChangePossible)                          {                              _NextCategory();                              keyEvent.Handled = true;                          }                      }                      else if (moveAllowed)                      {                          _SelectionNr += 1;                          _AutoplayPreviewIfEnabled();                          keyEvent.Handled = true;                      }                      break;              }
Missing Default,VocaluxeLib.Menu.SongMenu,CSongMenuFactory,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuFactory.cs,CreateSongMenu,The following switch statement is missing a default case: switch (CBase.Config.GetSongMenuType())              {                  case ESongMenu.TR_CONFIG_LIST:                      return new CSongMenuList(theme' partyModeID);                        //case ESongMenu.TR_CONFIG_DREIDEL:                      //    _SongMenu = new CSongMenuDreidel();                      //    break;                  case ESongMenu.TR_CONFIG_TILE_BOARD:                      return new CSongMenuTileBoard(theme' partyModeID);                        //case ESongMenu.TR_CONFIG_BOOK:                      //    _SongMenu = new CSongMenuBook();                      //    break;              }
Missing Default,VocaluxeLib.Menu.SongMenu,CSongMenuTileBoard,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Menu\SongMenu\CSongMenuTileBoard.cs,HandleInput,The following switch statement is missing a default case: switch (keyEvent.Key)              {                  case Keys.Enter:                      if (CBase.Songs.IsInCategory())                      {                          if (_SelectionNr >= 0 && _PreviewNr != _SelectionNr)                          {                              _PreviewSelectedSong();                              keyEvent.Handled = true;                          }                      }                      else                      {                          _EnterCategory(_PreviewNr);                          keyEvent.Handled = true;                      }                      break;                    case Keys.Escape:                  case Keys.Back:                      if (CBase.Songs.IsInCategory() && catChangePossible)                      {                          _LeaveCategory();                          keyEvent.Handled = true;                      }                      break;                    case Keys.PageUp:                      if (catChangePossible)                      {                          _PrevCategory();                          keyEvent.Handled = true;                      }                      break;                    case Keys.PageDown:                      if (catChangePossible)                      {                          _NextCategory();                          keyEvent.Handled = true;                      }                      break;                    case Keys.Left:                      //Check for >0 so we do not allow selection of nothing (-1)                      if (_SelectionNr > 0 && moveAllowed)                      {                          _SelectionNr--;                          _AutoplayPreviewIfEnabled();                          keyEvent.Handled = true;                      }                      break;                    case Keys.Right:                      if (moveAllowed)                      {                          _SelectionNr++;                          _AutoplayPreviewIfEnabled();                          keyEvent.Handled = true;                      }                      break;                    case Keys.Up:                      if (keyEvent.ModShift)                      {                          if (catChangePossible)                          {                              _PrevCategory();                              keyEvent.Handled = true;                          }                      }                      else if (_SelectionNr >= _NumW && moveAllowed)                      {                          _SelectionNr -= _NumW;                          _AutoplayPreviewIfEnabled();                          keyEvent.Handled = true;                      }                      break;                    case Keys.Down:                      if (keyEvent.ModShift)                      {                          if (catChangePossible)                          {                              _NextCategory();                              keyEvent.Handled = true;                          }                      }                      else if (moveAllowed)                      {                          _SelectionNr += _NumW;                          _AutoplayPreviewIfEnabled();                          keyEvent.Handled = true;                      }                      break;              }
Missing Default,VocaluxeLib.Songs,CSongLoader,C:\repos\Vocaluxe_Vocaluxe\VocaluxeLib\Songs\CSongLoader.cs,_UnifyLanguage,The following switch statement is missing a default case: switch (lang)                      {                          case "Englisch":                              lang = "English";                              break;                          case "Deutsch":                              lang = "German";                              break;                          case "Spanisch":                              lang = "Spanish";                              break;                      }
