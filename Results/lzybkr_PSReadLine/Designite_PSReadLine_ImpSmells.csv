Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,MenuCompleteImpl,The method has 268 lines of code.
Long Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,InteractiveHistorySearchLoop,The method has 103 lines of code.
Long Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,SetDefaultEmacsBindings,The method has 113 lines of code.
Long Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,GetDisplayGrouping,The method has 193 lines of code.
Long Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,SetDefaultViBindings,The method has 233 lines of code.
Long Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,SetOptionsInternal,The method has 118 lines of code.
Long Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,GetKeyHandlers,The method has 113 lines of code.
Long Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,GenerateRender,The method has 173 lines of code.
Long Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ReallyRender,The method has 137 lines of code.
Long Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,CaptureScreenImpl,The method has 104 lines of code.
Long Method,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The method has 169 lines of code.
Complex Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,GetUnambiguousPrefix,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,CompleteImpl,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,GetCompletions,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,MenuCompleteImpl,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,HistoryRecall,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,HistorySearch,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,SetOptionsInternal,Cyclomatic complexity of the method is 28
Complex Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,GetKeyHandlers,Cyclomatic complexity of the method is 20
Complex Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ReadOneOrMoreKeys,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ReadKey,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,InputLoop,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,DelayedOneTimeInitialize,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,DigitArgument,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ViDigitArgumentInChord,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,GenerateRender,Cyclomatic complexity of the method is 24
Complex Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ReallyRender,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,FindPreviousWordFromWord,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ViFindNextWordEnd,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.PowerShell,Menu,C:\repos\lzybkr_PSReadLine\PSReadLine\Completion.cs,UpdateMenuSelection,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetOneKey,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.PowerShell,Keys,C:\repos\lzybkr_PSReadLine\PSReadLine\Keys.cs,Keys,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.PowerShell,Keys,C:\repos\lzybkr_PSReadLine\PSReadLine\Keys.cs,ToGestureString,Cyclomatic complexity of the method is 8
Long Parameter List,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,MaybeAddToHistory,The method has 5 parameters. Parameters: result' edits' undoEditIndex' fromDifferentSession' fromInitialRead
Long Parameter List,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,SetKeyHandlerInternal,The method has 5 parameters. Parameters: keys' handler' briefDescription' longDescription' scriptBlock
Long Parameter List,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,Replace,The method has 5 parameters. Parameters: start' length' replacement' instigator' instigatorArg
Long Parameter List,Microsoft.PowerShell,ScreenCapture,C:\repos\lzybkr_PSReadLine\PSReadLine\ScreenCapture.cs,WriteConsoleOutput,The method has 5 parameters. Parameters: consoleOutput' buffer' bufferSize' bufferCoord' writeRegion
Long Parameter List,Microsoft.PowerShell,ScreenCapture,C:\repos\lzybkr_PSReadLine\PSReadLine\ScreenCapture.cs,ReadConsoleOutput,The method has 5 parameters. Parameters: consoleOutput' buffer' bufferSize' bufferCoord' readRegion
Long Parameter List,Internal,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\PublicAPI.cs,Replace,The method has 5 parameters. Parameters: start' length' replacement' instigator' instigatorArg
Long Identifier,Microsoft.PowerShell,PSConsoleReadLineOptions,C:\repos\lzybkr_PSReadLine\PSReadLine\Cmdlets.cs,,The length of the parameter DefaultHistorySearchCursorMovesToEnd is 36.
Long Identifier,Microsoft.PowerShell,PSConsoleReadLineOptions,C:\repos\lzybkr_PSReadLine\PSReadLine\Cmdlets.cs,,The length of the parameter DefaultHistorySearchCaseSensitive is 33.
Long Identifier,Microsoft.PowerShell,SetPSReadLineOption,C:\repos\lzybkr_PSReadLine\PSReadLine\Cmdlets.cs,,The length of the parameter _commandValidationHandlerSpecified is 34.
Long Identifier,Microsoft.PowerShell,SetPSReadLineOption,C:\repos\lzybkr_PSReadLine\PSReadLine\Cmdlets.cs,,The length of the parameter _historySearchCursorMovesToEnd is 30.
Long Statement,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,GetReplacementTextForDirectory,The length of the statement  "                    replacementText = replacementText.Substring(0' len - 1) + System.IO.Path.DirectorySeparatorChar + replacementText[len - 1]; " is 123.
Long Statement,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,PossibleCompletionsImpl,The length of the statement  "                if (!PromptYesOrNo(string.Format(CultureInfo.CurrentCulture' PSReadLineResources.DisplayAllPossibilities' completions.CompletionMatches.Count))) " is 144.
Long Statement,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,SetDefaultWindowsBindings,The length of the statement  "            _chordDispatchTable = new Dictionary<ConsoleKeyInfo' Dictionary<ConsoleKeyInfo' KeyHandler>>(ConsoleKeyInfoComparer.Instance); " is 126.
Long Statement,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,SetDefaultEmacsBindings,The length of the statement  "            _chordDispatchTable = new Dictionary<ConsoleKeyInfo' Dictionary<ConsoleKeyInfo' KeyHandler>>(ConsoleKeyInfoComparer.Instance) " is 125.
Long Statement,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,SetDefaultViBindings,The length of the statement  "            _viCmdChordTable = new Dictionary<ConsoleKeyInfo' Dictionary<ConsoleKeyInfo' KeyHandler>>(ConsoleKeyInfoComparer.Instance); " is 123.
Long Statement,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,SetDefaultViBindings,The length of the statement  "            _viInsChordTable = new Dictionary<ConsoleKeyInfo' Dictionary<ConsoleKeyInfo' KeyHandler>>(ConsoleKeyInfoComparer.Instance); " is 123.
Long Statement,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ReadLine,The length of the statement  "                    console.WriteLine(string.Format(CultureInfo.CurrentUICulture' PSReadLineResources.OopsAnErrorMessage2' _lastNKeys.Count' sb' e)); " is 129.
Long Statement,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ReplaceCharInPlace,The length of the statement  "            if (_singleton._buffer.Length > 0 && nextKey.KeyChar > 0 && nextKey.Key != ConsoleKey.Escape && nextKey.Key != ConsoleKey.Enter) " is 128.
Long Statement,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ReplaceCharInPlace,The length of the statement  "                _singleton.SaveEditItem(EditItemDelete.Create(_singleton._buffer[_singleton._current].ToString()' _singleton._current)); " is 120.
Long Statement,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ViReplaceToChar,The length of the statement  "            if (ViCharacterSearcher.SearchDelete(keyChar' arg' backoff: false' instigator: (_key' _arg) => ViReplaceToChar(keyChar' _key' _arg))) " is 133.
Long Statement,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ViReplaceToCharBack,The length of the statement  "            if (ViCharacterSearcher.SearchBackwardDelete(keyChar' arg' backoff: false' instigator: (_key' _arg) => ViReplaceToCharBack(keyChar' _key' _arg))) " is 145.
Long Statement,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ViReplaceToBeforeChar,The length of the statement  "            if (ViCharacterSearcher.SearchDelete(keyChar' arg' backoff: true' instigator: (_key' _arg) => ViReplaceToBeforeChar(keyChar' _key' _arg))) " is 138.
Long Statement,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ViReplaceToBeforeCharBack,The length of the statement  "            if (ViCharacterSearcher.SearchBackwardDelete(keyChar' arg' backoff: true' instigator: (_key' _arg) => ViReplaceToBeforeCharBack(keyChar' _key' _arg))) " is 150.
Long Statement,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,DeleteToEnd,The length of the statement  "            _singleton._clipboard = _singleton._buffer.ToString(_singleton._current' _singleton._buffer.Length - _singleton._current); " is 122.
Long Statement,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ViDeleteToChar,The length of the statement  "            ViCharacterSearcher.SearchDelete(keyChar' arg' backoff: false' instigator: (_key' _arg) => ViDeleteToChar(keyChar' _key' _arg)); " is 128.
Long Statement,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ViDeleteToCharBack,The length of the statement  "            ViCharacterSearcher.SearchBackwardDelete(keyChar' arg' backoff: false' instigator: (_key' _arg) => ViDeleteToCharBack(keyChar' _key' _arg)); " is 140.
Long Statement,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ViDeleteToBeforeChar,The length of the statement  "            ViCharacterSearcher.SearchDelete(keyChar' arg' backoff: true' instigator: (_key' _arg) => ViDeleteToBeforeChar(keyChar' _key' _arg)); " is 133.
Long Statement,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ViDeleteToBeforeCharBack,The length of the statement  "            ViCharacterSearcher.SearchBackwardDelete(keyChar' arg' backoff: true' instigator: (_key' _arg) => ViDeleteToBeforeCharBack(keyChar' _key' _arg)); " is 145.
Long Statement,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,InvertCase,The length of the statement  "                    char newChar = Char.IsUpper(c) ? Char.ToLower(c' CultureInfo.CurrentCulture) : char.ToUpper(c' CultureInfo.CurrentCulture); " is 123.
Long Statement,Microsoft.PowerShell,ScreenCapture,C:\repos\lzybkr_PSReadLine\PSReadLine\ScreenCapture.cs,GetColorTable,The length of the statement  "                return GetRTFColorFromColorRef(csbe.Black) + GetRTFColorFromColorRef(csbe.DarkBlue) + GetRTFColorFromColorRef(csbe.DarkGreen) + GetRTFColorFromColorRef(csbe.DarkCyan) + GetRTFColorFromColorRef(csbe.DarkRed) + GetRTFColorFromColorRef(csbe.DarkMagenta) + GetRTFColorFromColorRef(csbe.DarkYellow) + GetRTFColorFromColorRef(csbe.Gray) + GetRTFColorFromColorRef(csbe.DarkGray) + GetRTFColorFromColorRef(csbe.Blue) + GetRTFColorFromColorRef(csbe.Green) + GetRTFColorFromColorRef(csbe.Cyan) + GetRTFColorFromColorRef(csbe.Red) + GetRTFColorFromColorRef(csbe.Magenta) + GetRTFColorFromColorRef(csbe.Yellow) + GetRTFColorFromColorRef(csbe.White); " is 637.
Long Statement,Microsoft.PowerShell,EditItemInsertChar,C:\repos\lzybkr_PSReadLine\PSReadLine\UndoRedo.cs,Undo,The length of the statement  "                Debug.Assert(_singleton._buffer[_insertStartPosition] == _insertedCharacter' "Character to undo is not what it should be"); " is 123.
Complex Conditional,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,UnresolvedCommandCouldSucceed,The conditional expression  "candidateCommand.Equals("Import-Module"' StringComparison.OrdinalIgnoreCase)                      || candidateCommand.Equals("ipmo"' StringComparison.OrdinalIgnoreCase)                      || candidateCommand.Equals("Invoke-Expression"' StringComparison.OrdinalIgnoreCase)                      || candidateCommand.Equals("iex"' StringComparison.OrdinalIgnoreCase)"  is complex.
Complex Conditional,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,MenuCompleteImpl,The conditional expression  "_dispatchTable.TryGetValue(nextKey' out var handler) &&                              (                                  handler.Action == CopyOrCancelLine ||                                  handler.Action == Cut ||                                  handler.Action == DeleteChar ||                                  handler.Action == Paste                              )"  is complex.
Complex Conditional,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ReplaceCharInPlace,The conditional expression  "_singleton._buffer.Length > 0 && nextKey.KeyChar > 0 && nextKey.Key != ConsoleKey.Escape && nextKey.Key != ConsoleKey.Enter"  is complex.
Complex Conditional,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,GetSeqChar,The conditional expression  "ch == '\x1b' || ch == '\x09' || ch == '\x0a' || ch >= '\x7f'"  is complex.
Complex Conditional,Microsoft.PowerShell,VTColorUtils,C:\repos\lzybkr_PSReadLine\PSReadLine\Cmdlets.cs,AsEscapeSequence,The conditional expression  "s.Length == 6 &&                              int.TryParse(s' NumberStyles.HexNumber' NumberFormatInfo.InvariantInfo' out int rgb) &&                              rgb >= 0 && rgb <= 0x00ffffff"  is complex.
Complex Conditional,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The conditional expression  "(sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T')"  is complex.
Complex Conditional,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The conditional expression  "sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L')"  is complex.
Complex Conditional,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The conditional expression  "sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L')"  is complex.
Complex Conditional,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The conditional expression  "sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T')"  is complex.
Empty Catch Block,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,GetCompletions,The method has an empty catch block.
Empty Catch Block,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,PSConsoleReadLine,The method has an empty catch block.
Empty Catch Block,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,DelayedOneTimeInitialize,The method has an empty catch block.
Empty Catch Block,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,GetPrompt,The method has an empty catch block.
Empty Catch Block,Microsoft.PowerShell.Internal,Clipboard,C:\repos\lzybkr_PSReadLine\PSReadLine\Clipboard.cs,GetTextImpl,The method has an empty catch block.
Empty Catch Block,Microsoft.PowerShell.Internal,Clipboard,C:\repos\lzybkr_PSReadLine\PSReadLine\Clipboard.cs,SetSingleClipboardData,The method has an empty catch block.
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,IsQuoted,The following statement contains a magic number: if (s.Length >= 2)              {                  //consider possible '& ' prefix                  var first = (s.Length > 4 && s.StartsWith("& ")) ? s[2] : s[0];                  var last = s[s.Length - 1];                    return (IsSingleQuote(first) && IsSingleQuote(last)) ||                         (IsDoubleQuote(first) && IsDoubleQuote(last));              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,IsQuoted,The following statement contains a magic number: if (s.Length >= 2)              {                  //consider possible '& ' prefix                  var first = (s.Length > 4 && s.StartsWith("& ")) ? s[2] : s[0];                  var last = s[s.Length - 1];                    return (IsSingleQuote(first) && IsSingleQuote(last)) ||                         (IsDoubleQuote(first) && IsDoubleQuote(last));              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,IsQuoted,The following statement contains a magic number: if (s.Length >= 2)              {                  //consider possible '& ' prefix                  var first = (s.Length > 4 && s.StartsWith("& ")) ? s[2] : s[0];                  var last = s[s.Length - 1];                    return (IsSingleQuote(first) && IsSingleQuote(last)) ||                         (IsDoubleQuote(first) && IsDoubleQuote(last));              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,GetUnquotedText,The following statement contains a magic number: if (!consistentQuoting && IsQuoted(s))              {                  //consider possible '& ' prefix                  int startindex = s.StartsWith("& ") ? 3 : 1;                  s = s.Substring(startindex' s.Length - startindex - 1);              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,GetUnquotedText,The following statement contains a magic number: if (match.ResultType == CompletionResultType.Variable)              {                  if (IsQuotedVariable(s))                  {                      return '$' + s.Substring(2' s.Length - 3);                  }                  return s;              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,GetUnquotedText,The following statement contains a magic number: if (match.ResultType == CompletionResultType.Variable)              {                  if (IsQuotedVariable(s))                  {                      return '$' + s.Substring(2' s.Length - 3);                  }                  return s;              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ShortenLongCompletions,The following statement contains a magic number: int splitPos = 10;
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ShortenLongCompletions,The following statement contains a magic number: return s.Substring(0' maxLength - splitPos - 3) + "..." + s.Substring(s.Length - splitPos' splitPos);
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,CreateCompletionMenu,The following statement contains a magic number: var colWidth = Math.Min(matches.Max(c => c.ListItemText.Length) + 2' bufferWidth);
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,GetMenuItem,The following statement contains a magic number: if (spacesNeeded > 0)              {                  item = item + Spaces(spacesNeeded);              }              else if (spacesNeeded < 0)              {                  item = item.Substring(0' columnWidth - 3) + "...";              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,MenuCompleteImpl,The following statement contains a magic number: var menuStack = new Stack<Menu>(10);
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ReportHistoryFileError,The following statement contains a magic number: if (historyErrorReportedCount == 2)                  return;
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ReportHistoryFileError,The following statement contains a magic number: if (historyErrorReportedCount == 2)              {                  Console.WriteLine(PSReadLineResources.HistoryFileErrorFinalMessage);              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,WithHistoryFileMutexDo,The following statement contains a magic number: do              {                  try                  {                      if (_historyFileMutex.WaitOne(timeout))                      {                          try                          {                              action();                              return true;                          }                          catch (UnauthorizedAccessException uae)                          {                              ReportHistoryFileError(uae);                              return false;                          }                          catch (IOException ioe)                          {                              ReportHistoryFileError(ioe);                              return false;                          }                          finally                          {                              _historyFileMutex.ReleaseMutex();                          }                      }                  }                  catch (AbandonedMutexException)                  {                      retryCount += 1;                  }              } while (retryCount > 0 && retryCount < 3);
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,WriteHistoryRange,The following statement contains a magic number: WithHistoryFileMutexDo(100' () =>              {                  if (!MaybeReadHistoryFile())                      return;                    bool retry = true;                  retry_after_creating_directory:                  try                  {                      using (var file = fileOpener(Options.HistorySavePath))                      {                          for (var i = start; i <= end; i++)                          {                              _history[i]._saved = true;                              var line = _history[i].CommandLine.Replace("\n"' "`\n");                              file.WriteLine(line);                          }                      }                      var fileInfo = new FileInfo(Options.HistorySavePath);                      _historyFileLastSavedSize = fileInfo.Length;                  }                  catch (DirectoryNotFoundException)                  {                      // Try making the directory' but just once                      if (retry)                      {                          retry = false;                          Directory.CreateDirectory(Path.GetDirectoryName(Options.HistorySavePath));                          goto retry_after_creating_directory;                      }                  }              });
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,MaybeReadHistoryFile,The following statement contains a magic number: if (Options.HistorySaveStyle == HistorySaveStyle.SaveIncrementally)              {                  return WithHistoryFileMutexDo(1000' () =>                  {                      var fileInfo = new FileInfo(Options.HistorySavePath);                      if (fileInfo.Exists && fileInfo.Length != _historyFileLastSavedSize)                      {                          var historyLines = new List<string>();                          using (var fs = new FileStream(Options.HistorySavePath' FileMode.Open))                          using (var sr = new StreamReader(fs))                          {                              fs.Seek(_historyFileLastSavedSize' SeekOrigin.Begin);                                while (!sr.EndOfStream)                              {                                  historyLines.Add(sr.ReadLine());                              }                          }                          UpdateHistoryFromFile(historyLines' fromDifferentSession: true' fromInitialRead: false);                            _historyFileLastSavedSize = fileInfo.Length;                      }                  });              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ReadHistoryFile,The following statement contains a magic number: WithHistoryFileMutexDo(1000' () =>              {                  if (!File.Exists(Options.HistorySavePath))                  {                      return;                  }                    var historyLines = File.ReadAllLines(Options.HistorySavePath);                  UpdateHistoryFromFile(historyLines' fromDifferentSession: false' fromInitialRead: true);                  var fileInfo = new FileInfo(Options.HistorySavePath);                  _historyFileLastSavedSize = fileInfo.Length;              });
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,InteractiveHistorySearchLoop,The following statement contains a magic number: var toMatch = new StringBuilder(64);
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,InteractiveHistorySearchLoop,The following statement contains a magic number: while (true)              {                  var key = ReadKey();                  _dispatchTable.TryGetValue(key' out var handler);                  var function = handler?.Action;                  if (function == ReverseSearchHistory)                  {                      UpdateHistoryDuringInteractiveSearch(toMatch.ToString()' -1' ref searchFromPoint);                  }                  else if (function == ForwardSearchHistory)                  {                      UpdateHistoryDuringInteractiveSearch(toMatch.ToString()' +1' ref searchFromPoint);                  }                  else if (function == BackwardDeleteChar                      || key.EqualsNormalized(Keys.Backspace)                      || key.EqualsNormalized(Keys.CtrlH))                  {                      if (toMatch.Length > 0)                      {                          toMatch.Remove(toMatch.Length - 1' 1);                          _statusBuffer.Remove(_statusBuffer.Length - 2' 1);                          searchPositions.Pop();                          searchFromPoint = _currentHistoryIndex = searchPositions.Peek();                          var moveCursor = Options.HistorySearchCursorMovesToEnd                              ? HistoryMoveCursor.ToEnd                              : HistoryMoveCursor.DontMove;                          UpdateFromHistory(moveCursor);                            if (_hashedHistory != null)                          {                              // Remove any entries with index < searchFromPoint because                              // we are starting the search from this new index - we always                              // want to find the latest entry that matches the search string                              foreach (var pair in _hashedHistory.ToArray())                              {                                  if (pair.Value < searchFromPoint)                                  {                                      _hashedHistory.Remove(pair.Key);                                  }                              }                          }                            // Prompt may need to have 'failed-' removed.                          var toMatchStr = toMatch.ToString();                          var startIndex = _buffer.ToString().IndexOf(toMatchStr' Options.HistoryStringComparison);                          if (startIndex >= 0)                          {                              _statusLinePrompt = direction > 0 ? _forwardISearchPrompt : _backwardISearchPrompt;                              _current = startIndex;                              _emphasisStart = startIndex;                              _emphasisLength = toMatch.Length;                              Render();                          }                      }                      else                      {                          Ding();                      }                  }                  else if (key.EqualsNormalized(Keys.Escape))                  {                      // End search                      break;                  }                  else if (function == Abort)                  {                      // Abort search                      EndOfHistory();                      break;                  }                  else if (EndInteractiveHistorySearch(key))                  {                      PrependQueuedKeys(key);                      break;                  }                  else                  {                      toMatch.Append(key.KeyChar);                      _statusBuffer.Insert(_statusBuffer.Length - 1' key.KeyChar);                        var toMatchStr = toMatch.ToString();                      var startIndex = _buffer.ToString().IndexOf(toMatchStr' Options.HistoryStringComparison);                      if (startIndex < 0)                      {                          UpdateHistoryDuringInteractiveSearch(toMatchStr' direction' ref searchFromPoint);                      }                      else                      {                          _current = startIndex;                          _emphasisStart = startIndex;                          _emphasisLength = toMatch.Length;                          Render();                      }                      searchPositions.Push(_currentHistoryIndex);                  }              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ShowKeyBindings,The following statement contains a magic number: foreach (var group in boundKeys.GroupBy(k => k.Group).OrderBy(k => k.Key))              {                  var groupDescription = PowerShell.KeyHandler.GetGroupingDescription(group.Key);                  buffer.AppendFormat("\n{0}\n"' groupDescription);                  buffer.Append('='' groupDescription.Length);                  buffer.AppendLine();                    // Compute column widths                  var groupBindings = group.OrderBy(k => k.Function).ToArray();                  var keyWidth = -1;                  var funcWidth = -1;                  foreach (var binding in groupBindings)                  {                      keyWidth = Math.Max(keyWidth' binding.Key.Length);                      funcWidth = Math.Max(funcWidth' binding.Function.Length);                  }                  var maxDescriptionLength = console.WindowWidth - keyWidth - funcWidth - 2;                  var fmtString = "{0'-" + keyWidth + "} {1'-" + funcWidth + "} {2}\n";                    foreach (var boundKey in groupBindings)                  {                      var description = boundKey.Description;                      if (description.Length >= maxDescriptionLength)                      {                          description = description.Substring(0' maxDescriptionLength - 4) + "...";                      }                      buffer.AppendFormat(CultureInfo.InvariantCulture' fmtString' boundKey.Key' boundKey.Function' description);                  }              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ShowKeyBindings,The following statement contains a magic number: foreach (var group in boundKeys.GroupBy(k => k.Group).OrderBy(k => k.Key))              {                  var groupDescription = PowerShell.KeyHandler.GetGroupingDescription(group.Key);                  buffer.AppendFormat("\n{0}\n"' groupDescription);                  buffer.Append('='' groupDescription.Length);                  buffer.AppendLine();                    // Compute column widths                  var groupBindings = group.OrderBy(k => k.Function).ToArray();                  var keyWidth = -1;                  var funcWidth = -1;                  foreach (var binding in groupBindings)                  {                      keyWidth = Math.Max(keyWidth' binding.Key.Length);                      funcWidth = Math.Max(funcWidth' binding.Function.Length);                  }                  var maxDescriptionLength = console.WindowWidth - keyWidth - funcWidth - 2;                  var fmtString = "{0'-" + keyWidth + "} {1'-" + funcWidth + "} {2}\n";                    foreach (var boundKey in groupBindings)                  {                      var description = boundKey.Description;                      if (description.Length >= maxDescriptionLength)                      {                          description = description.Substring(0' maxDescriptionLength - 4) + "...";                      }                      buffer.AppendFormat(CultureInfo.InvariantCulture' fmtString' boundKey.Key' boundKey.Function' description);                  }              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,SetDefaultViBindings,The following statement contains a magic number: if ((_normalCursorSize < 1) || (_normalCursorSize > 100))              {                  // This is unlikely' but possible if the cursor size is set directly in                  // the registry.                  _normalCursorSize = 10;              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,SetDefaultViBindings,The following statement contains a magic number: if ((_normalCursorSize < 1) || (_normalCursorSize > 100))              {                  // This is unlikely' but possible if the cursor size is set directly in                  // the registry.                  _normalCursorSize = 10;              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,GetKeyHandlers,The following statement contains a magic number: if (includeUnbound)              {                  // SelfInsert isn't really unbound' but we don't want UI to show it that way                  boundFunctions.Add("SelfInsert");                    var methods = typeof (PSConsoleReadLine).GetMethods(BindingFlags.Public | BindingFlags.Static);                  foreach (var method in methods)                  {                      var parameters = method.GetParameters();                      if (parameters.Length != 2 ||                          parameters[0].ParameterType != typeof (ConsoleKeyInfo?) ||                          parameters[1].ParameterType != typeof (object))                      {                          continue;                      }                        if (!boundFunctions.Contains(method.Name))                      {                          yield return new PowerShell.KeyHandler                          {                              Key = "Unbound"'                              Function = method.Name'                              Description = null'                              Group = GetDisplayGrouping(method.Name)'                          };                      }                  }              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ReadOneOrMoreKeys,The following statement contains a magic number: while (_console.KeyAvailable)              {                  // _charMap is only guaranteed to accumulate input while KeyAvailable                  // returns false. Make sure to check KeyAvailable after every ProcessKey call'                  // and clear it in a loop in case the input was something like ^[[1 which can                  // be 3' 2' or part of 1 key depending on timing.                  _charMap.ProcessKey(_console.ReadKey());                  while (_charMap.KeyAvailable)                  {                      var key = _charMap.ReadKey();                      _lastNKeys.Enqueue(key);                      _queuedKeys.Enqueue(key);                  }                  if (_readkeyStopwatch.ElapsedMilliseconds > 2)                  {                      // Don't spend too long in this loop if there are lots of queued keys                      break;                  }              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ReadOneOrMoreKeys,The following statement contains a magic number: if (_queuedKeys.Count == 0)              {                  while (!_charMap.KeyAvailable)                  {                      // Don't want to block when there is an escape sequence being read.                      if (_charMap.InEscapeSequence)                      {                          if (_console.KeyAvailable)                          {                              _charMap.ProcessKey(_console.ReadKey());                          }                          else                          {                              // We don't want to sleep for the whole escape timeout                              // or the user will have a laggy console' but there's                              // nothing to block on at this point either' so do a                              // small sleep to yield the CPU while we're waiting                              // to decide what the input was. This will only run                              // if there are no keys waiting to be read.                              Thread.Sleep(5);                          }                      }                      else                      {                          _charMap.ProcessKey(_console.ReadKey());                      }                  }                  while (_charMap.KeyAvailable)                  {                      var key = _charMap.ReadKey();                      _lastNKeys.Enqueue(key);                      _queuedKeys.Enqueue(key);                  }              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ReadKey,The following statement contains a magic number: try              {                  while (true)                  {                      // Next' wait for one of three things:                      //   - a key is pressed                      //   - the console is exiting                      //   - 300ms - to process events if we're idle                        handleId = WaitHandle.WaitAny(_singleton._requestKeyWaitHandles' 300);                      if (handleId != WaitHandle.WaitTimeout)                          break;                        // If we timed out' check for event subscribers (which is just                      // a hint that there might be an event waiting to be processed.)                      var eventSubscribers = _singleton._engineIntrinsics?.Events.Subscribers;                      if (eventSubscribers?.Count > 0)                      {                          bool runPipelineForEventProcessing = false;                          foreach (var sub in eventSubscribers)                          {                              if (sub.SourceIdentifier.Equals("PowerShell.OnIdle"' StringComparison.OrdinalIgnoreCase))                              {                                  // There is an OnIdle event.  We're idle because we timed out.  Normally                                  // PowerShell generates this event' but PowerShell assumes the engine is not                                  // idle because it called PSConsoleHostReadLine which isn't returning.                                  // So we generate the event instead.                                  _singleton._engineIntrinsics.Events.GenerateEvent("PowerShell.OnIdle"' null' null' null);                                  runPipelineForEventProcessing = true;                                  break;                              }                                // If there are any event subscribers that have an action (which might                              // write to the console) and have a source object (i.e. aren't engine                              // events)' run a tiny useless bit of PowerShell so that the events                              // can be processed.                              if (sub.Action != null && sub.SourceObject != null)                              {                                  runPipelineForEventProcessing = true;                                  break;                              }                          }                            if (runPipelineForEventProcessing)                          {                              if (ps == null)                              {                                  ps = System.Management.Automation.PowerShell.Create(RunspaceMode.CurrentRunspace);                                  ps.AddScript("0");                              }                                // To detect output during possible event processing' see if the cursor moved                              // and rerender if so.                              var console = _singleton._console;                              var y = console.CursorTop;                              ps.Invoke();                              if (y != console.CursorTop)                              {                                  _singleton._initialY = console.CursorTop;                                  _singleton.Render();                              }                          }                      }                  }              }              finally              {                  ps?.Dispose();              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,PSConsoleReadLine,The following statement contains a magic number: _buffer = new StringBuilder(8 * 1024);
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,PSConsoleReadLine,The following statement contains a magic number: _buffer = new StringBuilder(8 * 1024);
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,PSConsoleReadLine,The following statement contains a magic number: _statusBuffer = new StringBuilder(256);
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ViIndicateCommandMode,The following statement contains a magic number: if (_options.ViModeIndicator == ViModeStyle.Cursor)              {                  _console.CursorSize = _normalCursorSize < 50 ? 100 : 25;              }              else if (_options.ViModeIndicator == ViModeStyle.Prompt)              {                  ConsoleColor savedBackground = _console.BackgroundColor;                  _console.BackgroundColor = AlternateBackground(_console.BackgroundColor);                  InvokePrompt();                  _console.BackgroundColor = savedBackground;              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ViIndicateCommandMode,The following statement contains a magic number: if (_options.ViModeIndicator == ViModeStyle.Cursor)              {                  _console.CursorSize = _normalCursorSize < 50 ? 100 : 25;              }              else if (_options.ViModeIndicator == ViModeStyle.Prompt)              {                  ConsoleColor savedBackground = _console.BackgroundColor;                  _console.BackgroundColor = AlternateBackground(_console.BackgroundColor);                  InvokePrompt();                  _console.BackgroundColor = savedBackground;              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ViIndicateCommandMode,The following statement contains a magic number: if (_options.ViModeIndicator == ViModeStyle.Cursor)              {                  _console.CursorSize = _normalCursorSize < 50 ? 100 : 25;              }              else if (_options.ViModeIndicator == ViModeStyle.Prompt)              {                  ConsoleColor savedBackground = _console.BackgroundColor;                  _console.BackgroundColor = AlternateBackground(_console.BackgroundColor);                  InvokePrompt();                  _console.BackgroundColor = savedBackground;              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,SwapCharacters,The following statement contains a magic number: if (_singleton._current <= 0 || bufferLength < 2 || _singleton._current > cursorRightLimit)              {                  Ding();                  return;              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,SwapCharacters,The following statement contains a magic number: _singleton.SaveEditItem(EditItemDelete.Create(_singleton._buffer.ToString(cursor - 1' 2)' cursor - 1));
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,Render,The following statement contains a magic number: if (_queuedKeys.Count > 10 && (_lastRenderTime.ElapsedMilliseconds < 50))              {                  // We won't render' but most likely the tokens will be different' so make                  // sure we don't use old tokens' also allow garbage to get collected.                  _tokens = null;                  _ast = null;                  _parseErrors = null;                  return;              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,Render,The following statement contains a magic number: if (_queuedKeys.Count > 10 && (_lastRenderTime.ElapsedMilliseconds < 50))              {                  // We won't render' but most likely the tokens will be different' so make                  // sure we don't use old tokens' also allow garbage to get collected.                  _tokens = null;                  _ast = null;                  _parseErrors = null;                  return;              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ForceRender,The following statement contains a magic number: if (excessBuffers > 5)              {                  _consoleBufferLines.RemoveRange(renderLines.Length' excessBuffers);              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,LengthInBufferCells,The following statement contains a magic number: for (var i = 0; i < len; i++)              {                  var c = str[i];                  if (c == 0x1b && (i+1) < len && str[i+1] == '[')                  {                      // Simple escape sequence skipping                      i += 2;                      while (i < len && str[i] != 'm')                          i++;                        continue;                  }                  sum += LengthInBufferCells(c);              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,LengthInBufferCells,The following statement contains a magic number: if (c < 256)              {                  // We render ^C for Ctrl+C' so return 2 for control characters                  return Char.IsControl(c) ? 2 : 1;              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,LengthInBufferCells,The following statement contains a magic number: if (c < 256)              {                  // We render ^C for Ctrl+C' so return 2 for control characters                  return Char.IsControl(c) ? 2 : 1;              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,ScrollDisplayToCursor,The following statement contains a magic number: if (newTop > console.CursorTop)              {                  // Add 10 for some extra context instead of putting the                  // cursor on the bottom line.                  newTop = console.CursorTop - console.WindowHeight + 10;              }
Magic Number,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,CaptureScreenImpl,The following statement contains a magic number: const int margin = 5;
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,WindowsAnsiCharMap,The following statement contains a magic number: this._pendingKeys = new List<ConsoleKeyInfo>(6);
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessMultipleKeys,The following statement contains a magic number: if (_escTimeoutStopwatch.ElapsedMilliseconds <= EscapeTimeout)              {                  // If it's not a valid escape or alt sequence' just return it as input.                  if (!ProcessSequencePart() && !ProcessAltSequence())                  {                      _readKeyIndexFrom = 0;                      _readKeyIndexTo = _addKeyIndex;                  }              }              else              {                  // If the timer expired and there are three or more pending                  // characters' that means the first two which were entered                  // before the timer expiring could be an alt sequence.                  if (_addKeyIndex >= 3)                  {                      ProcessAltSequence();                  }                  _readKeyIndexFrom = 0;                  _readKeyIndexTo = _addKeyIndex;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessSequencePart,The following statement contains a magic number: if (ch == '[')              {                  if (_addKeyIndex == 2)                  {                      // Still waiting for the rest.                      return true;                  }                    ch = GetSeqChar(2);                  if (ch == '1')                  {                      // ^[[1 - note' it could also be a ^[[1n~ so this function                      // will forward it on if it doesn't find what it expects.                      return ProcessBracket1Sequence();                  }                  else if (ch >= '2' && ch <= '9')                  {                      // ^[[n - expecting possibly 1 more number and a '~'.                      return ProcessBracketNTildeSequence();                  }                  else                  {                      // Completed ^[[x sequence (if the lookup succeeds).                      var index = Array.BinarySearch(_escBracketChars' ch);                      if (index < 0)                      {                          return false;                      }                      SetKey(0' new ConsoleKeyInfo('\0'' _escBracketConsoleKeys[index]' false' false' false));                      _addKeyIndex = 1;                      _readKeyIndexFrom = 0;                      _readKeyIndexTo = 1;                      return true;                  }              }              else if (ch == 'O')              {                  if (_addKeyIndex == 2)                  {                      return true;                  }                    ch = GetSeqChar(2);                  var index = Array.BinarySearch(_escOOrBracket1Chars' ch);                  if (index < 0)                  {                      return false;                  }                  SetKey(0' new ConsoleKeyInfo('\0'' _escBracketConsoleKeys[index]' false' false' false));                  _addKeyIndex = 1;                  _readKeyIndexFrom = 0;                  _readKeyIndexTo = 1;                  return true;              }              else              {                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessSequencePart,The following statement contains a magic number: if (ch == '[')              {                  if (_addKeyIndex == 2)                  {                      // Still waiting for the rest.                      return true;                  }                    ch = GetSeqChar(2);                  if (ch == '1')                  {                      // ^[[1 - note' it could also be a ^[[1n~ so this function                      // will forward it on if it doesn't find what it expects.                      return ProcessBracket1Sequence();                  }                  else if (ch >= '2' && ch <= '9')                  {                      // ^[[n - expecting possibly 1 more number and a '~'.                      return ProcessBracketNTildeSequence();                  }                  else                  {                      // Completed ^[[x sequence (if the lookup succeeds).                      var index = Array.BinarySearch(_escBracketChars' ch);                      if (index < 0)                      {                          return false;                      }                      SetKey(0' new ConsoleKeyInfo('\0'' _escBracketConsoleKeys[index]' false' false' false));                      _addKeyIndex = 1;                      _readKeyIndexFrom = 0;                      _readKeyIndexTo = 1;                      return true;                  }              }              else if (ch == 'O')              {                  if (_addKeyIndex == 2)                  {                      return true;                  }                    ch = GetSeqChar(2);                  var index = Array.BinarySearch(_escOOrBracket1Chars' ch);                  if (index < 0)                  {                      return false;                  }                  SetKey(0' new ConsoleKeyInfo('\0'' _escBracketConsoleKeys[index]' false' false' false));                  _addKeyIndex = 1;                  _readKeyIndexFrom = 0;                  _readKeyIndexTo = 1;                  return true;              }              else              {                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessSequencePart,The following statement contains a magic number: if (ch == '[')              {                  if (_addKeyIndex == 2)                  {                      // Still waiting for the rest.                      return true;                  }                    ch = GetSeqChar(2);                  if (ch == '1')                  {                      // ^[[1 - note' it could also be a ^[[1n~ so this function                      // will forward it on if it doesn't find what it expects.                      return ProcessBracket1Sequence();                  }                  else if (ch >= '2' && ch <= '9')                  {                      // ^[[n - expecting possibly 1 more number and a '~'.                      return ProcessBracketNTildeSequence();                  }                  else                  {                      // Completed ^[[x sequence (if the lookup succeeds).                      var index = Array.BinarySearch(_escBracketChars' ch);                      if (index < 0)                      {                          return false;                      }                      SetKey(0' new ConsoleKeyInfo('\0'' _escBracketConsoleKeys[index]' false' false' false));                      _addKeyIndex = 1;                      _readKeyIndexFrom = 0;                      _readKeyIndexTo = 1;                      return true;                  }              }              else if (ch == 'O')              {                  if (_addKeyIndex == 2)                  {                      return true;                  }                    ch = GetSeqChar(2);                  var index = Array.BinarySearch(_escOOrBracket1Chars' ch);                  if (index < 0)                  {                      return false;                  }                  SetKey(0' new ConsoleKeyInfo('\0'' _escBracketConsoleKeys[index]' false' false' false));                  _addKeyIndex = 1;                  _readKeyIndexFrom = 0;                  _readKeyIndexTo = 1;                  return true;              }              else              {                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessSequencePart,The following statement contains a magic number: if (ch == '[')              {                  if (_addKeyIndex == 2)                  {                      // Still waiting for the rest.                      return true;                  }                    ch = GetSeqChar(2);                  if (ch == '1')                  {                      // ^[[1 - note' it could also be a ^[[1n~ so this function                      // will forward it on if it doesn't find what it expects.                      return ProcessBracket1Sequence();                  }                  else if (ch >= '2' && ch <= '9')                  {                      // ^[[n - expecting possibly 1 more number and a '~'.                      return ProcessBracketNTildeSequence();                  }                  else                  {                      // Completed ^[[x sequence (if the lookup succeeds).                      var index = Array.BinarySearch(_escBracketChars' ch);                      if (index < 0)                      {                          return false;                      }                      SetKey(0' new ConsoleKeyInfo('\0'' _escBracketConsoleKeys[index]' false' false' false));                      _addKeyIndex = 1;                      _readKeyIndexFrom = 0;                      _readKeyIndexTo = 1;                      return true;                  }              }              else if (ch == 'O')              {                  if (_addKeyIndex == 2)                  {                      return true;                  }                    ch = GetSeqChar(2);                  var index = Array.BinarySearch(_escOOrBracket1Chars' ch);                  if (index < 0)                  {                      return false;                  }                  SetKey(0' new ConsoleKeyInfo('\0'' _escBracketConsoleKeys[index]' false' false' false));                  _addKeyIndex = 1;                  _readKeyIndexFrom = 0;                  _readKeyIndexTo = 1;                  return true;              }              else              {                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracket1Sequence,The following statement contains a magic number: if (_addKeyIndex == 3)              {                  // Have ^[[1                  return true;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracket1Sequence,The following statement contains a magic number: if (GetSeqChar(3) != ';')              {                  // Expected ';'' found something else.                  // If it's a number' it may be a sequence of the form ^[[1n~                  return ProcessBracketNTildeSequence();              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracket1Sequence,The following statement contains a magic number: if (_addKeyIndex == 4)              {                  // Have ^[[1;                  return true;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracket1Sequence,The following statement contains a magic number: var ch = GetSeqChar(4);
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracket1Sequence,The following statement contains a magic number: if (_addKeyIndex == 5)              {                  // Have ^[[1;n - waiting for the last char.                  return true;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracket1Sequence,The following statement contains a magic number: ch = GetSeqChar(5);
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: if (_addKeyIndex == 3)              {                  // ^[[n - incomplete                  return true;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: int n = (int)GetSeqChar(2) - (int)'0';
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: int chIndex = 3;
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: if (ch >= '0' && ch <= '9')              {                  ++chIndex;                  if (_addKeyIndex == chIndex)                  {                      // Incomplete' still need possible modifiers and a final '~'.                      return true;                  }                  // Complete the two digit number.                  n = n * 10 + ((int)ch - (int)'0');                  ch = GetSeqChar(chIndex);              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,WindowsAnsiCharMap,C:\repos\lzybkr_PSReadLine\PSReadLine\CharMap.cs,ProcessBracketNTildeSequence,The following statement contains a magic number: switch (n)              {              // This is normally ^[[H' but tmux emits ^[[1~.              case 1:                  key = ConsoleKey.Home;                  break;              case 2:                  key = ConsoleKey.Insert;                  break;              case 3:                  key = ConsoleKey.Delete;                  break;              // This is normally ^[[F' but tmux emits ^[[4~.              case 4:                  key = ConsoleKey.End;                  break;              case 5:                  key = ConsoleKey.PageUp;                  break;              case 6:                  key = ConsoleKey.PageDown;                  break;              // 11-14 are emitted by winpty' but Windows uses ^[[OP' etc.              case 11:                  key = ConsoleKey.F1;                  break;              case 12:                  key = ConsoleKey.F2;                  break;              case 13:                  key = ConsoleKey.F3;                  break;              case 14:                  key = ConsoleKey.F4;                  break;              case 15:                  key = ConsoleKey.F5;                  break;              case 17:                  key = ConsoleKey.F6;                  break;              case 18:                  key = ConsoleKey.F7;                  break;              case 19:                  key = ConsoleKey.F8;                  break;              case 20:                  key = ConsoleKey.F9;                  break;              case 21:                  key = ConsoleKey.F10;                  break;              case 23:                  key = ConsoleKey.F11;                  break;              case 24:                  key = ConsoleKey.F12;                  break;              // tmux emits these for Shift+F1-Shift+F8. I don't have F13 and higher              // on my keyboard but presumably that's what these codes are for.              // ConsoleKey defines up to F24' I can't get a code higher than 34              // and don't want to guess because some codes are randomly skipped.              case 25:                  key = ConsoleKey.F13;                  break;              case 26:                  key = ConsoleKey.F14;                  break;              case 28:                  key = ConsoleKey.F15;                  break;              case 29:                  key = ConsoleKey.F16;                  break;              case 31:                  key = ConsoleKey.F17;                  break;              case 32:                  key = ConsoleKey.F18;                  break;              case 33:                  key = ConsoleKey.F19;                  break;              case 34:                  key = ConsoleKey.F20;                  break;              default:                  return false;              }
Magic Number,Microsoft.PowerShell,SetPSReadLineKeyHandlerCommand,C:\repos\lzybkr_PSReadLine\PSReadLine\Cmdlets.cs,CreateDynamicParametersResult,The following statement contains a magic number: var bindableFunctions = (typeof(PSConsoleReadLine).GetMethods(BindingFlags.Public | BindingFlags.Static))                  .Where(method =>                      {                          var parameters = method.GetParameters();                          return parameters.Length == 2                                 && parameters[0].ParameterType == typeof(ConsoleKeyInfo?)                                 && parameters[1].ParameterType == typeof(object);                      })                  .Select(method => method.Name)                  .OrderBy(name => name);
Magic Number,Microsoft.PowerShell,VTColorUtils,C:\repos\lzybkr_PSReadLine\PSReadLine\Cmdlets.cs,AsEscapeSequence,The following statement contains a magic number: switch (o)              {                  case ConsoleColor c:                      return MapColorToEscapeSequence(c' isBackground);                    case string s:                      if (s.Length > 0)                      {                          // String can be converted to ConsoleColor' so it is a ConsoleColor                          if (LanguagePrimitives.TryConvertTo(s' out ConsoleColor c))                              return MapColorToEscapeSequence(c' isBackground);                            // Escape sequence - assume it's fine as is                          if (s[0] == '\x1b')                              return s;                            // RGB format with possible '#'                          if (s[0] == '#')                              s = s.Substring(1);                            if (s.Length == 6 &&                              int.TryParse(s' NumberStyles.HexNumber' NumberFormatInfo.InvariantInfo' out int rgb) &&                              rgb >= 0 && rgb <= 0x00ffffff)                          {                              if (rgb < 256)                              {                                  return "\x1b[" + (isBackground ? "4" : "3") + "8;5;" + rgb + "m";                              }                                var r = (rgb >> 16) & 0xff;                              var g = (rgb >> 8) & 0xff;                              var b = rgb & 0xff;                                return "\x1b[" + (isBackground ? "4" : "3") + "8;2;" + r + ";" + g + ";" + b + "m";                          }                      }                      break;              }
Magic Number,Microsoft.PowerShell,VTColorUtils,C:\repos\lzybkr_PSReadLine\PSReadLine\Cmdlets.cs,AsEscapeSequence,The following statement contains a magic number: switch (o)              {                  case ConsoleColor c:                      return MapColorToEscapeSequence(c' isBackground);                    case string s:                      if (s.Length > 0)                      {                          // String can be converted to ConsoleColor' so it is a ConsoleColor                          if (LanguagePrimitives.TryConvertTo(s' out ConsoleColor c))                              return MapColorToEscapeSequence(c' isBackground);                            // Escape sequence - assume it's fine as is                          if (s[0] == '\x1b')                              return s;                            // RGB format with possible '#'                          if (s[0] == '#')                              s = s.Substring(1);                            if (s.Length == 6 &&                              int.TryParse(s' NumberStyles.HexNumber' NumberFormatInfo.InvariantInfo' out int rgb) &&                              rgb >= 0 && rgb <= 0x00ffffff)                          {                              if (rgb < 256)                              {                                  return "\x1b[" + (isBackground ? "4" : "3") + "8;5;" + rgb + "m";                              }                                var r = (rgb >> 16) & 0xff;                              var g = (rgb >> 8) & 0xff;                              var b = rgb & 0xff;                                return "\x1b[" + (isBackground ? "4" : "3") + "8;2;" + r + ";" + g + ";" + b + "m";                          }                      }                      break;              }
Magic Number,Microsoft.PowerShell,VTColorUtils,C:\repos\lzybkr_PSReadLine\PSReadLine\Cmdlets.cs,AsEscapeSequence,The following statement contains a magic number: switch (o)              {                  case ConsoleColor c:                      return MapColorToEscapeSequence(c' isBackground);                    case string s:                      if (s.Length > 0)                      {                          // String can be converted to ConsoleColor' so it is a ConsoleColor                          if (LanguagePrimitives.TryConvertTo(s' out ConsoleColor c))                              return MapColorToEscapeSequence(c' isBackground);                            // Escape sequence - assume it's fine as is                          if (s[0] == '\x1b')                              return s;                            // RGB format with possible '#'                          if (s[0] == '#')                              s = s.Substring(1);                            if (s.Length == 6 &&                              int.TryParse(s' NumberStyles.HexNumber' NumberFormatInfo.InvariantInfo' out int rgb) &&                              rgb >= 0 && rgb <= 0x00ffffff)                          {                              if (rgb < 256)                              {                                  return "\x1b[" + (isBackground ? "4" : "3") + "8;5;" + rgb + "m";                              }                                var r = (rgb >> 16) & 0xff;                              var g = (rgb >> 8) & 0xff;                              var b = rgb & 0xff;                                return "\x1b[" + (isBackground ? "4" : "3") + "8;2;" + r + ";" + g + ";" + b + "m";                          }                      }                      break;              }
Magic Number,Microsoft.PowerShell,VTColorUtils,C:\repos\lzybkr_PSReadLine\PSReadLine\Cmdlets.cs,AsEscapeSequence,The following statement contains a magic number: switch (o)              {                  case ConsoleColor c:                      return MapColorToEscapeSequence(c' isBackground);                    case string s:                      if (s.Length > 0)                      {                          // String can be converted to ConsoleColor' so it is a ConsoleColor                          if (LanguagePrimitives.TryConvertTo(s' out ConsoleColor c))                              return MapColorToEscapeSequence(c' isBackground);                            // Escape sequence - assume it's fine as is                          if (s[0] == '\x1b')                              return s;                            // RGB format with possible '#'                          if (s[0] == '#')                              s = s.Substring(1);                            if (s.Length == 6 &&                              int.TryParse(s' NumberStyles.HexNumber' NumberFormatInfo.InvariantInfo' out int rgb) &&                              rgb >= 0 && rgb <= 0x00ffffff)                          {                              if (rgb < 256)                              {                                  return "\x1b[" + (isBackground ? "4" : "3") + "8;5;" + rgb + "m";                              }                                var r = (rgb >> 16) & 0xff;                              var g = (rgb >> 8) & 0xff;                              var b = rgb & 0xff;                                return "\x1b[" + (isBackground ? "4" : "3") + "8;2;" + r + ";" + g + ";" + b + "m";                          }                      }                      break;              }
Magic Number,Microsoft.PowerShell,VTColorUtils,C:\repos\lzybkr_PSReadLine\PSReadLine\Cmdlets.cs,AsEscapeSequence,The following statement contains a magic number: string ExtractCode(string s)              {                  return s.Substring(2).TrimEnd(new[] {'m'});              }
Magic Number,Microsoft.PowerShell,VTColorUtils,C:\repos\lzybkr_PSReadLine\PSReadLine\Cmdlets.cs,FormatColor,The following statement contains a magic number: var replacement = (typeof(PSObject).Assembly.GetName().Version.Major < 6)                  ? "$([char]0x1b)"                  : "`e";
Magic Number,Microsoft.PowerShell,Menu,C:\repos\lzybkr_PSReadLine\PSReadLine\Completion.cs,UpdateMenuSelection,The following statement contains a magic number: var toolTipLines = 2;
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,ConsoleKeyChordConverter,C:\repos\lzybkr_PSReadLine\PSReadLine\ConsoleKeyChordConverter.cs,GetModifier,The following statement contains a magic number: switch (sequence[start])              {                  case 's':                  case 'S':                      if ((sequence.Length - start >= 5) &&                          (sequence[start + 1] == 'h' || sequence[start + 1] == 'H') &&                          (sequence[start + 2] == 'i' || sequence[start + 2] == 'I') &&                          (sequence[start + 3] == 'f' || sequence[start + 3] == 'F') &&                          (sequence[start + 4] == 't' || sequence[start + 4] == 'T'))                      {                          start += 5;                          return ConsoleModifiers.Shift;                      }                      goto default;                    case 'c':                  case 'C':                      if (sequence.Length - start >= 7 &&                          (sequence[start + 1] == 'o' || sequence[start + 1] == 'O') &&                          (sequence[start + 2] == 'n' || sequence[start + 2] == 'N') &&                          (sequence[start + 3] == 't' || sequence[start + 3] == 'T') &&                          (sequence[start + 4] == 'r' || sequence[start + 4] == 'R') &&                          (sequence[start + 5] == 'o' || sequence[start + 5] == 'O') &&                          (sequence[start + 6] == 'l' || sequence[start + 6] == 'L'))                      {                          start += 7;                          return ConsoleModifiers.Control;                      }                      else if (sequence.Length - start >= 4 &&                               (sequence[start + 1] == 't' || sequence[start + 1] == 'T') &&                               (sequence[start + 2] == 'r' || sequence[start + 2] == 'R') &&                               (sequence[start + 3] == 'l' || sequence[start + 3] == 'L'))                      {                          start += 4;                          return ConsoleModifiers.Control;                      }                      goto default;                    case 'a':                  case 'A':                      if (sequence.Length - start >= 3 &&                          (sequence[start + 1] == 'l' || sequence[start + 1] == 'L') &&                          (sequence[start + 2] == 't' || sequence[start + 2] == 'T'))                      {                          start += 3;                          return ConsoleModifiers.Alt;                      }                      goto default;                    default:                      return 0;              }
Magic Number,Microsoft.PowerShell,Keys,C:\repos\lzybkr_PSReadLine\PSReadLine\Keys.cs,Keys,The following statement contains a magic number: for (i = 0; i < 26; i++)              {                  CtrlKeyToKeyCharMap.Add(new KeyWithModifiers(ConsoleKey.A + i)' (char)(i + 1));              }
Magic Number,Microsoft.PowerShell,Keys,C:\repos\lzybkr_PSReadLine\PSReadLine\Keys.cs,Keys,The following statement contains a magic number: for (i = 0; i < 10; i++)              {                  char c = i == 2 ? '\0' : i == 6 ? '\x1e' : (char) ('0' + i);                  CtrlKeyToKeyCharMap.Add(new KeyWithModifiers(ConsoleKey.D0 + i)' c);                  CtrlKeyToKeyCharMap.Add(new KeyWithModifiers(ConsoleKey.NumPad0 + i)' c);              }
Magic Number,Microsoft.PowerShell,Keys,C:\repos\lzybkr_PSReadLine\PSReadLine\Keys.cs,Keys,The following statement contains a magic number: for (i = 0; i < 10; i++)              {                  char c = i == 2 ? '\0' : i == 6 ? '\x1e' : (char) ('0' + i);                  CtrlKeyToKeyCharMap.Add(new KeyWithModifiers(ConsoleKey.D0 + i)' c);                  CtrlKeyToKeyCharMap.Add(new KeyWithModifiers(ConsoleKey.NumPad0 + i)' c);              }
Magic Number,Microsoft.PowerShell,Keys,C:\repos\lzybkr_PSReadLine\PSReadLine\Keys.cs,Keys,The following statement contains a magic number: for (i = 0; i < 10; i++)              {                  char c = i == 2 ? '\0' : i == 6 ? '\x1e' : (char) ('0' + i);                  CtrlKeyToKeyCharMap.Add(new KeyWithModifiers(ConsoleKey.D0 + i)' c);                  CtrlKeyToKeyCharMap.Add(new KeyWithModifiers(ConsoleKey.NumPad0 + i)' c);              }
Magic Number,Microsoft.PowerShell,Keys,C:\repos\lzybkr_PSReadLine\PSReadLine\Keys.cs,GetNormalizedHashCode,The following statement contains a magic number: return unchecked(((h1 << 5) + h1) ^ h2);
Magic Number,Microsoft.PowerShell,Keys,C:\repos\lzybkr_PSReadLine\PSReadLine\Keys.cs,ToGestureString,The following statement contains a magic number: if (useKeyEnum)              {                  sb.Append(key.Key);              }              else              {                  var c = key.NormalizeKeyChar();                  string s;                  switch (c)                  {                      case ' '   : s = "Space";     break;                      case '\x1b': s = "Escape";    break;                      case '\x1c': s = "\\";        break;                      case '\x1d': s = "]";         break;                      case '\x1f': s = "_";         break;                      case '\x7f': s = "Backspace"; break;                      case '\x08':                          s = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "Backspace" : "Ctrl+Backspace";                          break;                        case char _ when c <= 26:                          s = ((char)((isShift ? 'A' : 'a') + c - 1)).ToString();                          break;                        default:                          s = c.ToString();                          break;                  }                  sb.Append(s);              }
Magic Number,Microsoft.PowerShell,KeyWithModifiers,C:\repos\lzybkr_PSReadLine\PSReadLine\Keys.cs,GetHashCode,The following statement contains a magic number: return unchecked(((h1 << 5) + h1) ^ h2);
Magic Number,Microsoft.PowerShell,ScreenCapture,C:\repos\lzybkr_PSReadLine\PSReadLine\ScreenCapture.cs,InvertLines,The following statement contains a magic number: for (int i = 0; i < buffer.Length; i++)              {                  buffer[i].ForegroundColor = (ConsoleColor)((int)buffer[i].ForegroundColor ^ 7);                  buffer[i].BackgroundColor = (ConsoleColor)((int)buffer[i].BackgroundColor ^ 7);              }
Magic Number,Microsoft.PowerShell,ScreenCapture,C:\repos\lzybkr_PSReadLine\PSReadLine\ScreenCapture.cs,InvertLines,The following statement contains a magic number: for (int i = 0; i < buffer.Length; i++)              {                  buffer[i].ForegroundColor = (ConsoleColor)((int)buffer[i].ForegroundColor ^ 7);                  buffer[i].BackgroundColor = (ConsoleColor)((int)buffer[i].BackgroundColor ^ 7);              }
Magic Number,Microsoft.PowerShell,CHAR_INFO,C:\repos\lzybkr_PSReadLine\PSReadLine\ScreenCapture.cs,CHAR_INFO,The following statement contains a magic number: Attributes = (ushort)(((int)background << 4) | (int)foreground);
Magic Number,Microsoft.PowerShell.Internal,Clipboard,C:\repos\lzybkr_PSReadLine\PSReadLine\Clipboard.cs,SetSingleClipboardData,The following statement contains a magic number: try              {                    uint bytes;                  if (format == CF_RTF || format == CF_TEXT)                  {                      bytes = (uint)(text.Length + 1);                      data = Marshal.StringToHGlobalAnsi(text);                  }                  else if (format == CF_UNICODETEXT)                  {                      bytes = (uint) ((text.Length + 1) * 2);                      data = Marshal.StringToHGlobalUni(text);                  }                  else                  {                      // Not yet supported format.                      return false;                  }                    if (data == IntPtr.Zero) return false;                    hGlobal = GlobalAlloc(GHND' (UIntPtr) bytes);                  if (hGlobal == IntPtr.Zero) return false;                    IntPtr dataCopy = GlobalLock(hGlobal);                  if (dataCopy == IntPtr.Zero) return false;                  CopyMemory(dataCopy' data' bytes);                  GlobalUnlock(hGlobal);                    if (SetClipboardData(format' hGlobal) != IntPtr.Zero)                  {                      // The clipboard owns this memory now' so don't free it.                      hGlobal = IntPtr.Zero;                  }              }              catch              {              }              finally              {                  if (data != IntPtr.Zero)                  {                      Marshal.FreeHGlobal(data);                  }                  if (hGlobal != IntPtr.Zero)                  {                      GlobalFree(hGlobal);                  }              }
Magic Number,Microsoft.PowerShell.Internal,Clipboard,C:\repos\lzybkr_PSReadLine\PSReadLine\Clipboard.cs,ExecuteOnStaThread,The following statement contains a magic number: const int retryCount = 5;
Missing Default,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,UnresolvedCommandCouldSucceed,The following switch statement is missing a default case: switch (commandName[0])                  {                  // The following are debugger commands that should be accepted if we're debugging                  // because the console host will interpret these commands directly.                  case 's': case 'v': case 'o': case 'c': case 'q': case 'k': case 'l':                  case 'S': case 'V': case 'O': case 'C': case 'Q': case 'K': case 'L':                  case '?': case 'h': case 'H':                      // Ideally we would check $PSDebugContext' but it is set at function                      // scope' and because we're in a module' we can't find that variable                      // (arguably a PowerShell issue.)                      // NestedPromptLevel is good enough though - it's rare to be in a nested.                      var nestedPromptLevel = _engineIntrinsics.SessionState.PSVariable.GetValue("NestedPromptLevel");                      if (nestedPromptLevel is int)                      {                          return ((int)nestedPromptLevel) > 0;                      }                      break;                  }
Missing Default,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,SetDefaultBindings,The following switch statement is missing a default case: switch (editMode)              {                  case EditMode.Emacs:                      SetDefaultEmacsBindings();                      break;                  case EditMode.Vi:                      SetDefaultViBindings();                      break;                  case EditMode.Windows:                      SetDefaultWindowsBindings();                      break;              }
Missing Default,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,GetTokenColor,The following switch statement is missing a default case: switch (token.Kind)              {              case TokenKind.Comment:                  return _options._commentColor;                case TokenKind.Parameter:              case TokenKind.Generic when token is StringLiteralToken slt && slt.Text.StartsWith("--"):                  return _options._parameterColor;                case TokenKind.Variable:              case TokenKind.SplattedVariable:                  return _options._variableColor;                case TokenKind.StringExpandable:              case TokenKind.StringLiteral:              case TokenKind.HereStringExpandable:              case TokenKind.HereStringLiteral:                  return _options._stringColor;                case TokenKind.Number:                  return _options._numberColor;              }
Missing Default,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,Ding,The following switch statement is missing a default case: switch (Options.BellStyle)              {              case BellStyle.None:                  break;              case BellStyle.Audible:                  if (Options.DingDuration > 0)                  {                      if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))                      {                          Console.Beep(Options.DingTone' Options.DingDuration);                      }                      else                      {                          Console.Beep();                      }                  }                  break;              case BellStyle.Visual:                  // TODO: flash prompt? command line?                  break;              }
Missing Default,Microsoft.PowerShell,PSConsoleReadLine,C:\repos\lzybkr_PSReadLine\PSReadLine\BasicEditing.cs,FindNestedToken,The following switch statement is missing a default case: switch (mode)              {              case FindTokenMode.CurrentOrNext:                  if (token == null && (i + 1) < tokens.Count)                  {                      token = tokens[i + 1];                  }                  break;              case FindTokenMode.Next:                  if (!foundNestedToken)                  {                      // If there is no next token' return null (happens with nested                      // tokens where there is no EOF/EOS token).                      token = ((i + 1) < tokens.Count) ? tokens[i + 1] : null;                  }                  break;              case FindTokenMode.Previous:                  if (token == null)                  {                      if (i >= 0)                      {                          token = tokens[i];                      }                  }                  else if (offset == token.Extent.StartOffset)                  {                      token = i > 0 ? tokens[i - 1] : null;                  }                  break;              }
Missing Default,Microsoft.PowerShell,VTColorUtils,C:\repos\lzybkr_PSReadLine\PSReadLine\Cmdlets.cs,IsValidColor,The following switch statement is missing a default case: switch (o)              {                  case ConsoleColor c:                      return true;                    case string s:                      if (s.Length > 0)                      {                          // String can be converted to ConsoleColor' so is it a ConsoleColor?                          if (LanguagePrimitives.TryConvertTo(s' out ConsoleColor unused1))                              return true;                            // Escape sequence - assume it's fine as is                          if (s[0] == '\x1b')                              return true;                            // RGB format with possible '#'                          if (s[0] == '#')                              s = s.Substring(1);                            if (int.TryParse(s' NumberStyles.HexNumber' NumberFormatInfo.InvariantInfo' out int rgb) &&                              rgb >= 0 && rgb <= 0x00ffffff)                              return true;                      }                      break;              }
Missing Default,Microsoft.PowerShell,VTColorUtils,C:\repos\lzybkr_PSReadLine\PSReadLine\Cmdlets.cs,AsEscapeSequence,The following switch statement is missing a default case: switch (o)              {                  case ConsoleColor c:                      return MapColorToEscapeSequence(c' isBackground);                    case string s:                      if (s.Length > 0)                      {                          // String can be converted to ConsoleColor' so it is a ConsoleColor                          if (LanguagePrimitives.TryConvertTo(s' out ConsoleColor c))                              return MapColorToEscapeSequence(c' isBackground);                            // Escape sequence - assume it's fine as is                          if (s[0] == '\x1b')                              return s;                            // RGB format with possible '#'                          if (s[0] == '#')                              s = s.Substring(1);                            if (s.Length == 6 &&                              int.TryParse(s' NumberStyles.HexNumber' NumberFormatInfo.InvariantInfo' out int rgb) &&                              rgb >= 0 && rgb <= 0x00ffffff)                          {                              if (rgb < 256)                              {                                  return "\x1b[" + (isBackground ? "4" : "3") + "8;5;" + rgb + "m";                              }                                var r = (rgb >> 16) & 0xff;                              var g = (rgb >> 8) & 0xff;                              var b = rgb & 0xff;                                return "\x1b[" + (isBackground ? "4" : "3") + "8;2;" + r + ";" + g + ";" + b + "m";                          }                      }                      break;              }
Missing Default,Microsoft.PowerShell,Keys,C:\repos\lzybkr_PSReadLine\PSReadLine\Keys.cs,IgnoreKeyChar,The following switch statement is missing a default case: switch (key.Key)              {                  case ConsoleKey.F1:                  case ConsoleKey.F2:                  case ConsoleKey.F3:                  case ConsoleKey.F4:                  case ConsoleKey.F5:                  case ConsoleKey.F6:                  case ConsoleKey.F7:                  case ConsoleKey.F8:                  case ConsoleKey.F9:                  case ConsoleKey.F10:                  case ConsoleKey.F11:                  case ConsoleKey.F12:                  case ConsoleKey.F13:                  case ConsoleKey.F14:                  case ConsoleKey.F15:                  case ConsoleKey.F16:                  case ConsoleKey.F17:                  case ConsoleKey.F18:                  case ConsoleKey.F19:                  case ConsoleKey.F20:                  case ConsoleKey.F21:                  case ConsoleKey.F22:                  case ConsoleKey.F23:                  case ConsoleKey.F24:                  case ConsoleKey.Delete:                  case ConsoleKey.DownArrow:                  case ConsoleKey.End:                  case ConsoleKey.Enter:                  case ConsoleKey.Home:                  case ConsoleKey.Insert:                  case ConsoleKey.LeftArrow:                  case ConsoleKey.PageUp:                  case ConsoleKey.PageDown:                  case ConsoleKey.RightArrow:                  case ConsoleKey.Tab:                  case ConsoleKey.UpArrow:                      return true;              }
