Implementation smell,Namespace,Class,File,Method,Description
Long Method,SampleCommand,Program,D:\research\architectureSmells\repos\madelson_MedallionShell\SampleCommand\Program.cs,Main,The method has 123 lines of code.
Complex Method,SampleCommand,Program,D:\research\architectureSmells\repos\madelson_MedallionShell\SampleCommand\Program.cs,Main,Cyclomatic complexity of the method is 24
Long Statement,SampleCommand,PlatformCompatibilityTests,D:\research\architectureSmells\repos\madelson_MedallionShell\SampleCommand\PlatformCompatibilityTests.cs,TestExitWithMinusOne,The length of the statement  "            // Linux only returns the lower 8 bits of the exit code. Sounds like this may change in the future so we'll be robust to either " is 127.
Long Statement,SampleCommand,PlatformCompatibilityTests,D:\research\architectureSmells\repos\madelson_MedallionShell\SampleCommand\PlatformCompatibilityTests.cs,TestExitWithMinusOne,The length of the statement  "            // https://unix.stackexchange.com/questions/418784/what-is-the-min-and-max-values-of-exit-codes-in-linux/418802#418802?newreg=5f906406f0f04a1980a77192e3c64a6b " is 158.
Long Statement,SampleCommand,PlatformCompatibilityTests,D:\research\architectureSmells\repos\madelson_MedallionShell\SampleCommand\PlatformCompatibilityTests.cs,TestWriteToStandardInput,The length of the statement  "            if (command.Result.StandardOutput != ("abcd" + Environment.NewLine)) { throw new InvalidOperationException($"Was '{command.Result.StandardOutput}'"); } " is 151.
Long Statement,SampleCommand,PlatformCompatibilityTests,D:\research\architectureSmells\repos\madelson_MedallionShell\SampleCommand\PlatformCompatibilityTests.cs,TestArgumentsRoundTrip,The length of the statement  "                throw new InvalidOperationException($"Was {string.Join(" "' outputLines.Select((l' index) => $"'{l}' ({(index >= arguments.Length ? "EXTRA" : (l == arguments[index]).ToString())})"))}"); " is 186.
Long Statement,SampleCommand,PlatformCompatibilityTests,D:\research\architectureSmells\repos\madelson_MedallionShell\SampleCommand\PlatformCompatibilityTests.cs,AssertThrows,The length of the statement  "                if (ex.GetType() != typeof(TException)) { throw new InvalidOperationException($"Expected {typeof(TException)} but got {ex.GetType()}"); } " is 137.
Long Statement,SampleCommand,Program,D:\research\architectureSmells\repos\madelson_MedallionShell\SampleCommand\Program.cs,Log,The length of the statement  "            var baseText = string.Format("{0:h:m:ss.fff} {1} ({2}): "' DateTime.Now' Process.GetCurrentProcess().Id' string.Join(" "' Environment.GetCommandLineArgs())); " is 157.
Magic Number,SampleCommand,PlatformCompatibilityTests,D:\research\architectureSmells\repos\madelson_MedallionShell\SampleCommand\PlatformCompatibilityTests.cs,TestWriteToStandardInput,The following statement contains a magic number: var command = TestShell.Run(SampleCommandPath' new[] { "echo" }' options: o => o.Timeout(TimeSpan.FromSeconds(5)));
Magic Number,SampleCommand,PlatformCompatibilityTests,D:\research\architectureSmells\repos\madelson_MedallionShell\SampleCommand\PlatformCompatibilityTests.cs,TestKill,The following statement contains a magic number: !command.Task.Wait(1000)
Magic Number,SampleCommand,Program,D:\research\architectureSmells\repos\madelson_MedallionShell\SampleCommand\Program.cs,Main,The following statement contains a magic number: switch (args[0])              {                  case "echo":                      var isPerChar = args.Contains("--per-char");                      var encoding = args.Contains("--utf8") ? new UTF8Encoding(encoderShouldEmitUTF8Identifier: false)                          : args.Contains("--utf162") ? new UnicodeEncoding(bigEndian: false' byteOrderMark: false)                          : default(Encoding);                      if (encoding != null)                      {                          Console.InputEncoding = Console.OutputEncoding = encoding;                      }                        if (isPerChar)                      {                          int ch;                          while ((ch = Console.In.Read()) != -1)                          {                              Console.Out.Write((char)ch);                              Console.Out.Flush();                          }                      }                      else                      {                          var input = Console.In.ReadToEnd();                          Console.Out.Write(input);                      }                      break;                  case "errecho":                      var errEchoInput = Console.In.ReadToEnd();                      (args[0].StartsWith("err") ? Console.Error : Console.Out).Write(errEchoInput);                      break;                  case "grep":                      var regex = new Regex(args[1]);                      while ((line = Console.ReadLine()) != null)                      {                          //Log("Read '{0}'"' line);                          if (regex.Match(line).Success)                          {                              Console.WriteLine(line);                              //Log("Wrote '{0}'"' line);                          }                      }                      break;                  case "head":                      var count = int.Parse(args[1]);                      var i = 0;                      while ((i++) < count && (line = Console.ReadLine()) != null)                      {                          Console.WriteLine(line);                      }                      break;                  case "exit":                      var code = int.Parse(args[1]);                      Environment.Exit(code);                      break;                  case "argecho":                      foreach (var argument in args.Skip(1))                      {                          Console.WriteLine(argument);                      }                      break;                  case "sleep":                      Log("Sleeping for " + args[1]);                      Thread.Sleep(int.Parse(args[1]));                      break;                  case "bool":                      Console.WriteLine(args[2]);                      Console.Out.Flush();                      if (!bool.Parse(args[1]))                      {                          Environment.Exit(1);                      }                      break;                  case "pipe":                      string pipeLine;                      while ((pipeLine = Console.In.ReadLine()) != null)                      {                          Console.Out.WriteLine(pipeLine);                          Console.Out.Flush();                      }                      break;                  case "shortflush":                      Console.Out.Write(args[1]);                      Console.Out.Flush();                      // don't exit until stdin closes                      while (Console.ReadLine() != null)                      {                          Thread.Sleep(5);                      }                      break;                  case "echoLinesToBothStreams":                      async Task EchoLinesAsync(TextWriter output)                      {                          while (true)                          {                              string lineToEcho;                              lock (Console.In)                              {                                  lineToEcho = Console.In.ReadLine(); // no async due to lock                              }                              if (lineToEcho == null) { return; }                                await output.WriteLineAsync(lineToEcho);                          }                      }                      Task.WaitAll(Task.Run(() => EchoLinesAsync(Console.Error))' Task.Run(() => EchoLinesAsync(Console.Out)));                      break;                  case nameof(PlatformCompatibilityTests):                      var method = typeof(PlatformCompatibilityTests).GetMethod(args[1]);                      if (method == null)                      {                          throw new ArgumentException($"Unknown test method '{args[1]}'");                      }                      method.Invoke(null' new object[0]);                      break;                  default:                      Console.Error.WriteLine("Unrecognized mode " + args[0]);                      Environment.Exit(-1);                      break;              }
Magic Number,SampleCommand,Program,D:\research\architectureSmells\repos\madelson_MedallionShell\SampleCommand\Program.cs,Main,The following statement contains a magic number: switch (args[0])              {                  case "echo":                      var isPerChar = args.Contains("--per-char");                      var encoding = args.Contains("--utf8") ? new UTF8Encoding(encoderShouldEmitUTF8Identifier: false)                          : args.Contains("--utf162") ? new UnicodeEncoding(bigEndian: false' byteOrderMark: false)                          : default(Encoding);                      if (encoding != null)                      {                          Console.InputEncoding = Console.OutputEncoding = encoding;                      }                        if (isPerChar)                      {                          int ch;                          while ((ch = Console.In.Read()) != -1)                          {                              Console.Out.Write((char)ch);                              Console.Out.Flush();                          }                      }                      else                      {                          var input = Console.In.ReadToEnd();                          Console.Out.Write(input);                      }                      break;                  case "errecho":                      var errEchoInput = Console.In.ReadToEnd();                      (args[0].StartsWith("err") ? Console.Error : Console.Out).Write(errEchoInput);                      break;                  case "grep":                      var regex = new Regex(args[1]);                      while ((line = Console.ReadLine()) != null)                      {                          //Log("Read '{0}'"' line);                          if (regex.Match(line).Success)                          {                              Console.WriteLine(line);                              //Log("Wrote '{0}'"' line);                          }                      }                      break;                  case "head":                      var count = int.Parse(args[1]);                      var i = 0;                      while ((i++) < count && (line = Console.ReadLine()) != null)                      {                          Console.WriteLine(line);                      }                      break;                  case "exit":                      var code = int.Parse(args[1]);                      Environment.Exit(code);                      break;                  case "argecho":                      foreach (var argument in args.Skip(1))                      {                          Console.WriteLine(argument);                      }                      break;                  case "sleep":                      Log("Sleeping for " + args[1]);                      Thread.Sleep(int.Parse(args[1]));                      break;                  case "bool":                      Console.WriteLine(args[2]);                      Console.Out.Flush();                      if (!bool.Parse(args[1]))                      {                          Environment.Exit(1);                      }                      break;                  case "pipe":                      string pipeLine;                      while ((pipeLine = Console.In.ReadLine()) != null)                      {                          Console.Out.WriteLine(pipeLine);                          Console.Out.Flush();                      }                      break;                  case "shortflush":                      Console.Out.Write(args[1]);                      Console.Out.Flush();                      // don't exit until stdin closes                      while (Console.ReadLine() != null)                      {                          Thread.Sleep(5);                      }                      break;                  case "echoLinesToBothStreams":                      async Task EchoLinesAsync(TextWriter output)                      {                          while (true)                          {                              string lineToEcho;                              lock (Console.In)                              {                                  lineToEcho = Console.In.ReadLine(); // no async due to lock                              }                              if (lineToEcho == null) { return; }                                await output.WriteLineAsync(lineToEcho);                          }                      }                      Task.WaitAll(Task.Run(() => EchoLinesAsync(Console.Error))' Task.Run(() => EchoLinesAsync(Console.Out)));                      break;                  case nameof(PlatformCompatibilityTests):                      var method = typeof(PlatformCompatibilityTests).GetMethod(args[1]);                      if (method == null)                      {                          throw new ArgumentException($"Unknown test method '{args[1]}'");                      }                      method.Invoke(null' new object[0]);                      break;                  default:                      Console.Error.WriteLine("Unrecognized mode " + args[0]);                      Environment.Exit(-1);                      break;              }
