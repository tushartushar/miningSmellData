Implementation smell,Namespace,Class,File,Method,Description
Long Method,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The method has 312 lines of code.
Complex Method,ExHentaiAPI,Helper,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Helper.cs,ToCagetories,Cyclomatic complexity of the method is 11
Complex Method,ExHentaiAPI,Helper,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Helper.cs,ToCategories,Cyclomatic complexity of the method is 11
Complex Method,ExHentaiAPI,GalleryFileSearchOption,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\GalleryFileSearchOption.cs,ToByteArray,Cyclomatic complexity of the method is 12
Complex Method,ExHentaiAPI,GalleryInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\GalleryInfo.cs,GalleryInfo,Cyclomatic complexity of the method is 8
Complex Method,ExHentaiAPI,GallerySearchOption,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\GallerySearchOption.cs,GetParametor,Cyclomatic complexity of the method is 12
Complex Method,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,Cyclomatic complexity of the method is 28
Complex Method,ExHentaiAPI,TorrentSearchOption,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentSearchOption.cs,GetUrl,Cyclomatic complexity of the method is 19
Complex Method,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,Cyclomatic complexity of the method is 49
Complex Method,ComputerBeacon.Json,Serializer,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,writeObject,Cyclomatic complexity of the method is 18
Complex Method,ComputerBeacon.Json,Stringifier,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,writeEscapedString,Cyclomatic complexity of the method is 19
Long Parameter List,ExHentaiAPI,ApiResult,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\APIResult.cs,ApiResult,The method has 5 parameters.
Long Parameter List,ExHentaiAPI,ApiResult,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\APIResult.cs,ApiResult,The method has 6 parameters.
Long Parameter List,ExHentaiAPI,ApiResult,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\APIResult.cs,ApiResult,The method has 5 parameters.
Long Parameter List,ExHentaiAPI,ExHentai,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\ExHentai.cs,BeginGetGalleryInfo,The method has 5 parameters.
Long Statement,ExHentaiAPI,ExHentai,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\ExHentai.cs,BeginLogin,The length of the statement  "	byte[] buff = Encoding.ASCII.GetBytes (String.Format ("returntype=8&CookieDate=1&b=d&bt=pone&UserName={0}&PassWord={1}&ipb_login_submit=Login%21"' id' pw)); " is 156.
Long Statement,ExHentaiAPI,ExHentai,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\ExHentai.cs,BeginGetArchiveLink,The length of the statement  "	string url = String.Format ("http://exhentai.org/archiver.php?gid={0}&token={1}&or={2}"' info.token.gid' info.token.token' info.ArchiverKey); " is 141.
Long Statement,ExHentaiAPI,ExHentai,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\ExHentai.cs,BeginGetGalleryTokenFromURL,The length of the statement  "	byte[] buff = Encoding.ASCII.GetBytes (String.Format ("{0} \"method\": \"gtoken\"' \"pagelist\": [[{1}. \"{2}\"' {3}]] {4}"' "{"' m.Groups [2].Value' m.Groups [1].Value' m.Groups [3].Value' "}")); " is 196.
Long Statement,ExHentaiAPI,ExHentai,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\ExHentai.cs,BeginGetTorrentInfo,The length of the statement  "	WebRequest wReq = WebRequest.Create (String.Format ("http://exhentai.org/gallerytorrents.php?gid={0}&t={1}"' token.gid' token.token)); " is 134.
Long Statement,ExHentaiAPI,ExHentai,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\ExHentai.cs,BeginGetTorrentURL,The length of the statement  "	WebRequest wReq = WebRequest.Create (String.Format ("http://exhentai.org/gallerytorrents.php?gid={0}&t={1{&gtid={2}"' info.Token.gid' info.Token.token' info.gtid)); " is 164.
Long Statement,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The length of the statement  "				hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]); " is 127.
Long Statement,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,ParseJsonValue,The length of the statement  "	if (int.TryParse (jsonString' NumberStyles.AllowLeadingSign' System.Globalization.NumberFormatInfo.InvariantInfo' out result)) " is 126.
Long Statement,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,ParseJsonValue,The length of the statement  "	if (long.TryParse (jsonString' NumberStyles.AllowLeadingSign' System.Globalization.NumberFormatInfo.InvariantInfo' out result_long)) " is 132.
Long Statement,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,ParseJsonValue,The length of the statement  "	if (double.TryParse (jsonString' NumberStyles.AllowExponent | NumberStyles.AllowLeadingSign | NumberStyles.AllowDecimalPoint' System.Globalization.NumberFormatInfo.InvariantInfo' out result_double)) " is 198.
Complex Conditional,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The conditional expression  "c == ' ' || c == '\n' || c == '\r' || c == '\t'"  is complex.
Complex Conditional,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The conditional expression  "(c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-'"  is complex.
Complex Conditional,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The conditional expression  "c == ' ' || c == '\n' || c == '\r' || c == '\t'"  is complex.
Complex Conditional,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The conditional expression  "(c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+'"  is complex.
Empty Catch Block,ExHentaiAPI,GalleryTokenCollection,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\GalleryTokenCollection.cs,GalleryTokenCollection,The method has an empty catch block.
Empty Catch Block,ExHentaiAPI,TorrentInfoCollection,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfoCollection.cs,TorrentInfoCollection,The method has an empty catch block.
Empty Catch Block,ExHentaiAPI,TorrentInfoCollection,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfoCollection.cs,TorrentInfoCollection,The method has an empty catch block.
Magic Number,ExHentaiAPI,Helper,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Helper.cs,StringFromStream,The following statement contains a magic number: using (MemoryStream memoryStream = new MemoryStream ()) {  	byte[] buff = new byte[4096];  	int read;  	while ((read = stream.Read (buff' 0' 4096)) > 0)  		memoryStream.Write (buff' 0' read);  	memoryStream.Flush ();  	r = Encoding.UTF8.GetString (memoryStream.ToArray ());  	memoryStream.Dispose ();  }  
Magic Number,ExHentaiAPI,Helper,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Helper.cs,StringFromStream,The following statement contains a magic number: using (MemoryStream memoryStream = new MemoryStream ()) {  	byte[] buff = new byte[4096];  	int read;  	while ((read = stream.Read (buff' 0' 4096)) > 0)  		memoryStream.Write (buff' 0' read);  	memoryStream.Flush ();  	r = Encoding.UTF8.GetString (memoryStream.ToArray ());  	memoryStream.Dispose ();  }  
Magic Number,ExHentaiAPI,Helper,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Helper.cs,StringFromStream,The following statement contains a magic number: while ((read = stream.Read (buff' 0' 4096)) > 0)  	memoryStream.Write (buff' 0' read);  
Magic Number,ExHentaiAPI,GalleryFileSearchOption,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\GalleryFileSearchOption.cs,ToByteArray,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ()) {  	using (StreamWriter sw = new StreamWriter (ms' Encoding.ASCII)) {  		sw.Write ("--{0}\r\n"' boundary);  		sw.Write ("Content-Disposition: form-data; name=\"f_sfile\"\r\n");  		sw.Write ("\r\n");  		sw.Write ("File Search\r\n");  		if (this.UseSimilarityScan) {  			sw.Write ("--{0}\r\n"' boundary);  			sw.Write ("Content-Disposition: form-data; name=\"fs_similar\"\r\n");  			sw.Write ("\r\n");  			sw.Write ("on\r\n");  		}  		if (this.OnlySearchCovers) {  			sw.Write ("--{0}\r\n"' boundary);  			sw.Write ("Content-Disposition: form-data; name=\"fs_covers\"\r\n");  			sw.Write ("\r\n");  			sw.Write ("on\r\n");  		}  		if (this.ShowExpunged) {  			sw.Write ("--{0}\r\n"' boundary);  			sw.Write ("Content-Disposition: form-data; name=\"fs_exp\"\r\n");  			sw.Write ("\r\n");  			sw.Write ("on\r\n");  		}  		if (this.Page.HasValue && this.Page.Value > 1) {  			sw.Write ("--{0}\r\n"' boundary);  			sw.Write ("Content-Disposition: form-data; name=\"page\"\r\n");  			sw.Write ("\r\n");  			sw.Write (this.Page);  			sw.Write ("\r\n");  		}  		sw.Write ("--{0}\r\n"' boundary);  		sw.Write ("Content-Disposition: form-data; name=\"sfile\"; filename=\"\"\r\n"' fin.Name);  		sw.Write ("Content-Type: image/jpeg\r\n");  		sw.Write ("\r\n");  		sw.Flush ();  		int read;  		buff = new byte[4096];  		using (FileStream fstm = fin.OpenRead ())  			while ((read = fstm.Read (buff' 0' 4096)) > 0)  				ms.Write (buff' 0' read);  		sw.Write ("\r\n");  		sw.Write ("--{0}"' boundary);  		sw.Flush ();  		buff = ms.ToArray ();  	}  }  
Magic Number,ExHentaiAPI,GalleryFileSearchOption,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\GalleryFileSearchOption.cs,ToByteArray,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream ()) {  	using (StreamWriter sw = new StreamWriter (ms' Encoding.ASCII)) {  		sw.Write ("--{0}\r\n"' boundary);  		sw.Write ("Content-Disposition: form-data; name=\"f_sfile\"\r\n");  		sw.Write ("\r\n");  		sw.Write ("File Search\r\n");  		if (this.UseSimilarityScan) {  			sw.Write ("--{0}\r\n"' boundary);  			sw.Write ("Content-Disposition: form-data; name=\"fs_similar\"\r\n");  			sw.Write ("\r\n");  			sw.Write ("on\r\n");  		}  		if (this.OnlySearchCovers) {  			sw.Write ("--{0}\r\n"' boundary);  			sw.Write ("Content-Disposition: form-data; name=\"fs_covers\"\r\n");  			sw.Write ("\r\n");  			sw.Write ("on\r\n");  		}  		if (this.ShowExpunged) {  			sw.Write ("--{0}\r\n"' boundary);  			sw.Write ("Content-Disposition: form-data; name=\"fs_exp\"\r\n");  			sw.Write ("\r\n");  			sw.Write ("on\r\n");  		}  		if (this.Page.HasValue && this.Page.Value > 1) {  			sw.Write ("--{0}\r\n"' boundary);  			sw.Write ("Content-Disposition: form-data; name=\"page\"\r\n");  			sw.Write ("\r\n");  			sw.Write (this.Page);  			sw.Write ("\r\n");  		}  		sw.Write ("--{0}\r\n"' boundary);  		sw.Write ("Content-Disposition: form-data; name=\"sfile\"; filename=\"\"\r\n"' fin.Name);  		sw.Write ("Content-Type: image/jpeg\r\n");  		sw.Write ("\r\n");  		sw.Flush ();  		int read;  		buff = new byte[4096];  		using (FileStream fstm = fin.OpenRead ())  			while ((read = fstm.Read (buff' 0' 4096)) > 0)  				ms.Write (buff' 0' read);  		sw.Write ("\r\n");  		sw.Write ("--{0}"' boundary);  		sw.Flush ();  		buff = ms.ToArray ();  	}  }  
Magic Number,ExHentaiAPI,GalleryFileSearchOption,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\GalleryFileSearchOption.cs,ToByteArray,The following statement contains a magic number: using (StreamWriter sw = new StreamWriter (ms' Encoding.ASCII)) {  	sw.Write ("--{0}\r\n"' boundary);  	sw.Write ("Content-Disposition: form-data; name=\"f_sfile\"\r\n");  	sw.Write ("\r\n");  	sw.Write ("File Search\r\n");  	if (this.UseSimilarityScan) {  		sw.Write ("--{0}\r\n"' boundary);  		sw.Write ("Content-Disposition: form-data; name=\"fs_similar\"\r\n");  		sw.Write ("\r\n");  		sw.Write ("on\r\n");  	}  	if (this.OnlySearchCovers) {  		sw.Write ("--{0}\r\n"' boundary);  		sw.Write ("Content-Disposition: form-data; name=\"fs_covers\"\r\n");  		sw.Write ("\r\n");  		sw.Write ("on\r\n");  	}  	if (this.ShowExpunged) {  		sw.Write ("--{0}\r\n"' boundary);  		sw.Write ("Content-Disposition: form-data; name=\"fs_exp\"\r\n");  		sw.Write ("\r\n");  		sw.Write ("on\r\n");  	}  	if (this.Page.HasValue && this.Page.Value > 1) {  		sw.Write ("--{0}\r\n"' boundary);  		sw.Write ("Content-Disposition: form-data; name=\"page\"\r\n");  		sw.Write ("\r\n");  		sw.Write (this.Page);  		sw.Write ("\r\n");  	}  	sw.Write ("--{0}\r\n"' boundary);  	sw.Write ("Content-Disposition: form-data; name=\"sfile\"; filename=\"\"\r\n"' fin.Name);  	sw.Write ("Content-Type: image/jpeg\r\n");  	sw.Write ("\r\n");  	sw.Flush ();  	int read;  	buff = new byte[4096];  	using (FileStream fstm = fin.OpenRead ())  		while ((read = fstm.Read (buff' 0' 4096)) > 0)  			ms.Write (buff' 0' read);  	sw.Write ("\r\n");  	sw.Write ("--{0}"' boundary);  	sw.Flush ();  	buff = ms.ToArray ();  }  
Magic Number,ExHentaiAPI,GalleryFileSearchOption,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\GalleryFileSearchOption.cs,ToByteArray,The following statement contains a magic number: using (StreamWriter sw = new StreamWriter (ms' Encoding.ASCII)) {  	sw.Write ("--{0}\r\n"' boundary);  	sw.Write ("Content-Disposition: form-data; name=\"f_sfile\"\r\n");  	sw.Write ("\r\n");  	sw.Write ("File Search\r\n");  	if (this.UseSimilarityScan) {  		sw.Write ("--{0}\r\n"' boundary);  		sw.Write ("Content-Disposition: form-data; name=\"fs_similar\"\r\n");  		sw.Write ("\r\n");  		sw.Write ("on\r\n");  	}  	if (this.OnlySearchCovers) {  		sw.Write ("--{0}\r\n"' boundary);  		sw.Write ("Content-Disposition: form-data; name=\"fs_covers\"\r\n");  		sw.Write ("\r\n");  		sw.Write ("on\r\n");  	}  	if (this.ShowExpunged) {  		sw.Write ("--{0}\r\n"' boundary);  		sw.Write ("Content-Disposition: form-data; name=\"fs_exp\"\r\n");  		sw.Write ("\r\n");  		sw.Write ("on\r\n");  	}  	if (this.Page.HasValue && this.Page.Value > 1) {  		sw.Write ("--{0}\r\n"' boundary);  		sw.Write ("Content-Disposition: form-data; name=\"page\"\r\n");  		sw.Write ("\r\n");  		sw.Write (this.Page);  		sw.Write ("\r\n");  	}  	sw.Write ("--{0}\r\n"' boundary);  	sw.Write ("Content-Disposition: form-data; name=\"sfile\"; filename=\"\"\r\n"' fin.Name);  	sw.Write ("Content-Type: image/jpeg\r\n");  	sw.Write ("\r\n");  	sw.Flush ();  	int read;  	buff = new byte[4096];  	using (FileStream fstm = fin.OpenRead ())  		while ((read = fstm.Read (buff' 0' 4096)) > 0)  			ms.Write (buff' 0' read);  	sw.Write ("\r\n");  	sw.Write ("--{0}"' boundary);  	sw.Flush ();  	buff = ms.ToArray ();  }  
Magic Number,ExHentaiAPI,GalleryFileSearchOption,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\GalleryFileSearchOption.cs,ToByteArray,The following statement contains a magic number: buff = new byte[4096];  
Magic Number,ExHentaiAPI,GalleryFileSearchOption,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\GalleryFileSearchOption.cs,ToByteArray,The following statement contains a magic number: using (FileStream fstm = fin.OpenRead ())  	while ((read = fstm.Read (buff' 0' 4096)) > 0)  		ms.Write (buff' 0' read);  
Magic Number,ExHentaiAPI,GalleryFileSearchOption,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\GalleryFileSearchOption.cs,ToByteArray,The following statement contains a magic number: while ((read = fstm.Read (buff' 0' 4096)) > 0)  	ms.Write (buff' 0' read);  
Magic Number,ExHentaiAPI,GalleryTokenCollection,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\GalleryTokenCollection.cs,GalleryTokenCollection,The following statement contains a magic number: if (m.Success) {  	try {  		this.ShowingStart = int.Parse (m.Groups [1].Value);  		this.ShowingEnd = int.Parse (m.Groups [2].Value);  		this.SearchCount = int.Parse (m.Groups [3].Value.Replace ("'"' ""));  	}  	catch {  		this.ShowingStart = this.ShowingEnd = this.SearchCount = 0;  	}  }  
Magic Number,ExHentaiAPI,GalleryTokenCollection,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\GalleryTokenCollection.cs,GalleryTokenCollection,The following statement contains a magic number: if (m.Success) {  	try {  		this.ShowingStart = int.Parse (m.Groups [1].Value);  		this.ShowingEnd = int.Parse (m.Groups [2].Value);  		this.SearchCount = int.Parse (m.Groups [3].Value.Replace ("'"' ""));  	}  	catch {  		this.ShowingStart = this.ShowingEnd = this.SearchCount = 0;  	}  }  
Magic Number,ExHentaiAPI,GalleryTokenCollection,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\GalleryTokenCollection.cs,GalleryTokenCollection,The following statement contains a magic number: try {  	this.ShowingStart = int.Parse (m.Groups [1].Value);  	this.ShowingEnd = int.Parse (m.Groups [2].Value);  	this.SearchCount = int.Parse (m.Groups [3].Value.Replace ("'"' ""));  }  catch {  	this.ShowingStart = this.ShowingEnd = this.SearchCount = 0;  }  
Magic Number,ExHentaiAPI,GalleryTokenCollection,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\GalleryTokenCollection.cs,GalleryTokenCollection,The following statement contains a magic number: try {  	this.ShowingStart = int.Parse (m.Groups [1].Value);  	this.ShowingEnd = int.Parse (m.Groups [2].Value);  	this.SearchCount = int.Parse (m.Groups [3].Value.Replace ("'"' ""));  }  catch {  	this.ShowingStart = this.ShowingEnd = this.SearchCount = 0;  }  
Magic Number,ExHentaiAPI,GalleryTokenCollection,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\GalleryTokenCollection.cs,GalleryTokenCollection,The following statement contains a magic number: this.ShowingEnd = int.Parse (m.Groups [2].Value);  
Magic Number,ExHentaiAPI,GalleryTokenCollection,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\GalleryTokenCollection.cs,GalleryTokenCollection,The following statement contains a magic number: this.SearchCount = int.Parse (m.Groups [3].Value.Replace ("'"' ""));  
Magic Number,ExHentaiAPI,GalleryTokenCollection,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\GalleryTokenCollection.cs,GalleryTokenCollection,The following statement contains a magic number: while (m.Success) {  	try {  		GalleryToken gt = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  		if (!this.Contains (gt))  			this.Add (gt);  	}  	catch {  	}  	m = m.NextMatch ();  }  
Magic Number,ExHentaiAPI,GalleryTokenCollection,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\GalleryTokenCollection.cs,GalleryTokenCollection,The following statement contains a magic number: try {  	GalleryToken gt = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  	if (!this.Contains (gt))  		this.Add (gt);  }  catch {  }  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: while (mTd.Success) {  	value = mTd.Groups [1].Value;  	switch (i++) {  	// Added  	case 0:  		this.PostedUTC = DateTime.Parse (value);  		this.Posted = this.PostedUTC.ToLocalTime ();  		break;  	// Torrent Name  	case 1:  		m = rTorrentName.Match (value);  		this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  		this.gtid = int.Parse (m.Groups [3].Value);  		this.FileName = m.Groups [4].Value;  		break;  	// Gallery  	case 2:  		break;  	// Size  	case 3:  		this.Size = parseSize (value);  		break;  	// Seeds  	case 4:  		this.Seeds = int.Parse (value);  		break;  	// Peers  	case 5:  		this.Peers = int.Parse (value);  		break;  	// DLs  	case 6:  		this.Downloads = int.Parse (value);  		break;  	// Uploader  	case 7:  		this.Uploader = rUploader.Match (value).Groups [1].Value;  		break;  	}  }  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: while (mTd.Success) {  	value = mTd.Groups [1].Value;  	switch (i++) {  	// Added  	case 0:  		this.PostedUTC = DateTime.Parse (value);  		this.Posted = this.PostedUTC.ToLocalTime ();  		break;  	// Torrent Name  	case 1:  		m = rTorrentName.Match (value);  		this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  		this.gtid = int.Parse (m.Groups [3].Value);  		this.FileName = m.Groups [4].Value;  		break;  	// Gallery  	case 2:  		break;  	// Size  	case 3:  		this.Size = parseSize (value);  		break;  	// Seeds  	case 4:  		this.Seeds = int.Parse (value);  		break;  	// Peers  	case 5:  		this.Peers = int.Parse (value);  		break;  	// DLs  	case 6:  		this.Downloads = int.Parse (value);  		break;  	// Uploader  	case 7:  		this.Uploader = rUploader.Match (value).Groups [1].Value;  		break;  	}  }  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: while (mTd.Success) {  	value = mTd.Groups [1].Value;  	switch (i++) {  	// Added  	case 0:  		this.PostedUTC = DateTime.Parse (value);  		this.Posted = this.PostedUTC.ToLocalTime ();  		break;  	// Torrent Name  	case 1:  		m = rTorrentName.Match (value);  		this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  		this.gtid = int.Parse (m.Groups [3].Value);  		this.FileName = m.Groups [4].Value;  		break;  	// Gallery  	case 2:  		break;  	// Size  	case 3:  		this.Size = parseSize (value);  		break;  	// Seeds  	case 4:  		this.Seeds = int.Parse (value);  		break;  	// Peers  	case 5:  		this.Peers = int.Parse (value);  		break;  	// DLs  	case 6:  		this.Downloads = int.Parse (value);  		break;  	// Uploader  	case 7:  		this.Uploader = rUploader.Match (value).Groups [1].Value;  		break;  	}  }  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: while (mTd.Success) {  	value = mTd.Groups [1].Value;  	switch (i++) {  	// Added  	case 0:  		this.PostedUTC = DateTime.Parse (value);  		this.Posted = this.PostedUTC.ToLocalTime ();  		break;  	// Torrent Name  	case 1:  		m = rTorrentName.Match (value);  		this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  		this.gtid = int.Parse (m.Groups [3].Value);  		this.FileName = m.Groups [4].Value;  		break;  	// Gallery  	case 2:  		break;  	// Size  	case 3:  		this.Size = parseSize (value);  		break;  	// Seeds  	case 4:  		this.Seeds = int.Parse (value);  		break;  	// Peers  	case 5:  		this.Peers = int.Parse (value);  		break;  	// DLs  	case 6:  		this.Downloads = int.Parse (value);  		break;  	// Uploader  	case 7:  		this.Uploader = rUploader.Match (value).Groups [1].Value;  		break;  	}  }  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: while (mTd.Success) {  	value = mTd.Groups [1].Value;  	switch (i++) {  	// Added  	case 0:  		this.PostedUTC = DateTime.Parse (value);  		this.Posted = this.PostedUTC.ToLocalTime ();  		break;  	// Torrent Name  	case 1:  		m = rTorrentName.Match (value);  		this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  		this.gtid = int.Parse (m.Groups [3].Value);  		this.FileName = m.Groups [4].Value;  		break;  	// Gallery  	case 2:  		break;  	// Size  	case 3:  		this.Size = parseSize (value);  		break;  	// Seeds  	case 4:  		this.Seeds = int.Parse (value);  		break;  	// Peers  	case 5:  		this.Peers = int.Parse (value);  		break;  	// DLs  	case 6:  		this.Downloads = int.Parse (value);  		break;  	// Uploader  	case 7:  		this.Uploader = rUploader.Match (value).Groups [1].Value;  		break;  	}  }  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: while (mTd.Success) {  	value = mTd.Groups [1].Value;  	switch (i++) {  	// Added  	case 0:  		this.PostedUTC = DateTime.Parse (value);  		this.Posted = this.PostedUTC.ToLocalTime ();  		break;  	// Torrent Name  	case 1:  		m = rTorrentName.Match (value);  		this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  		this.gtid = int.Parse (m.Groups [3].Value);  		this.FileName = m.Groups [4].Value;  		break;  	// Gallery  	case 2:  		break;  	// Size  	case 3:  		this.Size = parseSize (value);  		break;  	// Seeds  	case 4:  		this.Seeds = int.Parse (value);  		break;  	// Peers  	case 5:  		this.Peers = int.Parse (value);  		break;  	// DLs  	case 6:  		this.Downloads = int.Parse (value);  		break;  	// Uploader  	case 7:  		this.Uploader = rUploader.Match (value).Groups [1].Value;  		break;  	}  }  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: while (mTd.Success) {  	value = mTd.Groups [1].Value;  	switch (i++) {  	// Added  	case 0:  		this.PostedUTC = DateTime.Parse (value);  		this.Posted = this.PostedUTC.ToLocalTime ();  		break;  	// Torrent Name  	case 1:  		m = rTorrentName.Match (value);  		this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  		this.gtid = int.Parse (m.Groups [3].Value);  		this.FileName = m.Groups [4].Value;  		break;  	// Gallery  	case 2:  		break;  	// Size  	case 3:  		this.Size = parseSize (value);  		break;  	// Seeds  	case 4:  		this.Seeds = int.Parse (value);  		break;  	// Peers  	case 5:  		this.Peers = int.Parse (value);  		break;  	// DLs  	case 6:  		this.Downloads = int.Parse (value);  		break;  	// Uploader  	case 7:  		this.Uploader = rUploader.Match (value).Groups [1].Value;  		break;  	}  }  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: while (mTd.Success) {  	value = mTd.Groups [1].Value;  	switch (i++) {  	// Added  	case 0:  		this.PostedUTC = DateTime.Parse (value);  		this.Posted = this.PostedUTC.ToLocalTime ();  		break;  	// Torrent Name  	case 1:  		m = rTorrentName.Match (value);  		this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  		this.gtid = int.Parse (m.Groups [3].Value);  		this.FileName = m.Groups [4].Value;  		break;  	// Gallery  	case 2:  		break;  	// Size  	case 3:  		this.Size = parseSize (value);  		break;  	// Seeds  	case 4:  		this.Seeds = int.Parse (value);  		break;  	// Peers  	case 5:  		this.Peers = int.Parse (value);  		break;  	// DLs  	case 6:  		this.Downloads = int.Parse (value);  		break;  	// Uploader  	case 7:  		this.Uploader = rUploader.Match (value).Groups [1].Value;  		break;  	}  }  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: while (mTd.Success) {  	value = mTd.Groups [1].Value;  	switch (i++) {  	// Added  	case 0:  		this.PostedUTC = DateTime.Parse (value);  		this.Posted = this.PostedUTC.ToLocalTime ();  		break;  	// Torrent Name  	case 1:  		m = rTorrentName.Match (value);  		this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  		this.gtid = int.Parse (m.Groups [3].Value);  		this.FileName = m.Groups [4].Value;  		break;  	// Gallery  	case 2:  		break;  	// Size  	case 3:  		this.Size = parseSize (value);  		break;  	// Seeds  	case 4:  		this.Seeds = int.Parse (value);  		break;  	// Peers  	case 5:  		this.Peers = int.Parse (value);  		break;  	// DLs  	case 6:  		this.Downloads = int.Parse (value);  		break;  	// Uploader  	case 7:  		this.Uploader = rUploader.Match (value).Groups [1].Value;  		break;  	}  }  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: switch (i++) {  // Added  case 0:  	this.PostedUTC = DateTime.Parse (value);  	this.Posted = this.PostedUTC.ToLocalTime ();  	break;  // Torrent Name  case 1:  	m = rTorrentName.Match (value);  	this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  	this.gtid = int.Parse (m.Groups [3].Value);  	this.FileName = m.Groups [4].Value;  	break;  // Gallery  case 2:  	break;  // Size  case 3:  	this.Size = parseSize (value);  	break;  // Seeds  case 4:  	this.Seeds = int.Parse (value);  	break;  // Peers  case 5:  	this.Peers = int.Parse (value);  	break;  // DLs  case 6:  	this.Downloads = int.Parse (value);  	break;  // Uploader  case 7:  	this.Uploader = rUploader.Match (value).Groups [1].Value;  	break;  }  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: switch (i++) {  // Added  case 0:  	this.PostedUTC = DateTime.Parse (value);  	this.Posted = this.PostedUTC.ToLocalTime ();  	break;  // Torrent Name  case 1:  	m = rTorrentName.Match (value);  	this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  	this.gtid = int.Parse (m.Groups [3].Value);  	this.FileName = m.Groups [4].Value;  	break;  // Gallery  case 2:  	break;  // Size  case 3:  	this.Size = parseSize (value);  	break;  // Seeds  case 4:  	this.Seeds = int.Parse (value);  	break;  // Peers  case 5:  	this.Peers = int.Parse (value);  	break;  // DLs  case 6:  	this.Downloads = int.Parse (value);  	break;  // Uploader  case 7:  	this.Uploader = rUploader.Match (value).Groups [1].Value;  	break;  }  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: switch (i++) {  // Added  case 0:  	this.PostedUTC = DateTime.Parse (value);  	this.Posted = this.PostedUTC.ToLocalTime ();  	break;  // Torrent Name  case 1:  	m = rTorrentName.Match (value);  	this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  	this.gtid = int.Parse (m.Groups [3].Value);  	this.FileName = m.Groups [4].Value;  	break;  // Gallery  case 2:  	break;  // Size  case 3:  	this.Size = parseSize (value);  	break;  // Seeds  case 4:  	this.Seeds = int.Parse (value);  	break;  // Peers  case 5:  	this.Peers = int.Parse (value);  	break;  // DLs  case 6:  	this.Downloads = int.Parse (value);  	break;  // Uploader  case 7:  	this.Uploader = rUploader.Match (value).Groups [1].Value;  	break;  }  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: switch (i++) {  // Added  case 0:  	this.PostedUTC = DateTime.Parse (value);  	this.Posted = this.PostedUTC.ToLocalTime ();  	break;  // Torrent Name  case 1:  	m = rTorrentName.Match (value);  	this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  	this.gtid = int.Parse (m.Groups [3].Value);  	this.FileName = m.Groups [4].Value;  	break;  // Gallery  case 2:  	break;  // Size  case 3:  	this.Size = parseSize (value);  	break;  // Seeds  case 4:  	this.Seeds = int.Parse (value);  	break;  // Peers  case 5:  	this.Peers = int.Parse (value);  	break;  // DLs  case 6:  	this.Downloads = int.Parse (value);  	break;  // Uploader  case 7:  	this.Uploader = rUploader.Match (value).Groups [1].Value;  	break;  }  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: switch (i++) {  // Added  case 0:  	this.PostedUTC = DateTime.Parse (value);  	this.Posted = this.PostedUTC.ToLocalTime ();  	break;  // Torrent Name  case 1:  	m = rTorrentName.Match (value);  	this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  	this.gtid = int.Parse (m.Groups [3].Value);  	this.FileName = m.Groups [4].Value;  	break;  // Gallery  case 2:  	break;  // Size  case 3:  	this.Size = parseSize (value);  	break;  // Seeds  case 4:  	this.Seeds = int.Parse (value);  	break;  // Peers  case 5:  	this.Peers = int.Parse (value);  	break;  // DLs  case 6:  	this.Downloads = int.Parse (value);  	break;  // Uploader  case 7:  	this.Uploader = rUploader.Match (value).Groups [1].Value;  	break;  }  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: switch (i++) {  // Added  case 0:  	this.PostedUTC = DateTime.Parse (value);  	this.Posted = this.PostedUTC.ToLocalTime ();  	break;  // Torrent Name  case 1:  	m = rTorrentName.Match (value);  	this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  	this.gtid = int.Parse (m.Groups [3].Value);  	this.FileName = m.Groups [4].Value;  	break;  // Gallery  case 2:  	break;  // Size  case 3:  	this.Size = parseSize (value);  	break;  // Seeds  case 4:  	this.Seeds = int.Parse (value);  	break;  // Peers  case 5:  	this.Peers = int.Parse (value);  	break;  // DLs  case 6:  	this.Downloads = int.Parse (value);  	break;  // Uploader  case 7:  	this.Uploader = rUploader.Match (value).Groups [1].Value;  	break;  }  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: switch (i++) {  // Added  case 0:  	this.PostedUTC = DateTime.Parse (value);  	this.Posted = this.PostedUTC.ToLocalTime ();  	break;  // Torrent Name  case 1:  	m = rTorrentName.Match (value);  	this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  	this.gtid = int.Parse (m.Groups [3].Value);  	this.FileName = m.Groups [4].Value;  	break;  // Gallery  case 2:  	break;  // Size  case 3:  	this.Size = parseSize (value);  	break;  // Seeds  case 4:  	this.Seeds = int.Parse (value);  	break;  // Peers  case 5:  	this.Peers = int.Parse (value);  	break;  // DLs  case 6:  	this.Downloads = int.Parse (value);  	break;  // Uploader  case 7:  	this.Uploader = rUploader.Match (value).Groups [1].Value;  	break;  }  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: switch (i++) {  // Added  case 0:  	this.PostedUTC = DateTime.Parse (value);  	this.Posted = this.PostedUTC.ToLocalTime ();  	break;  // Torrent Name  case 1:  	m = rTorrentName.Match (value);  	this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  	this.gtid = int.Parse (m.Groups [3].Value);  	this.FileName = m.Groups [4].Value;  	break;  // Gallery  case 2:  	break;  // Size  case 3:  	this.Size = parseSize (value);  	break;  // Seeds  case 4:  	this.Seeds = int.Parse (value);  	break;  // Peers  case 5:  	this.Peers = int.Parse (value);  	break;  // DLs  case 6:  	this.Downloads = int.Parse (value);  	break;  // Uploader  case 7:  	this.Uploader = rUploader.Match (value).Groups [1].Value;  	break;  }  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: switch (i++) {  // Added  case 0:  	this.PostedUTC = DateTime.Parse (value);  	this.Posted = this.PostedUTC.ToLocalTime ();  	break;  // Torrent Name  case 1:  	m = rTorrentName.Match (value);  	this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  	this.gtid = int.Parse (m.Groups [3].Value);  	this.FileName = m.Groups [4].Value;  	break;  // Gallery  case 2:  	break;  // Size  case 3:  	this.Size = parseSize (value);  	break;  // Seeds  case 4:  	this.Seeds = int.Parse (value);  	break;  // Peers  case 5:  	this.Peers = int.Parse (value);  	break;  // DLs  case 6:  	this.Downloads = int.Parse (value);  	break;  // Uploader  case 7:  	this.Uploader = rUploader.Match (value).Groups [1].Value;  	break;  }  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: this.gtid = int.Parse (m.Groups [3].Value);  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following statement contains a magic number: this.FileName = m.Groups [4].Value;  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,parseSize,The following statement contains a magic number: if (value.EndsWith ("kb"))  	return i * 1024;  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,parseSize,The following statement contains a magic number: return i * 1024;  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,parseSize,The following statement contains a magic number: if (value.EndsWith ("mb"))  	return i * 1024 * 1024;  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,parseSize,The following statement contains a magic number: if (value.EndsWith ("mb"))  	return i * 1024 * 1024;  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,parseSize,The following statement contains a magic number: return i * 1024 * 1024;  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,parseSize,The following statement contains a magic number: return i * 1024 * 1024;  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,parseSize,The following statement contains a magic number: if (value.EndsWith ("gb"))  	return i * 1024 * 1024 * 1024;  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,parseSize,The following statement contains a magic number: if (value.EndsWith ("gb"))  	return i * 1024 * 1024 * 1024;  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,parseSize,The following statement contains a magic number: if (value.EndsWith ("gb"))  	return i * 1024 * 1024 * 1024;  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,parseSize,The following statement contains a magic number: return i * 1024 * 1024 * 1024;  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,parseSize,The following statement contains a magic number: return i * 1024 * 1024 * 1024;  
Magic Number,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,parseSize,The following statement contains a magic number: return i * 1024 * 1024 * 1024;  
Magic Number,ExHentaiAPI,TorrentInfoCollection,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfoCollection.cs,TorrentInfoCollection,The following statement contains a magic number: if (m.Success) {  	try {  		this.ShowingStart = int.Parse (m.Groups [1].Value);  		this.ShowingEnd = int.Parse (m.Groups [2].Value);  		this.SearchCount = int.Parse (m.Groups [3].Value.Replace ("'"' ""));  	}  	catch {  		this.ShowingStart = this.ShowingEnd = this.SearchCount = 0;  	}  }  
Magic Number,ExHentaiAPI,TorrentInfoCollection,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfoCollection.cs,TorrentInfoCollection,The following statement contains a magic number: if (m.Success) {  	try {  		this.ShowingStart = int.Parse (m.Groups [1].Value);  		this.ShowingEnd = int.Parse (m.Groups [2].Value);  		this.SearchCount = int.Parse (m.Groups [3].Value.Replace ("'"' ""));  	}  	catch {  		this.ShowingStart = this.ShowingEnd = this.SearchCount = 0;  	}  }  
Magic Number,ExHentaiAPI,TorrentInfoCollection,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfoCollection.cs,TorrentInfoCollection,The following statement contains a magic number: try {  	this.ShowingStart = int.Parse (m.Groups [1].Value);  	this.ShowingEnd = int.Parse (m.Groups [2].Value);  	this.SearchCount = int.Parse (m.Groups [3].Value.Replace ("'"' ""));  }  catch {  	this.ShowingStart = this.ShowingEnd = this.SearchCount = 0;  }  
Magic Number,ExHentaiAPI,TorrentInfoCollection,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfoCollection.cs,TorrentInfoCollection,The following statement contains a magic number: try {  	this.ShowingStart = int.Parse (m.Groups [1].Value);  	this.ShowingEnd = int.Parse (m.Groups [2].Value);  	this.SearchCount = int.Parse (m.Groups [3].Value.Replace ("'"' ""));  }  catch {  	this.ShowingStart = this.ShowingEnd = this.SearchCount = 0;  }  
Magic Number,ExHentaiAPI,TorrentInfoCollection,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfoCollection.cs,TorrentInfoCollection,The following statement contains a magic number: this.ShowingEnd = int.Parse (m.Groups [2].Value);  
Magic Number,ExHentaiAPI,TorrentInfoCollection,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfoCollection.cs,TorrentInfoCollection,The following statement contains a magic number: this.SearchCount = int.Parse (m.Groups [3].Value.Replace ("'"' ""));  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: do {  	c = s [i];  	switch (state) {  	#region ReadChar  	case 4:  		switch (c) {  		case '"':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			if (!stack.Peek ().IsArray && key == null) {  				if (sb.Length == 0)  					throw MakeException (s' i' "Key in JSON object cannot be empty string");  				state = 7;  			}  			else {  				stack.Peek ().InternalAdd (key' sb.ToString ());  				key = null;  				sb.Length = 0;  				state = 8;  			}  			continue;  		case '\\':  			if (strLength > 0) {  				sb.Append (s' strStart' strLength);  				strLength = 0;  			}  			strStart = -1;  			state = 5;  			continue;  		default:  			++strLength;  			continue;  		}  	#endregion  	#region WaitingValue  	case 1:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if (c == '"') {  			strStart = i + 1;  			state = 4;  			continue;  		}  		if (c == '{') {  			aftercomma = false;  			var jo = new JsonObject ();  			stack.Peek ().InternalAdd (key' jo);  			stack.Push (jo);  			key = null;  			state = 3;  			continue;  		}  		if (c == '[') {  			aftercomma = false;  			var ja = new JsonArray ();  			stack.Peek ().InternalAdd (key' ja);  			stack.Push (ja);  			key = null;  			continue;  		}  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  			sb.Append (c);  			state = 2;  			continue;  		}  		if (!aftercomma && c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Unknown value expression.");  	#endregion  	#region ReadValue  	case 2:  		if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  			continue;  		if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  			sb.Append (c);  			continue;  		}  		if (c == ''') {  			aftercomma = true;  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			key = null;  			sb.Length = 0;  			if (stack.Peek ().IsArray) {  				state = 1;  				continue;  			}  			else {  				state = 3;  				continue;  			}  		}  		if (c == ']') {  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		if (c == '}') {  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  			stack.Pop ();  			key = null;  			sb.Length = 0;  			if (stack.Count > 0) {  				state = 8;  				continue;  			}  			state = 9;  			continue;  		}  		throw MakeException (s' i' "Invalid character in non-string value");  	#endregion  	#region WaitBeginString  	case 3:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '"':  			strStart = i + 1;  			state = 4;  			continue;  		case '}':  			if (aftercomma)  				goto default;  			stack.Pop ();  			//waitbeginstring can only be entered by '{'' therefore pop must be valid  			if (stack.Count == 0)  				state = 9;  			else  				state = 8;  			continue;  		default:  			throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  		}  	#endregion  	#region ReadEscapedChar  	case 5:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '\\':  			sb.Append ('\\');  			strStart = i + 1;  			state = 4;  			continue;  		case '/':  			sb.Append ('/');  			strStart = i + 1;  			state = 4;  			continue;  		case '"':  			sb.Append ('"');  			strStart = i + 1;  			state = 4;  			continue;  		case 'n':  			sb.Append ('\n');  			strStart = i + 1;  			state = 4;  			continue;  		case 'r':  			sb.Append ('\r');  			strStart = i + 1;  			state = 4;  			continue;  		case 't':  			sb.Append ('\t');  			strStart = i + 1;  			state = 4;  			continue;  		case 'u':  			if (i + 4 >= length)  				throw new FormatException ("Incomplete JSON string");  			hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  			sb.Append ((char)hexvalue);  			i += 4;  			strStart = i + 1;  			state = 4;  			continue;  		default:  			throw MakeException (s' i' "Unknown escaped character");  		}  	#endregion  	#region WaitColon  	case 7:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ':':  			key = sb.ToString ();  			sb.Length = 0;  			state = 1;  			continue;  		default:  			throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  		}  	#endregion  	#region WaitClose  	case 8:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case ''':  			aftercomma = true;  			state = 1;  			continue;  		case ']':  			if (!stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid ']' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		case '}':  			if (stack.Peek ().IsArray)  				throw MakeException (s' i' "Invalid '}' character");  			stack.Pop ();  			if (stack.Count == 0)  				state = 9;  			continue;  		default:  			throw MakeException (s' i' "Expect comma or close bracket after value");  		}  	#endregion  	#region Start  	case 0:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		case '[':  			var ja = new JsonArray ();  			root = ja;  			stack.Push (ja);  			state = 1;  			continue;  		case '{':  			var jo = new JsonObject ();  			root = jo;  			stack.Push (jo);  			state = 3;  			continue;  		default:  			throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  		}  	#endregion  	#region End  	case 9:  		switch (c) {  		case ' ':  		case '\n':  		case '\r':  		case '\t':  			continue;  		default:  			throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  		}  	#endregion  	}  }  while (++i < length);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (state) {  #region ReadChar  case 4:  	switch (c) {  	case '"':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		if (!stack.Peek ().IsArray && key == null) {  			if (sb.Length == 0)  				throw MakeException (s' i' "Key in JSON object cannot be empty string");  			state = 7;  		}  		else {  			stack.Peek ().InternalAdd (key' sb.ToString ());  			key = null;  			sb.Length = 0;  			state = 8;  		}  		continue;  	case '\\':  		if (strLength > 0) {  			sb.Append (s' strStart' strLength);  			strLength = 0;  		}  		strStart = -1;  		state = 5;  		continue;  	default:  		++strLength;  		continue;  	}  #endregion  #region WaitingValue  case 1:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if (c == '"') {  		strStart = i + 1;  		state = 4;  		continue;  	}  	if (c == '{') {  		aftercomma = false;  		var jo = new JsonObject ();  		stack.Peek ().InternalAdd (key' jo);  		stack.Push (jo);  		key = null;  		state = 3;  		continue;  	}  	if (c == '[') {  		aftercomma = false;  		var ja = new JsonArray ();  		stack.Peek ().InternalAdd (key' ja);  		stack.Push (ja);  		key = null;  		continue;  	}  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  		sb.Append (c);  		state = 2;  		continue;  	}  	if (!aftercomma && c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Unknown value expression.");  #endregion  #region ReadValue  case 2:  	if (c == ' ' || c == '\n' || c == '\r' || c == '\t')  		continue;  	if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '.' || c == '+') {  		sb.Append (c);  		continue;  	}  	if (c == ''') {  		aftercomma = true;  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		key = null;  		sb.Length = 0;  		if (stack.Peek ().IsArray) {  			state = 1;  			continue;  		}  		else {  			state = 3;  			continue;  		}  	}  	if (c == ']') {  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	if (c == '}') {  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  		stack.Pop ();  		key = null;  		sb.Length = 0;  		if (stack.Count > 0) {  			state = 8;  			continue;  		}  		state = 9;  		continue;  	}  	throw MakeException (s' i' "Invalid character in non-string value");  #endregion  #region WaitBeginString  case 3:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '"':  		strStart = i + 1;  		state = 4;  		continue;  	case '}':  		if (aftercomma)  			goto default;  		stack.Pop ();  		//waitbeginstring can only be entered by '{'' therefore pop must be valid  		if (stack.Count == 0)  			state = 9;  		else  			state = 8;  		continue;  	default:  		throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  	}  #endregion  #region ReadEscapedChar  case 5:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '\\':  		sb.Append ('\\');  		strStart = i + 1;  		state = 4;  		continue;  	case '/':  		sb.Append ('/');  		strStart = i + 1;  		state = 4;  		continue;  	case '"':  		sb.Append ('"');  		strStart = i + 1;  		state = 4;  		continue;  	case 'n':  		sb.Append ('\n');  		strStart = i + 1;  		state = 4;  		continue;  	case 'r':  		sb.Append ('\r');  		strStart = i + 1;  		state = 4;  		continue;  	case 't':  		sb.Append ('\t');  		strStart = i + 1;  		state = 4;  		continue;  	case 'u':  		if (i + 4 >= length)  			throw new FormatException ("Incomplete JSON string");  		hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  		sb.Append ((char)hexvalue);  		i += 4;  		strStart = i + 1;  		state = 4;  		continue;  	default:  		throw MakeException (s' i' "Unknown escaped character");  	}  #endregion  #region WaitColon  case 7:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ':':  		key = sb.ToString ();  		sb.Length = 0;  		state = 1;  		continue;  	default:  		throw MakeException (s' i' "Expected colon(:) to seperate key and values in JSON object");  	}  #endregion  #region WaitClose  case 8:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case ''':  		aftercomma = true;  		state = 1;  		continue;  	case ']':  		if (!stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid ']' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	case '}':  		if (stack.Peek ().IsArray)  			throw MakeException (s' i' "Invalid '}' character");  		stack.Pop ();  		if (stack.Count == 0)  			state = 9;  		continue;  	default:  		throw MakeException (s' i' "Expect comma or close bracket after value");  	}  #endregion  #region Start  case 0:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	case '[':  		var ja = new JsonArray ();  		root = ja;  		stack.Push (ja);  		state = 1;  		continue;  	case '{':  		var jo = new JsonObject ();  		root = jo;  		stack.Push (jo);  		state = 3;  		continue;  	default:  		throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  	}  #endregion  #region End  case 9:  	switch (c) {  	case ' ':  	case '\n':  	case '\r':  	case '\t':  		continue;  	default:  		throw MakeException (s' i' "Unexpected character(s) after termination of JSON string");  	}  #endregion  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case '"':  	if (strLength > 0) {  		sb.Append (s' strStart' strLength);  		strLength = 0;  	}  	strStart = -1;  	if (!stack.Peek ().IsArray && key == null) {  		if (sb.Length == 0)  			throw MakeException (s' i' "Key in JSON object cannot be empty string");  		state = 7;  	}  	else {  		stack.Peek ().InternalAdd (key' sb.ToString ());  		key = null;  		sb.Length = 0;  		state = 8;  	}  	continue;  case '\\':  	if (strLength > 0) {  		sb.Append (s' strStart' strLength);  		strLength = 0;  	}  	strStart = -1;  	state = 5;  	continue;  default:  	++strLength;  	continue;  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case '"':  	if (strLength > 0) {  		sb.Append (s' strStart' strLength);  		strLength = 0;  	}  	strStart = -1;  	if (!stack.Peek ().IsArray && key == null) {  		if (sb.Length == 0)  			throw MakeException (s' i' "Key in JSON object cannot be empty string");  		state = 7;  	}  	else {  		stack.Peek ().InternalAdd (key' sb.ToString ());  		key = null;  		sb.Length = 0;  		state = 8;  	}  	continue;  case '\\':  	if (strLength > 0) {  		sb.Append (s' strStart' strLength);  		strLength = 0;  	}  	strStart = -1;  	state = 5;  	continue;  default:  	++strLength;  	continue;  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case '"':  	if (strLength > 0) {  		sb.Append (s' strStart' strLength);  		strLength = 0;  	}  	strStart = -1;  	if (!stack.Peek ().IsArray && key == null) {  		if (sb.Length == 0)  			throw MakeException (s' i' "Key in JSON object cannot be empty string");  		state = 7;  	}  	else {  		stack.Peek ().InternalAdd (key' sb.ToString ());  		key = null;  		sb.Length = 0;  		state = 8;  	}  	continue;  case '\\':  	if (strLength > 0) {  		sb.Append (s' strStart' strLength);  		strLength = 0;  	}  	strStart = -1;  	state = 5;  	continue;  default:  	++strLength;  	continue;  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (!stack.Peek ().IsArray && key == null) {  	if (sb.Length == 0)  		throw MakeException (s' i' "Key in JSON object cannot be empty string");  	state = 7;  }  else {  	stack.Peek ().InternalAdd (key' sb.ToString ());  	key = null;  	sb.Length = 0;  	state = 8;  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (!stack.Peek ().IsArray && key == null) {  	if (sb.Length == 0)  		throw MakeException (s' i' "Key in JSON object cannot be empty string");  	state = 7;  }  else {  	stack.Peek ().InternalAdd (key' sb.ToString ());  	key = null;  	sb.Length = 0;  	state = 8;  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 7;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 8;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 5;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (c == '"') {  	strStart = i + 1;  	state = 4;  	continue;  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 4;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (c == '{') {  	aftercomma = false;  	var jo = new JsonObject ();  	stack.Peek ().InternalAdd (key' jo);  	stack.Push (jo);  	key = null;  	state = 3;  	continue;  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 3;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '-') {  	sb.Append (c);  	state = 2;  	continue;  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 2;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (!aftercomma && c == ']') {  	if (!stack.Peek ().IsArray)  		throw MakeException (s' i' "Invalid ']' character");  	stack.Pop ();  	if (stack.Count > 0) {  		state = 8;  		continue;  	}  	state = 9;  	continue;  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (!aftercomma && c == ']') {  	if (!stack.Peek ().IsArray)  		throw MakeException (s' i' "Invalid ']' character");  	stack.Pop ();  	if (stack.Count > 0) {  		state = 8;  		continue;  	}  	state = 9;  	continue;  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (stack.Count > 0) {  	state = 8;  	continue;  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 8;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 9;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (c == ''') {  	aftercomma = true;  	stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  	key = null;  	sb.Length = 0;  	if (stack.Peek ().IsArray) {  		state = 1;  		continue;  	}  	else {  		state = 3;  		continue;  	}  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (stack.Peek ().IsArray) {  	state = 1;  	continue;  }  else {  	state = 3;  	continue;  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 3;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (c == ']') {  	if (!stack.Peek ().IsArray)  		throw MakeException (s' i' "Invalid ']' character");  	stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  	stack.Pop ();  	sb.Length = 0;  	if (stack.Count > 0) {  		state = 8;  		continue;  	}  	state = 9;  	continue;  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (c == ']') {  	if (!stack.Peek ().IsArray)  		throw MakeException (s' i' "Invalid ']' character");  	stack.Peek ().InternalAdd (null' ParseJsonValue (sb.ToString ()));  	stack.Pop ();  	sb.Length = 0;  	if (stack.Count > 0) {  		state = 8;  		continue;  	}  	state = 9;  	continue;  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (stack.Count > 0) {  	state = 8;  	continue;  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 8;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 9;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (c == '}') {  	if (stack.Peek ().IsArray)  		throw MakeException (s' i' "Invalid '}' character");  	stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  	stack.Pop ();  	key = null;  	sb.Length = 0;  	if (stack.Count > 0) {  		state = 8;  		continue;  	}  	state = 9;  	continue;  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (c == '}') {  	if (stack.Peek ().IsArray)  		throw MakeException (s' i' "Invalid '}' character");  	stack.Peek ().InternalAdd (key' ParseJsonValue (sb.ToString ()));  	stack.Pop ();  	key = null;  	sb.Length = 0;  	if (stack.Count > 0) {  		state = 8;  		continue;  	}  	state = 9;  	continue;  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (stack.Count > 0) {  	state = 8;  	continue;  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 8;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 9;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case '"':  	strStart = i + 1;  	state = 4;  	continue;  case '}':  	if (aftercomma)  		goto default;  	stack.Pop ();  	//waitbeginstring can only be entered by '{'' therefore pop must be valid  	if (stack.Count == 0)  		state = 9;  	else  		state = 8;  	continue;  default:  	throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case '"':  	strStart = i + 1;  	state = 4;  	continue;  case '}':  	if (aftercomma)  		goto default;  	stack.Pop ();  	//waitbeginstring can only be entered by '{'' therefore pop must be valid  	if (stack.Count == 0)  		state = 9;  	else  		state = 8;  	continue;  default:  	throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case '"':  	strStart = i + 1;  	state = 4;  	continue;  case '}':  	if (aftercomma)  		goto default;  	stack.Pop ();  	//waitbeginstring can only be entered by '{'' therefore pop must be valid  	if (stack.Count == 0)  		state = 9;  	else  		state = 8;  	continue;  default:  	throw MakeException (s' i' "Expected double quotation character to mark beginning of string");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 4;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (stack.Count == 0)  	state = 9;  else  	state = 8;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (stack.Count == 0)  	state = 9;  else  	state = 8;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 9;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 8;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case '\\':  	sb.Append ('\\');  	strStart = i + 1;  	state = 4;  	continue;  case '/':  	sb.Append ('/');  	strStart = i + 1;  	state = 4;  	continue;  case '"':  	sb.Append ('"');  	strStart = i + 1;  	state = 4;  	continue;  case 'n':  	sb.Append ('\n');  	strStart = i + 1;  	state = 4;  	continue;  case 'r':  	sb.Append ('\r');  	strStart = i + 1;  	state = 4;  	continue;  case 't':  	sb.Append ('\t');  	strStart = i + 1;  	state = 4;  	continue;  case 'u':  	if (i + 4 >= length)  		throw new FormatException ("Incomplete JSON string");  	hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  	sb.Append ((char)hexvalue);  	i += 4;  	strStart = i + 1;  	state = 4;  	continue;  default:  	throw MakeException (s' i' "Unknown escaped character");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case '\\':  	sb.Append ('\\');  	strStart = i + 1;  	state = 4;  	continue;  case '/':  	sb.Append ('/');  	strStart = i + 1;  	state = 4;  	continue;  case '"':  	sb.Append ('"');  	strStart = i + 1;  	state = 4;  	continue;  case 'n':  	sb.Append ('\n');  	strStart = i + 1;  	state = 4;  	continue;  case 'r':  	sb.Append ('\r');  	strStart = i + 1;  	state = 4;  	continue;  case 't':  	sb.Append ('\t');  	strStart = i + 1;  	state = 4;  	continue;  case 'u':  	if (i + 4 >= length)  		throw new FormatException ("Incomplete JSON string");  	hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  	sb.Append ((char)hexvalue);  	i += 4;  	strStart = i + 1;  	state = 4;  	continue;  default:  	throw MakeException (s' i' "Unknown escaped character");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case '\\':  	sb.Append ('\\');  	strStart = i + 1;  	state = 4;  	continue;  case '/':  	sb.Append ('/');  	strStart = i + 1;  	state = 4;  	continue;  case '"':  	sb.Append ('"');  	strStart = i + 1;  	state = 4;  	continue;  case 'n':  	sb.Append ('\n');  	strStart = i + 1;  	state = 4;  	continue;  case 'r':  	sb.Append ('\r');  	strStart = i + 1;  	state = 4;  	continue;  case 't':  	sb.Append ('\t');  	strStart = i + 1;  	state = 4;  	continue;  case 'u':  	if (i + 4 >= length)  		throw new FormatException ("Incomplete JSON string");  	hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  	sb.Append ((char)hexvalue);  	i += 4;  	strStart = i + 1;  	state = 4;  	continue;  default:  	throw MakeException (s' i' "Unknown escaped character");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case '\\':  	sb.Append ('\\');  	strStart = i + 1;  	state = 4;  	continue;  case '/':  	sb.Append ('/');  	strStart = i + 1;  	state = 4;  	continue;  case '"':  	sb.Append ('"');  	strStart = i + 1;  	state = 4;  	continue;  case 'n':  	sb.Append ('\n');  	strStart = i + 1;  	state = 4;  	continue;  case 'r':  	sb.Append ('\r');  	strStart = i + 1;  	state = 4;  	continue;  case 't':  	sb.Append ('\t');  	strStart = i + 1;  	state = 4;  	continue;  case 'u':  	if (i + 4 >= length)  		throw new FormatException ("Incomplete JSON string");  	hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  	sb.Append ((char)hexvalue);  	i += 4;  	strStart = i + 1;  	state = 4;  	continue;  default:  	throw MakeException (s' i' "Unknown escaped character");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case '\\':  	sb.Append ('\\');  	strStart = i + 1;  	state = 4;  	continue;  case '/':  	sb.Append ('/');  	strStart = i + 1;  	state = 4;  	continue;  case '"':  	sb.Append ('"');  	strStart = i + 1;  	state = 4;  	continue;  case 'n':  	sb.Append ('\n');  	strStart = i + 1;  	state = 4;  	continue;  case 'r':  	sb.Append ('\r');  	strStart = i + 1;  	state = 4;  	continue;  case 't':  	sb.Append ('\t');  	strStart = i + 1;  	state = 4;  	continue;  case 'u':  	if (i + 4 >= length)  		throw new FormatException ("Incomplete JSON string");  	hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  	sb.Append ((char)hexvalue);  	i += 4;  	strStart = i + 1;  	state = 4;  	continue;  default:  	throw MakeException (s' i' "Unknown escaped character");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case '\\':  	sb.Append ('\\');  	strStart = i + 1;  	state = 4;  	continue;  case '/':  	sb.Append ('/');  	strStart = i + 1;  	state = 4;  	continue;  case '"':  	sb.Append ('"');  	strStart = i + 1;  	state = 4;  	continue;  case 'n':  	sb.Append ('\n');  	strStart = i + 1;  	state = 4;  	continue;  case 'r':  	sb.Append ('\r');  	strStart = i + 1;  	state = 4;  	continue;  case 't':  	sb.Append ('\t');  	strStart = i + 1;  	state = 4;  	continue;  case 'u':  	if (i + 4 >= length)  		throw new FormatException ("Incomplete JSON string");  	hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  	sb.Append ((char)hexvalue);  	i += 4;  	strStart = i + 1;  	state = 4;  	continue;  default:  	throw MakeException (s' i' "Unknown escaped character");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case '\\':  	sb.Append ('\\');  	strStart = i + 1;  	state = 4;  	continue;  case '/':  	sb.Append ('/');  	strStart = i + 1;  	state = 4;  	continue;  case '"':  	sb.Append ('"');  	strStart = i + 1;  	state = 4;  	continue;  case 'n':  	sb.Append ('\n');  	strStart = i + 1;  	state = 4;  	continue;  case 'r':  	sb.Append ('\r');  	strStart = i + 1;  	state = 4;  	continue;  case 't':  	sb.Append ('\t');  	strStart = i + 1;  	state = 4;  	continue;  case 'u':  	if (i + 4 >= length)  		throw new FormatException ("Incomplete JSON string");  	hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  	sb.Append ((char)hexvalue);  	i += 4;  	strStart = i + 1;  	state = 4;  	continue;  default:  	throw MakeException (s' i' "Unknown escaped character");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case '\\':  	sb.Append ('\\');  	strStart = i + 1;  	state = 4;  	continue;  case '/':  	sb.Append ('/');  	strStart = i + 1;  	state = 4;  	continue;  case '"':  	sb.Append ('"');  	strStart = i + 1;  	state = 4;  	continue;  case 'n':  	sb.Append ('\n');  	strStart = i + 1;  	state = 4;  	continue;  case 'r':  	sb.Append ('\r');  	strStart = i + 1;  	state = 4;  	continue;  case 't':  	sb.Append ('\t');  	strStart = i + 1;  	state = 4;  	continue;  case 'u':  	if (i + 4 >= length)  		throw new FormatException ("Incomplete JSON string");  	hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  	sb.Append ((char)hexvalue);  	i += 4;  	strStart = i + 1;  	state = 4;  	continue;  default:  	throw MakeException (s' i' "Unknown escaped character");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case '\\':  	sb.Append ('\\');  	strStart = i + 1;  	state = 4;  	continue;  case '/':  	sb.Append ('/');  	strStart = i + 1;  	state = 4;  	continue;  case '"':  	sb.Append ('"');  	strStart = i + 1;  	state = 4;  	continue;  case 'n':  	sb.Append ('\n');  	strStart = i + 1;  	state = 4;  	continue;  case 'r':  	sb.Append ('\r');  	strStart = i + 1;  	state = 4;  	continue;  case 't':  	sb.Append ('\t');  	strStart = i + 1;  	state = 4;  	continue;  case 'u':  	if (i + 4 >= length)  		throw new FormatException ("Incomplete JSON string");  	hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  	sb.Append ((char)hexvalue);  	i += 4;  	strStart = i + 1;  	state = 4;  	continue;  default:  	throw MakeException (s' i' "Unknown escaped character");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case '\\':  	sb.Append ('\\');  	strStart = i + 1;  	state = 4;  	continue;  case '/':  	sb.Append ('/');  	strStart = i + 1;  	state = 4;  	continue;  case '"':  	sb.Append ('"');  	strStart = i + 1;  	state = 4;  	continue;  case 'n':  	sb.Append ('\n');  	strStart = i + 1;  	state = 4;  	continue;  case 'r':  	sb.Append ('\r');  	strStart = i + 1;  	state = 4;  	continue;  case 't':  	sb.Append ('\t');  	strStart = i + 1;  	state = 4;  	continue;  case 'u':  	if (i + 4 >= length)  		throw new FormatException ("Incomplete JSON string");  	hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  	sb.Append ((char)hexvalue);  	i += 4;  	strStart = i + 1;  	state = 4;  	continue;  default:  	throw MakeException (s' i' "Unknown escaped character");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case '\\':  	sb.Append ('\\');  	strStart = i + 1;  	state = 4;  	continue;  case '/':  	sb.Append ('/');  	strStart = i + 1;  	state = 4;  	continue;  case '"':  	sb.Append ('"');  	strStart = i + 1;  	state = 4;  	continue;  case 'n':  	sb.Append ('\n');  	strStart = i + 1;  	state = 4;  	continue;  case 'r':  	sb.Append ('\r');  	strStart = i + 1;  	state = 4;  	continue;  case 't':  	sb.Append ('\t');  	strStart = i + 1;  	state = 4;  	continue;  case 'u':  	if (i + 4 >= length)  		throw new FormatException ("Incomplete JSON string");  	hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  	sb.Append ((char)hexvalue);  	i += 4;  	strStart = i + 1;  	state = 4;  	continue;  default:  	throw MakeException (s' i' "Unknown escaped character");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case '\\':  	sb.Append ('\\');  	strStart = i + 1;  	state = 4;  	continue;  case '/':  	sb.Append ('/');  	strStart = i + 1;  	state = 4;  	continue;  case '"':  	sb.Append ('"');  	strStart = i + 1;  	state = 4;  	continue;  case 'n':  	sb.Append ('\n');  	strStart = i + 1;  	state = 4;  	continue;  case 'r':  	sb.Append ('\r');  	strStart = i + 1;  	state = 4;  	continue;  case 't':  	sb.Append ('\t');  	strStart = i + 1;  	state = 4;  	continue;  case 'u':  	if (i + 4 >= length)  		throw new FormatException ("Incomplete JSON string");  	hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  	sb.Append ((char)hexvalue);  	i += 4;  	strStart = i + 1;  	state = 4;  	continue;  default:  	throw MakeException (s' i' "Unknown escaped character");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case '\\':  	sb.Append ('\\');  	strStart = i + 1;  	state = 4;  	continue;  case '/':  	sb.Append ('/');  	strStart = i + 1;  	state = 4;  	continue;  case '"':  	sb.Append ('"');  	strStart = i + 1;  	state = 4;  	continue;  case 'n':  	sb.Append ('\n');  	strStart = i + 1;  	state = 4;  	continue;  case 'r':  	sb.Append ('\r');  	strStart = i + 1;  	state = 4;  	continue;  case 't':  	sb.Append ('\t');  	strStart = i + 1;  	state = 4;  	continue;  case 'u':  	if (i + 4 >= length)  		throw new FormatException ("Incomplete JSON string");  	hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  	sb.Append ((char)hexvalue);  	i += 4;  	strStart = i + 1;  	state = 4;  	continue;  default:  	throw MakeException (s' i' "Unknown escaped character");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case '\\':  	sb.Append ('\\');  	strStart = i + 1;  	state = 4;  	continue;  case '/':  	sb.Append ('/');  	strStart = i + 1;  	state = 4;  	continue;  case '"':  	sb.Append ('"');  	strStart = i + 1;  	state = 4;  	continue;  case 'n':  	sb.Append ('\n');  	strStart = i + 1;  	state = 4;  	continue;  case 'r':  	sb.Append ('\r');  	strStart = i + 1;  	state = 4;  	continue;  case 't':  	sb.Append ('\t');  	strStart = i + 1;  	state = 4;  	continue;  case 'u':  	if (i + 4 >= length)  		throw new FormatException ("Incomplete JSON string");  	hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  	sb.Append ((char)hexvalue);  	i += 4;  	strStart = i + 1;  	state = 4;  	continue;  default:  	throw MakeException (s' i' "Unknown escaped character");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case '\\':  	sb.Append ('\\');  	strStart = i + 1;  	state = 4;  	continue;  case '/':  	sb.Append ('/');  	strStart = i + 1;  	state = 4;  	continue;  case '"':  	sb.Append ('"');  	strStart = i + 1;  	state = 4;  	continue;  case 'n':  	sb.Append ('\n');  	strStart = i + 1;  	state = 4;  	continue;  case 'r':  	sb.Append ('\r');  	strStart = i + 1;  	state = 4;  	continue;  case 't':  	sb.Append ('\t');  	strStart = i + 1;  	state = 4;  	continue;  case 'u':  	if (i + 4 >= length)  		throw new FormatException ("Incomplete JSON string");  	hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  	sb.Append ((char)hexvalue);  	i += 4;  	strStart = i + 1;  	state = 4;  	continue;  default:  	throw MakeException (s' i' "Unknown escaped character");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 4;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 4;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 4;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 4;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 4;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 4;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (i + 4 >= length)  	throw new FormatException ("Incomplete JSON string");  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: hexvalue = (CharToHex (s [i + 1]) << 12) | (CharToHex (s [i + 2]) << 8) | (CharToHex (s [i + 3]) << 4) | CharToHex (s [i + 4]);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: i += 4;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 4;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case ''':  	aftercomma = true;  	state = 1;  	continue;  case ']':  	if (!stack.Peek ().IsArray)  		throw MakeException (s' i' "Invalid ']' character");  	stack.Pop ();  	if (stack.Count == 0)  		state = 9;  	continue;  case '}':  	if (stack.Peek ().IsArray)  		throw MakeException (s' i' "Invalid '}' character");  	stack.Pop ();  	if (stack.Count == 0)  		state = 9;  	continue;  default:  	throw MakeException (s' i' "Expect comma or close bracket after value");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case ''':  	aftercomma = true;  	state = 1;  	continue;  case ']':  	if (!stack.Peek ().IsArray)  		throw MakeException (s' i' "Invalid ']' character");  	stack.Pop ();  	if (stack.Count == 0)  		state = 9;  	continue;  case '}':  	if (stack.Peek ().IsArray)  		throw MakeException (s' i' "Invalid '}' character");  	stack.Pop ();  	if (stack.Count == 0)  		state = 9;  	continue;  default:  	throw MakeException (s' i' "Expect comma or close bracket after value");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (stack.Count == 0)  	state = 9;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 9;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (stack.Count == 0)  	state = 9;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 9;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: switch (c) {  case ' ':  case '\n':  case '\r':  case '\t':  	continue;  case '[':  	var ja = new JsonArray ();  	root = ja;  	stack.Push (ja);  	state = 1;  	continue;  case '{':  	var jo = new JsonObject ();  	root = jo;  	stack.Push (jo);  	state = 3;  	continue;  default:  	throw MakeException (s' i' "Expect '{' or '[' to begin JSON string");  }  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: state = 3;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,Parse,The following statement contains a magic number: if (state != 9)  	throw new FormatException ("Incomplete JSON string");  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,CharToHex,The following statement contains a magic number: if (c >= 'a' && c <= 'f')  	return (uint)(c - 'a' + 10);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,CharToHex,The following statement contains a magic number: return (uint)(c - 'a' + 10);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,CharToHex,The following statement contains a magic number: if (c >= 'A' && c <= 'F')  	return (uint)(c - 'A' + 10);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,CharToHex,The following statement contains a magic number: return (uint)(c - 'A' + 10);  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,MakeException,The following statement contains a magic number: if (length > 5)  	length = 5;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,MakeException,The following statement contains a magic number: if (length > 5)  	length = 5;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,MakeException,The following statement contains a magic number: length = 5;  
Magic Number,ComputerBeacon.Json,Parser,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Library\JsonToolKit 4.1.736.cs,MakeException,The following statement contains a magic number: length += 5;  
Missing Default,ExHentaiAPI,Helper,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\Helper.cs,ToCategories,The following switch statement is missing a default case: switch (categoryString) {  case "Doujinshi":  	return Categories.Doujinshi;  case "Manga":  	return Categories.Manga;  case "Artist CG Sets":  	return Categories.ArtistCG;  case "Game CG Sets":  	return Categories.GameCG;  case "Western":  	return Categories.Western;  case "Image Sets":  	return Categories.ImageSets;  case "Non-H":  	return Categories.NonH;  case "Cosplay":  	return Categories.Cosplay;  case "Asian Porn":  	return Categories.AsianPorn;  case "Misc":  	return Categories.Misc;  case "Private":  	return Categories.Private;  }  
Missing Default,ExHentaiAPI,TorrentInfo,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentInfo.cs,TorrentInfo,The following switch statement is missing a default case: switch (i++) {  // Added  case 0:  	this.PostedUTC = DateTime.Parse (value);  	this.Posted = this.PostedUTC.ToLocalTime ();  	break;  // Torrent Name  case 1:  	m = rTorrentName.Match (value);  	this.Token = new GalleryToken (int.Parse (m.Groups [1].Value)' m.Groups [2].Value);  	this.gtid = int.Parse (m.Groups [3].Value);  	this.FileName = m.Groups [4].Value;  	break;  // Gallery  case 2:  	break;  // Size  case 3:  	this.Size = parseSize (value);  	break;  // Seeds  case 4:  	this.Seeds = int.Parse (value);  	break;  // Peers  case 5:  	this.Peers = int.Parse (value);  	break;  // DLs  case 6:  	this.Downloads = int.Parse (value);  	break;  // Uploader  case 7:  	this.Uploader = rUploader.Match (value).Groups [1].Value;  	break;  }  
Missing Default,ExHentaiAPI,TorrentSearchOption,C:\repos\RyuaNerin_ExHentaiAPI\EHentaiAPI\TorrentSearchOption.cs,GetUrl,The following switch statement is missing a default case: switch (this.OrderType.Value) {  case OrderTypes.Added:  	sb.Append ("a");  	break;  case OrderTypes.Size:  	sb.Append ("z");  	break;  case OrderTypes.Seeds:  	sb.Append ("s");  	break;  case OrderTypes.Peers:  	sb.Append ("d");  	break;  case OrderTypes.Downloads:  	sb.Append ("c");  	break;  }  
