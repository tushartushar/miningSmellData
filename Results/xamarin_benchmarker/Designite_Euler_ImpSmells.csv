Implementation smell,Namespace,Class,File,Method,Description
Long Method,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The method has 102 lines of code.
Long Method,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The method has 71 lines of code.
Long Method,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The method has 61 lines of code.
Long Method,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The method has 156 lines of code.
Long Method,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The method has 159 lines of code.
Complex Method,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,Cyclomatic complexity of the method is 16
Complex Method,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,Cyclomatic complexity of the method is 13
Complex Method,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,Cyclomatic complexity of the method is 13
Complex Method,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,Cyclomatic complexity of the method is 10
Complex Method,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,Cyclomatic complexity of the method is 9
Long Statement,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The length of the statement  "				newval [k' i' j] = (1.0 - xf) * (1.0 - yf) * oldval [k' iold' jold] + (1.0 - xf) * yf * oldval [k' iold' jold + 1] + xf * (1.0 - yf) * oldval [k' iold + 1' jold] + xf * yf * oldval [k' iold + 1' jold + 1]; " is 205.
Long Statement,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The length of the statement  "			a [i' j] = 0.5 * ((xnode [i' j] - xnode [i - 1' j - 1]) * (ynode [i - 1' j] - ynode [i' j - 1]) - (ynode [i' j] - ynode [i - 1' j - 1]) * (xnode [i - 1' j] - xnode [i' j - 1])); " is 177.
Long Statement,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateStateVar,The length of the statement  "			localtg [i' j] = localug [i' j].d / localug [i' j].a - 0.5 * (temp * temp + temp2 * temp2) / (localug [i' j].a * localug [i' j].a); " is 131.
Long Statement,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The length of the statement  "			deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi))); " is 209.
Long Statement,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The length of the statement  "		/* Bottom wall boundary cells *//* Routine checked by brute force for initial conditions' 4/9; 4:30 *//* Routine checked by brute force for random conditions' 4/13' 4:40 pm *//* Construct tangent vectors */tan.ihat = xnode [i' 0] - xnode [i - 1' 0]; " is 249.
Long Statement,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The length of the statement  "		/* Top Wall Boundary Cells *//* Checked numerically for default conditions' 4/9 at 5:30 pm *//* Construct normal and tangent vectors *//* This part checked and works; it produces the correct vectors */tan.ihat = xnode [i' jmax - 1] - xnode [i - 1' jmax - 1]; " is 258.
Long Statement,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The length of the statement  "		/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j]; " is 141.
Long Statement,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The length of the statement  "		theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j]))); " is 210.
Long Statement,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The length of the statement  "		/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1]; " is 125.
Long Statement,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The length of the statement  "			/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a; " is 171.
Long Statement,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The length of the statement  "	/* Do something with corners to avoid division by zero errors *//* What you do shouldn't matter */localug [0' 0] = localug [1' 0]; " is 130.
Magic Number,Euler,Euler,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,validate,The following statement contains a magic number: if (dev > 1.0e-12) {  	Console.WriteLine ("Validation failed");  	Console.WriteLine ("Computed RMS pressure error = " + error);  	Console.WriteLine ("Reference value = " + refval [size]);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: spt [2] = '\t';  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: spt [3] = '\r';  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: deltat = new double[imax + 1' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: opg = new double[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: opg = new double[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: pg = new double[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: pg = new double[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: pg1 = new double[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: pg1 = new double[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: sxi = new double[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: sxi = new double[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: seta = new double[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: seta = new double[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: tg = new double[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: tg = new double[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: tg1 = new double[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: tg1 = new double[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: ug = new Statevector[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: ug = new Statevector[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: d = new Statevector[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: d = new Statevector[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: f = new Statevector[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: f = new Statevector[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: g = new Statevector[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: g = new Statevector[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: r = new Statevector[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: r = new Statevector[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: ug1 = new Statevector[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: ug1 = new Statevector[imax + 2' jmax + 2];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: for (i = 0; i < imax + 2; ++i) {  	for (j = 0; j < jmax + 2; ++j) {  		d [i' j] = new Statevector ();  		f [i' j] = new Statevector ();  		g [i' j] = new Statevector ();  		r [i' j] = new Statevector ();  		ug [i' j] = new Statevector ();  		ug1 [i' j] = new Statevector ();  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: for (i = 0; i < imax + 2; ++i) {  	for (j = 0; j < jmax + 2; ++j) {  		d [i' j] = new Statevector ();  		f [i' j] = new Statevector ();  		g [i' j] = new Statevector ();  		r [i' j] = new Statevector ();  		ug [i' j] = new Statevector ();  		ug1 [i' j] = new Statevector ();  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: for (j = 0; j < jmax + 2; ++j) {  	d [i' j] = new Statevector ();  	f [i' j] = new Statevector ();  	g [i' j] = new Statevector ();  	r [i' j] = new Statevector ();  	ug [i' j] = new Statevector ();  	ug1 [i' j] = new Statevector ();  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: for (i = 0; i < imax; i++) {  	for (j = 0; j < jmax; j++) {  		xnode [i' j] = newval [0' i' j];  		ynode [i' j] = newval [1' i' j];  		ug [i + 1' j + 1].a = newval [2' i' j];  		ug [i + 1' j + 1].b = newval [3' i' j];  		ug [i + 1' j + 1].c = newval [4' i' j];  		ug [i + 1' j + 1].d = newval [5' i' j];  		scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  		scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  		tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  		tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  		pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: for (i = 0; i < imax; i++) {  	for (j = 0; j < jmax; j++) {  		xnode [i' j] = newval [0' i' j];  		ynode [i' j] = newval [1' i' j];  		ug [i + 1' j + 1].a = newval [2' i' j];  		ug [i + 1' j + 1].b = newval [3' i' j];  		ug [i + 1' j + 1].c = newval [4' i' j];  		ug [i + 1' j + 1].d = newval [5' i' j];  		scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  		scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  		tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  		tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  		pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: for (i = 0; i < imax; i++) {  	for (j = 0; j < jmax; j++) {  		xnode [i' j] = newval [0' i' j];  		ynode [i' j] = newval [1' i' j];  		ug [i + 1' j + 1].a = newval [2' i' j];  		ug [i + 1' j + 1].b = newval [3' i' j];  		ug [i + 1' j + 1].c = newval [4' i' j];  		ug [i + 1' j + 1].d = newval [5' i' j];  		scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  		scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  		tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  		tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  		pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: for (i = 0; i < imax; i++) {  	for (j = 0; j < jmax; j++) {  		xnode [i' j] = newval [0' i' j];  		ynode [i' j] = newval [1' i' j];  		ug [i + 1' j + 1].a = newval [2' i' j];  		ug [i + 1' j + 1].b = newval [3' i' j];  		ug [i + 1' j + 1].c = newval [4' i' j];  		ug [i + 1' j + 1].d = newval [5' i' j];  		scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  		scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  		tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  		tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  		pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: for (i = 0; i < imax; i++) {  	for (j = 0; j < jmax; j++) {  		xnode [i' j] = newval [0' i' j];  		ynode [i' j] = newval [1' i' j];  		ug [i + 1' j + 1].a = newval [2' i' j];  		ug [i + 1' j + 1].b = newval [3' i' j];  		ug [i + 1' j + 1].c = newval [4' i' j];  		ug [i + 1' j + 1].d = newval [5' i' j];  		scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  		scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  		tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  		tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  		pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: for (j = 0; j < jmax; j++) {  	xnode [i' j] = newval [0' i' j];  	ynode [i' j] = newval [1' i' j];  	ug [i + 1' j + 1].a = newval [2' i' j];  	ug [i + 1' j + 1].b = newval [3' i' j];  	ug [i + 1' j + 1].c = newval [4' i' j];  	ug [i + 1' j + 1].d = newval [5' i' j];  	scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  	scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  	tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  	tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  	pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: for (j = 0; j < jmax; j++) {  	xnode [i' j] = newval [0' i' j];  	ynode [i' j] = newval [1' i' j];  	ug [i + 1' j + 1].a = newval [2' i' j];  	ug [i + 1' j + 1].b = newval [3' i' j];  	ug [i + 1' j + 1].c = newval [4' i' j];  	ug [i + 1' j + 1].d = newval [5' i' j];  	scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  	scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  	tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  	tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  	pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: for (j = 0; j < jmax; j++) {  	xnode [i' j] = newval [0' i' j];  	ynode [i' j] = newval [1' i' j];  	ug [i + 1' j + 1].a = newval [2' i' j];  	ug [i + 1' j + 1].b = newval [3' i' j];  	ug [i + 1' j + 1].c = newval [4' i' j];  	ug [i + 1' j + 1].d = newval [5' i' j];  	scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  	scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  	tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  	tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  	pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: for (j = 0; j < jmax; j++) {  	xnode [i' j] = newval [0' i' j];  	ynode [i' j] = newval [1' i' j];  	ug [i + 1' j + 1].a = newval [2' i' j];  	ug [i + 1' j + 1].b = newval [3' i' j];  	ug [i + 1' j + 1].c = newval [4' i' j];  	ug [i + 1' j + 1].d = newval [5' i' j];  	scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  	scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  	tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  	tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  	pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: for (j = 0; j < jmax; j++) {  	xnode [i' j] = newval [0' i' j];  	ynode [i' j] = newval [1' i' j];  	ug [i + 1' j + 1].a = newval [2' i' j];  	ug [i + 1' j + 1].b = newval [3' i' j];  	ug [i + 1' j + 1].c = newval [4' i' j];  	ug [i + 1' j + 1].d = newval [5' i' j];  	scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  	scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  	tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  	tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  	pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: ug [i + 1' j + 1].a = newval [2' i' j];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: ug [i + 1' j + 1].b = newval [3' i' j];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: ug [i + 1' j + 1].c = newval [4' i' j];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: ug [i + 1' j + 1].d = newval [5' i' j];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j)  		a [i' j] = 0.5 * ((xnode [i' j] - xnode [i - 1' j - 1]) * (ynode [i - 1' j] - ynode [i' j - 1]) - (ynode [i' j] - ynode [i - 1' j - 1]) * (xnode [i - 1' j] - xnode [i' j - 1]));  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: for (j = 1; j < jmax; ++j)  	a [i' j] = 0.5 * ((xnode [i' j] - xnode [i - 1' j - 1]) * (ynode [i - 1' j] - ynode [i' j - 1]) - (ynode [i' j] - ynode [i - 1' j - 1]) * (xnode [i - 1' j] - xnode [i' j - 1]));  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,initialise,The following statement contains a magic number: a [i' j] = 0.5 * ((xnode [i' j] - xnode [i - 1' j - 1]) * (ynode [i - 1' j] - ynode [i' j - 1]) - (ynode [i' j] - ynode [i - 1' j - 1]) * (xnode [i - 1' j] - xnode [i' j - 1]));  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: ug1 [i' j].a = ug [i' j].a - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: ug1 [i' j].b = ug [i' j].b - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: ug1 [i' j].c = ug [i' j].c - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: ug1 [i' j].d = ug [i' j].d - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: ug1 [i' j].a = ug [i' j].a - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: ug1 [i' j].b = ug [i' j].b - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: ug1 [i' j].c = ug [i' j].c - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: ug1 [i' j].d = ug [i' j].d - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: ug1 [i' j].a = ug [i' j].a - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: ug1 [i' j].b = ug [i' j].b - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: ug1 [i' j].c = ug [i' j].c - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,doIteration,The following statement contains a magic number: ug1 [i' j].d = ug [i' j].d - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateStateVar,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		temp = localug [i' j].b;  		temp2 = localug [i' j].c;  		localtg [i' j] = localug [i' j].d / localug [i' j].a - 0.5 * (temp * temp + temp2 * temp2) / (localug [i' j].a * localug [i' j].a);  		localtg [i' j] = localtg [i' j] / Cv;  		localpg [i' j] = localug [i' j].a * rgas * localtg [i' j];  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateStateVar,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	temp = localug [i' j].b;  	temp2 = localug [i' j].c;  	localtg [i' j] = localug [i' j].d / localug [i' j].a - 0.5 * (temp * temp + temp2 * temp2) / (localug [i' j].a * localug [i' j].a);  	localtg [i' j] = localtg [i' j] / Cv;  	localpg [i' j] = localug [i' j].a * rgas * localtg [i' j];  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateStateVar,The following statement contains a magic number: localtg [i' j] = localug [i' j].d / localug [i' j].a - 0.5 * (temp * temp + temp2 * temp2) / (localug [i' j].a * localug [i' j].a);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Start by clearing R */r [i' j].a = 0.0;  		r [i' j].b = 0.0;  		r [i' j].c = 0.0;  		r [i' j].d = 0.0;  		/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  		deltax = (xnode [i' j] - xnode [i' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  		/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  		deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  		r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  		r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  		r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  		/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  		deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  		/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  		deltax = (xnode [i - 1' j] - xnode [i' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Start by clearing R */r [i' j].a = 0.0;  		r [i' j].b = 0.0;  		r [i' j].c = 0.0;  		r [i' j].d = 0.0;  		/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  		deltax = (xnode [i' j] - xnode [i' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  		/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  		deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  		r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  		r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  		r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  		/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  		deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  		/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  		deltax = (xnode [i - 1' j] - xnode [i' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Start by clearing R */r [i' j].a = 0.0;  		r [i' j].b = 0.0;  		r [i' j].c = 0.0;  		r [i' j].d = 0.0;  		/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  		deltax = (xnode [i' j] - xnode [i' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  		/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  		deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  		r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  		r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  		r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  		/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  		deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  		/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  		deltax = (xnode [i - 1' j] - xnode [i' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Start by clearing R */r [i' j].a = 0.0;  		r [i' j].b = 0.0;  		r [i' j].c = 0.0;  		r [i' j].d = 0.0;  		/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  		deltax = (xnode [i' j] - xnode [i' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  		/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  		deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  		r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  		r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  		r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  		/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  		deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  		/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  		deltax = (xnode [i - 1' j] - xnode [i' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Start by clearing R */r [i' j].a = 0.0;  		r [i' j].b = 0.0;  		r [i' j].c = 0.0;  		r [i' j].d = 0.0;  		/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  		deltax = (xnode [i' j] - xnode [i' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  		/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  		deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  		r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  		r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  		r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  		/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  		deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  		/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  		deltax = (xnode [i - 1' j] - xnode [i' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Start by clearing R */r [i' j].a = 0.0;  		r [i' j].b = 0.0;  		r [i' j].c = 0.0;  		r [i' j].d = 0.0;  		/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  		deltax = (xnode [i' j] - xnode [i' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  		/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  		deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  		r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  		r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  		r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  		/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  		deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  		/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  		deltax = (xnode [i - 1' j] - xnode [i' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Start by clearing R */r [i' j].a = 0.0;  		r [i' j].b = 0.0;  		r [i' j].c = 0.0;  		r [i' j].d = 0.0;  		/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  		deltax = (xnode [i' j] - xnode [i' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  		/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  		deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  		r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  		r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  		r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  		/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  		deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  		/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  		deltax = (xnode [i - 1' j] - xnode [i' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Start by clearing R */r [i' j].a = 0.0;  		r [i' j].b = 0.0;  		r [i' j].c = 0.0;  		r [i' j].d = 0.0;  		/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  		deltax = (xnode [i' j] - xnode [i' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  		/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  		deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  		r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  		r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  		r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  		/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  		deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  		/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  		deltax = (xnode [i - 1' j] - xnode [i' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Start by clearing R */r [i' j].a = 0.0;  	r [i' j].b = 0.0;  	r [i' j].c = 0.0;  	r [i' j].d = 0.0;  	/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  	deltax = (xnode [i' j] - xnode [i' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  	/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  	deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  	r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  	r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  	r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  	/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  	deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  	/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  	deltax = (xnode [i - 1' j] - xnode [i' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Start by clearing R */r [i' j].a = 0.0;  	r [i' j].b = 0.0;  	r [i' j].c = 0.0;  	r [i' j].d = 0.0;  	/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  	deltax = (xnode [i' j] - xnode [i' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  	/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  	deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  	r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  	r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  	r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  	/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  	deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  	/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  	deltax = (xnode [i - 1' j] - xnode [i' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Start by clearing R */r [i' j].a = 0.0;  	r [i' j].b = 0.0;  	r [i' j].c = 0.0;  	r [i' j].d = 0.0;  	/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  	deltax = (xnode [i' j] - xnode [i' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  	/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  	deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  	r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  	r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  	r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  	/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  	deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  	/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  	deltax = (xnode [i - 1' j] - xnode [i' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Start by clearing R */r [i' j].a = 0.0;  	r [i' j].b = 0.0;  	r [i' j].c = 0.0;  	r [i' j].d = 0.0;  	/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  	deltax = (xnode [i' j] - xnode [i' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  	/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  	deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  	r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  	r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  	r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  	/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  	deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  	/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  	deltax = (xnode [i - 1' j] - xnode [i' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Start by clearing R */r [i' j].a = 0.0;  	r [i' j].b = 0.0;  	r [i' j].c = 0.0;  	r [i' j].d = 0.0;  	/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  	deltax = (xnode [i' j] - xnode [i' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  	/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  	deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  	r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  	r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  	r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  	/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  	deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  	/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  	deltax = (xnode [i - 1' j] - xnode [i' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Start by clearing R */r [i' j].a = 0.0;  	r [i' j].b = 0.0;  	r [i' j].c = 0.0;  	r [i' j].d = 0.0;  	/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  	deltax = (xnode [i' j] - xnode [i' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  	/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  	deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  	r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  	r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  	r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  	/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  	deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  	/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  	deltax = (xnode [i - 1' j] - xnode [i' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Start by clearing R */r [i' j].a = 0.0;  	r [i' j].b = 0.0;  	r [i' j].c = 0.0;  	r [i' j].d = 0.0;  	/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  	deltax = (xnode [i' j] - xnode [i' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  	/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  	deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  	r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  	r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  	r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  	/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  	deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  	/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  	deltax = (xnode [i - 1' j] - xnode [i' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Start by clearing R */r [i' j].a = 0.0;  	r [i' j].b = 0.0;  	r [i' j].c = 0.0;  	r [i' j].d = 0.0;  	/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  	deltax = (xnode [i' j] - xnode [i' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  	/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  	deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  	r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  	r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  	r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  	/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  	deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  	/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  	deltax = (xnode [i - 1' j] - xnode [i' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: temp = 0.5 * deltay;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: temp = -0.5 * deltax;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: temp = 0.5 * deltay;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: temp = -0.5 * deltax;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: temp = 0.5 * deltay;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: temp = -0.5 * deltax;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: temp = 0.5 * deltay;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateR,The following statement contains a magic number: temp = -0.5 * deltax;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateG,The following statement contains a magic number: for (i = 0; i < imax + 1; ++i) {  	for (j = 0; j < jmax + 1; ++j) {  		v = localug [i' j].c / localug [i' j].a;  		g [i' j].a = localug [i' j].c;  		g [i' j].b = localug [i' j].b * v;  		g [i' j].c = localug [i' j].c * v + localpg [i' j];  		temp = localug [i' j].b * localug [i' j].b;  		temp2 = localug [i' j].c * localug [i' j].c;  		temp3 = localug [i' j].a * localug [i' j].a;  		g [i' j].d = localug [i' j].c * (Cp * localtg [i' j] + (0.5 * (temp + temp2) / (temp3)));  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateG,The following statement contains a magic number: for (j = 0; j < jmax + 1; ++j) {  	v = localug [i' j].c / localug [i' j].a;  	g [i' j].a = localug [i' j].c;  	g [i' j].b = localug [i' j].b * v;  	g [i' j].c = localug [i' j].c * v + localpg [i' j];  	temp = localug [i' j].b * localug [i' j].b;  	temp2 = localug [i' j].c * localug [i' j].c;  	temp3 = localug [i' j].a * localug [i' j].a;  	g [i' j].d = localug [i' j].c * (Cp * localtg [i' j] + (0.5 * (temp + temp2) / (temp3)));  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateG,The following statement contains a magic number: g [i' j].d = localug [i' j].c * (Cp * localtg [i' j] + (0.5 * (temp + temp2) / (temp3)));  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateF,The following statement contains a magic number: for (i = 0; i < imax + 1; ++i) {  	for (j = 0; j < jmax + 1; ++j) {  		u = localug [i' j].b / localug [i' j].a;  		f [i' j].a = localug [i' j].b;  		f [i' j].b = localug [i' j].b * u + localpg [i' j];  		f [i' j].c = localug [i' j].c * u;  		temp1 = localug [i' j].b * localug [i' j].b;  		temp2 = localug [i' j].c * localug [i' j].c;  		temp3 = localug [i' j].a * localug [i' j].a;  		f [i' j].d = localug [i' j].b * (Cp * localtg [i' j] + (0.5 * (temp1 + temp2) / (temp3)));  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateF,The following statement contains a magic number: for (j = 0; j < jmax + 1; ++j) {  	u = localug [i' j].b / localug [i' j].a;  	f [i' j].a = localug [i' j].b;  	f [i' j].b = localug [i' j].b * u + localpg [i' j];  	f [i' j].c = localug [i' j].c * u;  	temp1 = localug [i' j].b * localug [i' j].b;  	temp2 = localug [i' j].c * localug [i' j].c;  	temp3 = localug [i' j].a * localug [i' j].a;  	f [i' j].d = localug [i' j].b * (Cp * localtg [i' j] + (0.5 * (temp1 + temp2) / (temp3)));  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateF,The following statement contains a magic number: f [i' j].d = localug [i' j].b * (Cp * localtg [i' j] + (0.5 * (temp1 + temp2) / (temp3)));  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		sxi [i' j] = Math.Abs (localpg [i + 1' j] - 2.0 * localpg [i' j] + localpg [i - 1' j]) / localpg [i' j];  		seta [i' j] = Math.Abs (localpg [i' j + 1] - 2.0 * localpg [i' j] + localpg [i' j - 1]) / localpg [i' j];  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		sxi [i' j] = Math.Abs (localpg [i + 1' j] - 2.0 * localpg [i' j] + localpg [i - 1' j]) / localpg [i' j];  		seta [i' j] = Math.Abs (localpg [i' j + 1] - 2.0 * localpg [i' j] + localpg [i' j - 1]) / localpg [i' j];  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	sxi [i' j] = Math.Abs (localpg [i + 1' j] - 2.0 * localpg [i' j] + localpg [i - 1' j]) / localpg [i' j];  	seta [i' j] = Math.Abs (localpg [i' j + 1] - 2.0 * localpg [i' j] + localpg [i' j - 1]) / localpg [i' j];  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	sxi [i' j] = Math.Abs (localpg [i + 1' j] - 2.0 * localpg [i' j] + localpg [i - 1' j]) / localpg [i' j];  	seta [i' j] = Math.Abs (localpg [i' j + 1] - 2.0 * localpg [i' j] + localpg [i' j - 1]) / localpg [i' j];  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: sxi [i' j] = Math.Abs (localpg [i + 1' j] - 2.0 * localpg [i' j] + localpg [i - 1' j]) / localpg [i' j];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: seta [i' j] = Math.Abs (localpg [i' j + 1] - 2.0 * localpg [i' j] + localpg [i' j - 1]) / localpg [i' j];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  	sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  } else {  	adt = a [i' j] / deltat [i' j];  	sbar = sxi [i' j];  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 2' j].svect (localug [i - 1' j]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 2' j].svect (localug [i - 1' j]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 2' j].svect (localug [i - 1' j]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 2' j].svect (localug [i - 1' j]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 2' j].svect (localug [i - 1' j]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp = localug [i + 2' j].svect (localug [i - 1' j]);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  	sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  } else {  	adt = a [i' j] / deltat [i' j];  	sbar = sxi [i' j];  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 1' j].svect (localug [i - 2' j]);  	temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 1' j].svect (localug [i - 2' j]);  	temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 1' j].svect (localug [i - 2' j]);  	temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 1' j].svect (localug [i - 2' j]);  	temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 1' j].svect (localug [i - 2' j]);  	temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp = localug [i + 1' j].svect (localug [i - 2' j]);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  	sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  } else {  	adt = a [i' j] / deltat [i' j];  	sbar = seta [i' j];  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 2].svect (localug [i' j - 1]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 2].svect (localug [i' j - 1]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 2].svect (localug [i' j - 1]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 2].svect (localug [i' j - 1]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 2].svect (localug [i' j - 1]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp = localug [i' j + 2].svect (localug [i' j - 1]);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  	sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  } else {  	adt = a [i' j] / deltat [i' j];  	sbar = seta [i' j];  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 1].svect (localug [i' j - 2]);  	temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 1].svect (localug [i' j - 2]);  	temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 1].svect (localug [i' j - 2]);  	temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 1].svect (localug [i' j - 2]);  	temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 1].svect (localug [i' j - 2]);  	temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp = localug [i' j + 1].svect (localug [i' j - 2]);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDamping,The following statement contains a magic number: temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  		yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  		xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  		yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  		q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  		r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  		c = Math.Sqrt (gamma * rgas * tg [i' j]);  		deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  		yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  		xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  		yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  		q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  		r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  		c = Math.Sqrt (gamma * rgas * tg [i' j]);  		deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  		yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  		xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  		yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  		q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  		r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  		c = Math.Sqrt (gamma * rgas * tg [i' j]);  		deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  		yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  		xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  		yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  		q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  		r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  		c = Math.Sqrt (gamma * rgas * tg [i' j]);  		deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  		yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  		xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  		yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  		q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  		r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  		c = Math.Sqrt (gamma * rgas * tg [i' j]);  		deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  		yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  		xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  		yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  		q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  		r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  		c = Math.Sqrt (gamma * rgas * tg [i' j]);  		deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  	yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  	xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  	yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  	q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  	r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  	c = Math.Sqrt (gamma * rgas * tg [i' j]);  	deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  	yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  	xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  	yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  	q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  	r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  	c = Math.Sqrt (gamma * rgas * tg [i' j]);  	deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  	yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  	xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  	yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  	q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  	r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  	c = Math.Sqrt (gamma * rgas * tg [i' j]);  	deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  	yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  	xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  	yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  	q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  	r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  	c = Math.Sqrt (gamma * rgas * tg [i' j]);  	deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  	yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  	xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  	yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  	q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  	r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  	c = Math.Sqrt (gamma * rgas * tg [i' j]);  	deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  	yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  	xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  	yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  	q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  	r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  	c = Math.Sqrt (gamma * rgas * tg [i' j]);  	deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: if (ntime == 1) {  	mint = 100000.0;  	for (i = 1; i < imax; ++i) {  		for (j = 1; j < jmax; ++j) {  			if (deltat [i' j] < mint)  				mint = deltat [i' j];  		}  	}  	for (i = 1; i < imax; ++i) {  		for (j = 1; j < jmax; ++j)  			deltat [i' j] = mint;  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDeltaT,The following statement contains a magic number: mint = 100000.0;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: jplusff = uff + 2.0 / (gamma - 1.0) * cff;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: jminusff = uff - 2.0 / (gamma - 1.0) * cff;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	/* Bottom wall boundary cells *//* Routine checked by brute force for initial conditions' 4/9; 4:30 *//* Routine checked by brute force for random conditions' 4/13' 4:40 pm *//* Construct tangent vectors */tan.ihat = xnode [i' 0] - xnode [i - 1' 0];  	tan.jhat = ynode [i' 0] - ynode [i - 1' 0];  	norm.ihat = -(ynode [i' 0] - ynode [i - 1' 0]);  	norm.jhat = xnode [i' 0] - xnode [i - 1' 0];  	scrap = tan.magnitude ();  	tan.ihat = tan.ihat / scrap;  	tan.jhat = tan.jhat / scrap;  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	/* now set some state variables */rho = localug [i' 1].a;  	localtg [i' 0] = localtg [i' 1];  	u1.ihat = localug [i' 1].b / rho;  	u1.jhat = localug [i' 1].c / rho;  	u = u1.dot (tan) + u1.dot (norm) * tan.jhat / norm.jhat;  	u = u / (tan.ihat - (norm.ihat * tan.jhat / norm.jhat));  	v = -(u1.dot (norm) + u * norm.ihat) / norm.jhat;  	/* And construct the new state vector */localug [i' 0].a = localug [i' 1].a;  	localug [i' 0].b = rho * u;  	localug [i' 0].c = rho * v;  	localug [i' 0].d = rho * (Cv * localtg [i' 0] + 0.5 * (u * u + v * v));  	localpg [i' 0] = localpg [i' 1];  	/* Top Wall Boundary Cells *//* Checked numerically for default conditions' 4/9 at 5:30 pm *//* Construct normal and tangent vectors *//* This part checked and works; it produces the correct vectors */tan.ihat = xnode [i' jmax - 1] - xnode [i - 1' jmax - 1];  	tan.jhat = ynode [i' jmax - 1] - ynode [i - 1' jmax - 1];  	norm.ihat = ynode [i' jmax - 1] - ynode [i - 1' jmax - 1];  	norm.jhat = -(xnode [i' jmax - 1] - xnode [i - 1' jmax - 1]);  	scrap = tan.magnitude ();  	tan.ihat = tan.ihat / scrap;  	tan.jhat = tan.jhat / scrap;  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	/* now set some state variables */rho = localug [i' jmax - 1].a;  	temp = localtg [i' jmax - 1];  	u1.ihat = localug [i' jmax - 1].b / rho;  	u1.jhat = localug [i' jmax - 1].c / rho;  	u = u1.dot (tan) + u1.dot (norm) * tan.jhat / norm.jhat;  	u = u / (tan.ihat - (norm.ihat * tan.jhat / norm.jhat));  	v = -(u1.dot (norm) + u * norm.ihat) / norm.jhat;  	/* And construct the new state vector */localug [i' jmax].a = localug [i' jmax - 1].a;  	localug [i' jmax].b = rho * u;  	localug [i' jmax].c = rho * v;  	localug [i' jmax].d = rho * (Cv * temp + 0.5 * (u * u + v * v));  	localtg [i' jmax] = temp;  	localpg [i' jmax] = localpg [i' jmax - 1];  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	/* Bottom wall boundary cells *//* Routine checked by brute force for initial conditions' 4/9; 4:30 *//* Routine checked by brute force for random conditions' 4/13' 4:40 pm *//* Construct tangent vectors */tan.ihat = xnode [i' 0] - xnode [i - 1' 0];  	tan.jhat = ynode [i' 0] - ynode [i - 1' 0];  	norm.ihat = -(ynode [i' 0] - ynode [i - 1' 0]);  	norm.jhat = xnode [i' 0] - xnode [i - 1' 0];  	scrap = tan.magnitude ();  	tan.ihat = tan.ihat / scrap;  	tan.jhat = tan.jhat / scrap;  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	/* now set some state variables */rho = localug [i' 1].a;  	localtg [i' 0] = localtg [i' 1];  	u1.ihat = localug [i' 1].b / rho;  	u1.jhat = localug [i' 1].c / rho;  	u = u1.dot (tan) + u1.dot (norm) * tan.jhat / norm.jhat;  	u = u / (tan.ihat - (norm.ihat * tan.jhat / norm.jhat));  	v = -(u1.dot (norm) + u * norm.ihat) / norm.jhat;  	/* And construct the new state vector */localug [i' 0].a = localug [i' 1].a;  	localug [i' 0].b = rho * u;  	localug [i' 0].c = rho * v;  	localug [i' 0].d = rho * (Cv * localtg [i' 0] + 0.5 * (u * u + v * v));  	localpg [i' 0] = localpg [i' 1];  	/* Top Wall Boundary Cells *//* Checked numerically for default conditions' 4/9 at 5:30 pm *//* Construct normal and tangent vectors *//* This part checked and works; it produces the correct vectors */tan.ihat = xnode [i' jmax - 1] - xnode [i - 1' jmax - 1];  	tan.jhat = ynode [i' jmax - 1] - ynode [i - 1' jmax - 1];  	norm.ihat = ynode [i' jmax - 1] - ynode [i - 1' jmax - 1];  	norm.jhat = -(xnode [i' jmax - 1] - xnode [i - 1' jmax - 1]);  	scrap = tan.magnitude ();  	tan.ihat = tan.ihat / scrap;  	tan.jhat = tan.jhat / scrap;  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	/* now set some state variables */rho = localug [i' jmax - 1].a;  	temp = localtg [i' jmax - 1];  	u1.ihat = localug [i' jmax - 1].b / rho;  	u1.jhat = localug [i' jmax - 1].c / rho;  	u = u1.dot (tan) + u1.dot (norm) * tan.jhat / norm.jhat;  	u = u / (tan.ihat - (norm.ihat * tan.jhat / norm.jhat));  	v = -(u1.dot (norm) + u * norm.ihat) / norm.jhat;  	/* And construct the new state vector */localug [i' jmax].a = localug [i' jmax - 1].a;  	localug [i' jmax].b = rho * u;  	localug [i' jmax].c = rho * v;  	localug [i' jmax].d = rho * (Cv * temp + 0.5 * (u * u + v * v));  	localtg [i' jmax] = temp;  	localpg [i' jmax] = localpg [i' jmax - 1];  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: localug [i' 0].d = rho * (Cv * localtg [i' 0] + 0.5 * (u * u + v * v));  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: localug [i' jmax].d = rho * (Cv * temp + 0.5 * (u * u + v * v));  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options *//* Debug: throw exception here? */else {  		Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other options *//* We should throw an exception here */else {  	Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other options *//* We should throw an exception here */else {  	Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other options *//* We should throw an exception here */else {  	Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other options *//* We should throw an exception here */else {  	Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other options *//* We should throw an exception here */else {  	Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < 0.0) {  	/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other options *//* We should throw an exception here */else {  	Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < 0.0) {  	/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other options *//* We should throw an exception here */else {  	Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < 0.0) {  	/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other options *//* We should throw an exception here */else {  	Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < 0.0) {  	/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other options *//* We should throw an exception here */else {  	Console.WriteLine ("You have outflow at the inlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: u = (jplusff + jminus) / 2.0;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: jplus = u1.ihat + 2.0 / (gamma - 1) * c;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: u = (jplus + jminusff) / 2.0;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: scrap = (jplus - u) * (gamma - 1.0) * 0.5;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options *//* Debug: throw exception here? */else {  	Console.WriteLine ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: u = (jplusff + jminus) / 2.0;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  
Magic Number,Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tests\csgrande\Euler\Euler\Program.cs,calculateDummyCells,The following statement contains a magic number: localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  
