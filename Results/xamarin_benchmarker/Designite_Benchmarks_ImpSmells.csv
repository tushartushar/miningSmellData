Implementation smell,Namespace,Class,File,Method,Description
Long Method,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The method has 93 lines of code.
Long Method,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The method has 102 lines of code.
Long Method,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The method has 71 lines of code.
Long Method,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The method has 61 lines of code.
Long Method,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The method has 156 lines of code.
Long Method,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The method has 159 lines of code.
Long Method,Benchmarks.SpecRaytracer,IntersectPt,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\IntersectPt.cs,FindNearestIsect,The method has 65 lines of code.
Long Method,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateFaces,The method has 61 lines of code.
Long Method,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The method has 95 lines of code.
Long Method,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The method has 125 lines of code.
Long Method,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,The method has 71 lines of code.
Complex Method,Benchmarks.BH,BH,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BH.cs,Main,Cyclomatic complexity of the method is 8
Complex Method,Benchmarks.BH,BH,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BH.cs,parseCmdLine,Cyclomatic complexity of the method is 10
Complex Method,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,createTestData,Cyclomatic complexity of the method is 7
Complex Method,Benchmarks.BiSort,BiSort,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BiSort\BiSort.cs,parseCmdLine,Cyclomatic complexity of the method is 7
Complex Method,Benchmarks.BiSort,Value,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BiSort\Value.cs,bimerge,Cyclomatic complexity of the method is 7
Complex Method,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,shade,Cyclomatic complexity of the method is 10
Complex Method,Benchmarks.Graph4,Node,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\graph4.cs,otherRandomGraph,Cyclomatic complexity of the method is 8
Complex Method,Benchmarks.Graph8,Node,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\graph8.cs,otherRandomGraph,Cyclomatic complexity of the method is 8
Complex Method,Benchmarks.Hash3,Hash3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\hash3.cs,Main,Cyclomatic complexity of the method is 14
Complex Method,Benchmarks.Health,Health,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Health.cs,parseCmdLine,Cyclomatic complexity of the method is 10
Complex Method,Benchmarks.Lists,Lists,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\lists.cs,RunLists,Cyclomatic complexity of the method is 9
Complex Method,Benchmarks.Mandelbrot,Mandelbrot,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\mandelbrot.cs,Main,Cyclomatic complexity of the method is 8
Complex Method,Benchmarks.Perimeter,BlackNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\BlackNode.cs,perimeter,Cyclomatic complexity of the method is 9
Complex Method,Benchmarks.Perimeter,Perimeter,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\Perimeter.cs,parseCmdLine,Cyclomatic complexity of the method is 7
Complex Method,Benchmarks.SciMark,LU,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\LU.cs,factor,Cyclomatic complexity of the method is 12
Complex Method,Benchmarks.SciMark,LU,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\LU.cs,solve,Cyclomatic complexity of the method is 7
Complex Method,Benchmarks.SciMark,ScimarkEntrypoint,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\ScimarkEntrypoint.cs,Main,Cyclomatic complexity of the method is 24
Complex Method,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,Cyclomatic complexity of the method is 16
Complex Method,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,Cyclomatic complexity of the method is 13
Complex Method,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,Cyclomatic complexity of the method is 13
Complex Method,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,Cyclomatic complexity of the method is 10
Complex Method,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,Cyclomatic complexity of the method is 9
Complex Method,Benchmarks.SpecRaytracer,IntersectPt,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\IntersectPt.cs,FindNearestIsect,Cyclomatic complexity of the method is 16
Complex Method,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,Cyclomatic complexity of the method is 11
Complex Method,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,FindTreeNode,Cyclomatic complexity of the method is 7
Complex Method,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,Cyclomatic complexity of the method is 31
Complex Method,Benchmarks.SpecRaytracer,PolygonObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\PolygonObj.cs,InsidePolygon,Cyclomatic complexity of the method is 9
Complex Method,Benchmarks.SpecRaytracer,PolyTypeObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\PolyTypeObj.cs,PolyTypeObj,Cyclomatic complexity of the method is 14
Complex Method,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,Cyclomatic complexity of the method is 9
Complex Method,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,Shade,Cyclomatic complexity of the method is 7
Complex Method,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,FindLightBlock,Cyclomatic complexity of the method is 8
Complex Method,Benchmarks.SpecRaytracer,SphereObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\SphereObj.cs,SphereObj,Cyclomatic complexity of the method is 7
Long Parameter List,Benchmarks.BH,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\Body.cs,loadTree,The method has 4 parameters.
Long Parameter List,Benchmarks.BH,Cell,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\Cell.cs,loadTree,The method has 4 parameters.
Long Parameter List,Benchmarks.BH,Node,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\Node.cs,loadTree,The method has 4 parameters.
Long Parameter List,Benchmarks.GrandeTracer,Interval,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Interval.cs,Interval,The method has 6 parameters.
Long Parameter List,Benchmarks.GrandeTracer,Light,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Light.cs,Light,The method has 4 parameters.
Long Parameter List,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,TransDir,The method has 4 parameters.
Long Parameter List,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,shade,The method has 6 parameters.
Long Parameter List,Benchmarks.GrandeTracer,Vec,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Vec.cs,comb,The method has 4 parameters.
Long Parameter List,Benchmarks.GrandeTracer,Vec,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Vec.cs,comb2,The method has 4 parameters.
Long Parameter List,Benchmarks.GrandeTracer,View,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\View.cs,View,The method has 6 parameters.
Long Parameter List,Benchmarks.Graph4,Node,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\graph4.cs,connect,The method has 4 parameters.
Long Parameter List,Benchmarks.Graph8,Node,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\graph8.cs,connect,The method has 8 parameters.
Long Parameter List,Benchmarks.Health,Village,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Village.cs,Village,The method has 4 parameters.
Long Parameter List,Benchmarks.Health,Village,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Village.cs,createVillage,The method has 4 parameters.
Long Parameter List,Benchmarks.Perimeter,QuadTreeNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\QuadTreeNode.cs,QuadTreeNode,The method has 6 parameters.
Long Parameter List,Benchmarks.Perimeter,QuadTreeNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\QuadTreeNode.cs,setChildren,The method has 4 parameters.
Long Parameter List,Benchmarks.Perimeter,QuadTreeNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\QuadTreeNode.cs,createTree,The method has 6 parameters.
Long Parameter List,Benchmarks.SciMark,SparseCompRow,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\SparseCompRow.cs,matmult,The method has 6 parameters.
Long Parameter List,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,measureSparseMatmult,The method has 4 parameters.
Long Parameter List,Benchmarks.SpecRaytracer,Camera,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Camera.cs,Camera,The method has 5 parameters.
Long Parameter List,Benchmarks.SpecRaytracer,Canvas,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Canvas.cs,Write,The method has 4 parameters.
Long Parameter List,Benchmarks.SpecRaytracer,Color,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Color.cs,Combine,The method has 6 parameters.
Long Parameter List,Benchmarks.SpecRaytracer,IntersectPt,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\IntersectPt.cs,FindNearestIsect,The method has 5 parameters.
Long Parameter List,Benchmarks.SpecRaytracer,Material,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Material.cs,Material,The method has 6 parameters.
Long Parameter List,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateFaces,The method has 6 parameters.
Long Parameter List,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,FormAdjacent,The method has 6 parameters.
Long Parameter List,Benchmarks.SpecRaytracer,Point,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Point.cs,FindCorner,The method has 4 parameters.
Long Parameter List,Benchmarks.SpecRaytracer,Point,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Point.cs,Combine,The method has 4 parameters.
Long Parameter List,Benchmarks.SpecRaytracer,PolygonObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\PolygonObj.cs,InsidePolygon,The method has 4 parameters.
Long Parameter List,Benchmarks.SpecRaytracer,PolygonObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\PolygonObj.cs,PolygonObj,The method has 6 parameters.
Long Parameter List,Benchmarks.SpecRaytracer,PolyTypeObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\PolyTypeObj.cs,PolyTypeObj,The method has 6 parameters.
Long Parameter List,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,Shade,The method has 6 parameters.
Long Parameter List,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,GetLightColor,The method has 5 parameters.
Long Parameter List,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,RenderScene,The method has 4 parameters.
Long Parameter List,Benchmarks.SpecRaytracer,SphereObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\SphereObj.cs,SphereObj,The method has 6 parameters.
Long Parameter List,Benchmarks.SpecRaytracer,TriangleObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\TriangleObj.cs,TriangleObj,The method has 6 parameters.
Long Statement,Benchmarks.Nbody,NBodySystem,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Energy,The length of the statement  "		e += 0.5 * bodies [i].mass * (bodies [i].vx * bodies [i].vx + bodies [i].vy * bodies [i].vy + bodies [i].vz * bodies [i].vz); " is 125.
Long Statement,Benchmarks.Graph8,Node,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\graph8.cs,connectNode,The length of the statement  "	n.connect (nodes [r.Next (size)]' nodes [r.Next (size)]' nodes [r.Next (size)]' nodes [r.Next (size)]' nodes [r.Next (size)]' nodes [r.Next (size)]' nodes [r.Next (size)]' nodes [r.Next (size)]); " is 195.
Long Statement,Benchmarks.Perimeter,QuadTreeNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\QuadTreeNode.cs,checkIntersect,The length of the statement  "	if (checkOutside (center_x + size' center_y + size) == 0 && checkOutside (center_x + size' center_y - size) == 0 && checkOutside (center_x - size' center_y - size) == 0 && checkOutside (center_x - size' center_y + size) == 0) { " is 227.
Long Statement,Benchmarks.Perimeter,QuadTreeNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\QuadTreeNode.cs,checkIntersect,The length of the statement  "	int sum = checkOutside (center_x + size' center_y + size) + checkOutside (center_x + size' center_y - size) + checkOutside (center_x - size' center_y - size) + checkOutside (center_x - size' center_y + size); " is 208.
Long Statement,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The length of the statement  "	/* apply fft recursion *//* this loop executed log2(N) times */for (int bit = 0' dual = 1; bit < logn; bit++' dual *= 2) { " is 122.
Long Statement,Benchmarks.SciMark,ScimarkEntrypoint,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\ScimarkEntrypoint.cs,Main,The length of the statement  "		logger.InfoFormat ("FFT            : {0} - ({1})"' res == 0.0 ? "ERROR' INVALID NUMERICAL RESULT!" : res.ToString ("F2")' FFT_size); " is 132.
Long Statement,Benchmarks.SciMark,ScimarkEntrypoint,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\ScimarkEntrypoint.cs,Main,The length of the statement  "		logger.InfoFormat ("LU             : {1} - ({0}x{0})"' LU_size' res == 0.0 ? "ERROR' INVALID NUMERICAL RESULT!" : res.ToString ("F2")); " is 135.
Long Statement,Benchmarks.Euler,Euler,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,validate,The length of the statement  "		throw new Exception ("Validation failed\nComputed RMS pressure error = " + error + "\nReference value = " + refval [size]); " is 123.
Long Statement,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The length of the statement  "				newval [k' i' j] = (1.0 - xf) * (1.0 - yf) * oldval [k' iold' jold] + (1.0 - xf) * yf * oldval [k' iold' jold + 1] + xf * (1.0 - yf) * oldval [k' iold + 1' jold] + xf * yf * oldval [k' iold + 1' jold + 1]; " is 205.
Long Statement,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The length of the statement  "			a [i' j] = 0.5 * ((xnode [i' j] - xnode [i - 1' j - 1]) * (ynode [i - 1' j] - ynode [i' j - 1]) - (ynode [i' j] - ynode [i - 1' j - 1]) * (xnode [i - 1' j] - xnode [i' j - 1])); " is 177.
Long Statement,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateStateVar,The length of the statement  "			localtg [i' j] = localug [i' j].d / localug [i' j].a - 0.5 * (temp * temp + temp2 * temp2) / (localug [i' j].a * localug [i' j].a); " is 131.
Long Statement,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The length of the statement  "			deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi))); " is 209.
Long Statement,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The length of the statement  "		/* Bottom wall boundary cells *//* Routine checked by brute force for initial conditions' 4/9; 4:30 *//* Routine checked by brute force for random conditions' 4/13' 4:40 pm *//* Construct tangent vectors */tan.ihat = xnode [i' 0] - xnode [i - 1' 0]; " is 249.
Long Statement,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The length of the statement  "		/* Top Wall Boundary Cells *//* Checked numerically for default conditions' 4/9 at 5:30 pm *//* Construct normal and tangent vectors *//* This part checked and works; it produces the correct vectors */tan.ihat = xnode [i' jmax - 1] - xnode [i - 1' jmax - 1]; " is 258.
Long Statement,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The length of the statement  "		/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j]; " is 141.
Long Statement,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The length of the statement  "		theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j]))); " is 210.
Long Statement,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The length of the statement  "		/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1]; " is 125.
Long Statement,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The length of the statement  "			/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a; " is 171.
Long Statement,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The length of the statement  "	/* Do something with corners to avoid division by zero errors *//* What you do shouldn't matter */localug [0' 0] = localug [1' 0]; " is 130.
Long Statement,Benchmarks.SpecRaytracer,Color,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Color.cs,Combine,The length of the statement  "	green = color1.GetGreen () + color2.GetGreen () * color2factor + color3.GetGreen () + color4.GetGreen () + color5.GetGreen (); " is 126.
Long Statement,Benchmarks.SpecRaytracer,Color,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Color.cs,Combine,The length of the statement  "	blue = color1.GetBlue () + color2.GetBlue () * color2factor + color3.GetBlue () + color4.GetBlue () + color5.GetBlue (); " is 120.
Long Statement,Benchmarks.SpecRaytracer,IntersectPt,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\IntersectPt.cs,SetIsectPt,The length of the statement  "	Intersection.Set (isectpt.GetIntersection ().GetX ()' isectpt.GetIntersection ().GetY ()' isectpt.GetIntersection ().GetZ ()); " is 126.
Long Statement,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The length of the statement  "			if ((intersect.GetY () <= MAXYF.GetVert (0).GetY ()) && (intersect.GetY () >= MINYF.GetVert (0).GetY ()) && (intersect.GetZ () <= MAXZF.GetVert (0).GetZ ()) && (intersect.GetZ () >= MINZF.GetVert (0).GetZ ())) { " is 211.
Long Statement,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The length of the statement  "			if ((intersect.GetY () <= MAXYF.GetVert (0).GetY ()) && (intersect.GetY () >= MINYF.GetVert (0).GetY ()) && (intersect.GetZ () <= MAXZF.GetVert (0).GetZ ()) && (intersect.GetZ () >= MINZF.GetVert (0).GetZ ())) { " is 211.
Long Statement,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The length of the statement  "				if ((intersect.GetX () <= MAXXF.GetVert (0).GetX ()) && (intersect.GetX () >= MINXF.GetVert (0).GetX ()) && (intersect.GetZ () <= MAXZF.GetVert (0).GetZ ()) && (intersect.GetZ () >= MINZF.GetVert (0).GetZ ())) { " is 211.
Long Statement,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The length of the statement  "				if ((intersect.GetX () <= MAXXF.GetVert (0).GetX ()) && (intersect.GetX () >= MINXF.GetVert (0).GetX ()) && (intersect.GetZ () <= MAXZF.GetVert (0).GetZ ()) && (intersect.GetZ () >= MINZF.GetVert (0).GetZ ())) { " is 211.
Long Statement,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The length of the statement  "				if ((intersect.GetX () <= MAXXF.GetVert (0).GetX ()) && (intersect.GetX () >= MINXF.GetVert (0).GetX ()) && (intersect.GetY () <= MAXYF.GetVert (0).GetY ()) && (intersect.GetY () >= MINYF.GetVert (0).GetY ())) { " is 211.
Long Statement,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The length of the statement  "				if ((intersect.GetX () <= MAXXF.GetVert (0).GetX ()) && (intersect.GetX () >= MINXF.GetVert (0).GetX ()) && (intersect.GetY () <= MAXYF.GetVert (0).GetY ()) && (intersect.GetY () >= MINYF.GetVert (0).GetY ())) { " is 211.
Long Statement,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,Shade,The length of the statement  "			double check = factor * (1.0f - intersect.GetIntersectObj ().GetMaterial ().GetKTran ()) * intersect.GetIntersectObj ().GetMaterial ().GetShininess (); " is 151.
Long Statement,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,Shade,The length of the statement  "				reflectColor.Scale ((1.0f - intersect.GetIntersectObj ().GetMaterial ().GetKTran ()) * intersect.GetIntersectObj ().GetMaterial ().GetShininess ()' intersect.GetIntersectObj ().GetMaterial ().GetSpecColor ()); " is 209.
Long Statement,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,Shade,The length of the statement  "					refractColor.Scale (intersect.GetIntersectObj ().GetMaterial ().GetKTran ()' intersect.GetIntersectObj ().GetMaterial ().GetSpecColor ()); " is 138.
Long Statement,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,Shade,The length of the statement  "		color.Combine (intersect.GetIntersectObj ().GetMaterial ().GetEmissColor ()' intersect.GetIntersectObj ().GetMaterial ().GetAmbColor ()' AmbLightIntensity' lightColor' reflectColor' refractColor); " is 196.
Long Statement,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,RenderScene,The length of the statement  "	basepoint.Set (upleft.GetX () + 0.5f * (horIncr.GetX () + vertIncr.GetX ())' upleft.GetY () + 0.5f * (horIncr.GetY () + vertIncr.GetY ())' upleft.GetZ () + 0.5f * (horIncr.GetZ () + vertIncr.GetZ ())); " is 201.
Long Statement,Benchmarks.SpecRaytracer,TriangleObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\TriangleObj.cs,Check,The length of the statement  "	Vector intersectVec = new Vector (pt.GetIntersection ().GetX ()' pt.GetIntersection ().GetY ()' pt.GetIntersection ().GetZ ()); " is 127.
Long Statement,Benchmarks.SpecRaytracer,Vector,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Vector.cs,Cross,The length of the statement  "	Set ((op1.GetY () * op2.GetZ ()) - (op1.GetZ () * op2.GetY ())' (op1.GetZ () * op2.GetX ()) - (op1.GetX () * op2.GetZ ())' (op1.GetX () * op2.GetY ()) - (op1.GetY () * op2.GetX ())); " is 182.
Complex Conditional,Benchmarks.Perimeter,QuadTreeNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\QuadTreeNode.cs,countTree,The conditional expression  "nw == null && ne == null && sw == null && se == null"  is complex.
Complex Conditional,Benchmarks.Perimeter,QuadTreeNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\QuadTreeNode.cs,checkIntersect,The conditional expression  "checkOutside (center_x + size' center_y + size) == 0 && checkOutside (center_x + size' center_y - size) == 0 && checkOutside (center_x - size' center_y - size) == 0 && checkOutside (center_x - size' center_y + size) == 0"  is complex.
Complex Conditional,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The conditional expression  "(intersect.GetY () <= MAXYF.GetVert (0).GetY ()) && (intersect.GetY () >= MINYF.GetVert (0).GetY ()) && (intersect.GetZ () <= MAXZF.GetVert (0).GetZ ()) && (intersect.GetZ () >= MINZF.GetVert (0).GetZ ())"  is complex.
Complex Conditional,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The conditional expression  "(intersect.GetY () <= MAXYF.GetVert (0).GetY ()) && (intersect.GetY () >= MINYF.GetVert (0).GetY ()) && (intersect.GetZ () <= MAXZF.GetVert (0).GetZ ()) && (intersect.GetZ () >= MINZF.GetVert (0).GetZ ())"  is complex.
Complex Conditional,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The conditional expression  "(intersect.GetX () <= MAXXF.GetVert (0).GetX ()) && (intersect.GetX () >= MINXF.GetVert (0).GetX ()) && (intersect.GetZ () <= MAXZF.GetVert (0).GetZ ()) && (intersect.GetZ () >= MINZF.GetVert (0).GetZ ())"  is complex.
Complex Conditional,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The conditional expression  "(intersect.GetX () <= MAXXF.GetVert (0).GetX ()) && (intersect.GetX () >= MINXF.GetVert (0).GetX ()) && (intersect.GetZ () <= MAXZF.GetVert (0).GetZ ()) && (intersect.GetZ () >= MINZF.GetVert (0).GetZ ())"  is complex.
Complex Conditional,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The conditional expression  "(intersect.GetX () <= MAXXF.GetVert (0).GetX ()) && (intersect.GetX () >= MINXF.GetVert (0).GetX ()) && (intersect.GetY () <= MAXYF.GetVert (0).GetY ()) && (intersect.GetY () >= MINYF.GetVert (0).GetY ())"  is complex.
Complex Conditional,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The conditional expression  "(intersect.GetX () <= MAXXF.GetVert (0).GetX ()) && (intersect.GetX () >= MINXF.GetVert (0).GetX ()) && (intersect.GetY () <= MAXYF.GetVert (0).GetY ()) && (intersect.GetY () >= MINYF.GetVert (0).GetY ())"  is complex.
Virtual Method Call from Constructor,Benchmarks.SciMark,Stopwatch,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Stopwatch.cs,Stopwatch,The constructor "Stopwatch" calls a virtual method "reset".
Magic Number,Benchmarks.Nbody,NBody,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Main,The following statement contains a magic number: for (int i = 0; i < n; i++)  	bodies.Advance (0.01);  
Magic Number,Benchmarks.Nbody,NBody,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Main,The following statement contains a magic number: bodies.Advance (0.01);  
Magic Number,Benchmarks.Nbody,NBodySystem,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Energy,The following statement contains a magic number: for (int i = 0; i < bodies.Length; i++) {  	e += 0.5 * bodies [i].mass * (bodies [i].vx * bodies [i].vx + bodies [i].vy * bodies [i].vy + bodies [i].vz * bodies [i].vz);  	for (int j = i + 1; j < bodies.Length; j++) {  		dx = bodies [i].x - bodies [j].x;  		dy = bodies [i].y - bodies [j].y;  		dz = bodies [i].z - bodies [j].z;  		distance = Math.Sqrt (dx * dx + dy * dy + dz * dz);  		e -= (bodies [i].mass * bodies [j].mass) / distance;  	}  }  
Magic Number,Benchmarks.Nbody,NBodySystem,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Energy,The following statement contains a magic number: e += 0.5 * bodies [i].mass * (bodies [i].vx * bodies [i].vx + bodies [i].vy * bodies [i].vy + bodies [i].vz * bodies [i].vz);  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Jupiter,The following statement contains a magic number: p.x = 4.84143144246472090e+00;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Jupiter,The following statement contains a magic number: p.y = -1.16032004402742839e+00;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Jupiter,The following statement contains a magic number: p.z = -1.03622044471123109e-01;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Jupiter,The following statement contains a magic number: p.vx = 1.66007664274403694e-03 * DAYS_PER_YEAR;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Jupiter,The following statement contains a magic number: p.vy = 7.69901118419740425e-03 * DAYS_PER_YEAR;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Jupiter,The following statement contains a magic number: p.vz = -6.90460016972063023e-05 * DAYS_PER_YEAR;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Jupiter,The following statement contains a magic number: p.mass = 9.54791938424326609e-04 * SOLAR_MASS;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Saturn,The following statement contains a magic number: p.x = 8.34336671824457987e+00;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Saturn,The following statement contains a magic number: p.y = 4.12479856412430479e+00;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Saturn,The following statement contains a magic number: p.z = -4.03523417114321381e-01;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Saturn,The following statement contains a magic number: p.vx = -2.76742510726862411e-03 * DAYS_PER_YEAR;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Saturn,The following statement contains a magic number: p.vy = 4.99852801234917238e-03 * DAYS_PER_YEAR;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Saturn,The following statement contains a magic number: p.vz = 2.30417297573763929e-05 * DAYS_PER_YEAR;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Saturn,The following statement contains a magic number: p.mass = 2.85885980666130812e-04 * SOLAR_MASS;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Uranus,The following statement contains a magic number: p.x = 1.28943695621391310e+01;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Uranus,The following statement contains a magic number: p.y = -1.51111514016986312e+01;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Uranus,The following statement contains a magic number: p.z = -2.23307578892655734e-01;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Uranus,The following statement contains a magic number: p.vx = 2.96460137564761618e-03 * DAYS_PER_YEAR;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Uranus,The following statement contains a magic number: p.vy = 2.37847173959480950e-03 * DAYS_PER_YEAR;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Uranus,The following statement contains a magic number: p.vz = -2.96589568540237556e-05 * DAYS_PER_YEAR;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Uranus,The following statement contains a magic number: p.mass = 4.36624404335156298e-05 * SOLAR_MASS;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Neptune,The following statement contains a magic number: p.x = 1.53796971148509165e+01;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Neptune,The following statement contains a magic number: p.y = -2.59193146099879641e+01;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Neptune,The following statement contains a magic number: p.z = 1.79258772950371181e-01;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Neptune,The following statement contains a magic number: p.vx = 2.68067772490389322e-03 * DAYS_PER_YEAR;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Neptune,The following statement contains a magic number: p.vy = 1.62824170038242295e-03 * DAYS_PER_YEAR;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Neptune,The following statement contains a magic number: p.vz = -9.51592254519715870e-05 * DAYS_PER_YEAR;  
Magic Number,Benchmarks.Nbody,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\n-body.cs,Neptune,The following statement contains a magic number: p.mass = 5.15138902046611451e-05 * SOLAR_MASS;  
Magic Number,Benchmarks.BH,BH,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BH.cs,Main,The following statement contains a magic number: if (nbody < 2) {  	logger.InfoFormat ("Needs at least 2 bodies.");  	return;  }  
Magic Number,Benchmarks.BH,BH,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BH.cs,myRand,The following statement contains a magic number: seed = t - (2147483647.0 * Math.Floor (t / 2147483647.0));  
Magic Number,Benchmarks.BH,BH,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BH.cs,myRand,The following statement contains a magic number: seed = t - (2147483647.0 * Math.Floor (t / 2147483647.0));  
Magic Number,Benchmarks.BH,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\Body.cs,expandBox,The following statement contains a magic number: while (!inbox) {  	double rsize = tree.rsize;  	rmid.addScalar (tree.rmin' 0.5 * rsize);  	for (k = 0; k < MathVector.NDIM; k++) {  		if (pos.value (k) < rmid.value (k)) {  			double rmin = tree.rmin.value (k);  			tree.rmin.setValue (k' rmin - rsize);  		}  	}  	tree.rsize = 2.0 * rsize;  	if (tree.root != null) {  		MathVector ic = tree.intcoord (rmid);  		k = Node.oldSubindex (ic' Node.IMAX >> 1);  		Cell newt = Cell.makeCell ();  		newt.subp [k] = tree.root;  		tree.root = newt;  		inbox = icTest (tree);  	}  }  
Magic Number,Benchmarks.BH,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\Body.cs,expandBox,The following statement contains a magic number: while (!inbox) {  	double rsize = tree.rsize;  	rmid.addScalar (tree.rmin' 0.5 * rsize);  	for (k = 0; k < MathVector.NDIM; k++) {  		if (pos.value (k) < rmid.value (k)) {  			double rmin = tree.rmin.value (k);  			tree.rmin.setValue (k' rmin - rsize);  		}  	}  	tree.rsize = 2.0 * rsize;  	if (tree.root != null) {  		MathVector ic = tree.intcoord (rmid);  		k = Node.oldSubindex (ic' Node.IMAX >> 1);  		Cell newt = Cell.makeCell ();  		newt.subp [k] = tree.root;  		tree.root = newt;  		inbox = icTest (tree);  	}  }  
Magic Number,Benchmarks.BH,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\Body.cs,expandBox,The following statement contains a magic number: rmid.addScalar (tree.rmin' 0.5 * rsize);  
Magic Number,Benchmarks.BH,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\Body.cs,expandBox,The following statement contains a magic number: tree.rsize = 2.0 * rsize;  
Magic Number,Benchmarks.BH,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\Body.cs,icTest,The following statement contains a magic number: xsc = (pos2 - tree.rmin.value (2)) / tree.rsize;  
Magic Number,Benchmarks.BH,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\Body.cs,subindex,The following statement contains a magic number: xsc = (pos.value (2) - tree.rmin.value (2)) / tree.rsize;  
Magic Number,Benchmarks.BH,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\Body.cs,subindex,The following statement contains a magic number: xsc = (pos.value (2) - tree.rmin.value (2)) / tree.rsize;  
Magic Number,Benchmarks.BH,Body,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\Body.cs,subindex,The following statement contains a magic number: xp.setValue (2' Math.Floor (imxv * xsc));  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,makeTreeX,The following statement contains a magic number: t.rsize = -2.0 * -2.0;  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,makeTreeX,The following statement contains a magic number: t.rsize = -2.0 * -2.0;  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,makeTreeX,The following statement contains a magic number: t.rmin.setValue (0' -2.0);  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,makeTreeX,The following statement contains a magic number: t.rmin.setValue (1' -2.0);  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,makeTreeX,The following statement contains a magic number: t.rmin.setValue (2' -2.0);  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,makeTreeX,The following statement contains a magic number: t.rmin.setValue (2' -2.0);  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,createTestData,The following statement contains a magic number: for (int i = 0; i < nbody; i++) {  	Body p = Body.makeBody ();  	bodyTab.Add (p);  	p.mass = 1.0 / (double)nbody;  	seed = BH.myRand (seed);  	double t1 = BH.xRand (0.0' 0.999' seed);  	t1 = Math.Pow (t1' (-2.0 / 3.0)) - 1.0;  	double r = 1.0 / Math.Sqrt (t1);  	double coeff = 4.0;  	for (k = 0; k < MathVector.NDIM; k++) {  		seed = BH.myRand (seed);  		r = BH.xRand (0.0' 0.999' seed);  		p.pos.setValue (k' coeff * r);  	}  	cmr.addition (p.pos);  	double x = 0.0;  	double y = 0.0;  	do {  		seed = BH.myRand (seed);  		x = BH.xRand (0.0' 1.0' seed);  		seed = BH.myRand (seed);  		y = BH.xRand (0.0' 0.1' seed);  	} while (y > x * x * Math.Pow (1.0 - x * x' 3.5));  	double v = Math.Sqrt (2.0) * x / Math.Pow (1.0 + r * r' 0.25);  	double rad = vsc * v;  	double rsq = 0.0;  	do {  		for (k = 0; k < MathVector.NDIM; k++) {  			seed = BH.myRand (seed);  			p.vel.setValue (k' BH.xRand (-1.0' 1.0' seed));  		}  		rsq = p.vel.dotProduct ();  	} while (rsq > 1.0);  	double rsc1 = rad / Math.Sqrt (rsq);  	p.vel.multScalar1 (rsc1);  	cmv.addition (p.vel);  }  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,createTestData,The following statement contains a magic number: for (int i = 0; i < nbody; i++) {  	Body p = Body.makeBody ();  	bodyTab.Add (p);  	p.mass = 1.0 / (double)nbody;  	seed = BH.myRand (seed);  	double t1 = BH.xRand (0.0' 0.999' seed);  	t1 = Math.Pow (t1' (-2.0 / 3.0)) - 1.0;  	double r = 1.0 / Math.Sqrt (t1);  	double coeff = 4.0;  	for (k = 0; k < MathVector.NDIM; k++) {  		seed = BH.myRand (seed);  		r = BH.xRand (0.0' 0.999' seed);  		p.pos.setValue (k' coeff * r);  	}  	cmr.addition (p.pos);  	double x = 0.0;  	double y = 0.0;  	do {  		seed = BH.myRand (seed);  		x = BH.xRand (0.0' 1.0' seed);  		seed = BH.myRand (seed);  		y = BH.xRand (0.0' 0.1' seed);  	} while (y > x * x * Math.Pow (1.0 - x * x' 3.5));  	double v = Math.Sqrt (2.0) * x / Math.Pow (1.0 + r * r' 0.25);  	double rad = vsc * v;  	double rsq = 0.0;  	do {  		for (k = 0; k < MathVector.NDIM; k++) {  			seed = BH.myRand (seed);  			p.vel.setValue (k' BH.xRand (-1.0' 1.0' seed));  		}  		rsq = p.vel.dotProduct ();  	} while (rsq > 1.0);  	double rsc1 = rad / Math.Sqrt (rsq);  	p.vel.multScalar1 (rsc1);  	cmv.addition (p.vel);  }  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,createTestData,The following statement contains a magic number: for (int i = 0; i < nbody; i++) {  	Body p = Body.makeBody ();  	bodyTab.Add (p);  	p.mass = 1.0 / (double)nbody;  	seed = BH.myRand (seed);  	double t1 = BH.xRand (0.0' 0.999' seed);  	t1 = Math.Pow (t1' (-2.0 / 3.0)) - 1.0;  	double r = 1.0 / Math.Sqrt (t1);  	double coeff = 4.0;  	for (k = 0; k < MathVector.NDIM; k++) {  		seed = BH.myRand (seed);  		r = BH.xRand (0.0' 0.999' seed);  		p.pos.setValue (k' coeff * r);  	}  	cmr.addition (p.pos);  	double x = 0.0;  	double y = 0.0;  	do {  		seed = BH.myRand (seed);  		x = BH.xRand (0.0' 1.0' seed);  		seed = BH.myRand (seed);  		y = BH.xRand (0.0' 0.1' seed);  	} while (y > x * x * Math.Pow (1.0 - x * x' 3.5));  	double v = Math.Sqrt (2.0) * x / Math.Pow (1.0 + r * r' 0.25);  	double rad = vsc * v;  	double rsq = 0.0;  	do {  		for (k = 0; k < MathVector.NDIM; k++) {  			seed = BH.myRand (seed);  			p.vel.setValue (k' BH.xRand (-1.0' 1.0' seed));  		}  		rsq = p.vel.dotProduct ();  	} while (rsq > 1.0);  	double rsc1 = rad / Math.Sqrt (rsq);  	p.vel.multScalar1 (rsc1);  	cmv.addition (p.vel);  }  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,createTestData,The following statement contains a magic number: for (int i = 0; i < nbody; i++) {  	Body p = Body.makeBody ();  	bodyTab.Add (p);  	p.mass = 1.0 / (double)nbody;  	seed = BH.myRand (seed);  	double t1 = BH.xRand (0.0' 0.999' seed);  	t1 = Math.Pow (t1' (-2.0 / 3.0)) - 1.0;  	double r = 1.0 / Math.Sqrt (t1);  	double coeff = 4.0;  	for (k = 0; k < MathVector.NDIM; k++) {  		seed = BH.myRand (seed);  		r = BH.xRand (0.0' 0.999' seed);  		p.pos.setValue (k' coeff * r);  	}  	cmr.addition (p.pos);  	double x = 0.0;  	double y = 0.0;  	do {  		seed = BH.myRand (seed);  		x = BH.xRand (0.0' 1.0' seed);  		seed = BH.myRand (seed);  		y = BH.xRand (0.0' 0.1' seed);  	} while (y > x * x * Math.Pow (1.0 - x * x' 3.5));  	double v = Math.Sqrt (2.0) * x / Math.Pow (1.0 + r * r' 0.25);  	double rad = vsc * v;  	double rsq = 0.0;  	do {  		for (k = 0; k < MathVector.NDIM; k++) {  			seed = BH.myRand (seed);  			p.vel.setValue (k' BH.xRand (-1.0' 1.0' seed));  		}  		rsq = p.vel.dotProduct ();  	} while (rsq > 1.0);  	double rsc1 = rad / Math.Sqrt (rsq);  	p.vel.multScalar1 (rsc1);  	cmv.addition (p.vel);  }  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,createTestData,The following statement contains a magic number: for (int i = 0; i < nbody; i++) {  	Body p = Body.makeBody ();  	bodyTab.Add (p);  	p.mass = 1.0 / (double)nbody;  	seed = BH.myRand (seed);  	double t1 = BH.xRand (0.0' 0.999' seed);  	t1 = Math.Pow (t1' (-2.0 / 3.0)) - 1.0;  	double r = 1.0 / Math.Sqrt (t1);  	double coeff = 4.0;  	for (k = 0; k < MathVector.NDIM; k++) {  		seed = BH.myRand (seed);  		r = BH.xRand (0.0' 0.999' seed);  		p.pos.setValue (k' coeff * r);  	}  	cmr.addition (p.pos);  	double x = 0.0;  	double y = 0.0;  	do {  		seed = BH.myRand (seed);  		x = BH.xRand (0.0' 1.0' seed);  		seed = BH.myRand (seed);  		y = BH.xRand (0.0' 0.1' seed);  	} while (y > x * x * Math.Pow (1.0 - x * x' 3.5));  	double v = Math.Sqrt (2.0) * x / Math.Pow (1.0 + r * r' 0.25);  	double rad = vsc * v;  	double rsq = 0.0;  	do {  		for (k = 0; k < MathVector.NDIM; k++) {  			seed = BH.myRand (seed);  			p.vel.setValue (k' BH.xRand (-1.0' 1.0' seed));  		}  		rsq = p.vel.dotProduct ();  	} while (rsq > 1.0);  	double rsc1 = rad / Math.Sqrt (rsq);  	p.vel.multScalar1 (rsc1);  	cmv.addition (p.vel);  }  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,createTestData,The following statement contains a magic number: for (int i = 0; i < nbody; i++) {  	Body p = Body.makeBody ();  	bodyTab.Add (p);  	p.mass = 1.0 / (double)nbody;  	seed = BH.myRand (seed);  	double t1 = BH.xRand (0.0' 0.999' seed);  	t1 = Math.Pow (t1' (-2.0 / 3.0)) - 1.0;  	double r = 1.0 / Math.Sqrt (t1);  	double coeff = 4.0;  	for (k = 0; k < MathVector.NDIM; k++) {  		seed = BH.myRand (seed);  		r = BH.xRand (0.0' 0.999' seed);  		p.pos.setValue (k' coeff * r);  	}  	cmr.addition (p.pos);  	double x = 0.0;  	double y = 0.0;  	do {  		seed = BH.myRand (seed);  		x = BH.xRand (0.0' 1.0' seed);  		seed = BH.myRand (seed);  		y = BH.xRand (0.0' 0.1' seed);  	} while (y > x * x * Math.Pow (1.0 - x * x' 3.5));  	double v = Math.Sqrt (2.0) * x / Math.Pow (1.0 + r * r' 0.25);  	double rad = vsc * v;  	double rsq = 0.0;  	do {  		for (k = 0; k < MathVector.NDIM; k++) {  			seed = BH.myRand (seed);  			p.vel.setValue (k' BH.xRand (-1.0' 1.0' seed));  		}  		rsq = p.vel.dotProduct ();  	} while (rsq > 1.0);  	double rsc1 = rad / Math.Sqrt (rsq);  	p.vel.multScalar1 (rsc1);  	cmv.addition (p.vel);  }  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,createTestData,The following statement contains a magic number: for (int i = 0; i < nbody; i++) {  	Body p = Body.makeBody ();  	bodyTab.Add (p);  	p.mass = 1.0 / (double)nbody;  	seed = BH.myRand (seed);  	double t1 = BH.xRand (0.0' 0.999' seed);  	t1 = Math.Pow (t1' (-2.0 / 3.0)) - 1.0;  	double r = 1.0 / Math.Sqrt (t1);  	double coeff = 4.0;  	for (k = 0; k < MathVector.NDIM; k++) {  		seed = BH.myRand (seed);  		r = BH.xRand (0.0' 0.999' seed);  		p.pos.setValue (k' coeff * r);  	}  	cmr.addition (p.pos);  	double x = 0.0;  	double y = 0.0;  	do {  		seed = BH.myRand (seed);  		x = BH.xRand (0.0' 1.0' seed);  		seed = BH.myRand (seed);  		y = BH.xRand (0.0' 0.1' seed);  	} while (y > x * x * Math.Pow (1.0 - x * x' 3.5));  	double v = Math.Sqrt (2.0) * x / Math.Pow (1.0 + r * r' 0.25);  	double rad = vsc * v;  	double rsq = 0.0;  	do {  		for (k = 0; k < MathVector.NDIM; k++) {  			seed = BH.myRand (seed);  			p.vel.setValue (k' BH.xRand (-1.0' 1.0' seed));  		}  		rsq = p.vel.dotProduct ();  	} while (rsq > 1.0);  	double rsc1 = rad / Math.Sqrt (rsq);  	p.vel.multScalar1 (rsc1);  	cmv.addition (p.vel);  }  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,createTestData,The following statement contains a magic number: for (int i = 0; i < nbody; i++) {  	Body p = Body.makeBody ();  	bodyTab.Add (p);  	p.mass = 1.0 / (double)nbody;  	seed = BH.myRand (seed);  	double t1 = BH.xRand (0.0' 0.999' seed);  	t1 = Math.Pow (t1' (-2.0 / 3.0)) - 1.0;  	double r = 1.0 / Math.Sqrt (t1);  	double coeff = 4.0;  	for (k = 0; k < MathVector.NDIM; k++) {  		seed = BH.myRand (seed);  		r = BH.xRand (0.0' 0.999' seed);  		p.pos.setValue (k' coeff * r);  	}  	cmr.addition (p.pos);  	double x = 0.0;  	double y = 0.0;  	do {  		seed = BH.myRand (seed);  		x = BH.xRand (0.0' 1.0' seed);  		seed = BH.myRand (seed);  		y = BH.xRand (0.0' 0.1' seed);  	} while (y > x * x * Math.Pow (1.0 - x * x' 3.5));  	double v = Math.Sqrt (2.0) * x / Math.Pow (1.0 + r * r' 0.25);  	double rad = vsc * v;  	double rsq = 0.0;  	do {  		for (k = 0; k < MathVector.NDIM; k++) {  			seed = BH.myRand (seed);  			p.vel.setValue (k' BH.xRand (-1.0' 1.0' seed));  		}  		rsq = p.vel.dotProduct ();  	} while (rsq > 1.0);  	double rsc1 = rad / Math.Sqrt (rsq);  	p.vel.multScalar1 (rsc1);  	cmv.addition (p.vel);  }  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,createTestData,The following statement contains a magic number: for (int i = 0; i < nbody; i++) {  	Body p = Body.makeBody ();  	bodyTab.Add (p);  	p.mass = 1.0 / (double)nbody;  	seed = BH.myRand (seed);  	double t1 = BH.xRand (0.0' 0.999' seed);  	t1 = Math.Pow (t1' (-2.0 / 3.0)) - 1.0;  	double r = 1.0 / Math.Sqrt (t1);  	double coeff = 4.0;  	for (k = 0; k < MathVector.NDIM; k++) {  		seed = BH.myRand (seed);  		r = BH.xRand (0.0' 0.999' seed);  		p.pos.setValue (k' coeff * r);  	}  	cmr.addition (p.pos);  	double x = 0.0;  	double y = 0.0;  	do {  		seed = BH.myRand (seed);  		x = BH.xRand (0.0' 1.0' seed);  		seed = BH.myRand (seed);  		y = BH.xRand (0.0' 0.1' seed);  	} while (y > x * x * Math.Pow (1.0 - x * x' 3.5));  	double v = Math.Sqrt (2.0) * x / Math.Pow (1.0 + r * r' 0.25);  	double rad = vsc * v;  	double rsq = 0.0;  	do {  		for (k = 0; k < MathVector.NDIM; k++) {  			seed = BH.myRand (seed);  			p.vel.setValue (k' BH.xRand (-1.0' 1.0' seed));  		}  		rsq = p.vel.dotProduct ();  	} while (rsq > 1.0);  	double rsc1 = rad / Math.Sqrt (rsq);  	p.vel.multScalar1 (rsc1);  	cmv.addition (p.vel);  }  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,createTestData,The following statement contains a magic number: t1 = Math.Pow (t1' (-2.0 / 3.0)) - 1.0;  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,createTestData,The following statement contains a magic number: t1 = Math.Pow (t1' (-2.0 / 3.0)) - 1.0;  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,createTestData,The following statement contains a magic number: for (k = 0; k < MathVector.NDIM; k++) {  	seed = BH.myRand (seed);  	r = BH.xRand (0.0' 0.999' seed);  	p.pos.setValue (k' coeff * r);  }  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,createTestData,The following statement contains a magic number: r = BH.xRand (0.0' 0.999' seed);  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,createTestData,The following statement contains a magic number: do {  	seed = BH.myRand (seed);  	x = BH.xRand (0.0' 1.0' seed);  	seed = BH.myRand (seed);  	y = BH.xRand (0.0' 0.1' seed);  } while (y > x * x * Math.Pow (1.0 - x * x' 3.5));  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,createTestData,The following statement contains a magic number: do {  	seed = BH.myRand (seed);  	x = BH.xRand (0.0' 1.0' seed);  	seed = BH.myRand (seed);  	y = BH.xRand (0.0' 0.1' seed);  } while (y > x * x * Math.Pow (1.0 - x * x' 3.5));  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,createTestData,The following statement contains a magic number: y = BH.xRand (0.0' 0.1' seed);  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,makeTree,The following statement contains a magic number: for (int i = 2; i < this.bodyTabRev.Count; ++i) {  	Body q = this.bodyTabRev [i];  	if (q.mass != 0.0) {  		q.expandBox (this' nstep);  		MathVector xqic = intcoord (q.pos);  		root = root.loadTree (q' xqic' Node.IMAX >> 1' this);  	}  }  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,intcoord,The following statement contains a magic number: xsc = (vp.value (2) - rmin.value (2)) / rsize;  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,intcoord,The following statement contains a magic number: xsc = (vp.value (2) - rmin.value (2)) / rsize;  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,intcoord,The following statement contains a magic number: if (0.0 <= xsc && xsc < 1.0)  	xp.setValue (2' Math.Floor (imxv * xsc));  else  	return null;  
Magic Number,Benchmarks.BH,BTree,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\BTree.cs,intcoord,The following statement contains a magic number: xp.setValue (2' Math.Floor (imxv * xsc));  
Magic Number,Benchmarks.BH,Cell,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\Cell.cs,initCell,The following statement contains a magic number: Cell.NSUB = 8;  
Magic Number,Benchmarks.BH,Cell,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\Cell.cs,walkSubTree,The following statement contains a magic number: if (subdivp (dsq' hg)) {  	for (int k = 0; k < Cell.NSUB; k++) {  		Node r = this.subp [k];  		if (r != null)  			hg = r.walkSubTree (dsq / 4.0' hg);  	}  } else  	hg = gravSub (hg);  
Magic Number,Benchmarks.BH,Cell,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\Cell.cs,walkSubTree,The following statement contains a magic number: for (int k = 0; k < Cell.NSUB; k++) {  	Node r = this.subp [k];  	if (r != null)  		hg = r.walkSubTree (dsq / 4.0' hg);  }  
Magic Number,Benchmarks.BH,Cell,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\Cell.cs,walkSubTree,The following statement contains a magic number: if (r != null)  	hg = r.walkSubTree (dsq / 4.0' hg);  
Magic Number,Benchmarks.BH,Cell,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\Cell.cs,walkSubTree,The following statement contains a magic number: hg = r.walkSubTree (dsq / 4.0' hg);  
Magic Number,Benchmarks.BH,MathVector,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\MathVector.cs,crossProduct,The following statement contains a magic number: data [0] = u.data [1] * w.data [2] - u.data [2] * w.data [1];  
Magic Number,Benchmarks.BH,MathVector,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\MathVector.cs,crossProduct,The following statement contains a magic number: data [0] = u.data [1] * w.data [2] - u.data [2] * w.data [1];  
Magic Number,Benchmarks.BH,MathVector,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\MathVector.cs,crossProduct,The following statement contains a magic number: data [1] = u.data [2] * w.data [0] - u.data [0] * w.data [2];  
Magic Number,Benchmarks.BH,MathVector,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\MathVector.cs,crossProduct,The following statement contains a magic number: data [1] = u.data [2] * w.data [0] - u.data [0] * w.data [2];  
Magic Number,Benchmarks.BH,MathVector,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\MathVector.cs,crossProduct,The following statement contains a magic number: data [2] = u.data [0] * w.data [1] - u.data [1] * w.data [0];  
Magic Number,Benchmarks.BH,Node,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\Node.cs,staticInitNode,The following statement contains a magic number: Node.IMAX = 1073741824;  
Magic Number,Benchmarks.BH,Node,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BH\Node.cs,staticInitNode,The following statement contains a magic number: Node.EPS = 0.05;  
Magic Number,Benchmarks.BinaryTrees,BinaryTrees,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\binarytree.cs,Main,The following statement contains a magic number: for (int depth = minDepth; depth <= maxDepth; depth += 2) {  	int iterations = 1 << (maxDepth - depth + minDepth);  	check = 0;  	for (int i = 1; i <= iterations; i++) {  		check += (TreeNode.bottomUpTree (i' depth)).itemCheck ();  		check += (TreeNode.bottomUpTree (-i' depth)).itemCheck ();  	}  	logger.InfoFormat ("{0}\t trees of depth {1}\t check: {2}"' iterations * 2' depth' check);  }  
Magic Number,Benchmarks.BinaryTrees,BinaryTrees,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\binarytree.cs,Main,The following statement contains a magic number: for (int depth = minDepth; depth <= maxDepth; depth += 2) {  	int iterations = 1 << (maxDepth - depth + minDepth);  	check = 0;  	for (int i = 1; i <= iterations; i++) {  		check += (TreeNode.bottomUpTree (i' depth)).itemCheck ();  		check += (TreeNode.bottomUpTree (-i' depth)).itemCheck ();  	}  	logger.InfoFormat ("{0}\t trees of depth {1}\t check: {2}"' iterations * 2' depth' check);  }  
Magic Number,Benchmarks.BinaryTrees,BinaryTrees,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\binarytree.cs,Main,The following statement contains a magic number: depth += 2
Magic Number,Benchmarks.BinaryTrees,BinaryTrees,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\binarytree.cs,Main,The following statement contains a magic number: logger.InfoFormat ("{0}\t trees of depth {1}\t check: {2}"' iterations * 2' depth' check);  
Magic Number,Benchmarks.BiSort,Value,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BiSort\Value.cs,initValue,The following statement contains a magic number: Value.CONST_m1 = 10000;  
Magic Number,Benchmarks.BiSort,Value,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BiSort\Value.cs,initValue,The following statement contains a magic number: Value.CONST_b = 31415821;  
Magic Number,Benchmarks.BiSort,Value,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BiSort\Value.cs,initValue,The following statement contains a magic number: Value.RANGE = 100;  
Magic Number,Benchmarks.BiSort,Value,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BiSort\Value.cs,createTree,The following statement contains a magic number: if (size > 1) {  	seed = random (seed);  	int next_val = seed % RANGE;  	Value retval = Value.makeValue (next_val);  	retval.left = createTree (size / 2' seed);  	retval.right = createTree (size / 2' skiprand (seed' size + 1));  	return retval;  } else  	return null;  
Magic Number,Benchmarks.BiSort,Value,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BiSort\Value.cs,createTree,The following statement contains a magic number: if (size > 1) {  	seed = random (seed);  	int next_val = seed % RANGE;  	Value retval = Value.makeValue (next_val);  	retval.left = createTree (size / 2' seed);  	retval.right = createTree (size / 2' skiprand (seed' size + 1));  	return retval;  } else  	return null;  
Magic Number,Benchmarks.BiSort,Value,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BiSort\Value.cs,createTree,The following statement contains a magic number: retval.left = createTree (size / 2' seed);  
Magic Number,Benchmarks.BiSort,Value,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\BiSort\Value.cs,createTree,The following statement contains a magic number: retval.right = createTree (size / 2' skiprand (seed' size + 1));  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int i = 0; i < nx; i++) {  	for (int j = 0; j < ny; j++) {  		for (int k = 0; k < nz; k++) {  			double xx = 20.0 / (nx - 1) * i - 10.0;  			double yy = 20.0 / (ny - 1) * j - 10.0;  			double zz = 20.0 / (nz - 1) * k - 10.0;  			p = new Sphere (new Vec (xx' yy' zz)' 3);  			p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  			p.surf.shine = 15.0;  			p.surf.ks = 1.5 - 1.0;  			p.surf.kt = 1.5 - 1.0;  			scene.Objects.Add (p);  		}  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int i = 0; i < nx; i++) {  	for (int j = 0; j < ny; j++) {  		for (int k = 0; k < nz; k++) {  			double xx = 20.0 / (nx - 1) * i - 10.0;  			double yy = 20.0 / (ny - 1) * j - 10.0;  			double zz = 20.0 / (nz - 1) * k - 10.0;  			p = new Sphere (new Vec (xx' yy' zz)' 3);  			p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  			p.surf.shine = 15.0;  			p.surf.ks = 1.5 - 1.0;  			p.surf.kt = 1.5 - 1.0;  			scene.Objects.Add (p);  		}  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int i = 0; i < nx; i++) {  	for (int j = 0; j < ny; j++) {  		for (int k = 0; k < nz; k++) {  			double xx = 20.0 / (nx - 1) * i - 10.0;  			double yy = 20.0 / (ny - 1) * j - 10.0;  			double zz = 20.0 / (nz - 1) * k - 10.0;  			p = new Sphere (new Vec (xx' yy' zz)' 3);  			p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  			p.surf.shine = 15.0;  			p.surf.ks = 1.5 - 1.0;  			p.surf.kt = 1.5 - 1.0;  			scene.Objects.Add (p);  		}  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int i = 0; i < nx; i++) {  	for (int j = 0; j < ny; j++) {  		for (int k = 0; k < nz; k++) {  			double xx = 20.0 / (nx - 1) * i - 10.0;  			double yy = 20.0 / (ny - 1) * j - 10.0;  			double zz = 20.0 / (nz - 1) * k - 10.0;  			p = new Sphere (new Vec (xx' yy' zz)' 3);  			p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  			p.surf.shine = 15.0;  			p.surf.ks = 1.5 - 1.0;  			p.surf.kt = 1.5 - 1.0;  			scene.Objects.Add (p);  		}  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int i = 0; i < nx; i++) {  	for (int j = 0; j < ny; j++) {  		for (int k = 0; k < nz; k++) {  			double xx = 20.0 / (nx - 1) * i - 10.0;  			double yy = 20.0 / (ny - 1) * j - 10.0;  			double zz = 20.0 / (nz - 1) * k - 10.0;  			p = new Sphere (new Vec (xx' yy' zz)' 3);  			p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  			p.surf.shine = 15.0;  			p.surf.ks = 1.5 - 1.0;  			p.surf.kt = 1.5 - 1.0;  			scene.Objects.Add (p);  		}  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int i = 0; i < nx; i++) {  	for (int j = 0; j < ny; j++) {  		for (int k = 0; k < nz; k++) {  			double xx = 20.0 / (nx - 1) * i - 10.0;  			double yy = 20.0 / (ny - 1) * j - 10.0;  			double zz = 20.0 / (nz - 1) * k - 10.0;  			p = new Sphere (new Vec (xx' yy' zz)' 3);  			p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  			p.surf.shine = 15.0;  			p.surf.ks = 1.5 - 1.0;  			p.surf.kt = 1.5 - 1.0;  			scene.Objects.Add (p);  		}  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int i = 0; i < nx; i++) {  	for (int j = 0; j < ny; j++) {  		for (int k = 0; k < nz; k++) {  			double xx = 20.0 / (nx - 1) * i - 10.0;  			double yy = 20.0 / (ny - 1) * j - 10.0;  			double zz = 20.0 / (nz - 1) * k - 10.0;  			p = new Sphere (new Vec (xx' yy' zz)' 3);  			p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  			p.surf.shine = 15.0;  			p.surf.ks = 1.5 - 1.0;  			p.surf.kt = 1.5 - 1.0;  			scene.Objects.Add (p);  		}  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int i = 0; i < nx; i++) {  	for (int j = 0; j < ny; j++) {  		for (int k = 0; k < nz; k++) {  			double xx = 20.0 / (nx - 1) * i - 10.0;  			double yy = 20.0 / (ny - 1) * j - 10.0;  			double zz = 20.0 / (nz - 1) * k - 10.0;  			p = new Sphere (new Vec (xx' yy' zz)' 3);  			p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  			p.surf.shine = 15.0;  			p.surf.ks = 1.5 - 1.0;  			p.surf.kt = 1.5 - 1.0;  			scene.Objects.Add (p);  		}  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int i = 0; i < nx; i++) {  	for (int j = 0; j < ny; j++) {  		for (int k = 0; k < nz; k++) {  			double xx = 20.0 / (nx - 1) * i - 10.0;  			double yy = 20.0 / (ny - 1) * j - 10.0;  			double zz = 20.0 / (nz - 1) * k - 10.0;  			p = new Sphere (new Vec (xx' yy' zz)' 3);  			p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  			p.surf.shine = 15.0;  			p.surf.ks = 1.5 - 1.0;  			p.surf.kt = 1.5 - 1.0;  			scene.Objects.Add (p);  		}  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int i = 0; i < nx; i++) {  	for (int j = 0; j < ny; j++) {  		for (int k = 0; k < nz; k++) {  			double xx = 20.0 / (nx - 1) * i - 10.0;  			double yy = 20.0 / (ny - 1) * j - 10.0;  			double zz = 20.0 / (nz - 1) * k - 10.0;  			p = new Sphere (new Vec (xx' yy' zz)' 3);  			p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  			p.surf.shine = 15.0;  			p.surf.ks = 1.5 - 1.0;  			p.surf.kt = 1.5 - 1.0;  			scene.Objects.Add (p);  		}  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int i = 0; i < nx; i++) {  	for (int j = 0; j < ny; j++) {  		for (int k = 0; k < nz; k++) {  			double xx = 20.0 / (nx - 1) * i - 10.0;  			double yy = 20.0 / (ny - 1) * j - 10.0;  			double zz = 20.0 / (nz - 1) * k - 10.0;  			p = new Sphere (new Vec (xx' yy' zz)' 3);  			p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  			p.surf.shine = 15.0;  			p.surf.ks = 1.5 - 1.0;  			p.surf.kt = 1.5 - 1.0;  			scene.Objects.Add (p);  		}  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int j = 0; j < ny; j++) {  	for (int k = 0; k < nz; k++) {  		double xx = 20.0 / (nx - 1) * i - 10.0;  		double yy = 20.0 / (ny - 1) * j - 10.0;  		double zz = 20.0 / (nz - 1) * k - 10.0;  		p = new Sphere (new Vec (xx' yy' zz)' 3);  		p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  		p.surf.shine = 15.0;  		p.surf.ks = 1.5 - 1.0;  		p.surf.kt = 1.5 - 1.0;  		scene.Objects.Add (p);  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int j = 0; j < ny; j++) {  	for (int k = 0; k < nz; k++) {  		double xx = 20.0 / (nx - 1) * i - 10.0;  		double yy = 20.0 / (ny - 1) * j - 10.0;  		double zz = 20.0 / (nz - 1) * k - 10.0;  		p = new Sphere (new Vec (xx' yy' zz)' 3);  		p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  		p.surf.shine = 15.0;  		p.surf.ks = 1.5 - 1.0;  		p.surf.kt = 1.5 - 1.0;  		scene.Objects.Add (p);  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int j = 0; j < ny; j++) {  	for (int k = 0; k < nz; k++) {  		double xx = 20.0 / (nx - 1) * i - 10.0;  		double yy = 20.0 / (ny - 1) * j - 10.0;  		double zz = 20.0 / (nz - 1) * k - 10.0;  		p = new Sphere (new Vec (xx' yy' zz)' 3);  		p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  		p.surf.shine = 15.0;  		p.surf.ks = 1.5 - 1.0;  		p.surf.kt = 1.5 - 1.0;  		scene.Objects.Add (p);  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int j = 0; j < ny; j++) {  	for (int k = 0; k < nz; k++) {  		double xx = 20.0 / (nx - 1) * i - 10.0;  		double yy = 20.0 / (ny - 1) * j - 10.0;  		double zz = 20.0 / (nz - 1) * k - 10.0;  		p = new Sphere (new Vec (xx' yy' zz)' 3);  		p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  		p.surf.shine = 15.0;  		p.surf.ks = 1.5 - 1.0;  		p.surf.kt = 1.5 - 1.0;  		scene.Objects.Add (p);  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int j = 0; j < ny; j++) {  	for (int k = 0; k < nz; k++) {  		double xx = 20.0 / (nx - 1) * i - 10.0;  		double yy = 20.0 / (ny - 1) * j - 10.0;  		double zz = 20.0 / (nz - 1) * k - 10.0;  		p = new Sphere (new Vec (xx' yy' zz)' 3);  		p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  		p.surf.shine = 15.0;  		p.surf.ks = 1.5 - 1.0;  		p.surf.kt = 1.5 - 1.0;  		scene.Objects.Add (p);  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int j = 0; j < ny; j++) {  	for (int k = 0; k < nz; k++) {  		double xx = 20.0 / (nx - 1) * i - 10.0;  		double yy = 20.0 / (ny - 1) * j - 10.0;  		double zz = 20.0 / (nz - 1) * k - 10.0;  		p = new Sphere (new Vec (xx' yy' zz)' 3);  		p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  		p.surf.shine = 15.0;  		p.surf.ks = 1.5 - 1.0;  		p.surf.kt = 1.5 - 1.0;  		scene.Objects.Add (p);  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int j = 0; j < ny; j++) {  	for (int k = 0; k < nz; k++) {  		double xx = 20.0 / (nx - 1) * i - 10.0;  		double yy = 20.0 / (ny - 1) * j - 10.0;  		double zz = 20.0 / (nz - 1) * k - 10.0;  		p = new Sphere (new Vec (xx' yy' zz)' 3);  		p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  		p.surf.shine = 15.0;  		p.surf.ks = 1.5 - 1.0;  		p.surf.kt = 1.5 - 1.0;  		scene.Objects.Add (p);  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int j = 0; j < ny; j++) {  	for (int k = 0; k < nz; k++) {  		double xx = 20.0 / (nx - 1) * i - 10.0;  		double yy = 20.0 / (ny - 1) * j - 10.0;  		double zz = 20.0 / (nz - 1) * k - 10.0;  		p = new Sphere (new Vec (xx' yy' zz)' 3);  		p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  		p.surf.shine = 15.0;  		p.surf.ks = 1.5 - 1.0;  		p.surf.kt = 1.5 - 1.0;  		scene.Objects.Add (p);  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int j = 0; j < ny; j++) {  	for (int k = 0; k < nz; k++) {  		double xx = 20.0 / (nx - 1) * i - 10.0;  		double yy = 20.0 / (ny - 1) * j - 10.0;  		double zz = 20.0 / (nz - 1) * k - 10.0;  		p = new Sphere (new Vec (xx' yy' zz)' 3);  		p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  		p.surf.shine = 15.0;  		p.surf.ks = 1.5 - 1.0;  		p.surf.kt = 1.5 - 1.0;  		scene.Objects.Add (p);  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int j = 0; j < ny; j++) {  	for (int k = 0; k < nz; k++) {  		double xx = 20.0 / (nx - 1) * i - 10.0;  		double yy = 20.0 / (ny - 1) * j - 10.0;  		double zz = 20.0 / (nz - 1) * k - 10.0;  		p = new Sphere (new Vec (xx' yy' zz)' 3);  		p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  		p.surf.shine = 15.0;  		p.surf.ks = 1.5 - 1.0;  		p.surf.kt = 1.5 - 1.0;  		scene.Objects.Add (p);  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int j = 0; j < ny; j++) {  	for (int k = 0; k < nz; k++) {  		double xx = 20.0 / (nx - 1) * i - 10.0;  		double yy = 20.0 / (ny - 1) * j - 10.0;  		double zz = 20.0 / (nz - 1) * k - 10.0;  		p = new Sphere (new Vec (xx' yy' zz)' 3);  		p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  		p.surf.shine = 15.0;  		p.surf.ks = 1.5 - 1.0;  		p.surf.kt = 1.5 - 1.0;  		scene.Objects.Add (p);  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int k = 0; k < nz; k++) {  	double xx = 20.0 / (nx - 1) * i - 10.0;  	double yy = 20.0 / (ny - 1) * j - 10.0;  	double zz = 20.0 / (nz - 1) * k - 10.0;  	p = new Sphere (new Vec (xx' yy' zz)' 3);  	p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  	p.surf.shine = 15.0;  	p.surf.ks = 1.5 - 1.0;  	p.surf.kt = 1.5 - 1.0;  	scene.Objects.Add (p);  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int k = 0; k < nz; k++) {  	double xx = 20.0 / (nx - 1) * i - 10.0;  	double yy = 20.0 / (ny - 1) * j - 10.0;  	double zz = 20.0 / (nz - 1) * k - 10.0;  	p = new Sphere (new Vec (xx' yy' zz)' 3);  	p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  	p.surf.shine = 15.0;  	p.surf.ks = 1.5 - 1.0;  	p.surf.kt = 1.5 - 1.0;  	scene.Objects.Add (p);  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int k = 0; k < nz; k++) {  	double xx = 20.0 / (nx - 1) * i - 10.0;  	double yy = 20.0 / (ny - 1) * j - 10.0;  	double zz = 20.0 / (nz - 1) * k - 10.0;  	p = new Sphere (new Vec (xx' yy' zz)' 3);  	p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  	p.surf.shine = 15.0;  	p.surf.ks = 1.5 - 1.0;  	p.surf.kt = 1.5 - 1.0;  	scene.Objects.Add (p);  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int k = 0; k < nz; k++) {  	double xx = 20.0 / (nx - 1) * i - 10.0;  	double yy = 20.0 / (ny - 1) * j - 10.0;  	double zz = 20.0 / (nz - 1) * k - 10.0;  	p = new Sphere (new Vec (xx' yy' zz)' 3);  	p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  	p.surf.shine = 15.0;  	p.surf.ks = 1.5 - 1.0;  	p.surf.kt = 1.5 - 1.0;  	scene.Objects.Add (p);  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int k = 0; k < nz; k++) {  	double xx = 20.0 / (nx - 1) * i - 10.0;  	double yy = 20.0 / (ny - 1) * j - 10.0;  	double zz = 20.0 / (nz - 1) * k - 10.0;  	p = new Sphere (new Vec (xx' yy' zz)' 3);  	p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  	p.surf.shine = 15.0;  	p.surf.ks = 1.5 - 1.0;  	p.surf.kt = 1.5 - 1.0;  	scene.Objects.Add (p);  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int k = 0; k < nz; k++) {  	double xx = 20.0 / (nx - 1) * i - 10.0;  	double yy = 20.0 / (ny - 1) * j - 10.0;  	double zz = 20.0 / (nz - 1) * k - 10.0;  	p = new Sphere (new Vec (xx' yy' zz)' 3);  	p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  	p.surf.shine = 15.0;  	p.surf.ks = 1.5 - 1.0;  	p.surf.kt = 1.5 - 1.0;  	scene.Objects.Add (p);  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int k = 0; k < nz; k++) {  	double xx = 20.0 / (nx - 1) * i - 10.0;  	double yy = 20.0 / (ny - 1) * j - 10.0;  	double zz = 20.0 / (nz - 1) * k - 10.0;  	p = new Sphere (new Vec (xx' yy' zz)' 3);  	p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  	p.surf.shine = 15.0;  	p.surf.ks = 1.5 - 1.0;  	p.surf.kt = 1.5 - 1.0;  	scene.Objects.Add (p);  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int k = 0; k < nz; k++) {  	double xx = 20.0 / (nx - 1) * i - 10.0;  	double yy = 20.0 / (ny - 1) * j - 10.0;  	double zz = 20.0 / (nz - 1) * k - 10.0;  	p = new Sphere (new Vec (xx' yy' zz)' 3);  	p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  	p.surf.shine = 15.0;  	p.surf.ks = 1.5 - 1.0;  	p.surf.kt = 1.5 - 1.0;  	scene.Objects.Add (p);  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int k = 0; k < nz; k++) {  	double xx = 20.0 / (nx - 1) * i - 10.0;  	double yy = 20.0 / (ny - 1) * j - 10.0;  	double zz = 20.0 / (nz - 1) * k - 10.0;  	p = new Sphere (new Vec (xx' yy' zz)' 3);  	p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  	p.surf.shine = 15.0;  	p.surf.ks = 1.5 - 1.0;  	p.surf.kt = 1.5 - 1.0;  	scene.Objects.Add (p);  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int k = 0; k < nz; k++) {  	double xx = 20.0 / (nx - 1) * i - 10.0;  	double yy = 20.0 / (ny - 1) * j - 10.0;  	double zz = 20.0 / (nz - 1) * k - 10.0;  	p = new Sphere (new Vec (xx' yy' zz)' 3);  	p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  	p.surf.shine = 15.0;  	p.surf.ks = 1.5 - 1.0;  	p.surf.kt = 1.5 - 1.0;  	scene.Objects.Add (p);  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: for (int k = 0; k < nz; k++) {  	double xx = 20.0 / (nx - 1) * i - 10.0;  	double yy = 20.0 / (ny - 1) * j - 10.0;  	double zz = 20.0 / (nz - 1) * k - 10.0;  	p = new Sphere (new Vec (xx' yy' zz)' 3);  	p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  	p.surf.shine = 15.0;  	p.surf.ks = 1.5 - 1.0;  	p.surf.kt = 1.5 - 1.0;  	scene.Objects.Add (p);  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: p = new Sphere (new Vec (xx' yy' zz)' 3);  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: p.setColor (0' 0' (i + j) / (double)(nx + ny - 2));  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: p.surf.shine = 15.0;  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: p.surf.ks = 1.5 - 1.0;  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: p.surf.kt = 1.5 - 1.0;  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: scene.Lights.Add (new Light (100' 100' -50' 1.0));  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: scene.Lights.Add (new Light (100' 100' -50' 1.0));  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: scene.Lights.Add (new Light (100' 100' -50' 1.0));  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: scene.Lights.Add (new Light (-100' 100' -50' 1.0));  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: scene.Lights.Add (new Light (-100' 100' -50' 1.0));  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: scene.Lights.Add (new Light (-100' 100' -50' 1.0));  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: scene.Lights.Add (new Light (100' -100' -50' 1.0));  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: scene.Lights.Add (new Light (100' -100' -50' 1.0));  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: scene.Lights.Add (new Light (100' -100' -50' 1.0));  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: scene.Lights.Add (new Light (-100' -100' -50' 1.0));  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: scene.Lights.Add (new Light (-100' -100' -50' 1.0));  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: scene.Lights.Add (new Light (-100' -100' -50' 1.0));  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: scene.Lights.Add (new Light (200' 200' 0' 1.0));  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,createScene,The following statement contains a magic number: scene.Lights.Add (new Light (200' 200' 0' 1.0));  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (y = interval.yfrom; y < interval.yto; y++) {  	ylen = (double)(2.0 * y) / (double)interval.width - 1.0;  	for (x = 0; x < interval.width; x++) {  		xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  		r.D = Vec.comb (xlen' leftVec' ylen' upVec);  		r.D.add (viewVec);  		r.D.normalize ();  		col = trace (0' 1.0' r);  		// computes the color of the ray  		red = (int)(col.x * 255.0);  		if (red > 255)  			red = 255;  		green = (int)(col.y * 255.0);  		if (green > 255)  			green = 255;  		blue = (int)(col.z * 255.0);  		if (blue > 255)  			blue = 255;  		checksum += red;  		checksum += green;  		checksum += blue;  		// Sets the pixels  		row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  		pixCounter++;  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (y = interval.yfrom; y < interval.yto; y++) {  	ylen = (double)(2.0 * y) / (double)interval.width - 1.0;  	for (x = 0; x < interval.width; x++) {  		xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  		r.D = Vec.comb (xlen' leftVec' ylen' upVec);  		r.D.add (viewVec);  		r.D.normalize ();  		col = trace (0' 1.0' r);  		// computes the color of the ray  		red = (int)(col.x * 255.0);  		if (red > 255)  			red = 255;  		green = (int)(col.y * 255.0);  		if (green > 255)  			green = 255;  		blue = (int)(col.z * 255.0);  		if (blue > 255)  			blue = 255;  		checksum += red;  		checksum += green;  		checksum += blue;  		// Sets the pixels  		row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  		pixCounter++;  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (y = interval.yfrom; y < interval.yto; y++) {  	ylen = (double)(2.0 * y) / (double)interval.width - 1.0;  	for (x = 0; x < interval.width; x++) {  		xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  		r.D = Vec.comb (xlen' leftVec' ylen' upVec);  		r.D.add (viewVec);  		r.D.normalize ();  		col = trace (0' 1.0' r);  		// computes the color of the ray  		red = (int)(col.x * 255.0);  		if (red > 255)  			red = 255;  		green = (int)(col.y * 255.0);  		if (green > 255)  			green = 255;  		blue = (int)(col.z * 255.0);  		if (blue > 255)  			blue = 255;  		checksum += red;  		checksum += green;  		checksum += blue;  		// Sets the pixels  		row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  		pixCounter++;  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (y = interval.yfrom; y < interval.yto; y++) {  	ylen = (double)(2.0 * y) / (double)interval.width - 1.0;  	for (x = 0; x < interval.width; x++) {  		xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  		r.D = Vec.comb (xlen' leftVec' ylen' upVec);  		r.D.add (viewVec);  		r.D.normalize ();  		col = trace (0' 1.0' r);  		// computes the color of the ray  		red = (int)(col.x * 255.0);  		if (red > 255)  			red = 255;  		green = (int)(col.y * 255.0);  		if (green > 255)  			green = 255;  		blue = (int)(col.z * 255.0);  		if (blue > 255)  			blue = 255;  		checksum += red;  		checksum += green;  		checksum += blue;  		// Sets the pixels  		row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  		pixCounter++;  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (y = interval.yfrom; y < interval.yto; y++) {  	ylen = (double)(2.0 * y) / (double)interval.width - 1.0;  	for (x = 0; x < interval.width; x++) {  		xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  		r.D = Vec.comb (xlen' leftVec' ylen' upVec);  		r.D.add (viewVec);  		r.D.normalize ();  		col = trace (0' 1.0' r);  		// computes the color of the ray  		red = (int)(col.x * 255.0);  		if (red > 255)  			red = 255;  		green = (int)(col.y * 255.0);  		if (green > 255)  			green = 255;  		blue = (int)(col.z * 255.0);  		if (blue > 255)  			blue = 255;  		checksum += red;  		checksum += green;  		checksum += blue;  		// Sets the pixels  		row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  		pixCounter++;  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (y = interval.yfrom; y < interval.yto; y++) {  	ylen = (double)(2.0 * y) / (double)interval.width - 1.0;  	for (x = 0; x < interval.width; x++) {  		xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  		r.D = Vec.comb (xlen' leftVec' ylen' upVec);  		r.D.add (viewVec);  		r.D.normalize ();  		col = trace (0' 1.0' r);  		// computes the color of the ray  		red = (int)(col.x * 255.0);  		if (red > 255)  			red = 255;  		green = (int)(col.y * 255.0);  		if (green > 255)  			green = 255;  		blue = (int)(col.z * 255.0);  		if (blue > 255)  			blue = 255;  		checksum += red;  		checksum += green;  		checksum += blue;  		// Sets the pixels  		row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  		pixCounter++;  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (y = interval.yfrom; y < interval.yto; y++) {  	ylen = (double)(2.0 * y) / (double)interval.width - 1.0;  	for (x = 0; x < interval.width; x++) {  		xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  		r.D = Vec.comb (xlen' leftVec' ylen' upVec);  		r.D.add (viewVec);  		r.D.normalize ();  		col = trace (0' 1.0' r);  		// computes the color of the ray  		red = (int)(col.x * 255.0);  		if (red > 255)  			red = 255;  		green = (int)(col.y * 255.0);  		if (green > 255)  			green = 255;  		blue = (int)(col.z * 255.0);  		if (blue > 255)  			blue = 255;  		checksum += red;  		checksum += green;  		checksum += blue;  		// Sets the pixels  		row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  		pixCounter++;  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (y = interval.yfrom; y < interval.yto; y++) {  	ylen = (double)(2.0 * y) / (double)interval.width - 1.0;  	for (x = 0; x < interval.width; x++) {  		xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  		r.D = Vec.comb (xlen' leftVec' ylen' upVec);  		r.D.add (viewVec);  		r.D.normalize ();  		col = trace (0' 1.0' r);  		// computes the color of the ray  		red = (int)(col.x * 255.0);  		if (red > 255)  			red = 255;  		green = (int)(col.y * 255.0);  		if (green > 255)  			green = 255;  		blue = (int)(col.z * 255.0);  		if (blue > 255)  			blue = 255;  		checksum += red;  		checksum += green;  		checksum += blue;  		// Sets the pixels  		row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  		pixCounter++;  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (y = interval.yfrom; y < interval.yto; y++) {  	ylen = (double)(2.0 * y) / (double)interval.width - 1.0;  	for (x = 0; x < interval.width; x++) {  		xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  		r.D = Vec.comb (xlen' leftVec' ylen' upVec);  		r.D.add (viewVec);  		r.D.normalize ();  		col = trace (0' 1.0' r);  		// computes the color of the ray  		red = (int)(col.x * 255.0);  		if (red > 255)  			red = 255;  		green = (int)(col.y * 255.0);  		if (green > 255)  			green = 255;  		blue = (int)(col.z * 255.0);  		if (blue > 255)  			blue = 255;  		checksum += red;  		checksum += green;  		checksum += blue;  		// Sets the pixels  		row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  		pixCounter++;  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (y = interval.yfrom; y < interval.yto; y++) {  	ylen = (double)(2.0 * y) / (double)interval.width - 1.0;  	for (x = 0; x < interval.width; x++) {  		xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  		r.D = Vec.comb (xlen' leftVec' ylen' upVec);  		r.D.add (viewVec);  		r.D.normalize ();  		col = trace (0' 1.0' r);  		// computes the color of the ray  		red = (int)(col.x * 255.0);  		if (red > 255)  			red = 255;  		green = (int)(col.y * 255.0);  		if (green > 255)  			green = 255;  		blue = (int)(col.z * 255.0);  		if (blue > 255)  			blue = 255;  		checksum += red;  		checksum += green;  		checksum += blue;  		// Sets the pixels  		row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  		pixCounter++;  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (y = interval.yfrom; y < interval.yto; y++) {  	ylen = (double)(2.0 * y) / (double)interval.width - 1.0;  	for (x = 0; x < interval.width; x++) {  		xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  		r.D = Vec.comb (xlen' leftVec' ylen' upVec);  		r.D.add (viewVec);  		r.D.normalize ();  		col = trace (0' 1.0' r);  		// computes the color of the ray  		red = (int)(col.x * 255.0);  		if (red > 255)  			red = 255;  		green = (int)(col.y * 255.0);  		if (green > 255)  			green = 255;  		blue = (int)(col.z * 255.0);  		if (blue > 255)  			blue = 255;  		checksum += red;  		checksum += green;  		checksum += blue;  		// Sets the pixels  		row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  		pixCounter++;  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (y = interval.yfrom; y < interval.yto; y++) {  	ylen = (double)(2.0 * y) / (double)interval.width - 1.0;  	for (x = 0; x < interval.width; x++) {  		xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  		r.D = Vec.comb (xlen' leftVec' ylen' upVec);  		r.D.add (viewVec);  		r.D.normalize ();  		col = trace (0' 1.0' r);  		// computes the color of the ray  		red = (int)(col.x * 255.0);  		if (red > 255)  			red = 255;  		green = (int)(col.y * 255.0);  		if (green > 255)  			green = 255;  		blue = (int)(col.z * 255.0);  		if (blue > 255)  			blue = 255;  		checksum += red;  		checksum += green;  		checksum += blue;  		// Sets the pixels  		row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  		pixCounter++;  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (y = interval.yfrom; y < interval.yto; y++) {  	ylen = (double)(2.0 * y) / (double)interval.width - 1.0;  	for (x = 0; x < interval.width; x++) {  		xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  		r.D = Vec.comb (xlen' leftVec' ylen' upVec);  		r.D.add (viewVec);  		r.D.normalize ();  		col = trace (0' 1.0' r);  		// computes the color of the ray  		red = (int)(col.x * 255.0);  		if (red > 255)  			red = 255;  		green = (int)(col.y * 255.0);  		if (green > 255)  			green = 255;  		blue = (int)(col.z * 255.0);  		if (blue > 255)  			blue = 255;  		checksum += red;  		checksum += green;  		checksum += blue;  		// Sets the pixels  		row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  		pixCounter++;  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: ylen = (double)(2.0 * y) / (double)interval.width - 1.0;  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (x = 0; x < interval.width; x++) {  	xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  	r.D = Vec.comb (xlen' leftVec' ylen' upVec);  	r.D.add (viewVec);  	r.D.normalize ();  	col = trace (0' 1.0' r);  	// computes the color of the ray  	red = (int)(col.x * 255.0);  	if (red > 255)  		red = 255;  	green = (int)(col.y * 255.0);  	if (green > 255)  		green = 255;  	blue = (int)(col.z * 255.0);  	if (blue > 255)  		blue = 255;  	checksum += red;  	checksum += green;  	checksum += blue;  	// Sets the pixels  	row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  	pixCounter++;  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (x = 0; x < interval.width; x++) {  	xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  	r.D = Vec.comb (xlen' leftVec' ylen' upVec);  	r.D.add (viewVec);  	r.D.normalize ();  	col = trace (0' 1.0' r);  	// computes the color of the ray  	red = (int)(col.x * 255.0);  	if (red > 255)  		red = 255;  	green = (int)(col.y * 255.0);  	if (green > 255)  		green = 255;  	blue = (int)(col.z * 255.0);  	if (blue > 255)  		blue = 255;  	checksum += red;  	checksum += green;  	checksum += blue;  	// Sets the pixels  	row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  	pixCounter++;  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (x = 0; x < interval.width; x++) {  	xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  	r.D = Vec.comb (xlen' leftVec' ylen' upVec);  	r.D.add (viewVec);  	r.D.normalize ();  	col = trace (0' 1.0' r);  	// computes the color of the ray  	red = (int)(col.x * 255.0);  	if (red > 255)  		red = 255;  	green = (int)(col.y * 255.0);  	if (green > 255)  		green = 255;  	blue = (int)(col.z * 255.0);  	if (blue > 255)  		blue = 255;  	checksum += red;  	checksum += green;  	checksum += blue;  	// Sets the pixels  	row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  	pixCounter++;  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (x = 0; x < interval.width; x++) {  	xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  	r.D = Vec.comb (xlen' leftVec' ylen' upVec);  	r.D.add (viewVec);  	r.D.normalize ();  	col = trace (0' 1.0' r);  	// computes the color of the ray  	red = (int)(col.x * 255.0);  	if (red > 255)  		red = 255;  	green = (int)(col.y * 255.0);  	if (green > 255)  		green = 255;  	blue = (int)(col.z * 255.0);  	if (blue > 255)  		blue = 255;  	checksum += red;  	checksum += green;  	checksum += blue;  	// Sets the pixels  	row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  	pixCounter++;  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (x = 0; x < interval.width; x++) {  	xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  	r.D = Vec.comb (xlen' leftVec' ylen' upVec);  	r.D.add (viewVec);  	r.D.normalize ();  	col = trace (0' 1.0' r);  	// computes the color of the ray  	red = (int)(col.x * 255.0);  	if (red > 255)  		red = 255;  	green = (int)(col.y * 255.0);  	if (green > 255)  		green = 255;  	blue = (int)(col.z * 255.0);  	if (blue > 255)  		blue = 255;  	checksum += red;  	checksum += green;  	checksum += blue;  	// Sets the pixels  	row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  	pixCounter++;  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (x = 0; x < interval.width; x++) {  	xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  	r.D = Vec.comb (xlen' leftVec' ylen' upVec);  	r.D.add (viewVec);  	r.D.normalize ();  	col = trace (0' 1.0' r);  	// computes the color of the ray  	red = (int)(col.x * 255.0);  	if (red > 255)  		red = 255;  	green = (int)(col.y * 255.0);  	if (green > 255)  		green = 255;  	blue = (int)(col.z * 255.0);  	if (blue > 255)  		blue = 255;  	checksum += red;  	checksum += green;  	checksum += blue;  	// Sets the pixels  	row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  	pixCounter++;  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (x = 0; x < interval.width; x++) {  	xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  	r.D = Vec.comb (xlen' leftVec' ylen' upVec);  	r.D.add (viewVec);  	r.D.normalize ();  	col = trace (0' 1.0' r);  	// computes the color of the ray  	red = (int)(col.x * 255.0);  	if (red > 255)  		red = 255;  	green = (int)(col.y * 255.0);  	if (green > 255)  		green = 255;  	blue = (int)(col.z * 255.0);  	if (blue > 255)  		blue = 255;  	checksum += red;  	checksum += green;  	checksum += blue;  	// Sets the pixels  	row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  	pixCounter++;  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (x = 0; x < interval.width; x++) {  	xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  	r.D = Vec.comb (xlen' leftVec' ylen' upVec);  	r.D.add (viewVec);  	r.D.normalize ();  	col = trace (0' 1.0' r);  	// computes the color of the ray  	red = (int)(col.x * 255.0);  	if (red > 255)  		red = 255;  	green = (int)(col.y * 255.0);  	if (green > 255)  		green = 255;  	blue = (int)(col.z * 255.0);  	if (blue > 255)  		blue = 255;  	checksum += red;  	checksum += green;  	checksum += blue;  	// Sets the pixels  	row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  	pixCounter++;  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (x = 0; x < interval.width; x++) {  	xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  	r.D = Vec.comb (xlen' leftVec' ylen' upVec);  	r.D.add (viewVec);  	r.D.normalize ();  	col = trace (0' 1.0' r);  	// computes the color of the ray  	red = (int)(col.x * 255.0);  	if (red > 255)  		red = 255;  	green = (int)(col.y * 255.0);  	if (green > 255)  		green = 255;  	blue = (int)(col.z * 255.0);  	if (blue > 255)  		blue = 255;  	checksum += red;  	checksum += green;  	checksum += blue;  	// Sets the pixels  	row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  	pixCounter++;  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (x = 0; x < interval.width; x++) {  	xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  	r.D = Vec.comb (xlen' leftVec' ylen' upVec);  	r.D.add (viewVec);  	r.D.normalize ();  	col = trace (0' 1.0' r);  	// computes the color of the ray  	red = (int)(col.x * 255.0);  	if (red > 255)  		red = 255;  	green = (int)(col.y * 255.0);  	if (green > 255)  		green = 255;  	blue = (int)(col.z * 255.0);  	if (blue > 255)  		blue = 255;  	checksum += red;  	checksum += green;  	checksum += blue;  	// Sets the pixels  	row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  	pixCounter++;  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (x = 0; x < interval.width; x++) {  	xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  	r.D = Vec.comb (xlen' leftVec' ylen' upVec);  	r.D.add (viewVec);  	r.D.normalize ();  	col = trace (0' 1.0' r);  	// computes the color of the ray  	red = (int)(col.x * 255.0);  	if (red > 255)  		red = 255;  	green = (int)(col.y * 255.0);  	if (green > 255)  		green = 255;  	blue = (int)(col.z * 255.0);  	if (blue > 255)  		blue = 255;  	checksum += red;  	checksum += green;  	checksum += blue;  	// Sets the pixels  	row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  	pixCounter++;  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: for (x = 0; x < interval.width; x++) {  	xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  	r.D = Vec.comb (xlen' leftVec' ylen' upVec);  	r.D.add (viewVec);  	r.D.normalize ();  	col = trace (0' 1.0' r);  	// computes the color of the ray  	red = (int)(col.x * 255.0);  	if (red > 255)  		red = 255;  	green = (int)(col.y * 255.0);  	if (green > 255)  		green = 255;  	blue = (int)(col.z * 255.0);  	if (blue > 255)  		blue = 255;  	checksum += red;  	checksum += green;  	checksum += blue;  	// Sets the pixels  	row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  	pixCounter++;  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: xlen = (double)(2.0 * x) / (double)interval.width - 1.0;  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: red = (int)(col.x * 255.0);  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: if (red > 255)  	red = 255;  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: if (red > 255)  	red = 255;  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: red = 255;  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: green = (int)(col.y * 255.0);  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: if (green > 255)  	green = 255;  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: if (green > 255)  	green = 255;  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: green = 255;  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: blue = (int)(col.z * 255.0);  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: if (blue > 255)  	blue = 255;  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: if (blue > 255)  	blue = 255;  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: blue = 255;  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,render,The following statement contains a magic number: row [pixCounter] = alpha | (red << 16) | (green << 8) | (blue);  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,intersect,The following statement contains a magic number: inter.t = 1e9;  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,SpecularDirection,The following statement contains a magic number: r = Vec.comb (1.0 / Math.Abs (Vec.dot (I' N))' I' 2.0' N);  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,shade,The following statement contains a magic number: if (surf.shine > 1e-6) {  	R = SpecularDirection (I' N);  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,shade,The following statement contains a magic number: for (l = 0; l < lights.Length; l++) {  	L.sub2 (lights [l].pos' P);  	if (Vec.dot (N' L) >= 0.0) {  		t = L.normalize ();  		tRay.P = P;  		tRay.D = L;  		// Checks if there is a shadow  		if (Shadow (tRay' t) > 0) {  			diff = Vec.dot (N' L) * surf.kd * lights [l].brightness;  			col.adds (diff' surf.color);  			if (surf.shine > 1e-6) {  				spec = Vec.dot (R' L);  				if (spec > 1e-6) {  					spec = Math.Pow (spec' surf.shine);  					col.x += spec;  					col.y += spec;  					col.z += spec;  				}  			}  		}  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,shade,The following statement contains a magic number: for (l = 0; l < lights.Length; l++) {  	L.sub2 (lights [l].pos' P);  	if (Vec.dot (N' L) >= 0.0) {  		t = L.normalize ();  		tRay.P = P;  		tRay.D = L;  		// Checks if there is a shadow  		if (Shadow (tRay' t) > 0) {  			diff = Vec.dot (N' L) * surf.kd * lights [l].brightness;  			col.adds (diff' surf.color);  			if (surf.shine > 1e-6) {  				spec = Vec.dot (R' L);  				if (spec > 1e-6) {  					spec = Math.Pow (spec' surf.shine);  					col.x += spec;  					col.y += spec;  					col.z += spec;  				}  			}  		}  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,shade,The following statement contains a magic number: if (Vec.dot (N' L) >= 0.0) {  	t = L.normalize ();  	tRay.P = P;  	tRay.D = L;  	// Checks if there is a shadow  	if (Shadow (tRay' t) > 0) {  		diff = Vec.dot (N' L) * surf.kd * lights [l].brightness;  		col.adds (diff' surf.color);  		if (surf.shine > 1e-6) {  			spec = Vec.dot (R' L);  			if (spec > 1e-6) {  				spec = Math.Pow (spec' surf.shine);  				col.x += spec;  				col.y += spec;  				col.z += spec;  			}  		}  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,shade,The following statement contains a magic number: if (Vec.dot (N' L) >= 0.0) {  	t = L.normalize ();  	tRay.P = P;  	tRay.D = L;  	// Checks if there is a shadow  	if (Shadow (tRay' t) > 0) {  		diff = Vec.dot (N' L) * surf.kd * lights [l].brightness;  		col.adds (diff' surf.color);  		if (surf.shine > 1e-6) {  			spec = Vec.dot (R' L);  			if (spec > 1e-6) {  				spec = Math.Pow (spec' surf.shine);  				col.x += spec;  				col.y += spec;  				col.z += spec;  			}  		}  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,shade,The following statement contains a magic number: if (Shadow (tRay' t) > 0) {  	diff = Vec.dot (N' L) * surf.kd * lights [l].brightness;  	col.adds (diff' surf.color);  	if (surf.shine > 1e-6) {  		spec = Vec.dot (R' L);  		if (spec > 1e-6) {  			spec = Math.Pow (spec' surf.shine);  			col.x += spec;  			col.y += spec;  			col.z += spec;  		}  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,shade,The following statement contains a magic number: if (Shadow (tRay' t) > 0) {  	diff = Vec.dot (N' L) * surf.kd * lights [l].brightness;  	col.adds (diff' surf.color);  	if (surf.shine > 1e-6) {  		spec = Vec.dot (R' L);  		if (spec > 1e-6) {  			spec = Math.Pow (spec' surf.shine);  			col.x += spec;  			col.y += spec;  			col.z += spec;  		}  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,shade,The following statement contains a magic number: if (surf.shine > 1e-6) {  	spec = Vec.dot (R' L);  	if (spec > 1e-6) {  		spec = Math.Pow (spec' surf.shine);  		col.x += spec;  		col.y += spec;  		col.z += spec;  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,shade,The following statement contains a magic number: if (surf.shine > 1e-6) {  	spec = Vec.dot (R' L);  	if (spec > 1e-6) {  		spec = Math.Pow (spec' surf.shine);  		col.x += spec;  		col.y += spec;  		col.z += spec;  	}  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,shade,The following statement contains a magic number: if (spec > 1e-6) {  	spec = Math.Pow (spec' surf.shine);  	col.x += spec;  	col.y += spec;  	col.z += spec;  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,shade,The following statement contains a magic number: if (surf.ks * weight > 1e-3) {  	tRay.D = SpecularDirection (I' N);  	tcol = trace (level + 1' surf.ks * weight' tRay);  	col.adds (surf.ks' tcol);  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,shade,The following statement contains a magic number: if (surf.kt * weight > 1e-3) {  	if (hit.enter > 0)  		tRay.D = TransDir (null' surf' I' N);  	else  		tRay.D = TransDir (surf' null' I' N);  	tcol = trace (level + 1' surf.kt * weight' tRay);  	col.adds (surf.kt' tcol);  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,trace,The following statement contains a magic number: if (level > 6) {  	return new Vec ();  }  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,trace,The following statement contains a magic number: hit = intersect (r' 1e6);  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,validate,The following statement contains a magic number: refval [0] = 2676692;  
Magic Number,Benchmarks.GrandeTracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Raytracer.cs,validate,The following statement contains a magic number: refval [1] = 29827635;  
Magic Number,Benchmarks.GrandeTracer,Sphere,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Sphere.cs,intersect,The following statement contains a magic number: t = (b - disc < 1e-6) ? b + disc : b - disc;  
Magic Number,Benchmarks.GrandeTracer,Sphere,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Sphere.cs,intersect,The following statement contains a magic number: if (t < 1e-6) {  	return null;  }  
Magic Number,Benchmarks.GrandeTracer,Sphere,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\GrandeTracer\Sphere.cs,intersect,The following statement contains a magic number: ip.enter = Vec.dot (v' v) > r2 + 1e-6 ? 1 : 0;  
Magic Number,Benchmarks.Graph4,Node,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\graph4.cs,Main,The following statement contains a magic number: for (int i = 0; i < 30; ++i) {  	//otherRandomGraph (1000000' 128' r);  	randomGraph (20000' r);  }  
Magic Number,Benchmarks.Graph4,Node,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\graph4.cs,Main,The following statement contains a magic number: for (int i = 0; i < 30; ++i) {  	//otherRandomGraph (1000000' 128' r);  	randomGraph (20000' r);  }  
Magic Number,Benchmarks.Graph4,Node,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\graph4.cs,Main,The following statement contains a magic number: randomGraph (20000' r);  
Magic Number,Benchmarks.Graph8,Node,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\graph8.cs,Main,The following statement contains a magic number: for (int i = 0; i < 30; ++i) {  	//otherRandomGraph (1000000' 128' r);  	randomGraph (20000' r);  }  
Magic Number,Benchmarks.Graph8,Node,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\graph8.cs,Main,The following statement contains a magic number: for (int i = 0; i < 30; ++i) {  	//otherRandomGraph (1000000' 128' r);  	randomGraph (20000' r);  }  
Magic Number,Benchmarks.Graph8,Node,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\graph8.cs,Main,The following statement contains a magic number: randomGraph (20000' r);  
Magic Number,Benchmarks.Hash3,Hash3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\hash3.cs,Main,The following statement contains a magic number: for (int j = 0; j < 8; j++) {  	for (int i = 0; i < n; i++) {  		if (table.ContainsKey (v [i]))  			count++;  	}  }  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,putInHospital,The following statement contains a magic number: if (freePersonnel > 0) {  	freePersonnel = freePersonnel - 1;  	assess.Add (p);  	p.timeLeft = 3;  	p.time += 3;  } else {  	p.timeLeft = zillesTime;  	waiting.Add (p);  }  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,putInHospital,The following statement contains a magic number: if (freePersonnel > 0) {  	freePersonnel = freePersonnel - 1;  	assess.Add (p);  	p.timeLeft = 3;  	p.time += 3;  } else {  	p.timeLeft = zillesTime;  	waiting.Add (p);  }  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,putInHospital,The following statement contains a magic number: p.timeLeft = 3;  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,putInHospital,The following statement contains a magic number: p.time += 3;  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,checkPatientsAssess,The following statement contains a magic number: while (i < this.assess.Count) {  	Patient p = this.assess [i];  	p.timeLeft = p.timeLeft - 1;  	if (p.timeLeft == 0) {  		//inline stays here  		rand = Village.myRand (v.seed);  		v.seed = (int)(rand * Village.IM);  		stayhere = (rand > 0.1 || v.rootVillage);  		this.assess.RemoveAt (i);  		if (stayhere) {  			inside.Add (p);  			p.timeLeft = 10;  			p.time = p.timeLeft + 10;  		} else {  			freePersonnel = freePersonnel + 1;  			up.Add (p);  		}  	} else  		++i;  }  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,checkPatientsAssess,The following statement contains a magic number: while (i < this.assess.Count) {  	Patient p = this.assess [i];  	p.timeLeft = p.timeLeft - 1;  	if (p.timeLeft == 0) {  		//inline stays here  		rand = Village.myRand (v.seed);  		v.seed = (int)(rand * Village.IM);  		stayhere = (rand > 0.1 || v.rootVillage);  		this.assess.RemoveAt (i);  		if (stayhere) {  			inside.Add (p);  			p.timeLeft = 10;  			p.time = p.timeLeft + 10;  		} else {  			freePersonnel = freePersonnel + 1;  			up.Add (p);  		}  	} else  		++i;  }  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,checkPatientsAssess,The following statement contains a magic number: while (i < this.assess.Count) {  	Patient p = this.assess [i];  	p.timeLeft = p.timeLeft - 1;  	if (p.timeLeft == 0) {  		//inline stays here  		rand = Village.myRand (v.seed);  		v.seed = (int)(rand * Village.IM);  		stayhere = (rand > 0.1 || v.rootVillage);  		this.assess.RemoveAt (i);  		if (stayhere) {  			inside.Add (p);  			p.timeLeft = 10;  			p.time = p.timeLeft + 10;  		} else {  			freePersonnel = freePersonnel + 1;  			up.Add (p);  		}  	} else  		++i;  }  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,checkPatientsAssess,The following statement contains a magic number: if (p.timeLeft == 0) {  	//inline stays here  	rand = Village.myRand (v.seed);  	v.seed = (int)(rand * Village.IM);  	stayhere = (rand > 0.1 || v.rootVillage);  	this.assess.RemoveAt (i);  	if (stayhere) {  		inside.Add (p);  		p.timeLeft = 10;  		p.time = p.timeLeft + 10;  	} else {  		freePersonnel = freePersonnel + 1;  		up.Add (p);  	}  } else  	++i;  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,checkPatientsAssess,The following statement contains a magic number: if (p.timeLeft == 0) {  	//inline stays here  	rand = Village.myRand (v.seed);  	v.seed = (int)(rand * Village.IM);  	stayhere = (rand > 0.1 || v.rootVillage);  	this.assess.RemoveAt (i);  	if (stayhere) {  		inside.Add (p);  		p.timeLeft = 10;  		p.time = p.timeLeft + 10;  	} else {  		freePersonnel = freePersonnel + 1;  		up.Add (p);  	}  } else  	++i;  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,checkPatientsAssess,The following statement contains a magic number: if (p.timeLeft == 0) {  	//inline stays here  	rand = Village.myRand (v.seed);  	v.seed = (int)(rand * Village.IM);  	stayhere = (rand > 0.1 || v.rootVillage);  	this.assess.RemoveAt (i);  	if (stayhere) {  		inside.Add (p);  		p.timeLeft = 10;  		p.time = p.timeLeft + 10;  	} else {  		freePersonnel = freePersonnel + 1;  		up.Add (p);  	}  } else  	++i;  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,checkPatientsAssess,The following statement contains a magic number: stayhere = (rand > 0.1 || v.rootVillage);  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,checkPatientsAssess,The following statement contains a magic number: if (stayhere) {  	inside.Add (p);  	p.timeLeft = 10;  	p.time = p.timeLeft + 10;  } else {  	freePersonnel = freePersonnel + 1;  	up.Add (p);  }  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,checkPatientsAssess,The following statement contains a magic number: if (stayhere) {  	inside.Add (p);  	p.timeLeft = 10;  	p.time = p.timeLeft + 10;  } else {  	freePersonnel = freePersonnel + 1;  	up.Add (p);  }  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,checkPatientsAssess,The following statement contains a magic number: p.timeLeft = 10;  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,checkPatientsAssess,The following statement contains a magic number: p.time = p.timeLeft + 10;  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,checkPatientsWaiting,The following statement contains a magic number: while (i < this.waiting.Count) {  	Patient p = this.waiting [i];  	if (freePersonnel > 0) {  		freePersonnel = freePersonnel - 1;  		p.time = p.time + (3 + this.zillesTime - p.timeLeft);  		//health harmful  		p.timeLeft = 3;  		this.waiting.RemoveAt (i);  		assess.Add (p);  	} else  		++i;  }  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,checkPatientsWaiting,The following statement contains a magic number: while (i < this.waiting.Count) {  	Patient p = this.waiting [i];  	if (freePersonnel > 0) {  		freePersonnel = freePersonnel - 1;  		p.time = p.time + (3 + this.zillesTime - p.timeLeft);  		//health harmful  		p.timeLeft = 3;  		this.waiting.RemoveAt (i);  		assess.Add (p);  	} else  		++i;  }  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,checkPatientsWaiting,The following statement contains a magic number: if (freePersonnel > 0) {  	freePersonnel = freePersonnel - 1;  	p.time = p.time + (3 + this.zillesTime - p.timeLeft);  	//health harmful  	p.timeLeft = 3;  	this.waiting.RemoveAt (i);  	assess.Add (p);  } else  	++i;  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,checkPatientsWaiting,The following statement contains a magic number: if (freePersonnel > 0) {  	freePersonnel = freePersonnel - 1;  	p.time = p.time + (3 + this.zillesTime - p.timeLeft);  	//health harmful  	p.timeLeft = 3;  	this.waiting.RemoveAt (i);  	assess.Add (p);  } else  	++i;  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,checkPatientsWaiting,The following statement contains a magic number: p.time = p.time + (3 + this.zillesTime - p.timeLeft);  
Magic Number,Benchmarks.Health,Hospital,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Hospital.cs,checkPatientsWaiting,The following statement contains a magic number: p.timeLeft = 3;  
Magic Number,Benchmarks.Health,Village,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Village.cs,Village,The following statement contains a magic number: forward = new Village[4];  
Magic Number,Benchmarks.Health,Village,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Village.cs,initVillageStatic,The following statement contains a magic number: Village.IA = 16807;  
Magic Number,Benchmarks.Health,Village,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Village.cs,initVillageStatic,The following statement contains a magic number: Village.IM = 2147483647.0;  
Magic Number,Benchmarks.Health,Village,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Village.cs,initVillageStatic,The following statement contains a magic number: Village.IQ = 127773;  
Magic Number,Benchmarks.Health,Village,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Village.cs,initVillageStatic,The following statement contains a magic number: Village.IR = 2836;  
Magic Number,Benchmarks.Health,Village,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Village.cs,initVillageStatic,The following statement contains a magic number: Village.MASK = 123459876;  
Magic Number,Benchmarks.Health,Village,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Village.cs,staysHere,The following statement contains a magic number: return (rand > 0.1 || rootVillage);  
Magic Number,Benchmarks.Health,Village,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Village.cs,createVillage,The following statement contains a magic number: if (level == 0)  	return null;  else {  	Village village = new Village (level' label' isRootV' seed);  	for (int i = 3; i >= 0; i--) {  		Village child = createVillage (level - 1' (label * 4) + i + 1' false' seed);  		village.forward [i] = child;  	}  	return village;  }  
Magic Number,Benchmarks.Health,Village,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Village.cs,createVillage,The following statement contains a magic number: if (level == 0)  	return null;  else {  	Village village = new Village (level' label' isRootV' seed);  	for (int i = 3; i >= 0; i--) {  		Village child = createVillage (level - 1' (label * 4) + i + 1' false' seed);  		village.forward [i] = child;  	}  	return village;  }  
Magic Number,Benchmarks.Health,Village,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Village.cs,createVillage,The following statement contains a magic number: for (int i = 3; i >= 0; i--) {  	Village child = createVillage (level - 1' (label * 4) + i + 1' false' seed);  	village.forward [i] = child;  }  
Magic Number,Benchmarks.Health,Village,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Village.cs,createVillage,The following statement contains a magic number: for (int i = 3; i >= 0; i--) {  	Village child = createVillage (level - 1' (label * 4) + i + 1' false' seed);  	village.forward [i] = child;  }  
Magic Number,Benchmarks.Health,Village,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\health\Village.cs,generatePatient,The following statement contains a magic number: if (rand > 0.666)  	p = Patient.makePatient (this);  
Magic Number,Benchmarks.Lists,IntDeQueue,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\lists.cs,Reverse,The following statement contains a magic number: if (Count < 2)  	return;  
Magic Number,Benchmarks.Mandelbrot,Mandelbrot,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\mandelbrot.cs,Main,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	int bits = 0;  	int xcounter = 0;  	double Ci = 2.0 * y / height - 1.0;  	for (int x = 0; x < width; x++) {  		double Zr = 0.0;  		double Zi = 0.0;  		double Cr = 2.0 * x / width - 1.5;  		int i = maxiter;  		bits = bits << 1;  		do {  			double Tr = Zr * Zr - Zi * Zi + Cr;  			Zi = 2.0 * Zr * Zi + Ci;  			Zr = Tr;  			if (Zr * Zr + Zi * Zi > limit) {  				bits |= 1;  				break;  			}  		} while (--i > 0);  		if (++xcounter == 8) {  			s.WriteByte ((byte)(bits ^ 0xff));  			bits = 0;  			xcounter = 0;  		}  	}  	if (xcounter != 0)  		s.WriteByte ((byte)((bits << (8 - xcounter)) ^ 0xff));  }  
Magic Number,Benchmarks.Mandelbrot,Mandelbrot,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\mandelbrot.cs,Main,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	int bits = 0;  	int xcounter = 0;  	double Ci = 2.0 * y / height - 1.0;  	for (int x = 0; x < width; x++) {  		double Zr = 0.0;  		double Zi = 0.0;  		double Cr = 2.0 * x / width - 1.5;  		int i = maxiter;  		bits = bits << 1;  		do {  			double Tr = Zr * Zr - Zi * Zi + Cr;  			Zi = 2.0 * Zr * Zi + Ci;  			Zr = Tr;  			if (Zr * Zr + Zi * Zi > limit) {  				bits |= 1;  				break;  			}  		} while (--i > 0);  		if (++xcounter == 8) {  			s.WriteByte ((byte)(bits ^ 0xff));  			bits = 0;  			xcounter = 0;  		}  	}  	if (xcounter != 0)  		s.WriteByte ((byte)((bits << (8 - xcounter)) ^ 0xff));  }  
Magic Number,Benchmarks.Mandelbrot,Mandelbrot,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\mandelbrot.cs,Main,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	int bits = 0;  	int xcounter = 0;  	double Ci = 2.0 * y / height - 1.0;  	for (int x = 0; x < width; x++) {  		double Zr = 0.0;  		double Zi = 0.0;  		double Cr = 2.0 * x / width - 1.5;  		int i = maxiter;  		bits = bits << 1;  		do {  			double Tr = Zr * Zr - Zi * Zi + Cr;  			Zi = 2.0 * Zr * Zi + Ci;  			Zr = Tr;  			if (Zr * Zr + Zi * Zi > limit) {  				bits |= 1;  				break;  			}  		} while (--i > 0);  		if (++xcounter == 8) {  			s.WriteByte ((byte)(bits ^ 0xff));  			bits = 0;  			xcounter = 0;  		}  	}  	if (xcounter != 0)  		s.WriteByte ((byte)((bits << (8 - xcounter)) ^ 0xff));  }  
Magic Number,Benchmarks.Mandelbrot,Mandelbrot,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\mandelbrot.cs,Main,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	int bits = 0;  	int xcounter = 0;  	double Ci = 2.0 * y / height - 1.0;  	for (int x = 0; x < width; x++) {  		double Zr = 0.0;  		double Zi = 0.0;  		double Cr = 2.0 * x / width - 1.5;  		int i = maxiter;  		bits = bits << 1;  		do {  			double Tr = Zr * Zr - Zi * Zi + Cr;  			Zi = 2.0 * Zr * Zi + Ci;  			Zr = Tr;  			if (Zr * Zr + Zi * Zi > limit) {  				bits |= 1;  				break;  			}  		} while (--i > 0);  		if (++xcounter == 8) {  			s.WriteByte ((byte)(bits ^ 0xff));  			bits = 0;  			xcounter = 0;  		}  	}  	if (xcounter != 0)  		s.WriteByte ((byte)((bits << (8 - xcounter)) ^ 0xff));  }  
Magic Number,Benchmarks.Mandelbrot,Mandelbrot,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\mandelbrot.cs,Main,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	int bits = 0;  	int xcounter = 0;  	double Ci = 2.0 * y / height - 1.0;  	for (int x = 0; x < width; x++) {  		double Zr = 0.0;  		double Zi = 0.0;  		double Cr = 2.0 * x / width - 1.5;  		int i = maxiter;  		bits = bits << 1;  		do {  			double Tr = Zr * Zr - Zi * Zi + Cr;  			Zi = 2.0 * Zr * Zi + Ci;  			Zr = Tr;  			if (Zr * Zr + Zi * Zi > limit) {  				bits |= 1;  				break;  			}  		} while (--i > 0);  		if (++xcounter == 8) {  			s.WriteByte ((byte)(bits ^ 0xff));  			bits = 0;  			xcounter = 0;  		}  	}  	if (xcounter != 0)  		s.WriteByte ((byte)((bits << (8 - xcounter)) ^ 0xff));  }  
Magic Number,Benchmarks.Mandelbrot,Mandelbrot,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\mandelbrot.cs,Main,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	int bits = 0;  	int xcounter = 0;  	double Ci = 2.0 * y / height - 1.0;  	for (int x = 0; x < width; x++) {  		double Zr = 0.0;  		double Zi = 0.0;  		double Cr = 2.0 * x / width - 1.5;  		int i = maxiter;  		bits = bits << 1;  		do {  			double Tr = Zr * Zr - Zi * Zi + Cr;  			Zi = 2.0 * Zr * Zi + Ci;  			Zr = Tr;  			if (Zr * Zr + Zi * Zi > limit) {  				bits |= 1;  				break;  			}  		} while (--i > 0);  		if (++xcounter == 8) {  			s.WriteByte ((byte)(bits ^ 0xff));  			bits = 0;  			xcounter = 0;  		}  	}  	if (xcounter != 0)  		s.WriteByte ((byte)((bits << (8 - xcounter)) ^ 0xff));  }  
Magic Number,Benchmarks.Mandelbrot,Mandelbrot,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\mandelbrot.cs,Main,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	double Zr = 0.0;  	double Zi = 0.0;  	double Cr = 2.0 * x / width - 1.5;  	int i = maxiter;  	bits = bits << 1;  	do {  		double Tr = Zr * Zr - Zi * Zi + Cr;  		Zi = 2.0 * Zr * Zi + Ci;  		Zr = Tr;  		if (Zr * Zr + Zi * Zi > limit) {  			bits |= 1;  			break;  		}  	} while (--i > 0);  	if (++xcounter == 8) {  		s.WriteByte ((byte)(bits ^ 0xff));  		bits = 0;  		xcounter = 0;  	}  }  
Magic Number,Benchmarks.Mandelbrot,Mandelbrot,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\mandelbrot.cs,Main,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	double Zr = 0.0;  	double Zi = 0.0;  	double Cr = 2.0 * x / width - 1.5;  	int i = maxiter;  	bits = bits << 1;  	do {  		double Tr = Zr * Zr - Zi * Zi + Cr;  		Zi = 2.0 * Zr * Zi + Ci;  		Zr = Tr;  		if (Zr * Zr + Zi * Zi > limit) {  			bits |= 1;  			break;  		}  	} while (--i > 0);  	if (++xcounter == 8) {  		s.WriteByte ((byte)(bits ^ 0xff));  		bits = 0;  		xcounter = 0;  	}  }  
Magic Number,Benchmarks.Mandelbrot,Mandelbrot,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\mandelbrot.cs,Main,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	double Zr = 0.0;  	double Zi = 0.0;  	double Cr = 2.0 * x / width - 1.5;  	int i = maxiter;  	bits = bits << 1;  	do {  		double Tr = Zr * Zr - Zi * Zi + Cr;  		Zi = 2.0 * Zr * Zi + Ci;  		Zr = Tr;  		if (Zr * Zr + Zi * Zi > limit) {  			bits |= 1;  			break;  		}  	} while (--i > 0);  	if (++xcounter == 8) {  		s.WriteByte ((byte)(bits ^ 0xff));  		bits = 0;  		xcounter = 0;  	}  }  
Magic Number,Benchmarks.Mandelbrot,Mandelbrot,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\mandelbrot.cs,Main,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	double Zr = 0.0;  	double Zi = 0.0;  	double Cr = 2.0 * x / width - 1.5;  	int i = maxiter;  	bits = bits << 1;  	do {  		double Tr = Zr * Zr - Zi * Zi + Cr;  		Zi = 2.0 * Zr * Zi + Ci;  		Zr = Tr;  		if (Zr * Zr + Zi * Zi > limit) {  			bits |= 1;  			break;  		}  	} while (--i > 0);  	if (++xcounter == 8) {  		s.WriteByte ((byte)(bits ^ 0xff));  		bits = 0;  		xcounter = 0;  	}  }  
Magic Number,Benchmarks.Mandelbrot,Mandelbrot,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\mandelbrot.cs,Main,The following statement contains a magic number: do {  	double Tr = Zr * Zr - Zi * Zi + Cr;  	Zi = 2.0 * Zr * Zi + Ci;  	Zr = Tr;  	if (Zr * Zr + Zi * Zi > limit) {  		bits |= 1;  		break;  	}  } while (--i > 0);  
Magic Number,Benchmarks.Mandelbrot,Mandelbrot,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\mandelbrot.cs,Main,The following statement contains a magic number: Zi = 2.0 * Zr * Zi + Ci;  
Magic Number,Benchmarks.Mandelbrot,Mandelbrot,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\mandelbrot.cs,Main,The following statement contains a magic number: if (++xcounter == 8) {  	s.WriteByte ((byte)(bits ^ 0xff));  	bits = 0;  	xcounter = 0;  }  
Magic Number,Benchmarks.Mandelbrot,Mandelbrot,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\mandelbrot.cs,Main,The following statement contains a magic number: if (xcounter != 0)  	s.WriteByte ((byte)((bits << (8 - xcounter)) ^ 0xff));  
Magic Number,Benchmarks.Mandelbrot,Mandelbrot,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\mandelbrot.cs,Main,The following statement contains a magic number: s.WriteByte ((byte)((bits << (8 - xcounter)) ^ 0xff));  
Magic Number,Benchmarks.Objinst,Objinst,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\objinst.cs,Main,The following statement contains a magic number: for (int i = 0; i < 5; i++) {  	logger.InfoFormat ((toggle1.activate ().value ()) ? "true" : "false");  }  
Magic Number,Benchmarks.Objinst,Objinst,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\objinst.cs,Main,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	logger.InfoFormat ((ntoggle1.activate ().value ()) ? "true" : "false");  }  
Magic Number,Benchmarks.Objinst,Objinst,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\objinst.cs,Main,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	NthToggle toggle = new NthToggle (true' 3);  }  
Magic Number,Benchmarks.OneList,OneList,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\onelist.cs,Main,The following statement contains a magic number: MakeList (10000000);  
Magic Number,Benchmarks.Perimeter,GreyNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\GreyNode.cs,perimeter,The following statement contains a magic number: size = size / 2;  
Magic Number,Benchmarks.Perimeter,GreyNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\GreyNode.cs,sumAdjacent,The following statement contains a magic number: size = size / 2;  
Magic Number,Benchmarks.Perimeter,Perimeter,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\Perimeter.cs,Main,The following statement contains a magic number: QuadTreeNode.gcmp = size * 1024;  
Magic Number,Benchmarks.Perimeter,Perimeter,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\Perimeter.cs,Main,The following statement contains a magic number: QuadTreeNode.lcmp = msize * 1024;  
Magic Number,Benchmarks.Perimeter,QuadTreeNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\QuadTreeNode.cs,createTree,The following statement contains a magic number: size = size / 2;  
Magic Number,Benchmarks.Perimeter,QuadTreeNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\QuadTreeNode.cs,createTree,The following statement contains a magic number: if (intersect == 0 && size < 512) {  	node = new WhiteNode (quadrant' parent);  } else if (intersect == 2) {  	node = new BlackNode (quadrant' parent);  } else {  	if (level == 0) {  		node = new BlackNode (quadrant' parent);  	} else {  		node = new GreyNode (quadrant' parent);  		QuadTreeNode sw = createTree (size' center_x - size' center_y - size' node' Quadrant.cSouthWest' level - 1);  		QuadTreeNode se = createTree (size' center_x + size' center_y - size' node' Quadrant.cSouthEast' level - 1);  		QuadTreeNode ne = createTree (size' center_x + size' center_y + size' node' Quadrant.cNorthEast' level - 1);  		QuadTreeNode nw = createTree (size' center_x - size' center_y + size' node' Quadrant.cNorthWest' level - 1);  		node.setChildren (nw' ne' sw' se);  	}  }  
Magic Number,Benchmarks.Perimeter,QuadTreeNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\QuadTreeNode.cs,createTree,The following statement contains a magic number: if (intersect == 0 && size < 512) {  	node = new WhiteNode (quadrant' parent);  } else if (intersect == 2) {  	node = new BlackNode (quadrant' parent);  } else {  	if (level == 0) {  		node = new BlackNode (quadrant' parent);  	} else {  		node = new GreyNode (quadrant' parent);  		QuadTreeNode sw = createTree (size' center_x - size' center_y - size' node' Quadrant.cSouthWest' level - 1);  		QuadTreeNode se = createTree (size' center_x + size' center_y - size' node' Quadrant.cSouthEast' level - 1);  		QuadTreeNode ne = createTree (size' center_x + size' center_y + size' node' Quadrant.cNorthEast' level - 1);  		QuadTreeNode nw = createTree (size' center_x - size' center_y + size' node' Quadrant.cNorthWest' level - 1);  		node.setChildren (nw' ne' sw' se);  	}  }  
Magic Number,Benchmarks.Perimeter,QuadTreeNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\QuadTreeNode.cs,createTree,The following statement contains a magic number: if (intersect == 2) {  	node = new BlackNode (quadrant' parent);  } else {  	if (level == 0) {  		node = new BlackNode (quadrant' parent);  	} else {  		node = new GreyNode (quadrant' parent);  		QuadTreeNode sw = createTree (size' center_x - size' center_y - size' node' Quadrant.cSouthWest' level - 1);  		QuadTreeNode se = createTree (size' center_x + size' center_y - size' node' Quadrant.cSouthEast' level - 1);  		QuadTreeNode ne = createTree (size' center_x + size' center_y + size' node' Quadrant.cNorthEast' level - 1);  		QuadTreeNode nw = createTree (size' center_x - size' center_y + size' node' Quadrant.cNorthWest' level - 1);  		node.setChildren (nw' ne' sw' se);  	}  }  
Magic Number,Benchmarks.Perimeter,QuadTreeNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\QuadTreeNode.cs,checkIntersect,The following statement contains a magic number: if (checkOutside (center_x + size' center_y + size) == 0 && checkOutside (center_x + size' center_y - size) == 0 && checkOutside (center_x - size' center_y - size) == 0 && checkOutside (center_x - size' center_y + size) == 0) {  	return 2;  }  
Magic Number,Benchmarks.Perimeter,QuadTreeNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\QuadTreeNode.cs,checkIntersect,The following statement contains a magic number: return 2;  
Magic Number,Benchmarks.Perimeter,QuadTreeNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\QuadTreeNode.cs,checkIntersect,The following statement contains a magic number: if ((sum == 4) || (sum == -4)) {  	return 0;  }  
Magic Number,Benchmarks.Perimeter,QuadTreeNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Perimeter\QuadTreeNode.cs,checkIntersect,The following statement contains a magic number: if ((sum == 4) || (sum == -4)) {  	return 0;  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int y = n - 1; y >= 0; --y) {  	for (int x = 0; x < n; ++x) {  		double greyscale = 0.0;  		for (int dx = 0; dx < ss; ++dx) {  			for (int dy = 0; dy < ss; ++dy) {  				Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  				Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  				greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  			}  		}  		temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  		stream.Write (temp' 0' 1);  	}  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int y = n - 1; y >= 0; --y) {  	for (int x = 0; x < n; ++x) {  		double greyscale = 0.0;  		for (int dx = 0; dx < ss; ++dx) {  			for (int dy = 0; dy < ss; ++dy) {  				Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  				Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  				greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  			}  		}  		temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  		stream.Write (temp' 0' 1);  	}  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int y = n - 1; y >= 0; --y) {  	for (int x = 0; x < n; ++x) {  		double greyscale = 0.0;  		for (int dx = 0; dx < ss; ++dx) {  			for (int dy = 0; dy < ss; ++dy) {  				Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  				Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  				greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  			}  		}  		temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  		stream.Write (temp' 0' 1);  	}  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int y = n - 1; y >= 0; --y) {  	for (int x = 0; x < n; ++x) {  		double greyscale = 0.0;  		for (int dx = 0; dx < ss; ++dx) {  			for (int dy = 0; dy < ss; ++dy) {  				Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  				Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  				greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  			}  		}  		temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  		stream.Write (temp' 0' 1);  	}  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int y = n - 1; y >= 0; --y) {  	for (int x = 0; x < n; ++x) {  		double greyscale = 0.0;  		for (int dx = 0; dx < ss; ++dx) {  			for (int dy = 0; dy < ss; ++dy) {  				Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  				Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  				greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  			}  		}  		temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  		stream.Write (temp' 0' 1);  	}  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int y = n - 1; y >= 0; --y) {  	for (int x = 0; x < n; ++x) {  		double greyscale = 0.0;  		for (int dx = 0; dx < ss; ++dx) {  			for (int dy = 0; dy < ss; ++dy) {  				Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  				Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  				greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  			}  		}  		temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  		stream.Write (temp' 0' 1);  	}  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int y = n - 1; y >= 0; --y) {  	for (int x = 0; x < n; ++x) {  		double greyscale = 0.0;  		for (int dx = 0; dx < ss; ++dx) {  			for (int dy = 0; dy < ss; ++dy) {  				Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  				Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  				greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  			}  		}  		temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  		stream.Write (temp' 0' 1);  	}  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int x = 0; x < n; ++x) {  	double greyscale = 0.0;  	for (int dx = 0; dx < ss; ++dx) {  		for (int dy = 0; dy < ss; ++dy) {  			Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  			Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  			greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  		}  	}  	temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  	stream.Write (temp' 0' 1);  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int x = 0; x < n; ++x) {  	double greyscale = 0.0;  	for (int dx = 0; dx < ss; ++dx) {  		for (int dy = 0; dy < ss; ++dy) {  			Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  			Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  			greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  		}  	}  	temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  	stream.Write (temp' 0' 1);  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int x = 0; x < n; ++x) {  	double greyscale = 0.0;  	for (int dx = 0; dx < ss; ++dx) {  		for (int dy = 0; dy < ss; ++dy) {  			Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  			Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  			greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  		}  	}  	temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  	stream.Write (temp' 0' 1);  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int x = 0; x < n; ++x) {  	double greyscale = 0.0;  	for (int dx = 0; dx < ss; ++dx) {  		for (int dy = 0; dy < ss; ++dy) {  			Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  			Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  			greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  		}  	}  	temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  	stream.Write (temp' 0' 1);  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int x = 0; x < n; ++x) {  	double greyscale = 0.0;  	for (int dx = 0; dx < ss; ++dx) {  		for (int dy = 0; dy < ss; ++dy) {  			Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  			Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  			greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  		}  	}  	temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  	stream.Write (temp' 0' 1);  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int x = 0; x < n; ++x) {  	double greyscale = 0.0;  	for (int dx = 0; dx < ss; ++dx) {  		for (int dy = 0; dy < ss; ++dy) {  			Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  			Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  			greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  		}  	}  	temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  	stream.Write (temp' 0' 1);  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int x = 0; x < n; ++x) {  	double greyscale = 0.0;  	for (int dx = 0; dx < ss; ++dx) {  		for (int dy = 0; dy < ss; ++dy) {  			Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  			Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  			greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  		}  	}  	temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  	stream.Write (temp' 0' 1);  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int dx = 0; dx < ss; ++dx) {  	for (int dy = 0; dy < ss; ++dy) {  		Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  		Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  		greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  	}  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int dx = 0; dx < ss; ++dx) {  	for (int dy = 0; dy < ss; ++dy) {  		Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  		Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  		greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  	}  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int dx = 0; dx < ss; ++dx) {  	for (int dy = 0; dy < ss; ++dy) {  		Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  		Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  		greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  	}  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int dx = 0; dx < ss; ++dx) {  	for (int dy = 0; dy < ss; ++dy) {  		Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  		Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  		greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  	}  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int dx = 0; dx < ss; ++dx) {  	for (int dy = 0; dy < ss; ++dy) {  		Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  		Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  		greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  	}  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int dy = 0; dy < ss; ++dy) {  	Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  	Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  	greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int dy = 0; dy < ss; ++dy) {  	Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  	Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  	greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int dy = 0; dy < ss; ++dy) {  	Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  	Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  	greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int dy = 0; dy < ss; ++dy) {  	Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  	Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  	greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: for (int dy = 0; dy < ss; ++dy) {  	Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  	Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  	greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  }  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  
Magic Number,Benchmarks.Raytracer2,RayTracer2,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer2.cs,Main,The following statement contains a magic number: temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int y = n - 1; y >= 0; --y) {  	for (int x = 0; x < n; ++x) {  		double greyscale = 0.0;  		for (int dx = 0; dx < ss; ++dx) {  			for (int dy = 0; dy < ss; ++dy) {  				Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  				Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  				greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  			}  		}  		temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  		stream.Write (temp' 0' 1);  	}  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int y = n - 1; y >= 0; --y) {  	for (int x = 0; x < n; ++x) {  		double greyscale = 0.0;  		for (int dx = 0; dx < ss; ++dx) {  			for (int dy = 0; dy < ss; ++dy) {  				Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  				Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  				greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  			}  		}  		temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  		stream.Write (temp' 0' 1);  	}  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int y = n - 1; y >= 0; --y) {  	for (int x = 0; x < n; ++x) {  		double greyscale = 0.0;  		for (int dx = 0; dx < ss; ++dx) {  			for (int dy = 0; dy < ss; ++dy) {  				Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  				Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  				greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  			}  		}  		temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  		stream.Write (temp' 0' 1);  	}  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int y = n - 1; y >= 0; --y) {  	for (int x = 0; x < n; ++x) {  		double greyscale = 0.0;  		for (int dx = 0; dx < ss; ++dx) {  			for (int dy = 0; dy < ss; ++dy) {  				Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  				Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  				greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  			}  		}  		temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  		stream.Write (temp' 0' 1);  	}  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int y = n - 1; y >= 0; --y) {  	for (int x = 0; x < n; ++x) {  		double greyscale = 0.0;  		for (int dx = 0; dx < ss; ++dx) {  			for (int dy = 0; dy < ss; ++dy) {  				Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  				Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  				greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  			}  		}  		temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  		stream.Write (temp' 0' 1);  	}  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int y = n - 1; y >= 0; --y) {  	for (int x = 0; x < n; ++x) {  		double greyscale = 0.0;  		for (int dx = 0; dx < ss; ++dx) {  			for (int dy = 0; dy < ss; ++dy) {  				Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  				Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  				greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  			}  		}  		temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  		stream.Write (temp' 0' 1);  	}  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int y = n - 1; y >= 0; --y) {  	for (int x = 0; x < n; ++x) {  		double greyscale = 0.0;  		for (int dx = 0; dx < ss; ++dx) {  			for (int dy = 0; dy < ss; ++dy) {  				Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  				Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  				greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  			}  		}  		temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  		stream.Write (temp' 0' 1);  	}  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int x = 0; x < n; ++x) {  	double greyscale = 0.0;  	for (int dx = 0; dx < ss; ++dx) {  		for (int dy = 0; dy < ss; ++dy) {  			Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  			Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  			greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  		}  	}  	temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  	stream.Write (temp' 0' 1);  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int x = 0; x < n; ++x) {  	double greyscale = 0.0;  	for (int dx = 0; dx < ss; ++dx) {  		for (int dy = 0; dy < ss; ++dy) {  			Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  			Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  			greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  		}  	}  	temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  	stream.Write (temp' 0' 1);  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int x = 0; x < n; ++x) {  	double greyscale = 0.0;  	for (int dx = 0; dx < ss; ++dx) {  		for (int dy = 0; dy < ss; ++dy) {  			Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  			Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  			greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  		}  	}  	temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  	stream.Write (temp' 0' 1);  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int x = 0; x < n; ++x) {  	double greyscale = 0.0;  	for (int dx = 0; dx < ss; ++dx) {  		for (int dy = 0; dy < ss; ++dy) {  			Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  			Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  			greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  		}  	}  	temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  	stream.Write (temp' 0' 1);  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int x = 0; x < n; ++x) {  	double greyscale = 0.0;  	for (int dx = 0; dx < ss; ++dx) {  		for (int dy = 0; dy < ss; ++dy) {  			Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  			Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  			greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  		}  	}  	temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  	stream.Write (temp' 0' 1);  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int x = 0; x < n; ++x) {  	double greyscale = 0.0;  	for (int dx = 0; dx < ss; ++dx) {  		for (int dy = 0; dy < ss; ++dy) {  			Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  			Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  			greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  		}  	}  	temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  	stream.Write (temp' 0' 1);  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int x = 0; x < n; ++x) {  	double greyscale = 0.0;  	for (int dx = 0; dx < ss; ++dx) {  		for (int dy = 0; dy < ss; ++dy) {  			Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  			Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  			greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  		}  	}  	temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  	stream.Write (temp' 0' 1);  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int dx = 0; dx < ss; ++dx) {  	for (int dy = 0; dy < ss; ++dy) {  		Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  		Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  		greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  	}  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int dx = 0; dx < ss; ++dx) {  	for (int dy = 0; dy < ss; ++dy) {  		Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  		Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  		greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  	}  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int dx = 0; dx < ss; ++dx) {  	for (int dy = 0; dy < ss; ++dy) {  		Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  		Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  		greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  	}  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int dx = 0; dx < ss; ++dx) {  	for (int dy = 0; dy < ss; ++dy) {  		Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  		Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  		greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  	}  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int dx = 0; dx < ss; ++dx) {  	for (int dy = 0; dy < ss; ++dy) {  		Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  		Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  		greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  	}  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int dy = 0; dy < ss; ++dy) {  	Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  	Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  	greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int dy = 0; dy < ss; ++dy) {  	Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  	Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  	greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int dy = 0; dy < ss; ++dy) {  	Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  	Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  	greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int dy = 0; dy < ss; ++dy) {  	Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  	Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  	greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: for (int dy = 0; dy < ss; ++dy) {  	Vector v = new Vector (x + dx / (double)ss - n / 2.0' y + dy / (double)ss - n / 2.0' n);  	Ray ray = new Ray (new Vector (0.0' 0.0' -4.0)' v.Normalized ());  	greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  }  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: greyscale += scene.TraceRay (ray' new Vector (-1.0' -3.0' 2.0).Normalized ());  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  
Magic Number,Benchmarks.Raytracer3,RayTracer3,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\raytracer3.cs,Main,The following statement contains a magic number: temp [0] = (byte)(0.5 + 255.0 * greyscale / (ss * ss));  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,num_flops,The following statement contains a magic number: return (5.0 * Nd - 2) * logN + 2 * (Nd + 1);  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,num_flops,The following statement contains a magic number: return (5.0 * Nd - 2) * logN + 2 * (Nd + 1);  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,num_flops,The following statement contains a magic number: return (5.0 * Nd - 2) * logN + 2 * (Nd + 1);  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,log2,The following statement contains a magic number: for (int k = 1; k < n; k *= 2' log++)  	;  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,log2,The following statement contains a magic number: k *= 2
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int bit = 0' dual = 1; bit < logn; bit++' dual *= 2) {  	double w_real = 1.0;  	double w_imag = 0.0;  	double theta = 2.0 * direction * Math.PI / (2.0 * (double)dual);  	double s = Math.Sin (theta);  	double t = Math.Sin (theta / 2.0);  	double s2 = 2.0 * t * t;  	/* a = 0 */for (int b = 0; b < n; b += 2 * dual) {  		int i = 2 * b;  		int j = 2 * (b + dual);  		double wd_real = data [j];  		double wd_imag = data [j + 1];  		data [j] = data [i] - wd_real;  		data [j + 1] = data [i + 1] - wd_imag;  		data [i] += wd_real;  		data [i + 1] += wd_imag;  	}  	/* a = 1 .. (dual-1) */for (int a = 1; a < dual; a++) {  		/* trignometric recurrence for w-> exp(i theta) w */{  			double tmp_real = w_real - s * w_imag - s2 * w_real;  			double tmp_imag = w_imag + s * w_real - s2 * w_imag;  			w_real = tmp_real;  			w_imag = tmp_imag;  		}  		for (int b = 0; b < n; b += 2 * dual) {  			int i = 2 * (b + a);  			int j = 2 * (b + a + dual);  			double z1_real = data [j];  			double z1_imag = data [j + 1];  			double wd_real = w_real * z1_real - w_imag * z1_imag;  			double wd_imag = w_real * z1_imag + w_imag * z1_real;  			data [j] = data [i] - wd_real;  			data [j + 1] = data [i + 1] - wd_imag;  			data [i] += wd_real;  			data [i + 1] += wd_imag;  		}  	}  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int bit = 0' dual = 1; bit < logn; bit++' dual *= 2) {  	double w_real = 1.0;  	double w_imag = 0.0;  	double theta = 2.0 * direction * Math.PI / (2.0 * (double)dual);  	double s = Math.Sin (theta);  	double t = Math.Sin (theta / 2.0);  	double s2 = 2.0 * t * t;  	/* a = 0 */for (int b = 0; b < n; b += 2 * dual) {  		int i = 2 * b;  		int j = 2 * (b + dual);  		double wd_real = data [j];  		double wd_imag = data [j + 1];  		data [j] = data [i] - wd_real;  		data [j + 1] = data [i + 1] - wd_imag;  		data [i] += wd_real;  		data [i + 1] += wd_imag;  	}  	/* a = 1 .. (dual-1) */for (int a = 1; a < dual; a++) {  		/* trignometric recurrence for w-> exp(i theta) w */{  			double tmp_real = w_real - s * w_imag - s2 * w_real;  			double tmp_imag = w_imag + s * w_real - s2 * w_imag;  			w_real = tmp_real;  			w_imag = tmp_imag;  		}  		for (int b = 0; b < n; b += 2 * dual) {  			int i = 2 * (b + a);  			int j = 2 * (b + a + dual);  			double z1_real = data [j];  			double z1_imag = data [j + 1];  			double wd_real = w_real * z1_real - w_imag * z1_imag;  			double wd_imag = w_real * z1_imag + w_imag * z1_real;  			data [j] = data [i] - wd_real;  			data [j + 1] = data [i + 1] - wd_imag;  			data [i] += wd_real;  			data [i + 1] += wd_imag;  		}  	}  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int bit = 0' dual = 1; bit < logn; bit++' dual *= 2) {  	double w_real = 1.0;  	double w_imag = 0.0;  	double theta = 2.0 * direction * Math.PI / (2.0 * (double)dual);  	double s = Math.Sin (theta);  	double t = Math.Sin (theta / 2.0);  	double s2 = 2.0 * t * t;  	/* a = 0 */for (int b = 0; b < n; b += 2 * dual) {  		int i = 2 * b;  		int j = 2 * (b + dual);  		double wd_real = data [j];  		double wd_imag = data [j + 1];  		data [j] = data [i] - wd_real;  		data [j + 1] = data [i + 1] - wd_imag;  		data [i] += wd_real;  		data [i + 1] += wd_imag;  	}  	/* a = 1 .. (dual-1) */for (int a = 1; a < dual; a++) {  		/* trignometric recurrence for w-> exp(i theta) w */{  			double tmp_real = w_real - s * w_imag - s2 * w_real;  			double tmp_imag = w_imag + s * w_real - s2 * w_imag;  			w_real = tmp_real;  			w_imag = tmp_imag;  		}  		for (int b = 0; b < n; b += 2 * dual) {  			int i = 2 * (b + a);  			int j = 2 * (b + a + dual);  			double z1_real = data [j];  			double z1_imag = data [j + 1];  			double wd_real = w_real * z1_real - w_imag * z1_imag;  			double wd_imag = w_real * z1_imag + w_imag * z1_real;  			data [j] = data [i] - wd_real;  			data [j + 1] = data [i + 1] - wd_imag;  			data [i] += wd_real;  			data [i + 1] += wd_imag;  		}  	}  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int bit = 0' dual = 1; bit < logn; bit++' dual *= 2) {  	double w_real = 1.0;  	double w_imag = 0.0;  	double theta = 2.0 * direction * Math.PI / (2.0 * (double)dual);  	double s = Math.Sin (theta);  	double t = Math.Sin (theta / 2.0);  	double s2 = 2.0 * t * t;  	/* a = 0 */for (int b = 0; b < n; b += 2 * dual) {  		int i = 2 * b;  		int j = 2 * (b + dual);  		double wd_real = data [j];  		double wd_imag = data [j + 1];  		data [j] = data [i] - wd_real;  		data [j + 1] = data [i + 1] - wd_imag;  		data [i] += wd_real;  		data [i + 1] += wd_imag;  	}  	/* a = 1 .. (dual-1) */for (int a = 1; a < dual; a++) {  		/* trignometric recurrence for w-> exp(i theta) w */{  			double tmp_real = w_real - s * w_imag - s2 * w_real;  			double tmp_imag = w_imag + s * w_real - s2 * w_imag;  			w_real = tmp_real;  			w_imag = tmp_imag;  		}  		for (int b = 0; b < n; b += 2 * dual) {  			int i = 2 * (b + a);  			int j = 2 * (b + a + dual);  			double z1_real = data [j];  			double z1_imag = data [j + 1];  			double wd_real = w_real * z1_real - w_imag * z1_imag;  			double wd_imag = w_real * z1_imag + w_imag * z1_real;  			data [j] = data [i] - wd_real;  			data [j + 1] = data [i + 1] - wd_imag;  			data [i] += wd_real;  			data [i + 1] += wd_imag;  		}  	}  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int bit = 0' dual = 1; bit < logn; bit++' dual *= 2) {  	double w_real = 1.0;  	double w_imag = 0.0;  	double theta = 2.0 * direction * Math.PI / (2.0 * (double)dual);  	double s = Math.Sin (theta);  	double t = Math.Sin (theta / 2.0);  	double s2 = 2.0 * t * t;  	/* a = 0 */for (int b = 0; b < n; b += 2 * dual) {  		int i = 2 * b;  		int j = 2 * (b + dual);  		double wd_real = data [j];  		double wd_imag = data [j + 1];  		data [j] = data [i] - wd_real;  		data [j + 1] = data [i + 1] - wd_imag;  		data [i] += wd_real;  		data [i + 1] += wd_imag;  	}  	/* a = 1 .. (dual-1) */for (int a = 1; a < dual; a++) {  		/* trignometric recurrence for w-> exp(i theta) w */{  			double tmp_real = w_real - s * w_imag - s2 * w_real;  			double tmp_imag = w_imag + s * w_real - s2 * w_imag;  			w_real = tmp_real;  			w_imag = tmp_imag;  		}  		for (int b = 0; b < n; b += 2 * dual) {  			int i = 2 * (b + a);  			int j = 2 * (b + a + dual);  			double z1_real = data [j];  			double z1_imag = data [j + 1];  			double wd_real = w_real * z1_real - w_imag * z1_imag;  			double wd_imag = w_real * z1_imag + w_imag * z1_real;  			data [j] = data [i] - wd_real;  			data [j + 1] = data [i + 1] - wd_imag;  			data [i] += wd_real;  			data [i + 1] += wd_imag;  		}  	}  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int bit = 0' dual = 1; bit < logn; bit++' dual *= 2) {  	double w_real = 1.0;  	double w_imag = 0.0;  	double theta = 2.0 * direction * Math.PI / (2.0 * (double)dual);  	double s = Math.Sin (theta);  	double t = Math.Sin (theta / 2.0);  	double s2 = 2.0 * t * t;  	/* a = 0 */for (int b = 0; b < n; b += 2 * dual) {  		int i = 2 * b;  		int j = 2 * (b + dual);  		double wd_real = data [j];  		double wd_imag = data [j + 1];  		data [j] = data [i] - wd_real;  		data [j + 1] = data [i + 1] - wd_imag;  		data [i] += wd_real;  		data [i + 1] += wd_imag;  	}  	/* a = 1 .. (dual-1) */for (int a = 1; a < dual; a++) {  		/* trignometric recurrence for w-> exp(i theta) w */{  			double tmp_real = w_real - s * w_imag - s2 * w_real;  			double tmp_imag = w_imag + s * w_real - s2 * w_imag;  			w_real = tmp_real;  			w_imag = tmp_imag;  		}  		for (int b = 0; b < n; b += 2 * dual) {  			int i = 2 * (b + a);  			int j = 2 * (b + a + dual);  			double z1_real = data [j];  			double z1_imag = data [j + 1];  			double wd_real = w_real * z1_real - w_imag * z1_imag;  			double wd_imag = w_real * z1_imag + w_imag * z1_real;  			data [j] = data [i] - wd_real;  			data [j + 1] = data [i + 1] - wd_imag;  			data [i] += wd_real;  			data [i + 1] += wd_imag;  		}  	}  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int bit = 0' dual = 1; bit < logn; bit++' dual *= 2) {  	double w_real = 1.0;  	double w_imag = 0.0;  	double theta = 2.0 * direction * Math.PI / (2.0 * (double)dual);  	double s = Math.Sin (theta);  	double t = Math.Sin (theta / 2.0);  	double s2 = 2.0 * t * t;  	/* a = 0 */for (int b = 0; b < n; b += 2 * dual) {  		int i = 2 * b;  		int j = 2 * (b + dual);  		double wd_real = data [j];  		double wd_imag = data [j + 1];  		data [j] = data [i] - wd_real;  		data [j + 1] = data [i + 1] - wd_imag;  		data [i] += wd_real;  		data [i + 1] += wd_imag;  	}  	/* a = 1 .. (dual-1) */for (int a = 1; a < dual; a++) {  		/* trignometric recurrence for w-> exp(i theta) w */{  			double tmp_real = w_real - s * w_imag - s2 * w_real;  			double tmp_imag = w_imag + s * w_real - s2 * w_imag;  			w_real = tmp_real;  			w_imag = tmp_imag;  		}  		for (int b = 0; b < n; b += 2 * dual) {  			int i = 2 * (b + a);  			int j = 2 * (b + a + dual);  			double z1_real = data [j];  			double z1_imag = data [j + 1];  			double wd_real = w_real * z1_real - w_imag * z1_imag;  			double wd_imag = w_real * z1_imag + w_imag * z1_real;  			data [j] = data [i] - wd_real;  			data [j + 1] = data [i + 1] - wd_imag;  			data [i] += wd_real;  			data [i + 1] += wd_imag;  		}  	}  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int bit = 0' dual = 1; bit < logn; bit++' dual *= 2) {  	double w_real = 1.0;  	double w_imag = 0.0;  	double theta = 2.0 * direction * Math.PI / (2.0 * (double)dual);  	double s = Math.Sin (theta);  	double t = Math.Sin (theta / 2.0);  	double s2 = 2.0 * t * t;  	/* a = 0 */for (int b = 0; b < n; b += 2 * dual) {  		int i = 2 * b;  		int j = 2 * (b + dual);  		double wd_real = data [j];  		double wd_imag = data [j + 1];  		data [j] = data [i] - wd_real;  		data [j + 1] = data [i + 1] - wd_imag;  		data [i] += wd_real;  		data [i + 1] += wd_imag;  	}  	/* a = 1 .. (dual-1) */for (int a = 1; a < dual; a++) {  		/* trignometric recurrence for w-> exp(i theta) w */{  			double tmp_real = w_real - s * w_imag - s2 * w_real;  			double tmp_imag = w_imag + s * w_real - s2 * w_imag;  			w_real = tmp_real;  			w_imag = tmp_imag;  		}  		for (int b = 0; b < n; b += 2 * dual) {  			int i = 2 * (b + a);  			int j = 2 * (b + a + dual);  			double z1_real = data [j];  			double z1_imag = data [j + 1];  			double wd_real = w_real * z1_real - w_imag * z1_imag;  			double wd_imag = w_real * z1_imag + w_imag * z1_real;  			data [j] = data [i] - wd_real;  			data [j + 1] = data [i + 1] - wd_imag;  			data [i] += wd_real;  			data [i + 1] += wd_imag;  		}  	}  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int bit = 0' dual = 1; bit < logn; bit++' dual *= 2) {  	double w_real = 1.0;  	double w_imag = 0.0;  	double theta = 2.0 * direction * Math.PI / (2.0 * (double)dual);  	double s = Math.Sin (theta);  	double t = Math.Sin (theta / 2.0);  	double s2 = 2.0 * t * t;  	/* a = 0 */for (int b = 0; b < n; b += 2 * dual) {  		int i = 2 * b;  		int j = 2 * (b + dual);  		double wd_real = data [j];  		double wd_imag = data [j + 1];  		data [j] = data [i] - wd_real;  		data [j + 1] = data [i + 1] - wd_imag;  		data [i] += wd_real;  		data [i + 1] += wd_imag;  	}  	/* a = 1 .. (dual-1) */for (int a = 1; a < dual; a++) {  		/* trignometric recurrence for w-> exp(i theta) w */{  			double tmp_real = w_real - s * w_imag - s2 * w_real;  			double tmp_imag = w_imag + s * w_real - s2 * w_imag;  			w_real = tmp_real;  			w_imag = tmp_imag;  		}  		for (int b = 0; b < n; b += 2 * dual) {  			int i = 2 * (b + a);  			int j = 2 * (b + a + dual);  			double z1_real = data [j];  			double z1_imag = data [j + 1];  			double wd_real = w_real * z1_real - w_imag * z1_imag;  			double wd_imag = w_real * z1_imag + w_imag * z1_real;  			data [j] = data [i] - wd_real;  			data [j + 1] = data [i + 1] - wd_imag;  			data [i] += wd_real;  			data [i + 1] += wd_imag;  		}  	}  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int bit = 0' dual = 1; bit < logn; bit++' dual *= 2) {  	double w_real = 1.0;  	double w_imag = 0.0;  	double theta = 2.0 * direction * Math.PI / (2.0 * (double)dual);  	double s = Math.Sin (theta);  	double t = Math.Sin (theta / 2.0);  	double s2 = 2.0 * t * t;  	/* a = 0 */for (int b = 0; b < n; b += 2 * dual) {  		int i = 2 * b;  		int j = 2 * (b + dual);  		double wd_real = data [j];  		double wd_imag = data [j + 1];  		data [j] = data [i] - wd_real;  		data [j + 1] = data [i + 1] - wd_imag;  		data [i] += wd_real;  		data [i + 1] += wd_imag;  	}  	/* a = 1 .. (dual-1) */for (int a = 1; a < dual; a++) {  		/* trignometric recurrence for w-> exp(i theta) w */{  			double tmp_real = w_real - s * w_imag - s2 * w_real;  			double tmp_imag = w_imag + s * w_real - s2 * w_imag;  			w_real = tmp_real;  			w_imag = tmp_imag;  		}  		for (int b = 0; b < n; b += 2 * dual) {  			int i = 2 * (b + a);  			int j = 2 * (b + a + dual);  			double z1_real = data [j];  			double z1_imag = data [j + 1];  			double wd_real = w_real * z1_real - w_imag * z1_imag;  			double wd_imag = w_real * z1_imag + w_imag * z1_real;  			data [j] = data [i] - wd_real;  			data [j + 1] = data [i + 1] - wd_imag;  			data [i] += wd_real;  			data [i + 1] += wd_imag;  		}  	}  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int bit = 0' dual = 1; bit < logn; bit++' dual *= 2) {  	double w_real = 1.0;  	double w_imag = 0.0;  	double theta = 2.0 * direction * Math.PI / (2.0 * (double)dual);  	double s = Math.Sin (theta);  	double t = Math.Sin (theta / 2.0);  	double s2 = 2.0 * t * t;  	/* a = 0 */for (int b = 0; b < n; b += 2 * dual) {  		int i = 2 * b;  		int j = 2 * (b + dual);  		double wd_real = data [j];  		double wd_imag = data [j + 1];  		data [j] = data [i] - wd_real;  		data [j + 1] = data [i + 1] - wd_imag;  		data [i] += wd_real;  		data [i + 1] += wd_imag;  	}  	/* a = 1 .. (dual-1) */for (int a = 1; a < dual; a++) {  		/* trignometric recurrence for w-> exp(i theta) w */{  			double tmp_real = w_real - s * w_imag - s2 * w_real;  			double tmp_imag = w_imag + s * w_real - s2 * w_imag;  			w_real = tmp_real;  			w_imag = tmp_imag;  		}  		for (int b = 0; b < n; b += 2 * dual) {  			int i = 2 * (b + a);  			int j = 2 * (b + a + dual);  			double z1_real = data [j];  			double z1_imag = data [j + 1];  			double wd_real = w_real * z1_real - w_imag * z1_imag;  			double wd_imag = w_real * z1_imag + w_imag * z1_real;  			data [j] = data [i] - wd_real;  			data [j + 1] = data [i + 1] - wd_imag;  			data [i] += wd_real;  			data [i + 1] += wd_imag;  		}  	}  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: dual *= 2
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int b = 0; b < n; b += 2 * dual) {  	int i = 2 * b;  	int j = 2 * (b + dual);  	double wd_real = data [j];  	double wd_imag = data [j + 1];  	data [j] = data [i] - wd_real;  	data [j + 1] = data [i + 1] - wd_imag;  	data [i] += wd_real;  	data [i + 1] += wd_imag;  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int b = 0; b < n; b += 2 * dual) {  	int i = 2 * b;  	int j = 2 * (b + dual);  	double wd_real = data [j];  	double wd_imag = data [j + 1];  	data [j] = data [i] - wd_real;  	data [j + 1] = data [i + 1] - wd_imag;  	data [i] += wd_real;  	data [i + 1] += wd_imag;  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int b = 0; b < n; b += 2 * dual) {  	int i = 2 * b;  	int j = 2 * (b + dual);  	double wd_real = data [j];  	double wd_imag = data [j + 1];  	data [j] = data [i] - wd_real;  	data [j + 1] = data [i + 1] - wd_imag;  	data [i] += wd_real;  	data [i + 1] += wd_imag;  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: b += 2 * dual
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int a = 1; a < dual; a++) {  	/* trignometric recurrence for w-> exp(i theta) w */{  		double tmp_real = w_real - s * w_imag - s2 * w_real;  		double tmp_imag = w_imag + s * w_real - s2 * w_imag;  		w_real = tmp_real;  		w_imag = tmp_imag;  	}  	for (int b = 0; b < n; b += 2 * dual) {  		int i = 2 * (b + a);  		int j = 2 * (b + a + dual);  		double z1_real = data [j];  		double z1_imag = data [j + 1];  		double wd_real = w_real * z1_real - w_imag * z1_imag;  		double wd_imag = w_real * z1_imag + w_imag * z1_real;  		data [j] = data [i] - wd_real;  		data [j + 1] = data [i + 1] - wd_imag;  		data [i] += wd_real;  		data [i + 1] += wd_imag;  	}  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int a = 1; a < dual; a++) {  	/* trignometric recurrence for w-> exp(i theta) w */{  		double tmp_real = w_real - s * w_imag - s2 * w_real;  		double tmp_imag = w_imag + s * w_real - s2 * w_imag;  		w_real = tmp_real;  		w_imag = tmp_imag;  	}  	for (int b = 0; b < n; b += 2 * dual) {  		int i = 2 * (b + a);  		int j = 2 * (b + a + dual);  		double z1_real = data [j];  		double z1_imag = data [j + 1];  		double wd_real = w_real * z1_real - w_imag * z1_imag;  		double wd_imag = w_real * z1_imag + w_imag * z1_real;  		data [j] = data [i] - wd_real;  		data [j + 1] = data [i + 1] - wd_imag;  		data [i] += wd_real;  		data [i + 1] += wd_imag;  	}  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int a = 1; a < dual; a++) {  	/* trignometric recurrence for w-> exp(i theta) w */{  		double tmp_real = w_real - s * w_imag - s2 * w_real;  		double tmp_imag = w_imag + s * w_real - s2 * w_imag;  		w_real = tmp_real;  		w_imag = tmp_imag;  	}  	for (int b = 0; b < n; b += 2 * dual) {  		int i = 2 * (b + a);  		int j = 2 * (b + a + dual);  		double z1_real = data [j];  		double z1_imag = data [j + 1];  		double wd_real = w_real * z1_real - w_imag * z1_imag;  		double wd_imag = w_real * z1_imag + w_imag * z1_real;  		data [j] = data [i] - wd_real;  		data [j + 1] = data [i + 1] - wd_imag;  		data [i] += wd_real;  		data [i + 1] += wd_imag;  	}  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int b = 0; b < n; b += 2 * dual) {  	int i = 2 * (b + a);  	int j = 2 * (b + a + dual);  	double z1_real = data [j];  	double z1_imag = data [j + 1];  	double wd_real = w_real * z1_real - w_imag * z1_imag;  	double wd_imag = w_real * z1_imag + w_imag * z1_real;  	data [j] = data [i] - wd_real;  	data [j + 1] = data [i + 1] - wd_imag;  	data [i] += wd_real;  	data [i + 1] += wd_imag;  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int b = 0; b < n; b += 2 * dual) {  	int i = 2 * (b + a);  	int j = 2 * (b + a + dual);  	double z1_real = data [j];  	double z1_imag = data [j + 1];  	double wd_real = w_real * z1_real - w_imag * z1_imag;  	double wd_imag = w_real * z1_imag + w_imag * z1_real;  	data [j] = data [i] - wd_real;  	data [j + 1] = data [i + 1] - wd_imag;  	data [i] += wd_real;  	data [i + 1] += wd_imag;  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: for (int b = 0; b < n; b += 2 * dual) {  	int i = 2 * (b + a);  	int j = 2 * (b + a + dual);  	double z1_real = data [j];  	double z1_imag = data [j + 1];  	double wd_real = w_real * z1_real - w_imag * z1_imag;  	double wd_imag = w_real * z1_imag + w_imag * z1_real;  	data [j] = data [i] - wd_real;  	data [j + 1] = data [i + 1] - wd_imag;  	data [i] += wd_real;  	data [i + 1] += wd_imag;  }  
Magic Number,Benchmarks.SciMark,FFT,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\FFT.cs,transform_internal,The following statement contains a magic number: b += 2 * dual
Magic Number,Benchmarks.SciMark,LU,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\LU.cs,num_flops,The following statement contains a magic number: return (2.0 * Nd * Nd * Nd / 3.0);  
Magic Number,Benchmarks.SciMark,LU,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\LU.cs,num_flops,The following statement contains a magic number: return (2.0 * Nd * Nd * Nd / 3.0);  
Magic Number,Benchmarks.SciMark,MonteCarlo,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\MonteCarlo.cs,num_flops,The following statement contains a magic number: return ((double)Num_samples) * 4.0;  
Magic Number,Benchmarks.SciMark,MonteCarlo,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\MonteCarlo.cs,integrate,The following statement contains a magic number: return ((double)under_curve / Num_samples) * 4.0;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDouble,The following statement contains a magic number: lock (this) {  	int k;  	k = m [i] - m [j];  	if (k < 0)  		k += m1;  	m [j] = k;  	if (i == 0)  		i = 16;  	else  		i--;  	if (j == 0)  		j = 16;  	else  		j--;  	if (haveRange)  		return left + dm1 * (double)k * width;  	else  		return dm1 * (double)k;  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDouble,The following statement contains a magic number: lock (this) {  	int k;  	k = m [i] - m [j];  	if (k < 0)  		k += m1;  	m [j] = k;  	if (i == 0)  		i = 16;  	else  		i--;  	if (j == 0)  		j = 16;  	else  		j--;  	if (haveRange)  		return left + dm1 * (double)k * width;  	else  		return dm1 * (double)k;  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDouble,The following statement contains a magic number: if (i == 0)  	i = 16;  else  	i--;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDouble,The following statement contains a magic number: i = 16;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDouble,The following statement contains a magic number: if (j == 0)  	j = 16;  else  	j--;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDouble,The following statement contains a magic number: j = 16;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: lock (this) {  	int N = x.Length;  	int remainder = N & 3;  	if (haveRange) {  		for (int count = 0; count < N; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = left + dm1 * (double)k * width;  		}  	} else {  		for (int count = 0; count < remainder; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  		}  		for (int count = remainder; count < N; count += 4) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 1] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 2] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 3] = dm1 * (double)k;  		}  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: lock (this) {  	int N = x.Length;  	int remainder = N & 3;  	if (haveRange) {  		for (int count = 0; count < N; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = left + dm1 * (double)k * width;  		}  	} else {  		for (int count = 0; count < remainder; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  		}  		for (int count = remainder; count < N; count += 4) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 1] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 2] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 3] = dm1 * (double)k;  		}  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: lock (this) {  	int N = x.Length;  	int remainder = N & 3;  	if (haveRange) {  		for (int count = 0; count < N; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = left + dm1 * (double)k * width;  		}  	} else {  		for (int count = 0; count < remainder; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  		}  		for (int count = remainder; count < N; count += 4) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 1] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 2] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 3] = dm1 * (double)k;  		}  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: lock (this) {  	int N = x.Length;  	int remainder = N & 3;  	if (haveRange) {  		for (int count = 0; count < N; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = left + dm1 * (double)k * width;  		}  	} else {  		for (int count = 0; count < remainder; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  		}  		for (int count = remainder; count < N; count += 4) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 1] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 2] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 3] = dm1 * (double)k;  		}  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: lock (this) {  	int N = x.Length;  	int remainder = N & 3;  	if (haveRange) {  		for (int count = 0; count < N; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = left + dm1 * (double)k * width;  		}  	} else {  		for (int count = 0; count < remainder; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  		}  		for (int count = remainder; count < N; count += 4) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 1] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 2] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 3] = dm1 * (double)k;  		}  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: lock (this) {  	int N = x.Length;  	int remainder = N & 3;  	if (haveRange) {  		for (int count = 0; count < N; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = left + dm1 * (double)k * width;  		}  	} else {  		for (int count = 0; count < remainder; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  		}  		for (int count = remainder; count < N; count += 4) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 1] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 2] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 3] = dm1 * (double)k;  		}  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: lock (this) {  	int N = x.Length;  	int remainder = N & 3;  	if (haveRange) {  		for (int count = 0; count < N; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = left + dm1 * (double)k * width;  		}  	} else {  		for (int count = 0; count < remainder; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  		}  		for (int count = remainder; count < N; count += 4) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 1] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 2] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 3] = dm1 * (double)k;  		}  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: lock (this) {  	int N = x.Length;  	int remainder = N & 3;  	if (haveRange) {  		for (int count = 0; count < N; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = left + dm1 * (double)k * width;  		}  	} else {  		for (int count = 0; count < remainder; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  		}  		for (int count = remainder; count < N; count += 4) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 1] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 2] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 3] = dm1 * (double)k;  		}  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: lock (this) {  	int N = x.Length;  	int remainder = N & 3;  	if (haveRange) {  		for (int count = 0; count < N; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = left + dm1 * (double)k * width;  		}  	} else {  		for (int count = 0; count < remainder; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  		}  		for (int count = remainder; count < N; count += 4) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 1] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 2] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 3] = dm1 * (double)k;  		}  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: lock (this) {  	int N = x.Length;  	int remainder = N & 3;  	if (haveRange) {  		for (int count = 0; count < N; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = left + dm1 * (double)k * width;  		}  	} else {  		for (int count = 0; count < remainder; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  		}  		for (int count = remainder; count < N; count += 4) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 1] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 2] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 3] = dm1 * (double)k;  		}  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: lock (this) {  	int N = x.Length;  	int remainder = N & 3;  	if (haveRange) {  		for (int count = 0; count < N; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = left + dm1 * (double)k * width;  		}  	} else {  		for (int count = 0; count < remainder; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  		}  		for (int count = remainder; count < N; count += 4) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 1] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 2] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 3] = dm1 * (double)k;  		}  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: lock (this) {  	int N = x.Length;  	int remainder = N & 3;  	if (haveRange) {  		for (int count = 0; count < N; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = left + dm1 * (double)k * width;  		}  	} else {  		for (int count = 0; count < remainder; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  		}  		for (int count = remainder; count < N; count += 4) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 1] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 2] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 3] = dm1 * (double)k;  		}  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: lock (this) {  	int N = x.Length;  	int remainder = N & 3;  	if (haveRange) {  		for (int count = 0; count < N; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = left + dm1 * (double)k * width;  		}  	} else {  		for (int count = 0; count < remainder; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  		}  		for (int count = remainder; count < N; count += 4) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 1] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 2] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 3] = dm1 * (double)k;  		}  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: lock (this) {  	int N = x.Length;  	int remainder = N & 3;  	if (haveRange) {  		for (int count = 0; count < N; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = left + dm1 * (double)k * width;  		}  	} else {  		for (int count = 0; count < remainder; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  		}  		for (int count = remainder; count < N; count += 4) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 1] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 2] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 3] = dm1 * (double)k;  		}  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: lock (this) {  	int N = x.Length;  	int remainder = N & 3;  	if (haveRange) {  		for (int count = 0; count < N; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = left + dm1 * (double)k * width;  		}  	} else {  		for (int count = 0; count < remainder; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  		}  		for (int count = remainder; count < N; count += 4) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 1] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 2] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 3] = dm1 * (double)k;  		}  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: lock (this) {  	int N = x.Length;  	int remainder = N & 3;  	if (haveRange) {  		for (int count = 0; count < N; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = left + dm1 * (double)k * width;  		}  	} else {  		for (int count = 0; count < remainder; count++) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  		}  		for (int count = remainder; count < N; count += 4) {  			int k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 1] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 2] = dm1 * (double)k;  			k = m [i] - m [j];  			if (i == 0)  				i = 16;  			else  				i--;  			if (k < 0)  				k += m1;  			m [j] = k;  			if (j == 0)  				j = 16;  			else  				j--;  			x [count + 3] = dm1 * (double)k;  		}  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (haveRange) {  	for (int count = 0; count < N; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = left + dm1 * (double)k * width;  	}  } else {  	for (int count = 0; count < remainder; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  	}  	for (int count = remainder; count < N; count += 4) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 1] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 2] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 3] = dm1 * (double)k;  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (haveRange) {  	for (int count = 0; count < N; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = left + dm1 * (double)k * width;  	}  } else {  	for (int count = 0; count < remainder; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  	}  	for (int count = remainder; count < N; count += 4) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 1] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 2] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 3] = dm1 * (double)k;  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (haveRange) {  	for (int count = 0; count < N; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = left + dm1 * (double)k * width;  	}  } else {  	for (int count = 0; count < remainder; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  	}  	for (int count = remainder; count < N; count += 4) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 1] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 2] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 3] = dm1 * (double)k;  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (haveRange) {  	for (int count = 0; count < N; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = left + dm1 * (double)k * width;  	}  } else {  	for (int count = 0; count < remainder; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  	}  	for (int count = remainder; count < N; count += 4) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 1] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 2] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 3] = dm1 * (double)k;  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (haveRange) {  	for (int count = 0; count < N; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = left + dm1 * (double)k * width;  	}  } else {  	for (int count = 0; count < remainder; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  	}  	for (int count = remainder; count < N; count += 4) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 1] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 2] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 3] = dm1 * (double)k;  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (haveRange) {  	for (int count = 0; count < N; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = left + dm1 * (double)k * width;  	}  } else {  	for (int count = 0; count < remainder; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  	}  	for (int count = remainder; count < N; count += 4) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 1] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 2] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 3] = dm1 * (double)k;  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (haveRange) {  	for (int count = 0; count < N; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = left + dm1 * (double)k * width;  	}  } else {  	for (int count = 0; count < remainder; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  	}  	for (int count = remainder; count < N; count += 4) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 1] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 2] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 3] = dm1 * (double)k;  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (haveRange) {  	for (int count = 0; count < N; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = left + dm1 * (double)k * width;  	}  } else {  	for (int count = 0; count < remainder; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  	}  	for (int count = remainder; count < N; count += 4) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 1] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 2] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 3] = dm1 * (double)k;  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (haveRange) {  	for (int count = 0; count < N; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = left + dm1 * (double)k * width;  	}  } else {  	for (int count = 0; count < remainder; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  	}  	for (int count = remainder; count < N; count += 4) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 1] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 2] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 3] = dm1 * (double)k;  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (haveRange) {  	for (int count = 0; count < N; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = left + dm1 * (double)k * width;  	}  } else {  	for (int count = 0; count < remainder; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  	}  	for (int count = remainder; count < N; count += 4) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 1] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 2] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 3] = dm1 * (double)k;  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (haveRange) {  	for (int count = 0; count < N; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = left + dm1 * (double)k * width;  	}  } else {  	for (int count = 0; count < remainder; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  	}  	for (int count = remainder; count < N; count += 4) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 1] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 2] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 3] = dm1 * (double)k;  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (haveRange) {  	for (int count = 0; count < N; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = left + dm1 * (double)k * width;  	}  } else {  	for (int count = 0; count < remainder; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  	}  	for (int count = remainder; count < N; count += 4) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 1] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 2] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 3] = dm1 * (double)k;  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (haveRange) {  	for (int count = 0; count < N; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = left + dm1 * (double)k * width;  	}  } else {  	for (int count = 0; count < remainder; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  	}  	for (int count = remainder; count < N; count += 4) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 1] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 2] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 3] = dm1 * (double)k;  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (haveRange) {  	for (int count = 0; count < N; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = left + dm1 * (double)k * width;  	}  } else {  	for (int count = 0; count < remainder; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  	}  	for (int count = remainder; count < N; count += 4) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 1] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 2] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 3] = dm1 * (double)k;  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (haveRange) {  	for (int count = 0; count < N; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = left + dm1 * (double)k * width;  	}  } else {  	for (int count = 0; count < remainder; count++) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  	}  	for (int count = remainder; count < N; count += 4) {  		int k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 1] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 2] = dm1 * (double)k;  		k = m [i] - m [j];  		if (i == 0)  			i = 16;  		else  			i--;  		if (k < 0)  			k += m1;  		m [j] = k;  		if (j == 0)  			j = 16;  		else  			j--;  		x [count + 3] = dm1 * (double)k;  	}  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: for (int count = 0; count < N; count++) {  	int k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count] = left + dm1 * (double)k * width;  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: for (int count = 0; count < N; count++) {  	int k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count] = left + dm1 * (double)k * width;  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (i == 0)  	i = 16;  else  	i--;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: i = 16;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (j == 0)  	j = 16;  else  	j--;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: j = 16;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: for (int count = 0; count < remainder; count++) {  	int k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count] = dm1 * (double)k;  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: for (int count = 0; count < remainder; count++) {  	int k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count] = dm1 * (double)k;  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (i == 0)  	i = 16;  else  	i--;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: i = 16;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (j == 0)  	j = 16;  else  	j--;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: j = 16;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: for (int count = remainder; count < N; count += 4) {  	int k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 1] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 2] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 3] = dm1 * (double)k;  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: for (int count = remainder; count < N; count += 4) {  	int k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 1] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 2] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 3] = dm1 * (double)k;  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: for (int count = remainder; count < N; count += 4) {  	int k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 1] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 2] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 3] = dm1 * (double)k;  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: for (int count = remainder; count < N; count += 4) {  	int k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 1] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 2] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 3] = dm1 * (double)k;  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: for (int count = remainder; count < N; count += 4) {  	int k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 1] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 2] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 3] = dm1 * (double)k;  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: for (int count = remainder; count < N; count += 4) {  	int k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 1] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 2] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 3] = dm1 * (double)k;  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: for (int count = remainder; count < N; count += 4) {  	int k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 1] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 2] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 3] = dm1 * (double)k;  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: for (int count = remainder; count < N; count += 4) {  	int k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 1] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 2] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 3] = dm1 * (double)k;  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: for (int count = remainder; count < N; count += 4) {  	int k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 1] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 2] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 3] = dm1 * (double)k;  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: for (int count = remainder; count < N; count += 4) {  	int k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 1] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 2] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 3] = dm1 * (double)k;  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: for (int count = remainder; count < N; count += 4) {  	int k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 1] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 2] = dm1 * (double)k;  	k = m [i] - m [j];  	if (i == 0)  		i = 16;  	else  		i--;  	if (k < 0)  		k += m1;  	m [j] = k;  	if (j == 0)  		j = 16;  	else  		j--;  	x [count + 3] = dm1 * (double)k;  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: count += 4
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (i == 0)  	i = 16;  else  	i--;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: i = 16;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (j == 0)  	j = 16;  else  	j--;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: j = 16;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (i == 0)  	i = 16;  else  	i--;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: i = 16;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (j == 0)  	j = 16;  else  	j--;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: j = 16;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (i == 0)  	i = 16;  else  	i--;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: i = 16;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (j == 0)  	j = 16;  else  	j--;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: j = 16;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: x [count + 2] = dm1 * (double)k;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (i == 0)  	i = 16;  else  	i--;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: i = 16;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: if (j == 0)  	j = 16;  else  	j--;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: j = 16;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,nextDoubles,The following statement contains a magic number: x [count + 3] = dm1 * (double)k;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,initialize,The following statement contains a magic number: m1 = (one << mdig - 2) + ((one << mdig - 2) - one);  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,initialize,The following statement contains a magic number: m1 = (one << mdig - 2) + ((one << mdig - 2) - one);  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,initialize,The following statement contains a magic number: m2 = one << mdig / 2;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,initialize,The following statement contains a magic number: m = new int[17];  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,initialize,The following statement contains a magic number: if (jseed % 2 == 0)  	--jseed;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,initialize,The following statement contains a magic number: k0 = 9069 % m2;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,initialize,The following statement contains a magic number: k1 = 9069 / m2;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,initialize,The following statement contains a magic number: for (iloop = 0; iloop < 17; ++iloop) {  	jseed = j0 * k0;  	j1 = (jseed / m2 + j0 * k1 + j1 * k0) % (m2 / 2);  	j0 = jseed % m2;  	m [iloop] = j0 + m2 * j1;  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,initialize,The following statement contains a magic number: for (iloop = 0; iloop < 17; ++iloop) {  	jseed = j0 * k0;  	j1 = (jseed / m2 + j0 * k1 + j1 * k0) % (m2 / 2);  	j0 = jseed % m2;  	m [iloop] = j0 + m2 * j1;  }  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,initialize,The following statement contains a magic number: j1 = (jseed / m2 + j0 * k1 + j1 * k0) % (m2 / 2);  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,initialize,The following statement contains a magic number: i = 4;  
Magic Number,Benchmarks.SciMark,Random,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Random.cs,initialize,The following statement contains a magic number: j = 16;  
Magic Number,Benchmarks.SciMark,SOR,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\SOR.cs,num_flops,The following statement contains a magic number: return (Md - 1) * (Nd - 1) * num_iterD * 6.0;  
Magic Number,Benchmarks.SciMark,SparseCompRow,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\SparseCompRow.cs,num_flops,The following statement contains a magic number: return ((double)actual_nz) * 2.0 * ((double)num_iterations);  
Magic Number,Benchmarks.SciMark,Stopwatch,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\Stopwatch.cs,seconds,The following statement contains a magic number: return (System.DateTime.Now.Ticks * 1.0E-7);  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,measureFFT,The following statement contains a magic number: return FFT.num_flops (N) * (double)cycles / Q.read () * 1.0e-6;  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,measureSOR,The following statement contains a magic number: SOR.execute (1.25' G' num_iterations);  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,measureSOR,The following statement contains a magic number: return SOR.num_flops (N' N' num_iterations) / Q.read () * 1.0e-6;  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,measureMonteCarlo,The following statement contains a magic number: return MonteCarlo.num_flops (num_samples) / Q.read () * 1.0e-6;  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,measureSparseMatmult,The following statement contains a magic number: return SparseCompRow.num_flops (N' nz' cycles) / Q.read () * 1.0e-6;  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,measureLU,The following statement contains a magic number: return LU.num_flops (N) * cycles / Q.read () * 1.0e-6;  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,CopyMatrix,The following statement contains a magic number: for (int i = 0; i < M; i++) {  	double[] Bi = B [i];  	double[] Ai = A [i];  	for (int j = 0; j < remainder; j++)  		Bi [j] = Ai [j];  	for (int j = remainder; j < N; j += 4) {  		Bi [j] = Ai [j];  		Bi [j + 1] = Ai [j + 1];  		Bi [j + 2] = Ai [j + 2];  		Bi [j + 3] = Ai [j + 3];  	}  }  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,CopyMatrix,The following statement contains a magic number: for (int i = 0; i < M; i++) {  	double[] Bi = B [i];  	double[] Ai = A [i];  	for (int j = 0; j < remainder; j++)  		Bi [j] = Ai [j];  	for (int j = remainder; j < N; j += 4) {  		Bi [j] = Ai [j];  		Bi [j + 1] = Ai [j + 1];  		Bi [j + 2] = Ai [j + 2];  		Bi [j + 3] = Ai [j + 3];  	}  }  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,CopyMatrix,The following statement contains a magic number: for (int i = 0; i < M; i++) {  	double[] Bi = B [i];  	double[] Ai = A [i];  	for (int j = 0; j < remainder; j++)  		Bi [j] = Ai [j];  	for (int j = remainder; j < N; j += 4) {  		Bi [j] = Ai [j];  		Bi [j + 1] = Ai [j + 1];  		Bi [j + 2] = Ai [j + 2];  		Bi [j + 3] = Ai [j + 3];  	}  }  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,CopyMatrix,The following statement contains a magic number: for (int i = 0; i < M; i++) {  	double[] Bi = B [i];  	double[] Ai = A [i];  	for (int j = 0; j < remainder; j++)  		Bi [j] = Ai [j];  	for (int j = remainder; j < N; j += 4) {  		Bi [j] = Ai [j];  		Bi [j + 1] = Ai [j + 1];  		Bi [j + 2] = Ai [j + 2];  		Bi [j + 3] = Ai [j + 3];  	}  }  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,CopyMatrix,The following statement contains a magic number: for (int i = 0; i < M; i++) {  	double[] Bi = B [i];  	double[] Ai = A [i];  	for (int j = 0; j < remainder; j++)  		Bi [j] = Ai [j];  	for (int j = remainder; j < N; j += 4) {  		Bi [j] = Ai [j];  		Bi [j + 1] = Ai [j + 1];  		Bi [j + 2] = Ai [j + 2];  		Bi [j + 3] = Ai [j + 3];  	}  }  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,CopyMatrix,The following statement contains a magic number: for (int j = remainder; j < N; j += 4) {  	Bi [j] = Ai [j];  	Bi [j + 1] = Ai [j + 1];  	Bi [j + 2] = Ai [j + 2];  	Bi [j + 3] = Ai [j + 3];  }  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,CopyMatrix,The following statement contains a magic number: for (int j = remainder; j < N; j += 4) {  	Bi [j] = Ai [j];  	Bi [j + 1] = Ai [j + 1];  	Bi [j + 2] = Ai [j + 2];  	Bi [j + 3] = Ai [j + 3];  }  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,CopyMatrix,The following statement contains a magic number: for (int j = remainder; j < N; j += 4) {  	Bi [j] = Ai [j];  	Bi [j + 1] = Ai [j + 1];  	Bi [j + 2] = Ai [j + 2];  	Bi [j + 3] = Ai [j + 3];  }  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,CopyMatrix,The following statement contains a magic number: for (int j = remainder; j < N; j += 4) {  	Bi [j] = Ai [j];  	Bi [j + 1] = Ai [j + 1];  	Bi [j + 2] = Ai [j + 2];  	Bi [j + 3] = Ai [j + 3];  }  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,CopyMatrix,The following statement contains a magic number: for (int j = remainder; j < N; j += 4) {  	Bi [j] = Ai [j];  	Bi [j + 1] = Ai [j + 1];  	Bi [j + 2] = Ai [j + 2];  	Bi [j + 3] = Ai [j + 3];  }  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,CopyMatrix,The following statement contains a magic number: j += 4
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,CopyMatrix,The following statement contains a magic number: Bi [j + 2] = Ai [j + 2];  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,CopyMatrix,The following statement contains a magic number: Bi [j + 2] = Ai [j + 2];  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,CopyMatrix,The following statement contains a magic number: Bi [j + 3] = Ai [j + 3];  
Magic Number,Benchmarks.SciMark,kernel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SciMark\kernel.cs,CopyMatrix,The following statement contains a magic number: Bi [j + 3] = Ai [j + 3];  
Magic Number,Benchmarks.Euler,Euler,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,validate,The following statement contains a magic number: if (dev > 1.0e-12) {  	throw new Exception ("Validation failed\nComputed RMS pressure error = " + error + "\nReference value = " + refval [size]);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: spt [2] = '\t';  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: spt [3] = '\r';  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: deltat = new double[imax + 1' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: opg = new double[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: opg = new double[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: pg = new double[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: pg = new double[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: pg1 = new double[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: pg1 = new double[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: sxi = new double[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: sxi = new double[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: seta = new double[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: seta = new double[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: tg = new double[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: tg = new double[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: tg1 = new double[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: tg1 = new double[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: ug = new Statevector[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: ug = new Statevector[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: d = new Statevector[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: d = new Statevector[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: f = new Statevector[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: f = new Statevector[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: g = new Statevector[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: g = new Statevector[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: r = new Statevector[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: r = new Statevector[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: ug1 = new Statevector[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: ug1 = new Statevector[imax + 2' jmax + 2];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: for (i = 0; i < imax + 2; ++i) {  	for (j = 0; j < jmax + 2; ++j) {  		d [i' j] = new Statevector ();  		f [i' j] = new Statevector ();  		g [i' j] = new Statevector ();  		r [i' j] = new Statevector ();  		ug [i' j] = new Statevector ();  		ug1 [i' j] = new Statevector ();  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: for (i = 0; i < imax + 2; ++i) {  	for (j = 0; j < jmax + 2; ++j) {  		d [i' j] = new Statevector ();  		f [i' j] = new Statevector ();  		g [i' j] = new Statevector ();  		r [i' j] = new Statevector ();  		ug [i' j] = new Statevector ();  		ug1 [i' j] = new Statevector ();  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: for (j = 0; j < jmax + 2; ++j) {  	d [i' j] = new Statevector ();  	f [i' j] = new Statevector ();  	g [i' j] = new Statevector ();  	r [i' j] = new Statevector ();  	ug [i' j] = new Statevector ();  	ug1 [i' j] = new Statevector ();  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: for (i = 0; i < imax; i++) {  	for (j = 0; j < jmax; j++) {  		xnode [i' j] = newval [0' i' j];  		ynode [i' j] = newval [1' i' j];  		ug [i + 1' j + 1].a = newval [2' i' j];  		ug [i + 1' j + 1].b = newval [3' i' j];  		ug [i + 1' j + 1].c = newval [4' i' j];  		ug [i + 1' j + 1].d = newval [5' i' j];  		scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  		scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  		tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  		tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  		pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: for (i = 0; i < imax; i++) {  	for (j = 0; j < jmax; j++) {  		xnode [i' j] = newval [0' i' j];  		ynode [i' j] = newval [1' i' j];  		ug [i + 1' j + 1].a = newval [2' i' j];  		ug [i + 1' j + 1].b = newval [3' i' j];  		ug [i + 1' j + 1].c = newval [4' i' j];  		ug [i + 1' j + 1].d = newval [5' i' j];  		scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  		scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  		tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  		tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  		pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: for (i = 0; i < imax; i++) {  	for (j = 0; j < jmax; j++) {  		xnode [i' j] = newval [0' i' j];  		ynode [i' j] = newval [1' i' j];  		ug [i + 1' j + 1].a = newval [2' i' j];  		ug [i + 1' j + 1].b = newval [3' i' j];  		ug [i + 1' j + 1].c = newval [4' i' j];  		ug [i + 1' j + 1].d = newval [5' i' j];  		scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  		scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  		tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  		tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  		pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: for (i = 0; i < imax; i++) {  	for (j = 0; j < jmax; j++) {  		xnode [i' j] = newval [0' i' j];  		ynode [i' j] = newval [1' i' j];  		ug [i + 1' j + 1].a = newval [2' i' j];  		ug [i + 1' j + 1].b = newval [3' i' j];  		ug [i + 1' j + 1].c = newval [4' i' j];  		ug [i + 1' j + 1].d = newval [5' i' j];  		scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  		scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  		tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  		tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  		pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: for (i = 0; i < imax; i++) {  	for (j = 0; j < jmax; j++) {  		xnode [i' j] = newval [0' i' j];  		ynode [i' j] = newval [1' i' j];  		ug [i + 1' j + 1].a = newval [2' i' j];  		ug [i + 1' j + 1].b = newval [3' i' j];  		ug [i + 1' j + 1].c = newval [4' i' j];  		ug [i + 1' j + 1].d = newval [5' i' j];  		scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  		scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  		tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  		tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  		pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: for (j = 0; j < jmax; j++) {  	xnode [i' j] = newval [0' i' j];  	ynode [i' j] = newval [1' i' j];  	ug [i + 1' j + 1].a = newval [2' i' j];  	ug [i + 1' j + 1].b = newval [3' i' j];  	ug [i + 1' j + 1].c = newval [4' i' j];  	ug [i + 1' j + 1].d = newval [5' i' j];  	scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  	scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  	tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  	tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  	pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: for (j = 0; j < jmax; j++) {  	xnode [i' j] = newval [0' i' j];  	ynode [i' j] = newval [1' i' j];  	ug [i + 1' j + 1].a = newval [2' i' j];  	ug [i + 1' j + 1].b = newval [3' i' j];  	ug [i + 1' j + 1].c = newval [4' i' j];  	ug [i + 1' j + 1].d = newval [5' i' j];  	scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  	scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  	tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  	tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  	pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: for (j = 0; j < jmax; j++) {  	xnode [i' j] = newval [0' i' j];  	ynode [i' j] = newval [1' i' j];  	ug [i + 1' j + 1].a = newval [2' i' j];  	ug [i + 1' j + 1].b = newval [3' i' j];  	ug [i + 1' j + 1].c = newval [4' i' j];  	ug [i + 1' j + 1].d = newval [5' i' j];  	scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  	scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  	tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  	tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  	pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: for (j = 0; j < jmax; j++) {  	xnode [i' j] = newval [0' i' j];  	ynode [i' j] = newval [1' i' j];  	ug [i + 1' j + 1].a = newval [2' i' j];  	ug [i + 1' j + 1].b = newval [3' i' j];  	ug [i + 1' j + 1].c = newval [4' i' j];  	ug [i + 1' j + 1].d = newval [5' i' j];  	scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  	scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  	tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  	tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  	pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: for (j = 0; j < jmax; j++) {  	xnode [i' j] = newval [0' i' j];  	ynode [i' j] = newval [1' i' j];  	ug [i + 1' j + 1].a = newval [2' i' j];  	ug [i + 1' j + 1].b = newval [3' i' j];  	ug [i + 1' j + 1].c = newval [4' i' j];  	ug [i + 1' j + 1].d = newval [5' i' j];  	scrap = ug [i + 1' j + 1].c / ug [i + 1' j + 1].a;  	scrap2 = ug [i + 1' j + 1].b / ug [i + 1' j + 1].a;  	tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  	tg [i + 1' j + 1] = tg [i + 1' j + 1] / Cv;  	pg [i + 1' j + 1] = rgas * ug [i + 1' j + 1].a * tg [i + 1' j + 1];  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: ug [i + 1' j + 1].a = newval [2' i' j];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: ug [i + 1' j + 1].b = newval [3' i' j];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: ug [i + 1' j + 1].c = newval [4' i' j];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: ug [i + 1' j + 1].d = newval [5' i' j];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: tg [i + 1' j + 1] = ug [i + 1' j + 1].d / ug [i + 1' j + 1].a - (0.5 * (scrap * scrap + scrap2 * scrap2));  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j)  		a [i' j] = 0.5 * ((xnode [i' j] - xnode [i - 1' j - 1]) * (ynode [i - 1' j] - ynode [i' j - 1]) - (ynode [i' j] - ynode [i - 1' j - 1]) * (xnode [i - 1' j] - xnode [i' j - 1]));  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: for (j = 1; j < jmax; ++j)  	a [i' j] = 0.5 * ((xnode [i' j] - xnode [i - 1' j - 1]) * (ynode [i - 1' j] - ynode [i' j - 1]) - (ynode [i' j] - ynode [i - 1' j - 1]) * (xnode [i - 1' j] - xnode [i' j - 1]));  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,initialise,The following statement contains a magic number: a [i' j] = 0.5 * ((xnode [i' j] - xnode [i - 1' j - 1]) * (ynode [i - 1' j] - ynode [i' j - 1]) - (ynode [i' j] - ynode [i - 1' j - 1]) * (xnode [i - 1' j] - xnode [i' j - 1]));  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: ug1 [i' j].a = ug [i' j].a - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: ug1 [i' j].b = ug [i' j].b - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: ug1 [i' j].c = ug [i' j].c - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: ug1 [i' j].d = ug [i' j].d - 0.25 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: ug1 [i' j].a = ug [i' j].a - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: ug1 [i' j].b = ug [i' j].b - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: ug1 [i' j].c = ug [i' j].c - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: ug1 [i' j].d = ug [i' j].d - 0.33333 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		ug1 [i' j].a = ug [i' j].a - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  		ug1 [i' j].b = ug [i' j].b - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  		ug1 [i' j].c = ug [i' j].c - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  		ug1 [i' j].d = ug [i' j].d - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	ug1 [i' j].a = ug [i' j].a - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  	ug1 [i' j].b = ug [i' j].b - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  	ug1 [i' j].c = ug [i' j].c - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  	ug1 [i' j].d = ug [i' j].d - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: ug1 [i' j].a = ug [i' j].a - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].a - d [i' j].a);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: ug1 [i' j].b = ug [i' j].b - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].b - d [i' j].b);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: ug1 [i' j].c = ug [i' j].c - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].c - d [i' j].c);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,doIteration,The following statement contains a magic number: ug1 [i' j].d = ug [i' j].d - 0.5 * deltat [i' j] / a [i' j] * (r [i' j].d - d [i' j].d);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateStateVar,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		temp = localug [i' j].b;  		temp2 = localug [i' j].c;  		localtg [i' j] = localug [i' j].d / localug [i' j].a - 0.5 * (temp * temp + temp2 * temp2) / (localug [i' j].a * localug [i' j].a);  		localtg [i' j] = localtg [i' j] / Cv;  		localpg [i' j] = localug [i' j].a * rgas * localtg [i' j];  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateStateVar,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	temp = localug [i' j].b;  	temp2 = localug [i' j].c;  	localtg [i' j] = localug [i' j].d / localug [i' j].a - 0.5 * (temp * temp + temp2 * temp2) / (localug [i' j].a * localug [i' j].a);  	localtg [i' j] = localtg [i' j] / Cv;  	localpg [i' j] = localug [i' j].a * rgas * localtg [i' j];  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateStateVar,The following statement contains a magic number: localtg [i' j] = localug [i' j].d / localug [i' j].a - 0.5 * (temp * temp + temp2 * temp2) / (localug [i' j].a * localug [i' j].a);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Start by clearing R */r [i' j].a = 0.0;  		r [i' j].b = 0.0;  		r [i' j].c = 0.0;  		r [i' j].d = 0.0;  		/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  		deltax = (xnode [i' j] - xnode [i' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  		/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  		deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  		r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  		r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  		r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  		/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  		deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  		/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  		deltax = (xnode [i - 1' j] - xnode [i' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Start by clearing R */r [i' j].a = 0.0;  		r [i' j].b = 0.0;  		r [i' j].c = 0.0;  		r [i' j].d = 0.0;  		/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  		deltax = (xnode [i' j] - xnode [i' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  		/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  		deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  		r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  		r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  		r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  		/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  		deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  		/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  		deltax = (xnode [i - 1' j] - xnode [i' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Start by clearing R */r [i' j].a = 0.0;  		r [i' j].b = 0.0;  		r [i' j].c = 0.0;  		r [i' j].d = 0.0;  		/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  		deltax = (xnode [i' j] - xnode [i' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  		/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  		deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  		r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  		r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  		r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  		/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  		deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  		/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  		deltax = (xnode [i - 1' j] - xnode [i' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Start by clearing R */r [i' j].a = 0.0;  		r [i' j].b = 0.0;  		r [i' j].c = 0.0;  		r [i' j].d = 0.0;  		/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  		deltax = (xnode [i' j] - xnode [i' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  		/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  		deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  		r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  		r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  		r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  		/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  		deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  		/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  		deltax = (xnode [i - 1' j] - xnode [i' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Start by clearing R */r [i' j].a = 0.0;  		r [i' j].b = 0.0;  		r [i' j].c = 0.0;  		r [i' j].d = 0.0;  		/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  		deltax = (xnode [i' j] - xnode [i' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  		/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  		deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  		r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  		r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  		r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  		/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  		deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  		/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  		deltax = (xnode [i - 1' j] - xnode [i' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Start by clearing R */r [i' j].a = 0.0;  		r [i' j].b = 0.0;  		r [i' j].c = 0.0;  		r [i' j].d = 0.0;  		/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  		deltax = (xnode [i' j] - xnode [i' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  		/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  		deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  		r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  		r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  		r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  		/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  		deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  		/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  		deltax = (xnode [i - 1' j] - xnode [i' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Start by clearing R */r [i' j].a = 0.0;  		r [i' j].b = 0.0;  		r [i' j].c = 0.0;  		r [i' j].d = 0.0;  		/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  		deltax = (xnode [i' j] - xnode [i' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  		/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  		deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  		r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  		r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  		r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  		/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  		deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  		/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  		deltax = (xnode [i - 1' j] - xnode [i' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Start by clearing R */r [i' j].a = 0.0;  		r [i' j].b = 0.0;  		r [i' j].c = 0.0;  		r [i' j].d = 0.0;  		/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  		deltax = (xnode [i' j] - xnode [i' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  		/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  		deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  		r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  		r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  		r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  		/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  		deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  		r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  		r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  		r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  		/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  		deltax = (xnode [i - 1' j] - xnode [i' j]);  		temp = 0.5 * deltay;  		r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  		r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  		r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  		r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  		temp = -0.5 * deltax;  		r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  		r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  		r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  		r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Start by clearing R */r [i' j].a = 0.0;  	r [i' j].b = 0.0;  	r [i' j].c = 0.0;  	r [i' j].d = 0.0;  	/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  	deltax = (xnode [i' j] - xnode [i' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  	/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  	deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  	r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  	r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  	r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  	/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  	deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  	/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  	deltax = (xnode [i - 1' j] - xnode [i' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Start by clearing R */r [i' j].a = 0.0;  	r [i' j].b = 0.0;  	r [i' j].c = 0.0;  	r [i' j].d = 0.0;  	/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  	deltax = (xnode [i' j] - xnode [i' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  	/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  	deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  	r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  	r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  	r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  	/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  	deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  	/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  	deltax = (xnode [i - 1' j] - xnode [i' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Start by clearing R */r [i' j].a = 0.0;  	r [i' j].b = 0.0;  	r [i' j].c = 0.0;  	r [i' j].d = 0.0;  	/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  	deltax = (xnode [i' j] - xnode [i' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  	/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  	deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  	r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  	r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  	r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  	/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  	deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  	/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  	deltax = (xnode [i - 1' j] - xnode [i' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Start by clearing R */r [i' j].a = 0.0;  	r [i' j].b = 0.0;  	r [i' j].c = 0.0;  	r [i' j].d = 0.0;  	/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  	deltax = (xnode [i' j] - xnode [i' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  	/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  	deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  	r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  	r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  	r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  	/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  	deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  	/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  	deltax = (xnode [i - 1' j] - xnode [i' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Start by clearing R */r [i' j].a = 0.0;  	r [i' j].b = 0.0;  	r [i' j].c = 0.0;  	r [i' j].d = 0.0;  	/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  	deltax = (xnode [i' j] - xnode [i' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  	/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  	deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  	r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  	r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  	r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  	/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  	deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  	/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  	deltax = (xnode [i - 1' j] - xnode [i' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Start by clearing R */r [i' j].a = 0.0;  	r [i' j].b = 0.0;  	r [i' j].c = 0.0;  	r [i' j].d = 0.0;  	/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  	deltax = (xnode [i' j] - xnode [i' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  	/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  	deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  	r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  	r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  	r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  	/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  	deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  	/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  	deltax = (xnode [i - 1' j] - xnode [i' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Start by clearing R */r [i' j].a = 0.0;  	r [i' j].b = 0.0;  	r [i' j].c = 0.0;  	r [i' j].d = 0.0;  	/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  	deltax = (xnode [i' j] - xnode [i' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  	/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  	deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  	r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  	r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  	r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  	/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  	deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  	/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  	deltax = (xnode [i - 1' j] - xnode [i' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Start by clearing R */r [i' j].a = 0.0;  	r [i' j].b = 0.0;  	r [i' j].c = 0.0;  	r [i' j].d = 0.0;  	/* East Face */deltay = (ynode [i' j] - ynode [i' j - 1]);  	deltax = (xnode [i' j] - xnode [i' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i + 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i + 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i + 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i + 1' j].d);  	/* South Face */deltay = (ynode [i' j - 1] - ynode [i - 1' j - 1]);  	deltax = (xnode [i' j - 1] - xnode [i - 1' j - 1]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i' j - 1].a);  	r [i' j].b += temp * (f [i' j].b + f [i' j - 1].b);  	r [i' j].c += temp * (f [i' j].c + f [i' j - 1].c);  	r [i' j].d += temp * (f [i' j].d + f [i' j - 1].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j - 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j - 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j - 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j - 1].d);  	/* West Face */deltay = (ynode [i - 1' j - 1] - ynode [i - 1' j]);  	deltax = (xnode [i - 1' j - 1] - xnode [i - 1' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i - 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i - 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i - 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i - 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i - 1' j].a);  	r [i' j].b += temp * (g [i' j].b + g [i - 1' j].b);  	r [i' j].c += temp * (g [i' j].c + g [i - 1' j].c);  	r [i' j].d += temp * (g [i' j].d + g [i - 1' j].d);  	/* North Face */deltay = (ynode [i - 1' j] - ynode [i' j]);  	deltax = (xnode [i - 1' j] - xnode [i' j]);  	temp = 0.5 * deltay;  	r [i' j].a += temp * (f [i' j].a + f [i + 1' j].a);  	r [i' j].b += temp * (f [i' j].b + f [i + 1' j].b);  	r [i' j].c += temp * (f [i' j].c + f [i + 1' j].c);  	r [i' j].d += temp * (f [i' j].d + f [i + 1' j].d);  	temp = -0.5 * deltax;  	r [i' j].a += temp * (g [i' j].a + g [i' j + 1].a);  	r [i' j].b += temp * (g [i' j].b + g [i' j + 1].b);  	r [i' j].c += temp * (g [i' j].c + g [i' j + 1].c);  	r [i' j].d += temp * (g [i' j].d + g [i' j + 1].d);  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: temp = 0.5 * deltay;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: temp = -0.5 * deltax;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: temp = 0.5 * deltay;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: temp = -0.5 * deltax;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: temp = 0.5 * deltay;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: temp = -0.5 * deltax;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: temp = 0.5 * deltay;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateR,The following statement contains a magic number: temp = -0.5 * deltax;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateG,The following statement contains a magic number: for (i = 0; i < imax + 1; ++i) {  	for (j = 0; j < jmax + 1; ++j) {  		v = localug [i' j].c / localug [i' j].a;  		g [i' j].a = localug [i' j].c;  		g [i' j].b = localug [i' j].b * v;  		g [i' j].c = localug [i' j].c * v + localpg [i' j];  		temp = localug [i' j].b * localug [i' j].b;  		temp2 = localug [i' j].c * localug [i' j].c;  		temp3 = localug [i' j].a * localug [i' j].a;  		g [i' j].d = localug [i' j].c * (Cp * localtg [i' j] + (0.5 * (temp + temp2) / (temp3)));  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateG,The following statement contains a magic number: for (j = 0; j < jmax + 1; ++j) {  	v = localug [i' j].c / localug [i' j].a;  	g [i' j].a = localug [i' j].c;  	g [i' j].b = localug [i' j].b * v;  	g [i' j].c = localug [i' j].c * v + localpg [i' j];  	temp = localug [i' j].b * localug [i' j].b;  	temp2 = localug [i' j].c * localug [i' j].c;  	temp3 = localug [i' j].a * localug [i' j].a;  	g [i' j].d = localug [i' j].c * (Cp * localtg [i' j] + (0.5 * (temp + temp2) / (temp3)));  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateG,The following statement contains a magic number: g [i' j].d = localug [i' j].c * (Cp * localtg [i' j] + (0.5 * (temp + temp2) / (temp3)));  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateF,The following statement contains a magic number: for (i = 0; i < imax + 1; ++i) {  	for (j = 0; j < jmax + 1; ++j) {  		u = localug [i' j].b / localug [i' j].a;  		f [i' j].a = localug [i' j].b;  		f [i' j].b = localug [i' j].b * u + localpg [i' j];  		f [i' j].c = localug [i' j].c * u;  		temp1 = localug [i' j].b * localug [i' j].b;  		temp2 = localug [i' j].c * localug [i' j].c;  		temp3 = localug [i' j].a * localug [i' j].a;  		f [i' j].d = localug [i' j].b * (Cp * localtg [i' j] + (0.5 * (temp1 + temp2) / (temp3)));  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateF,The following statement contains a magic number: for (j = 0; j < jmax + 1; ++j) {  	u = localug [i' j].b / localug [i' j].a;  	f [i' j].a = localug [i' j].b;  	f [i' j].b = localug [i' j].b * u + localpg [i' j];  	f [i' j].c = localug [i' j].c * u;  	temp1 = localug [i' j].b * localug [i' j].b;  	temp2 = localug [i' j].c * localug [i' j].c;  	temp3 = localug [i' j].a * localug [i' j].a;  	f [i' j].d = localug [i' j].b * (Cp * localtg [i' j] + (0.5 * (temp1 + temp2) / (temp3)));  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateF,The following statement contains a magic number: f [i' j].d = localug [i' j].b * (Cp * localtg [i' j] + (0.5 * (temp1 + temp2) / (temp3)));  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		sxi [i' j] = Math.Abs (localpg [i + 1' j] - 2.0 * localpg [i' j] + localpg [i - 1' j]) / localpg [i' j];  		seta [i' j] = Math.Abs (localpg [i' j + 1] - 2.0 * localpg [i' j] + localpg [i' j - 1]) / localpg [i' j];  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		sxi [i' j] = Math.Abs (localpg [i + 1' j] - 2.0 * localpg [i' j] + localpg [i - 1' j]) / localpg [i' j];  		seta [i' j] = Math.Abs (localpg [i' j + 1] - 2.0 * localpg [i' j] + localpg [i' j - 1]) / localpg [i' j];  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	sxi [i' j] = Math.Abs (localpg [i + 1' j] - 2.0 * localpg [i' j] + localpg [i - 1' j]) / localpg [i' j];  	seta [i' j] = Math.Abs (localpg [i' j + 1] - 2.0 * localpg [i' j] + localpg [i' j - 1]) / localpg [i' j];  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	sxi [i' j] = Math.Abs (localpg [i + 1' j] - 2.0 * localpg [i' j] + localpg [i - 1' j]) / localpg [i' j];  	seta [i' j] = Math.Abs (localpg [i' j + 1] - 2.0 * localpg [i' j] + localpg [i' j - 1]) / localpg [i' j];  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: sxi [i' j] = Math.Abs (localpg [i + 1' j] - 2.0 * localpg [i' j] + localpg [i - 1' j]) / localpg [i' j];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: seta [i' j] = Math.Abs (localpg [i' j + 1] - 2.0 * localpg [i' j] + localpg [i' j - 1]) / localpg [i' j];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  			sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 2' j].svect (localug [i - 1' j]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		temp.a = scrap2.a + scrap4.a;  		temp.b = scrap2.b + scrap4.b;  		temp.c = scrap2.c + scrap4.c;  		temp.d = scrap2.d + scrap4.d;  		d [i' j] = temp;  		/* West Face */if (i > 1 && i < imax - 1) {  			adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  			sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = sxi [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  		if (i > 1 && i < imax - 1) {  			temp = localug [i + 1' j].svect (localug [i - 2' j]);  			temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* North Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  			sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  		scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  		scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  		scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 2].svect (localug [i' j - 1]);  			temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  			temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  			temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  			temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  			tempdouble = -nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  		/* South Face */if (j > 1 && j < jmax - 1) {  			adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  			sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  		} else {  			adt = a [i' j] / deltat [i' j];  			sbar = seta [i' j];  		}  		tempdouble = -nu2 * sbar * adt;  		scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  		scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  		scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  		scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  		if (j > 1 && j < jmax - 1) {  			temp = localug [i' j + 1].svect (localug [i' j - 2]);  			temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  			temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  			temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  			temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  			tempdouble = nu4 * adt;  			scrap4.a = tempdouble * (temp.a + temp2.a);  			scrap4.b = tempdouble * (temp.a + temp2.b);  			scrap4.c = tempdouble * (temp.a + temp2.c);  			scrap4.d = tempdouble * (temp.a + temp2.d);  		} else {  			scrap4.a = 0.0;  			scrap4.b = 0.0;  			scrap4.c = 0.0;  			scrap4.d = 0.0;  		}  		d [i' j].a += scrap2.a + scrap4.a;  		d [i' j].b += scrap2.b + scrap4.b;  		d [i' j].c += scrap2.c + scrap4.c;  		d [i' j].d += scrap2.d + scrap4.d;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Clear values *//* East Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  		sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i + 1' j].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i + 1' j].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i + 1' j].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i + 1' j].d - localug [i' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 2' j].svect (localug [i - 1' j]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	temp.a = scrap2.a + scrap4.a;  	temp.b = scrap2.b + scrap4.b;  	temp.c = scrap2.c + scrap4.c;  	temp.d = scrap2.d + scrap4.d;  	d [i' j] = temp;  	/* West Face */if (i > 1 && i < imax - 1) {  		adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  		sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = sxi [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i - 1' j].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i - 1' j].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i - 1' j].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i - 1' j].d);  	if (i > 1 && i < imax - 1) {  		temp = localug [i + 1' j].svect (localug [i - 2' j]);  		temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* North Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  		sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j + 1].a - localug [i' j].a);  	scrap2.b = tempdouble * (localug [i' j + 1].b - localug [i' j].b);  	scrap2.c = tempdouble * (localug [i' j + 1].c - localug [i' j].c);  	scrap2.d = tempdouble * (localug [i' j + 1].d - localug [i' j].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 2].svect (localug [i' j - 1]);  		temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  		temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  		temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  		temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  		tempdouble = -nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  	/* South Face */if (j > 1 && j < jmax - 1) {  		adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  		sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  	} else {  		adt = a [i' j] / deltat [i' j];  		sbar = seta [i' j];  	}  	tempdouble = -nu2 * sbar * adt;  	scrap2.a = tempdouble * (localug [i' j].a - localug [i' j - 1].a);  	scrap2.b = tempdouble * (localug [i' j].b - localug [i' j - 1].b);  	scrap2.c = tempdouble * (localug [i' j].c - localug [i' j - 1].c);  	scrap2.d = tempdouble * (localug [i' j].d - localug [i' j - 1].d);  	if (j > 1 && j < jmax - 1) {  		temp = localug [i' j + 1].svect (localug [i' j - 2]);  		temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  		temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  		temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  		temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  		tempdouble = nu4 * adt;  		scrap4.a = tempdouble * (temp.a + temp2.a);  		scrap4.b = tempdouble * (temp.a + temp2.b);  		scrap4.c = tempdouble * (temp.a + temp2.c);  		scrap4.d = tempdouble * (temp.a + temp2.d);  	} else {  		scrap4.a = 0.0;  		scrap4.b = 0.0;  		scrap4.c = 0.0;  		scrap4.d = 0.0;  	}  	d [i' j].a += scrap2.a + scrap4.a;  	d [i' j].b += scrap2.b + scrap4.b;  	d [i' j].c += scrap2.c + scrap4.c;  	d [i' j].d += scrap2.d + scrap4.d;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	adt = (a [i' j] + a [i + 1' j]) / (deltat [i' j] + deltat [i + 1' j]);  	sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  } else {  	adt = a [i' j] / deltat [i' j];  	sbar = sxi [i' j];  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: sbar = (sxi [i + 1' j] + sxi [i' j]) * 0.5;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 2' j].svect (localug [i - 1' j]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 2' j].svect (localug [i - 1' j]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 2' j].svect (localug [i - 1' j]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 2' j].svect (localug [i - 1' j]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 2' j].svect (localug [i - 1' j]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp = localug [i + 2' j].svect (localug [i - 1' j]);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp2.a = 3.0 * (localug [i' j].a - localug [i + 1' j].a);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp2.b = 3.0 * (localug [i' j].b - localug [i + 1' j].b);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp2.c = 3.0 * (localug [i' j].c - localug [i + 1' j].c);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp2.d = 3.0 * (localug [i' j].d - localug [i + 1' j].d);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	adt = (a [i' j] + a [i - 1' j]) / (deltat [i' j] + deltat [i - 1' j]);  	sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  } else {  	adt = a [i' j] / deltat [i' j];  	sbar = sxi [i' j];  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: sbar = (sxi [i' j] + sxi [i - 1' j]) * 0.5;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 1' j].svect (localug [i - 2' j]);  	temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 1' j].svect (localug [i - 2' j]);  	temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 1' j].svect (localug [i - 2' j]);  	temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 1' j].svect (localug [i - 2' j]);  	temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (i > 1 && i < imax - 1) {  	temp = localug [i + 1' j].svect (localug [i - 2' j]);  	temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp = localug [i + 1' j].svect (localug [i - 2' j]);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp2.a = 3.0 * (localug [i - 1' j].a - localug [i' j].a);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp2.b = 3.0 * (localug [i - 1' j].b - localug [i' j].b);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp2.c = 3.0 * (localug [i - 1' j].c - localug [i' j].c);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp2.d = 3.0 * (localug [i - 1' j].d - localug [i' j].d);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	adt = (a [i' j] + a [i' j + 1]) / (deltat [i' j] + deltat [i' j + 1]);  	sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  } else {  	adt = a [i' j] / deltat [i' j];  	sbar = seta [i' j];  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: sbar = (seta [i' j] + seta [i' j + 1]) * 0.5;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 2].svect (localug [i' j - 1]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 2].svect (localug [i' j - 1]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 2].svect (localug [i' j - 1]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 2].svect (localug [i' j - 1]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 2].svect (localug [i' j - 1]);  	temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  	temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  	temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  	temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  	tempdouble = -nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp = localug [i' j + 2].svect (localug [i' j - 1]);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp2.a = 3.0 * (localug [i' j].a - localug [i' j + 1].a);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp2.b = 3.0 * (localug [i' j].b - localug [i' j + 1].b);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp2.c = 3.0 * (localug [i' j].c - localug [i' j + 1].c);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp2.d = 3.0 * (localug [i' j].d - localug [i' j + 1].d);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	adt = (a [i' j] + a [i' j - 1]) / (deltat [i' j] + deltat [i' j - 1]);  	sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  } else {  	adt = a [i' j] / deltat [i' j];  	sbar = seta [i' j];  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: sbar = (seta [i' j] + seta [i' j - 1]) * 0.5;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 1].svect (localug [i' j - 2]);  	temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 1].svect (localug [i' j - 2]);  	temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 1].svect (localug [i' j - 2]);  	temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 1].svect (localug [i' j - 2]);  	temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: if (j > 1 && j < jmax - 1) {  	temp = localug [i' j + 1].svect (localug [i' j - 2]);  	temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  	temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  	temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  	temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  	tempdouble = nu4 * adt;  	scrap4.a = tempdouble * (temp.a + temp2.a);  	scrap4.b = tempdouble * (temp.a + temp2.b);  	scrap4.c = tempdouble * (temp.a + temp2.c);  	scrap4.d = tempdouble * (temp.a + temp2.d);  } else {  	scrap4.a = 0.0;  	scrap4.b = 0.0;  	scrap4.c = 0.0;  	scrap4.d = 0.0;  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp = localug [i' j + 1].svect (localug [i' j - 2]);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp2.a = 3.0 * (localug [i' j - 1].a - localug [i' j].a);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp2.b = 3.0 * (localug [i' j - 1].b - localug [i' j].b);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp2.c = 3.0 * (localug [i' j - 1].c - localug [i' j].c);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDamping,The following statement contains a magic number: temp2.d = 3.0 * (localug [i' j - 1].d - localug [i' j].d);  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  		yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  		xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  		yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  		q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  		r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  		c = Math.Sqrt (gamma * rgas * tg [i' j]);  		deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  		yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  		xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  		yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  		q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  		r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  		c = Math.Sqrt (gamma * rgas * tg [i' j]);  		deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  		yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  		xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  		yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  		q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  		r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  		c = Math.Sqrt (gamma * rgas * tg [i' j]);  		deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  		yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  		xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  		yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  		q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  		r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  		c = Math.Sqrt (gamma * rgas * tg [i' j]);  		deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  		yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  		xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  		yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  		q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  		r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  		c = Math.Sqrt (gamma * rgas * tg [i' j]);  		deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	for (j = 1; j < jmax; ++j) {  		xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  		yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  		xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  		yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  		q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  		r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  		c = Math.Sqrt (gamma * rgas * tg [i' j]);  		deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  	yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  	xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  	yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  	q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  	r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  	c = Math.Sqrt (gamma * rgas * tg [i' j]);  	deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  	yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  	xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  	yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  	q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  	r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  	c = Math.Sqrt (gamma * rgas * tg [i' j]);  	deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  	yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  	xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  	yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  	q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  	r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  	c = Math.Sqrt (gamma * rgas * tg [i' j]);  	deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  	yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  	xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  	yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  	q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  	r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  	c = Math.Sqrt (gamma * rgas * tg [i' j]);  	deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  	yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  	xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  	yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  	q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  	r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  	c = Math.Sqrt (gamma * rgas * tg [i' j]);  	deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  	yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  	xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  	yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  	q = (yeta * ug [i' j].b - xeta * ug [i' j].c);  	r = (-yxi * ug [i' j].b + xxi * ug [i' j].c);  	c = Math.Sqrt (gamma * rgas * tg [i' j]);  	deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: xxi = (xnode [i' j] - xnode [i - 1' j] + xnode [i' j - 1] - xnode [i - 1' j - 1]) * 0.5;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: yxi = (ynode [i' j] - ynode [i - 1' j] + ynode [i' j - 1] - ynode [i - 1' j - 1]) * 0.5;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: xeta = (xnode [i' j] - xnode [i' j - 1] + xnode [i - 1' j] - xnode [i - 1' j - 1]) * 0.5;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: yeta = (ynode [i' j] - ynode [i' j - 1] + ynode [i - 1' j] - ynode [i - 1' j - 1]) * 0.5;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: deltat [i' j] = safety_factor * 2.8284 * a [i' j] / ((Math.Abs (q) + Math.Abs (r)) / ug [i' j].a + c * Math.Sqrt (xxi * xxi + yxi * yxi + xeta * xeta + yeta * yeta + 2.0 * Math.Abs (xeta * xxi + yeta * yxi)));  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: if (ntime == 1) {  	mint = 100000.0;  	for (i = 1; i < imax; ++i) {  		for (j = 1; j < jmax; ++j) {  			if (deltat [i' j] < mint)  				mint = deltat [i' j];  		}  	}  	for (i = 1; i < imax; ++i) {  		for (j = 1; j < jmax; ++j)  			deltat [i' j] = mint;  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDeltaT,The following statement contains a magic number: mint = 100000.0;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: jplusff = uff + 2.0 / (gamma - 1.0) * cff;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: jminusff = uff - 2.0 / (gamma - 1.0) * cff;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	/* Bottom wall boundary cells *//* Routine checked by brute force for initial conditions' 4/9; 4:30 *//* Routine checked by brute force for random conditions' 4/13' 4:40 pm *//* Construct tangent vectors */tan.ihat = xnode [i' 0] - xnode [i - 1' 0];  	tan.jhat = ynode [i' 0] - ynode [i - 1' 0];  	norm.ihat = -(ynode [i' 0] - ynode [i - 1' 0]);  	norm.jhat = xnode [i' 0] - xnode [i - 1' 0];  	scrap = tan.magnitude ();  	tan.ihat = tan.ihat / scrap;  	tan.jhat = tan.jhat / scrap;  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	/* now set some state variables */rho = localug [i' 1].a;  	localtg [i' 0] = localtg [i' 1];  	u1.ihat = localug [i' 1].b / rho;  	u1.jhat = localug [i' 1].c / rho;  	u = u1.dot (tan) + u1.dot (norm) * tan.jhat / norm.jhat;  	u = u / (tan.ihat - (norm.ihat * tan.jhat / norm.jhat));  	v = -(u1.dot (norm) + u * norm.ihat) / norm.jhat;  	/* And construct the new state vector */localug [i' 0].a = localug [i' 1].a;  	localug [i' 0].b = rho * u;  	localug [i' 0].c = rho * v;  	localug [i' 0].d = rho * (Cv * localtg [i' 0] + 0.5 * (u * u + v * v));  	localpg [i' 0] = localpg [i' 1];  	/* Top Wall Boundary Cells *//* Checked numerically for default conditions' 4/9 at 5:30 pm *//* Construct normal and tangent vectors *//* This part checked and works; it produces the correct vectors */tan.ihat = xnode [i' jmax - 1] - xnode [i - 1' jmax - 1];  	tan.jhat = ynode [i' jmax - 1] - ynode [i - 1' jmax - 1];  	norm.ihat = ynode [i' jmax - 1] - ynode [i - 1' jmax - 1];  	norm.jhat = -(xnode [i' jmax - 1] - xnode [i - 1' jmax - 1]);  	scrap = tan.magnitude ();  	tan.ihat = tan.ihat / scrap;  	tan.jhat = tan.jhat / scrap;  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	/* now set some state variables */rho = localug [i' jmax - 1].a;  	temp = localtg [i' jmax - 1];  	u1.ihat = localug [i' jmax - 1].b / rho;  	u1.jhat = localug [i' jmax - 1].c / rho;  	u = u1.dot (tan) + u1.dot (norm) * tan.jhat / norm.jhat;  	u = u / (tan.ihat - (norm.ihat * tan.jhat / norm.jhat));  	v = -(u1.dot (norm) + u * norm.ihat) / norm.jhat;  	/* And construct the new state vector */localug [i' jmax].a = localug [i' jmax - 1].a;  	localug [i' jmax].b = rho * u;  	localug [i' jmax].c = rho * v;  	localug [i' jmax].d = rho * (Cv * temp + 0.5 * (u * u + v * v));  	localtg [i' jmax] = temp;  	localpg [i' jmax] = localpg [i' jmax - 1];  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (i = 1; i < imax; ++i) {  	/* Bottom wall boundary cells *//* Routine checked by brute force for initial conditions' 4/9; 4:30 *//* Routine checked by brute force for random conditions' 4/13' 4:40 pm *//* Construct tangent vectors */tan.ihat = xnode [i' 0] - xnode [i - 1' 0];  	tan.jhat = ynode [i' 0] - ynode [i - 1' 0];  	norm.ihat = -(ynode [i' 0] - ynode [i - 1' 0]);  	norm.jhat = xnode [i' 0] - xnode [i - 1' 0];  	scrap = tan.magnitude ();  	tan.ihat = tan.ihat / scrap;  	tan.jhat = tan.jhat / scrap;  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	/* now set some state variables */rho = localug [i' 1].a;  	localtg [i' 0] = localtg [i' 1];  	u1.ihat = localug [i' 1].b / rho;  	u1.jhat = localug [i' 1].c / rho;  	u = u1.dot (tan) + u1.dot (norm) * tan.jhat / norm.jhat;  	u = u / (tan.ihat - (norm.ihat * tan.jhat / norm.jhat));  	v = -(u1.dot (norm) + u * norm.ihat) / norm.jhat;  	/* And construct the new state vector */localug [i' 0].a = localug [i' 1].a;  	localug [i' 0].b = rho * u;  	localug [i' 0].c = rho * v;  	localug [i' 0].d = rho * (Cv * localtg [i' 0] + 0.5 * (u * u + v * v));  	localpg [i' 0] = localpg [i' 1];  	/* Top Wall Boundary Cells *//* Checked numerically for default conditions' 4/9 at 5:30 pm *//* Construct normal and tangent vectors *//* This part checked and works; it produces the correct vectors */tan.ihat = xnode [i' jmax - 1] - xnode [i - 1' jmax - 1];  	tan.jhat = ynode [i' jmax - 1] - ynode [i - 1' jmax - 1];  	norm.ihat = ynode [i' jmax - 1] - ynode [i - 1' jmax - 1];  	norm.jhat = -(xnode [i' jmax - 1] - xnode [i - 1' jmax - 1]);  	scrap = tan.magnitude ();  	tan.ihat = tan.ihat / scrap;  	tan.jhat = tan.jhat / scrap;  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	/* now set some state variables */rho = localug [i' jmax - 1].a;  	temp = localtg [i' jmax - 1];  	u1.ihat = localug [i' jmax - 1].b / rho;  	u1.jhat = localug [i' jmax - 1].c / rho;  	u = u1.dot (tan) + u1.dot (norm) * tan.jhat / norm.jhat;  	u = u / (tan.ihat - (norm.ihat * tan.jhat / norm.jhat));  	v = -(u1.dot (norm) + u * norm.ihat) / norm.jhat;  	/* And construct the new state vector */localug [i' jmax].a = localug [i' jmax - 1].a;  	localug [i' jmax].b = rho * u;  	localug [i' jmax].c = rho * v;  	localug [i' jmax].d = rho * (Cv * temp + 0.5 * (u * u + v * v));  	localtg [i' jmax] = temp;  	localpg [i' jmax] = localpg [i' jmax - 1];  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: localug [i' 0].d = rho * (Cv * localtg [i' 0] + 0.5 * (u * u + v * v));  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: localug [i' jmax].d = rho * (Cv * temp + 0.5 * (u * u + v * v));  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: for (j = 1; j < jmax; ++j) {  	/* Inlet Boundary Cells: unchecked *//* Construct the normal vector; This works' 4/10' 2:00 pm */norm.ihat = ynode [0' j - 1] - ynode [0' j];  	norm.jhat = xnode [0' j] - xnode [0' j - 1];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	theta = Math.Acos ((ynode [0' j - 1] - ynode [0' j]) / Math.Sqrt ((xnode [0' j] - xnode [0' j - 1]) * (xnode [0' j] - xnode [0' j - 1]) + (ynode [0' j - 1] - ynode [0' j]) * (ynode [0' j - 1] - ynode [0' j])));  	u1.ihat = localug [1' j].b / localug [1' j].a;  	u1.jhat = localug [1' j].c / localug [1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [1' j]);  	/* Supersonic inflow; works on the initial cond' 4/10 at 3:10 pm */if (uprime < -c) {  		/* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other options *//* We should throw an exception here */else {  		throw new Exception ("You have outflow at the inlet' which is not allowed.");  	}  	/* Outlet Boundary Cells *//* Construct the normal vector; works' 4/10 3:10 pm */norm.ihat = ynode [0' j] - ynode [0' j - 1];  	norm.jhat = xnode [0' j - 1] - xnode [0' j];  	scrap = norm.magnitude ();  	norm.ihat = norm.ihat / scrap;  	norm.jhat = norm.jhat / scrap;  	scrap = xnode [0' j - 1] - xnode [0' j];  	scrap2 = ynode [0' j] - ynode [0' j - 1];  	theta = Math.Acos ((ynode [0' j] - ynode [0' j - 1]) / Math.Sqrt (scrap * scrap + scrap2 * scrap2));  	u1.ihat = localug [imax - 1' j].b / localug [imax - 1' j].a;  	u1.jhat = localug [imax - 1' j].c / localug [imax - 1' j].a;  	uprime = u1.ihat * Math.Cos (theta);  	c = Math.Sqrt (gamma * rgas * localtg [imax - 1' j]);  	/* Supersonic outflow; works for defaults cond' 4/10: 3:10 pm */if (uprime > c) {  		/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  		localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  		localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  		localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  		localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  		localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  	} /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  		jplus = u1.ihat + 2.0 / (gamma - 1) * c;  		v = localug [imax - 1' j].c / localug [imax - 1' j].a;  		s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  		u = (jplus + jminusff) / 2.0;  		scrap = (jplus - u) * (gamma - 1.0) * 0.5;  		localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  		localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  		rho = localpg [imax' j] / (rgas * localtg [imax' j]);  		/* And now' construct the new state vector */localug [imax' j].a = rho;  		localug [imax' j].b = rho * u;  		localug [imax' j].c = rho * v;  		localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  	} /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  		/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  		localug [0' j].b = rhoff * uff;  		localug [0' j].c = rhoff * vff;  		localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  		localtg [0' j] = tff;  		localpg [0' j] = pff;  	} /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  		/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  		s = Math.Log (pff) - gamma * Math.Log (rhoff);  		v = vff;  		u = (jplusff + jminus) / 2.0;  		scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  		localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  		localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  		localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  		/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  		localug [0' j].b = localug [0' j].a * u;  		localug [0' j].c = localug [0' j].a * v;  		localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  	} /* Other Options */else {  		throw new Exception ("You have inflow at the outlet' which is not allowed.");  	}  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other options *//* We should throw an exception here */else {  	throw new Exception ("You have outflow at the inlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other options *//* We should throw an exception here */else {  	throw new Exception ("You have outflow at the inlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other options *//* We should throw an exception here */else {  	throw new Exception ("You have outflow at the inlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other options *//* We should throw an exception here */else {  	throw new Exception ("You have outflow at the inlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other options *//* We should throw an exception here */else {  	throw new Exception ("You have outflow at the inlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < 0.0) {  	/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other options *//* We should throw an exception here */else {  	throw new Exception ("You have outflow at the inlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < 0.0) {  	/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other options *//* We should throw an exception here */else {  	throw new Exception ("You have outflow at the inlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < 0.0) {  	/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other options *//* We should throw an exception here */else {  	throw new Exception ("You have outflow at the inlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < 0.0) {  	/* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other options *//* We should throw an exception here */else {  	throw new Exception ("You have outflow at the inlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: u = (jplusff + jminus) / 2.0;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime > c) {  	/* Use a backward difference 2nd order derivative approximation *//* To set values at exit */localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  	localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  	localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  	localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  	localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  	localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  } /* Subsonic Outflow; works for defaults cond' 4/10: 3:10 pm */else if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: localug [imax' j].a = 2.0 * localug [imax - 1' j].a - localug [imax - 2' j].a;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: localug [imax' j].b = 2.0 * localug [imax - 1' j].b - localug [imax - 2' j].b;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: localug [imax' j].c = 2.0 * localug [imax - 1' j].c - localug [imax - 2' j].c;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: localug [imax' j].d = 2.0 * localug [imax - 1' j].d - localug [imax - 2' j].d;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: localpg [imax' j] = 2.0 * localpg [imax - 1' j] - localpg [imax - 2' j];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: localtg [imax' j] = 2.0 * localtg [imax - 1' j] - localtg [imax - 2' j];  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < c && uprime > 0) {  	jplus = u1.ihat + 2.0 / (gamma - 1) * c;  	v = localug [imax - 1' j].c / localug [imax - 1' j].a;  	s = Math.Log (localpg [imax - 1' j]) - gamma * Math.Log (localug [imax - 1' j].a);  	u = (jplus + jminusff) / 2.0;  	scrap = (jplus - u) * (gamma - 1.0) * 0.5;  	localtg [imax' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [imax' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [imax' j])' gamma);  	localpg [imax' j] = Math.Pow (localpg [imax' j]' 1.0 / (1.0 - gamma));  	rho = localpg [imax' j] / (rgas * localtg [imax' j]);  	/* And now' construct the new state vector */localug [imax' j].a = rho;  	localug [imax' j].b = rho * u;  	localug [imax' j].c = rho * v;  	localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  } /* Other cases that shouldn't have to be used. */else if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: jplus = u1.ihat + 2.0 / (gamma - 1) * c;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: u = (jplus + jminusff) / 2.0;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: scrap = (jplus - u) * (gamma - 1.0) * 0.5;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: localug [imax' j].d = rho * (Cv * localtg [imax' j] + 0.5 * (u * u + v * v));  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < -c) {  	/* Supersonic inflow *//* Use far field conditions */localug [0' j].a = rhoff;  	localug [0' j].b = rhoff * uff;  	localug [0' j].c = rhoff * vff;  	localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  	localtg [0' j] = tff;  	localpg [0' j] = pff;  } /* Subsonic inflow *//* This works on the initial conditions 4/10 @ 2:20 pm */else if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: localug [0' j].d = rhoff * (Cv * tff + 0.5 * (uff * uff + vff * vff));  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: if (uprime < 0.0) {  	/* Debug: throw exception here? *//* Calculate Riemann invarients here */jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  	s = Math.Log (pff) - gamma * Math.Log (rhoff);  	v = vff;  	u = (jplusff + jminus) / 2.0;  	scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  	localtg [0' j] = (1.0 / (gamma * rgas)) * scrap * scrap;  	localpg [0' j] = Math.Exp (s) / Math.Pow ((rgas * localtg [0' j])' gamma);  	localpg [0' j] = Math.Pow (localpg [0' j]' 1.0 / (1.0 - gamma));  	/* And now: construct the new state vector */localug [0' j].a = localpg [0' j] / (rgas * localtg [0' j]);  	localug [0' j].b = localug [0' j].a * u;  	localug [0' j].c = localug [0' j].a * v;  	localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  } /* Other Options */else {  	throw new Exception ("You have inflow at the outlet' which is not allowed.");  }  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: jminus = u1.ihat - 2.0 / (gamma - 1.0) * c;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: u = (jplusff + jminus) / 2.0;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: scrap = (jplusff - u) * (gamma - 1.0) * 0.5;  
Magic Number,Benchmarks.Euler,Tunnel,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\Euler\Euler.cs,calculateDummyCells,The following statement contains a magic number: localug [0' j].d = localug [0' j].a * (Cv * tff + 0.5 * (u * u + v * v));  
Magic Number,Benchmarks.SpecRaytracer,Canvas,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Canvas.cs,SetGreen,The following statement contains a magic number: Pixels [index] = Pixels [index] & 0x00FF00FF | (((int)component) << 8);  
Magic Number,Benchmarks.SpecRaytracer,Canvas,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Canvas.cs,SetBlue,The following statement contains a magic number: Pixels [index] = Pixels [index] & 0x0000FFFF | (((int)component) << 16);  
Magic Number,Benchmarks.SpecRaytracer,Canvas,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Canvas.cs,Write,The following statement contains a magic number: SetRed (x' y' color.GetRed () * 255);  
Magic Number,Benchmarks.SpecRaytracer,Canvas,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Canvas.cs,Write,The following statement contains a magic number: SetGreen (x' y' color.GetGreen () * 255);  
Magic Number,Benchmarks.SpecRaytracer,Canvas,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Canvas.cs,Write,The following statement contains a magic number: SetBlue (x' y' color.GetBlue () * 255);  
Magic Number,Benchmarks.SpecRaytracer,Face,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Face.cs,Face,The following statement contains a magic number: Verts = new Point[4];  
Magic Number,Benchmarks.SpecRaytracer,MainCL,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Main.cs,Main,The following statement contains a magic number: if (args.Length == 0) {  	args = new String[3];  	args [0] = "20";  	// + (200*spec.harness.Context.getSpeed())/100;  	args [1] = "200";  }  
Magic Number,Benchmarks.SpecRaytracer,MainCL,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Main.cs,Main,The following statement contains a magic number: args = new String[3];  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Initialize,The following statement contains a magic number: Adjacent = new OctNode[6];  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Initialize,The following statement contains a magic number: OctFaces = new Face[6];  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Initialize,The following statement contains a magic number: Child = new OctNode[8];  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Initialize,The following statement contains a magic number: for (i = 0; i < 6; i++) {  	Adjacent [i] = null;  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Initialize,The following statement contains a magic number: for (i = 0; i < 8; i++) {  	Child [i] = null;  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateFaces,The following statement contains a magic number: for (int i = 0; i < 6; i++) {  	OctFaces [i] = new Face ();  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateFaces,The following statement contains a magic number: MAXXF.SetVert (temp' 2);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateFaces,The following statement contains a magic number: MAXXF.SetVert (temp' 3);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateFaces,The following statement contains a magic number: MAXYF.SetVert (temp' 2);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateFaces,The following statement contains a magic number: MAXYF.SetVert (temp' 3);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateFaces,The following statement contains a magic number: MAXZF.SetVert (temp' 2);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateFaces,The following statement contains a magic number: MAXZF.SetVert (temp' 3);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateFaces,The following statement contains a magic number: MINXF.SetVert (temp' 2);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateFaces,The following statement contains a magic number: MINXF.SetVert (temp' 3);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateFaces,The following statement contains a magic number: MINYF.SetVert (temp' 2);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateFaces,The following statement contains a magic number: MINYF.SetVert (temp' 3);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateFaces,The following statement contains a magic number: MINZF.SetVert (temp' 2);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateFaces,The following statement contains a magic number: MINZF.SetVert (temp' 3);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: Child [2] = new OctNode (max' min);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: Child [3] = new OctNode (max' min);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: Child [4] = new OctNode (max' min);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: Child [5] = new OctNode (max' min);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: Child [6] = new OctNode (max' min);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: Child [7] = new OctNode (max' min);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: Child [2].FormAdjacent (adj0' chld3' chld1' chld6' adj4' adj5);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: Child [3].FormAdjacent (adj0' adj1' chld0' chld7' chld2' adj5);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: Child [4].FormAdjacent (chld0' adj1' adj2' adj3' chld5' chld7);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: Child [5].FormAdjacent (chld1' chld4' adj2' adj3' adj4' chld6);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: Child [6].FormAdjacent (chld2' chld7' chld5' adj3' adj4' adj5);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: Child [7].FormAdjacent (chld3' adj1' chld4' adj3' chld6' adj5);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: while (currentnode != null) {  	ObjectType currentobj = currentnode.GetObj ();  	for (i = 0; i < 8; i++) {  		OctNode cc = chld [i];  		max = cc.GetFace (0).GetVert (0);  		min = cc.GetFace (5).GetVert (3);  		if (!((currentobj.GetMin ().GetX () > max.GetX ()) || (currentobj.GetMax ().GetX () < min.GetX ()))) {  			if (!((currentobj.GetMin ().GetY () > max.GetY ()) || (currentobj.GetMax ().GetY () < min.GetY ()))) {  				if (!((currentobj.GetMin ().GetZ () > max.GetZ ()) || (currentobj.GetMax ().GetZ () < min.GetZ ()))) {  					ObjNode newnode = new ObjNode (currentobj' Child [i].GetList ());  					cc.SetList (newnode);  					cc.IncNumObj ();  				}  			}  		}  	}  	currentnode = currentnode.Next ();  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: while (currentnode != null) {  	ObjectType currentobj = currentnode.GetObj ();  	for (i = 0; i < 8; i++) {  		OctNode cc = chld [i];  		max = cc.GetFace (0).GetVert (0);  		min = cc.GetFace (5).GetVert (3);  		if (!((currentobj.GetMin ().GetX () > max.GetX ()) || (currentobj.GetMax ().GetX () < min.GetX ()))) {  			if (!((currentobj.GetMin ().GetY () > max.GetY ()) || (currentobj.GetMax ().GetY () < min.GetY ()))) {  				if (!((currentobj.GetMin ().GetZ () > max.GetZ ()) || (currentobj.GetMax ().GetZ () < min.GetZ ()))) {  					ObjNode newnode = new ObjNode (currentobj' Child [i].GetList ());  					cc.SetList (newnode);  					cc.IncNumObj ();  				}  			}  		}  	}  	currentnode = currentnode.Next ();  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: while (currentnode != null) {  	ObjectType currentobj = currentnode.GetObj ();  	for (i = 0; i < 8; i++) {  		OctNode cc = chld [i];  		max = cc.GetFace (0).GetVert (0);  		min = cc.GetFace (5).GetVert (3);  		if (!((currentobj.GetMin ().GetX () > max.GetX ()) || (currentobj.GetMax ().GetX () < min.GetX ()))) {  			if (!((currentobj.GetMin ().GetY () > max.GetY ()) || (currentobj.GetMax ().GetY () < min.GetY ()))) {  				if (!((currentobj.GetMin ().GetZ () > max.GetZ ()) || (currentobj.GetMax ().GetZ () < min.GetZ ()))) {  					ObjNode newnode = new ObjNode (currentobj' Child [i].GetList ());  					cc.SetList (newnode);  					cc.IncNumObj ();  				}  			}  		}  	}  	currentnode = currentnode.Next ();  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: for (i = 0; i < 8; i++) {  	OctNode cc = chld [i];  	max = cc.GetFace (0).GetVert (0);  	min = cc.GetFace (5).GetVert (3);  	if (!((currentobj.GetMin ().GetX () > max.GetX ()) || (currentobj.GetMax ().GetX () < min.GetX ()))) {  		if (!((currentobj.GetMin ().GetY () > max.GetY ()) || (currentobj.GetMax ().GetY () < min.GetY ()))) {  			if (!((currentobj.GetMin ().GetZ () > max.GetZ ()) || (currentobj.GetMax ().GetZ () < min.GetZ ()))) {  				ObjNode newnode = new ObjNode (currentobj' Child [i].GetList ());  				cc.SetList (newnode);  				cc.IncNumObj ();  			}  		}  	}  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: for (i = 0; i < 8; i++) {  	OctNode cc = chld [i];  	max = cc.GetFace (0).GetVert (0);  	min = cc.GetFace (5).GetVert (3);  	if (!((currentobj.GetMin ().GetX () > max.GetX ()) || (currentobj.GetMax ().GetX () < min.GetX ()))) {  		if (!((currentobj.GetMin ().GetY () > max.GetY ()) || (currentobj.GetMax ().GetY () < min.GetY ()))) {  			if (!((currentobj.GetMin ().GetZ () > max.GetZ ()) || (currentobj.GetMax ().GetZ () < min.GetZ ()))) {  				ObjNode newnode = new ObjNode (currentobj' Child [i].GetList ());  				cc.SetList (newnode);  				cc.IncNumObj ();  			}  		}  	}  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: for (i = 0; i < 8; i++) {  	OctNode cc = chld [i];  	max = cc.GetFace (0).GetVert (0);  	min = cc.GetFace (5).GetVert (3);  	if (!((currentobj.GetMin ().GetX () > max.GetX ()) || (currentobj.GetMax ().GetX () < min.GetX ()))) {  		if (!((currentobj.GetMin ().GetY () > max.GetY ()) || (currentobj.GetMax ().GetY () < min.GetY ()))) {  			if (!((currentobj.GetMin ().GetZ () > max.GetZ ()) || (currentobj.GetMax ().GetZ () < min.GetZ ()))) {  				ObjNode newnode = new ObjNode (currentobj' Child [i].GetList ());  				cc.SetList (newnode);  				cc.IncNumObj ();  			}  		}  	}  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: min = cc.GetFace (5).GetVert (3);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: min = cc.GetFace (5).GetVert (3);  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: if (depth < MaxDepth) {  	for (i = 0; i < 8; i++) {  		if (Child [i].GetNumObj () > MaxObj) {  			Child [i].CreateChildren (null' depth + 1);  		}  	}  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,CreateChildren,The following statement contains a magic number: for (i = 0; i < 8; i++) {  	if (Child [i].GetNumObj () > MaxObj) {  		Child [i].CreateChildren (null' depth + 1);  	}  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,FormAdjacent,The following statement contains a magic number: Adjacent [2] = maxZ;  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,FormAdjacent,The following statement contains a magic number: Adjacent [3] = minX;  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,FormAdjacent,The following statement contains a magic number: Adjacent [4] = minY;  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,FormAdjacent,The following statement contains a magic number: Adjacent [5] = minZ;  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Copy,The following statement contains a magic number: for (i = 0; i < 6; i++) {  	Adjacent [i] = original.GetAdjacent (i);  	OctFaces [i] = original.GetFace (i);  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Copy,The following statement contains a magic number: for (i = 0; i < 8; i++) {  	Child [i] = original.GetChild (i);  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,FindTreeNode,The following statement contains a magic number: if (Child [0] != null) {  	for (int i = 0; i < 8; i++) {  		found = Child [i].FindTreeNode (point);  		if (found != null) {  			return (found);  		}  	}  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,FindTreeNode,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	found = Child [i].FindTreeNode (point);  	if (found != null) {  		return (found);  	}  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: facehits [2] = -1;  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: if (ray.GetDirection ().GetZ () != 0.0) {  	t = -(ray.GetOrigin ().GetZ () - OctFaces [MAXZ].GetVert (0).GetZ ()) / ray.GetDirection ().GetZ ();  	if (t > Threshold) {  		if (t > current) {  			intersect.Combine (ray.GetOrigin ()' ray.GetDirection ()' 1.0f' t);  			if ((intersect.GetX () <= MAXXF.GetVert (0).GetX ()) && (intersect.GetX () >= MINXF.GetVert (0).GetX ()) && (intersect.GetY () <= MAXYF.GetVert (0).GetY ()) && (intersect.GetY () >= MINYF.GetVert (0).GetY ())) {  				current = t;  				facehits [0] = MAXZ;  				delta.Set (0.0f' 0.0f' Threshold);  			}  		} else if (t == current) {  			if (facehits [1] < 0) {  				facehits [1] = MAXZ;  			} else {  				facehits [2] = MAXZ;  			}  			delta.SetZ (Threshold);  		}  	}  	t = -(ray.GetOrigin ().GetZ () - OctFaces [MINZ].GetVert (0).GetZ ()) / ray.GetDirection ().GetZ ();  	if (t > Threshold) {  		if (t > current) {  			intersect.Combine (ray.GetOrigin ()' ray.GetDirection ()' 1.0f' t);  			if ((intersect.GetX () <= MAXXF.GetVert (0).GetX ()) && (intersect.GetX () >= MINXF.GetVert (0).GetX ()) && (intersect.GetY () <= MAXYF.GetVert (0).GetY ()) && (intersect.GetY () >= MINYF.GetVert (0).GetY ())) {  				current = t;  				facehits [0] = MINZ;  				delta.Set (0.0f' 0.0f' -Threshold);  			}  		} else if (t == current) {  			if (facehits [1] < 0) {  				facehits [1] = MINZ;  			} else {  				facehits [2] = MINZ;  			}  			delta.SetZ (-Threshold);  		}  	}  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: if (ray.GetDirection ().GetZ () != 0.0) {  	t = -(ray.GetOrigin ().GetZ () - OctFaces [MAXZ].GetVert (0).GetZ ()) / ray.GetDirection ().GetZ ();  	if (t > Threshold) {  		if (t > current) {  			intersect.Combine (ray.GetOrigin ()' ray.GetDirection ()' 1.0f' t);  			if ((intersect.GetX () <= MAXXF.GetVert (0).GetX ()) && (intersect.GetX () >= MINXF.GetVert (0).GetX ()) && (intersect.GetY () <= MAXYF.GetVert (0).GetY ()) && (intersect.GetY () >= MINYF.GetVert (0).GetY ())) {  				current = t;  				facehits [0] = MAXZ;  				delta.Set (0.0f' 0.0f' Threshold);  			}  		} else if (t == current) {  			if (facehits [1] < 0) {  				facehits [1] = MAXZ;  			} else {  				facehits [2] = MAXZ;  			}  			delta.SetZ (Threshold);  		}  	}  	t = -(ray.GetOrigin ().GetZ () - OctFaces [MINZ].GetVert (0).GetZ ()) / ray.GetDirection ().GetZ ();  	if (t > Threshold) {  		if (t > current) {  			intersect.Combine (ray.GetOrigin ()' ray.GetDirection ()' 1.0f' t);  			if ((intersect.GetX () <= MAXXF.GetVert (0).GetX ()) && (intersect.GetX () >= MINXF.GetVert (0).GetX ()) && (intersect.GetY () <= MAXYF.GetVert (0).GetY ()) && (intersect.GetY () >= MINYF.GetVert (0).GetY ())) {  				current = t;  				facehits [0] = MINZ;  				delta.Set (0.0f' 0.0f' -Threshold);  			}  		} else if (t == current) {  			if (facehits [1] < 0) {  				facehits [1] = MINZ;  			} else {  				facehits [2] = MINZ;  			}  			delta.SetZ (-Threshold);  		}  	}  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: if (t > Threshold) {  	if (t > current) {  		intersect.Combine (ray.GetOrigin ()' ray.GetDirection ()' 1.0f' t);  		if ((intersect.GetX () <= MAXXF.GetVert (0).GetX ()) && (intersect.GetX () >= MINXF.GetVert (0).GetX ()) && (intersect.GetY () <= MAXYF.GetVert (0).GetY ()) && (intersect.GetY () >= MINYF.GetVert (0).GetY ())) {  			current = t;  			facehits [0] = MAXZ;  			delta.Set (0.0f' 0.0f' Threshold);  		}  	} else if (t == current) {  		if (facehits [1] < 0) {  			facehits [1] = MAXZ;  		} else {  			facehits [2] = MAXZ;  		}  		delta.SetZ (Threshold);  	}  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: if (t > current) {  	intersect.Combine (ray.GetOrigin ()' ray.GetDirection ()' 1.0f' t);  	if ((intersect.GetX () <= MAXXF.GetVert (0).GetX ()) && (intersect.GetX () >= MINXF.GetVert (0).GetX ()) && (intersect.GetY () <= MAXYF.GetVert (0).GetY ()) && (intersect.GetY () >= MINYF.GetVert (0).GetY ())) {  		current = t;  		facehits [0] = MAXZ;  		delta.Set (0.0f' 0.0f' Threshold);  	}  } else if (t == current) {  	if (facehits [1] < 0) {  		facehits [1] = MAXZ;  	} else {  		facehits [2] = MAXZ;  	}  	delta.SetZ (Threshold);  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: if (t == current) {  	if (facehits [1] < 0) {  		facehits [1] = MAXZ;  	} else {  		facehits [2] = MAXZ;  	}  	delta.SetZ (Threshold);  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: if (facehits [1] < 0) {  	facehits [1] = MAXZ;  } else {  	facehits [2] = MAXZ;  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: facehits [2] = MAXZ;  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: if (t > Threshold) {  	if (t > current) {  		intersect.Combine (ray.GetOrigin ()' ray.GetDirection ()' 1.0f' t);  		if ((intersect.GetX () <= MAXXF.GetVert (0).GetX ()) && (intersect.GetX () >= MINXF.GetVert (0).GetX ()) && (intersect.GetY () <= MAXYF.GetVert (0).GetY ()) && (intersect.GetY () >= MINYF.GetVert (0).GetY ())) {  			current = t;  			facehits [0] = MINZ;  			delta.Set (0.0f' 0.0f' -Threshold);  		}  	} else if (t == current) {  		if (facehits [1] < 0) {  			facehits [1] = MINZ;  		} else {  			facehits [2] = MINZ;  		}  		delta.SetZ (-Threshold);  	}  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: if (t > current) {  	intersect.Combine (ray.GetOrigin ()' ray.GetDirection ()' 1.0f' t);  	if ((intersect.GetX () <= MAXXF.GetVert (0).GetX ()) && (intersect.GetX () >= MINXF.GetVert (0).GetX ()) && (intersect.GetY () <= MAXYF.GetVert (0).GetY ()) && (intersect.GetY () >= MINYF.GetVert (0).GetY ())) {  		current = t;  		facehits [0] = MINZ;  		delta.Set (0.0f' 0.0f' -Threshold);  	}  } else if (t == current) {  	if (facehits [1] < 0) {  		facehits [1] = MINZ;  	} else {  		facehits [2] = MINZ;  	}  	delta.SetZ (-Threshold);  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: if (t == current) {  	if (facehits [1] < 0) {  		facehits [1] = MINZ;  	} else {  		facehits [2] = MINZ;  	}  	delta.SetZ (-Threshold);  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: if (facehits [1] < 0) {  	facehits [1] = MINZ;  } else {  	facehits [2] = MINZ;  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: facehits [2] = MINZ;  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: if (facehits [0] >= MAXX) {  	intersect.Combine (ray.GetOrigin ()' ray.GetDirection ()' 1.0f' current);  	intersect.Add (delta);  	adjacent = Adjacent [facehits [0]];  	if (facehits [1] >= MAXX) {  		if (adjacent != null) {  			adjacent = adjacent.GetAdjacent (facehits [1]);  			if (facehits [2] >= MAXX) {  				if (adjacent != null) {  					adjacent = adjacent.GetAdjacent (facehits [2]);  				} else {  					adjacent = null;  				}  			}  		} else {  			adjacent = null;  		}  	}  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: if (facehits [0] >= MAXX) {  	intersect.Combine (ray.GetOrigin ()' ray.GetDirection ()' 1.0f' current);  	intersect.Add (delta);  	adjacent = Adjacent [facehits [0]];  	if (facehits [1] >= MAXX) {  		if (adjacent != null) {  			adjacent = adjacent.GetAdjacent (facehits [1]);  			if (facehits [2] >= MAXX) {  				if (adjacent != null) {  					adjacent = adjacent.GetAdjacent (facehits [2]);  				} else {  					adjacent = null;  				}  			}  		} else {  			adjacent = null;  		}  	}  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: if (facehits [1] >= MAXX) {  	if (adjacent != null) {  		adjacent = adjacent.GetAdjacent (facehits [1]);  		if (facehits [2] >= MAXX) {  			if (adjacent != null) {  				adjacent = adjacent.GetAdjacent (facehits [2]);  			} else {  				adjacent = null;  			}  		}  	} else {  		adjacent = null;  	}  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: if (facehits [1] >= MAXX) {  	if (adjacent != null) {  		adjacent = adjacent.GetAdjacent (facehits [1]);  		if (facehits [2] >= MAXX) {  			if (adjacent != null) {  				adjacent = adjacent.GetAdjacent (facehits [2]);  			} else {  				adjacent = null;  			}  		}  	} else {  		adjacent = null;  	}  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: if (adjacent != null) {  	adjacent = adjacent.GetAdjacent (facehits [1]);  	if (facehits [2] >= MAXX) {  		if (adjacent != null) {  			adjacent = adjacent.GetAdjacent (facehits [2]);  		} else {  			adjacent = null;  		}  	}  } else {  	adjacent = null;  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: if (adjacent != null) {  	adjacent = adjacent.GetAdjacent (facehits [1]);  	if (facehits [2] >= MAXX) {  		if (adjacent != null) {  			adjacent = adjacent.GetAdjacent (facehits [2]);  		} else {  			adjacent = null;  		}  	}  } else {  	adjacent = null;  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: if (facehits [2] >= MAXX) {  	if (adjacent != null) {  		adjacent = adjacent.GetAdjacent (facehits [2]);  	} else {  		adjacent = null;  	}  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: if (facehits [2] >= MAXX) {  	if (adjacent != null) {  		adjacent = adjacent.GetAdjacent (facehits [2]);  	} else {  		adjacent = null;  	}  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: if (adjacent != null) {  	adjacent = adjacent.GetAdjacent (facehits [2]);  } else {  	adjacent = null;  }  
Magic Number,Benchmarks.SpecRaytracer,OctNode,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\OctNode.cs,Intersect,The following statement contains a magic number: adjacent = adjacent.GetAdjacent (facehits [2]);  
Magic Number,Benchmarks.SpecRaytracer,PolygonObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\PolygonObj.cs,InsidePolygon,The following statement contains a magic number: if (MaxComp == 0) {  	xindex = 1;  	yindex = 2;  	xtest = pt.GetY ();  	ytest = pt.GetZ ();  } else if (MaxComp == 1) {  	xindex = 0;  	yindex = 2;  	xtest = pt.GetX ();  	ytest = pt.GetZ ();  } else {  	xindex = 0;  	yindex = 1;  	xtest = pt.GetX ();  	ytest = pt.GetY ();  }  
Magic Number,Benchmarks.SpecRaytracer,PolygonObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\PolygonObj.cs,InsidePolygon,The following statement contains a magic number: if (MaxComp == 0) {  	xindex = 1;  	yindex = 2;  	xtest = pt.GetY ();  	ytest = pt.GetZ ();  } else if (MaxComp == 1) {  	xindex = 0;  	yindex = 2;  	xtest = pt.GetX ();  	ytest = pt.GetZ ();  } else {  	xindex = 0;  	yindex = 1;  	xtest = pt.GetX ();  	ytest = pt.GetY ();  }  
Magic Number,Benchmarks.SpecRaytracer,PolygonObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\PolygonObj.cs,InsidePolygon,The following statement contains a magic number: yindex = 2;  
Magic Number,Benchmarks.SpecRaytracer,PolygonObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\PolygonObj.cs,InsidePolygon,The following statement contains a magic number: if (MaxComp == 1) {  	xindex = 0;  	yindex = 2;  	xtest = pt.GetX ();  	ytest = pt.GetZ ();  } else {  	xindex = 0;  	yindex = 1;  	xtest = pt.GetX ();  	ytest = pt.GetY ();  }  
Magic Number,Benchmarks.SpecRaytracer,PolygonObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\PolygonObj.cs,InsidePolygon,The following statement contains a magic number: yindex = 2;  
Magic Number,Benchmarks.SpecRaytracer,PolygonObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\PolygonObj.cs,PolygonObj,The following statement contains a magic number: if (x >= y && x >= z) {  	MaxComp = 0;  } else if (y >= z) {  	MaxComp = 1;  } else {  	MaxComp = 2;  }  
Magic Number,Benchmarks.SpecRaytracer,PolygonObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\PolygonObj.cs,PolygonObj,The following statement contains a magic number: if (y >= z) {  	MaxComp = 1;  } else {  	MaxComp = 2;  }  
Magic Number,Benchmarks.SpecRaytracer,PolygonObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\PolygonObj.cs,PolygonObj,The following statement contains a magic number: MaxComp = 2;  
Magic Number,Benchmarks.SpecRaytracer,PolyTypeObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\PolyTypeObj.cs,CalculateNormal,The following statement contains a magic number: bc.Sub (Vertices [2]' Vertices [1]);  
Magic Number,Benchmarks.SpecRaytracer,RayTracer,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\RayTracer.cs,inst_main,The following statement contains a magic number: if (argv.Length >= 2) {  	width = Int32.Parse (argv [0]);  	height = Int32.Parse (argv [1]);  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadCamera,The following statement contains a magic number: temp = temp.Substring (11);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadCamera,The following statement contains a magic number: for (i = 0; i < 2; i++) {  	input [i] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  	temp = temp.Substring (temp.IndexOf (' ') + 1);  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadCamera,The following statement contains a magic number: input [2] = (double)Double.Parse (temp);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadCamera,The following statement contains a magic number: MaxZ = MinZ = input [2];  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadCamera,The following statement contains a magic number: temp = temp.Substring (16);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadCamera,The following statement contains a magic number: for (i = 0; i < 2; i++) {  	input [i] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  	temp = temp.Substring (temp.IndexOf (' ') + 1);  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadCamera,The following statement contains a magic number: input [2] = (double)Double.Parse (temp);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadCamera,The following statement contains a magic number: temp = temp.Substring (16);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadCamera,The following statement contains a magic number: temp = temp.Substring (10);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadCamera,The following statement contains a magic number: for (i = 0; i < 2; i++) {  	input [i] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  	temp = temp.Substring (temp.IndexOf (' ') + 1);  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadCamera,The following statement contains a magic number: input [2] = (double)Double.Parse (temp);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadCamera,The following statement contains a magic number: temp = temp.Substring (14);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadLight,The following statement contains a magic number: temp = temp.Substring (11);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadLight,The following statement contains a magic number: for (i = 0; i < 2; i++) {  	input [i] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  	temp = temp.Substring (temp.IndexOf (' ') + 1);  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadLight,The following statement contains a magic number: input [2] = (double)Double.Parse (temp);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadLight,The following statement contains a magic number: temp = temp.Substring (8);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadLight,The following statement contains a magic number: for (i = 0; i < 2; i++) {  	input [i] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  	temp = temp.Substring (temp.IndexOf (' ') + 1);  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadLight,The following statement contains a magic number: input [2] = (double)Double.Parse (temp);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadSphere,The following statement contains a magic number: temp = temp.Substring (9);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadSphere,The following statement contains a magic number: for (i = 0; i < 2; i++) {  	input [i] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  	temp = temp.Substring (temp.IndexOf (' ') + 1);  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadSphere,The following statement contains a magic number: input [2] = (double)Double.Parse (temp);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadSphere,The following statement contains a magic number: temp = temp.Substring (9);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadSphere,The following statement contains a magic number: for (i = 0; i < 7; i++) {  	temp = readString ();  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,The following statement contains a magic number: if (temp.Substring (7).Equals ("POLYSET_TRI_MESH")) {  	trimesh = true;  } else {  	trimesh = false;  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,The following statement contains a magic number: if (temp.Substring (11).Equals ("PER_VERTEX_NORMAL")) {  	vertnormal = true;  } else {  	vertnormal = false;  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,The following statement contains a magic number: for (i = 0; i < 4; i++) {  	temp = readString ();  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,The following statement contains a magic number: temp = temp.Substring (11);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,The following statement contains a magic number: for (i = 0; i < numpolys; i++) {  	temp = readString ();  	temp = readString ();  	temp = temp.Substring (16);  	numverts = Int32.Parse (temp);  	Point[] vertices = new Point[numverts];  	for (j = 0; j < numverts; j++) {  		temp = readString ();  		temp = temp.Substring (8);  		for (k = 0; k < 2; k++) {  			input [k] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  			temp = temp.Substring (temp.IndexOf (' ') + 1);  		}  		input [2] = (double)Double.Parse (temp);  		vertices [j] = new Point (input [0]' input [1]' input [2]);  		if (vertnormal) {  			temp = readString ();  		}  	}  	temp = readString ();  	TriangleObj newtriangle;  	PolygonObj newpoly;  	ObjNode newnode;  	if (trimesh) {  		newtriangle = new TriangleObj (theMaterial' ObjID' numverts' vertices' max' min);  		newnode = new ObjNode (newtriangle' objects);  	} else {  		newpoly = new PolygonObj (theMaterial' ObjID' numverts' vertices' max' min);  		newnode = new ObjNode (newpoly' objects);  	}  	objects = newnode;  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,The following statement contains a magic number: for (i = 0; i < numpolys; i++) {  	temp = readString ();  	temp = readString ();  	temp = temp.Substring (16);  	numverts = Int32.Parse (temp);  	Point[] vertices = new Point[numverts];  	for (j = 0; j < numverts; j++) {  		temp = readString ();  		temp = temp.Substring (8);  		for (k = 0; k < 2; k++) {  			input [k] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  			temp = temp.Substring (temp.IndexOf (' ') + 1);  		}  		input [2] = (double)Double.Parse (temp);  		vertices [j] = new Point (input [0]' input [1]' input [2]);  		if (vertnormal) {  			temp = readString ();  		}  	}  	temp = readString ();  	TriangleObj newtriangle;  	PolygonObj newpoly;  	ObjNode newnode;  	if (trimesh) {  		newtriangle = new TriangleObj (theMaterial' ObjID' numverts' vertices' max' min);  		newnode = new ObjNode (newtriangle' objects);  	} else {  		newpoly = new PolygonObj (theMaterial' ObjID' numverts' vertices' max' min);  		newnode = new ObjNode (newpoly' objects);  	}  	objects = newnode;  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,The following statement contains a magic number: for (i = 0; i < numpolys; i++) {  	temp = readString ();  	temp = readString ();  	temp = temp.Substring (16);  	numverts = Int32.Parse (temp);  	Point[] vertices = new Point[numverts];  	for (j = 0; j < numverts; j++) {  		temp = readString ();  		temp = temp.Substring (8);  		for (k = 0; k < 2; k++) {  			input [k] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  			temp = temp.Substring (temp.IndexOf (' ') + 1);  		}  		input [2] = (double)Double.Parse (temp);  		vertices [j] = new Point (input [0]' input [1]' input [2]);  		if (vertnormal) {  			temp = readString ();  		}  	}  	temp = readString ();  	TriangleObj newtriangle;  	PolygonObj newpoly;  	ObjNode newnode;  	if (trimesh) {  		newtriangle = new TriangleObj (theMaterial' ObjID' numverts' vertices' max' min);  		newnode = new ObjNode (newtriangle' objects);  	} else {  		newpoly = new PolygonObj (theMaterial' ObjID' numverts' vertices' max' min);  		newnode = new ObjNode (newpoly' objects);  	}  	objects = newnode;  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,The following statement contains a magic number: for (i = 0; i < numpolys; i++) {  	temp = readString ();  	temp = readString ();  	temp = temp.Substring (16);  	numverts = Int32.Parse (temp);  	Point[] vertices = new Point[numverts];  	for (j = 0; j < numverts; j++) {  		temp = readString ();  		temp = temp.Substring (8);  		for (k = 0; k < 2; k++) {  			input [k] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  			temp = temp.Substring (temp.IndexOf (' ') + 1);  		}  		input [2] = (double)Double.Parse (temp);  		vertices [j] = new Point (input [0]' input [1]' input [2]);  		if (vertnormal) {  			temp = readString ();  		}  	}  	temp = readString ();  	TriangleObj newtriangle;  	PolygonObj newpoly;  	ObjNode newnode;  	if (trimesh) {  		newtriangle = new TriangleObj (theMaterial' ObjID' numverts' vertices' max' min);  		newnode = new ObjNode (newtriangle' objects);  	} else {  		newpoly = new PolygonObj (theMaterial' ObjID' numverts' vertices' max' min);  		newnode = new ObjNode (newpoly' objects);  	}  	objects = newnode;  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,The following statement contains a magic number: for (i = 0; i < numpolys; i++) {  	temp = readString ();  	temp = readString ();  	temp = temp.Substring (16);  	numverts = Int32.Parse (temp);  	Point[] vertices = new Point[numverts];  	for (j = 0; j < numverts; j++) {  		temp = readString ();  		temp = temp.Substring (8);  		for (k = 0; k < 2; k++) {  			input [k] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  			temp = temp.Substring (temp.IndexOf (' ') + 1);  		}  		input [2] = (double)Double.Parse (temp);  		vertices [j] = new Point (input [0]' input [1]' input [2]);  		if (vertnormal) {  			temp = readString ();  		}  	}  	temp = readString ();  	TriangleObj newtriangle;  	PolygonObj newpoly;  	ObjNode newnode;  	if (trimesh) {  		newtriangle = new TriangleObj (theMaterial' ObjID' numverts' vertices' max' min);  		newnode = new ObjNode (newtriangle' objects);  	} else {  		newpoly = new PolygonObj (theMaterial' ObjID' numverts' vertices' max' min);  		newnode = new ObjNode (newpoly' objects);  	}  	objects = newnode;  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,The following statement contains a magic number: temp = temp.Substring (16);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,The following statement contains a magic number: for (j = 0; j < numverts; j++) {  	temp = readString ();  	temp = temp.Substring (8);  	for (k = 0; k < 2; k++) {  		input [k] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  		temp = temp.Substring (temp.IndexOf (' ') + 1);  	}  	input [2] = (double)Double.Parse (temp);  	vertices [j] = new Point (input [0]' input [1]' input [2]);  	if (vertnormal) {  		temp = readString ();  	}  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,The following statement contains a magic number: for (j = 0; j < numverts; j++) {  	temp = readString ();  	temp = temp.Substring (8);  	for (k = 0; k < 2; k++) {  		input [k] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  		temp = temp.Substring (temp.IndexOf (' ') + 1);  	}  	input [2] = (double)Double.Parse (temp);  	vertices [j] = new Point (input [0]' input [1]' input [2]);  	if (vertnormal) {  		temp = readString ();  	}  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,The following statement contains a magic number: for (j = 0; j < numverts; j++) {  	temp = readString ();  	temp = temp.Substring (8);  	for (k = 0; k < 2; k++) {  		input [k] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  		temp = temp.Substring (temp.IndexOf (' ') + 1);  	}  	input [2] = (double)Double.Parse (temp);  	vertices [j] = new Point (input [0]' input [1]' input [2]);  	if (vertnormal) {  		temp = readString ();  	}  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,The following statement contains a magic number: for (j = 0; j < numverts; j++) {  	temp = readString ();  	temp = temp.Substring (8);  	for (k = 0; k < 2; k++) {  		input [k] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  		temp = temp.Substring (temp.IndexOf (' ') + 1);  	}  	input [2] = (double)Double.Parse (temp);  	vertices [j] = new Point (input [0]' input [1]' input [2]);  	if (vertnormal) {  		temp = readString ();  	}  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,The following statement contains a magic number: temp = temp.Substring (8);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,The following statement contains a magic number: for (k = 0; k < 2; k++) {  	input [k] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  	temp = temp.Substring (temp.IndexOf (' ') + 1);  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,The following statement contains a magic number: input [2] = (double)Double.Parse (temp);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadPoly,The following statement contains a magic number: vertices [j] = new Point (input [0]' input [1]' input [2]);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadMaterial,The following statement contains a magic number: for (i = 0; i < 4; i++) {  	temp = readString ();  	if (i != 1) {  		temp = temp.Substring (14);  	} else {  		temp = temp.Substring (13);  	}  	for (j = 0; j < 2; j++) {  		input [j] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  		temp = temp.Substring (temp.IndexOf (' ') + 1);  	}  	input [2] = (double)Double.Parse (temp);  	colors [i] = new Color (input [0]' input [1]' input [2]);  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadMaterial,The following statement contains a magic number: for (i = 0; i < 4; i++) {  	temp = readString ();  	if (i != 1) {  		temp = temp.Substring (14);  	} else {  		temp = temp.Substring (13);  	}  	for (j = 0; j < 2; j++) {  		input [j] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  		temp = temp.Substring (temp.IndexOf (' ') + 1);  	}  	input [2] = (double)Double.Parse (temp);  	colors [i] = new Color (input [0]' input [1]' input [2]);  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadMaterial,The following statement contains a magic number: for (i = 0; i < 4; i++) {  	temp = readString ();  	if (i != 1) {  		temp = temp.Substring (14);  	} else {  		temp = temp.Substring (13);  	}  	for (j = 0; j < 2; j++) {  		input [j] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  		temp = temp.Substring (temp.IndexOf (' ') + 1);  	}  	input [2] = (double)Double.Parse (temp);  	colors [i] = new Color (input [0]' input [1]' input [2]);  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadMaterial,The following statement contains a magic number: for (i = 0; i < 4; i++) {  	temp = readString ();  	if (i != 1) {  		temp = temp.Substring (14);  	} else {  		temp = temp.Substring (13);  	}  	for (j = 0; j < 2; j++) {  		input [j] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  		temp = temp.Substring (temp.IndexOf (' ') + 1);  	}  	input [2] = (double)Double.Parse (temp);  	colors [i] = new Color (input [0]' input [1]' input [2]);  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadMaterial,The following statement contains a magic number: for (i = 0; i < 4; i++) {  	temp = readString ();  	if (i != 1) {  		temp = temp.Substring (14);  	} else {  		temp = temp.Substring (13);  	}  	for (j = 0; j < 2; j++) {  		input [j] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  		temp = temp.Substring (temp.IndexOf (' ') + 1);  	}  	input [2] = (double)Double.Parse (temp);  	colors [i] = new Color (input [0]' input [1]' input [2]);  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadMaterial,The following statement contains a magic number: for (i = 0; i < 4; i++) {  	temp = readString ();  	if (i != 1) {  		temp = temp.Substring (14);  	} else {  		temp = temp.Substring (13);  	}  	for (j = 0; j < 2; j++) {  		input [j] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  		temp = temp.Substring (temp.IndexOf (' ') + 1);  	}  	input [2] = (double)Double.Parse (temp);  	colors [i] = new Color (input [0]' input [1]' input [2]);  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadMaterial,The following statement contains a magic number: if (i != 1) {  	temp = temp.Substring (14);  } else {  	temp = temp.Substring (13);  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadMaterial,The following statement contains a magic number: if (i != 1) {  	temp = temp.Substring (14);  } else {  	temp = temp.Substring (13);  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadMaterial,The following statement contains a magic number: temp = temp.Substring (14);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadMaterial,The following statement contains a magic number: temp = temp.Substring (13);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadMaterial,The following statement contains a magic number: for (j = 0; j < 2; j++) {  	input [j] = (double)Double.Parse (temp.Substring (0' temp.IndexOf (' ')));  	temp = temp.Substring (temp.IndexOf (' ') + 1);  }  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadMaterial,The following statement contains a magic number: input [2] = (double)Double.Parse (temp);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadMaterial,The following statement contains a magic number: colors [i] = new Color (input [0]' input [1]' input [2]);  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadMaterial,The following statement contains a magic number: shininess = (double)Double.Parse (temp.Substring (14));  
Magic Number,Benchmarks.SpecRaytracer,Scene,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\Scene.cs,ReadMaterial,The following statement contains a magic number: ktran = (double)Double.Parse (temp.Substring (10));  
Magic Number,Benchmarks.SpecRaytracer,TriangleObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\TriangleObj.cs,TriangleObj,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	temp [i] = new Vector (vertices [i].GetX ()' vertices [i].GetY ()' vertices [i].GetZ ());  }  
Magic Number,Benchmarks.SpecRaytracer,TriangleObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\TriangleObj.cs,TriangleObj,The following statement contains a magic number: S1.Cross (temp [1]' temp [2]);  
Magic Number,Benchmarks.SpecRaytracer,TriangleObj,D:\newReposJune17\xamarin_benchmarker\tools\Benchmarks\SpecRaytracer\TriangleObj.cs,TriangleObj,The following statement contains a magic number: S2.Cross (temp [2]' temp [0]);  
