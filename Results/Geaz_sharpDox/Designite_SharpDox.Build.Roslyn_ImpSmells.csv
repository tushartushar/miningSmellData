Implementation smell,Namespace,Class,File,Method,Description
Complex Method,SharpDox.Build.Roslyn.Parser.ProjectParser,DocumentationParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\DocumentationParser.cs,ParseContentTokens,Cyclomatic complexity of the method is 14
Complex Method,SharpDox.Build.Roslyn.Parser.ProjectParser,UseParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\UseParser.cs,ResolveCall,Cyclomatic complexity of the method is 8
Long Parameter List,SharpDox.Build.Roslyn,RoslynParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\RoslynParser.cs,GetParsedSolution,The method has 5 parameters. Parameters: solutionFile' sharpDoxConfig' tokens' parseMethodCalls' ignoreExcludes
Long Statement,SharpDox.Build.Roslyn.Parser.ProjectParser,DocumentationParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\DocumentationParser.cs,ParseDocumentation,The length of the statement  "                    if (CultureInfo.GetCultures(CultureTypes.NeutralCultures).Any(c => c.TwoLetterISOLanguageName == isoCode) || isoCode == "default") " is 130.
Long Statement,SharpDox.Build.Roslyn.Parser.ProjectParser,DocumentationParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\DocumentationParser.cs,ParseContentTokens,The length of the statement  "                            var formattedResult = Formatter.Format(CSharpSyntaxTree.ParseText(nodeElement.Value' CSharpParseOptions.Default).GetRoot()' workspace); " is 135.
Long Statement,SharpDox.Build.Roslyn.Parser.ProjectParser,SeeParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\SeeParser.cs,ResolveAllSeeTokens,The length of the statement  "                                var splittedName = seeToken.Name.Replace("("' string.Empty).Replace(")"' string.Empty).Split(new [] {"`"}' StringSplitOptions.RemoveEmptyEntries); " is 146.
Long Statement,SharpDox.Build.Roslyn.Parser.ProjectParser,UseParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\UseParser.cs,ResolveCall,The length of the statement  "                if (calledType != null && callerType != null && calledType.Identifier != callerType.Identifier && !calledType.IsProjectStranger && !callerType.IsProjectStranger) " is 161.
Long Statement,SharpDox.Build.Roslyn.Parser.ProjectParser,UseParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\UseParser.cs,ResolveCall,The length of the statement  "                    if (!calledType.IsProjectStranger && calledType.UsedBy.SingleOrDefault(u => u.Identifier == callerType.Identifier) == null) " is 123.
Long Statement,SharpDox.Build.Roslyn.Parser.ProjectParser,UseParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\UseParser.cs,ResolveCall,The length of the statement  "                    if (!calledType.IsProjectStranger && callerType.Uses.SingleOrDefault(u => u.Identifier == calledType.Identifier) == null) " is 121.
Long Statement,SharpDox.Build.Roslyn.Parser.ProjectParser,FieldParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\FieldParser.cs,ParseFields,The length of the statement  "            var fields = typeSymbol.GetMembers().Where(m => m.Kind == SymbolKind.Field && !m.IsImplicitlyDeclared).Select(f => f as IFieldSymbol); " is 134.
Long Statement,SharpDox.Build.Roslyn.Parser.ProjectParser,MethodParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\MethodParser.cs,ParseConstructors,The length of the statement  "            constructors = constructors.Where(o => !o.ContainingType.GetIdentifier().StartsWith("System.Object") && !o.IsImplicitlyDeclared).ToList(); " is 138.
Long Statement,SharpDox.Build.Roslyn.Parser.ProjectParser,MethodParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\MethodParser.cs,ParseMethods,The length of the statement  "            var methods = typeSymbol.GetMembers().Where(m => m.Kind == SymbolKind.Method && !m.IsImplicitlyDeclared).Select(f => f as IMethodSymbol); " is 137.
Long Statement,SharpDox.Build.Roslyn.Parser.ProjectParser,MethodParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\MethodParser.cs,ParseMethods,The length of the statement  "            methods = methods.Where(o => !o.ContainingType.GetIdentifier().StartsWith("System.Object") && o.MethodKind == MethodKind.Ordinary); " is 131.
Long Statement,SharpDox.Build.Roslyn.Parser.ProjectParser,NamespaceParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\NamespaceParser.cs,ParseProjectNamespacesRecursively,The length of the statement  "            if (!ParserOptions.SharpDoxConfig.ExcludedIdentifiers.Contains(namespaceSymbol.GetIdentifier()) || ParserOptions.IgnoreExcludes) " is 128.
Long Statement,SharpDox.Build.Roslyn.Parser.ProjectParser,NamespaceParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\NamespaceParser.cs,GetParsedNamespace,The length of the statement  "            var descriptionFiles = _descriptionFiles.Where(d => Path.GetFileName(d).ToLower().Contains(namespaceSymbol.ToDisplayString().ToLower() + ".sdnd")); " is 147.
Long Statement,SharpDox.Build.Roslyn.Parser.ProjectParser,NamespaceParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\NamespaceParser.cs,GetParsedNamespace,The length of the statement  "                    if (splitted.Length > 0 && splitted[0].Length == 2 && CultureInfo.GetCultures(CultureTypes.AllCultures).Any(c => c.TwoLetterISOLanguageName == splitted[0])) " is 156.
Long Statement,SharpDox.Build.Roslyn.Parser.ProjectParser,TypeParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\TypeParser.cs,AddParsedBaseType,The length of the statement  "                if (sdType.BaseTypes.SingleOrDefault((i => i.Type.Identifier == typeRef.Type.Identifier)) == null && typeRef.Type.Fullname != "System.Object") " is 142.
Long Statement,SharpDox.Build.Roslyn.Parser.ProjectParser,TypeParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\TypeParser.cs,AddParsedInterfaces,The length of the statement  "                    if (sdType.ImplementedInterfaces.SingleOrDefault((i => i.Type.Identifier == typeRef.Type.Identifier)) == null && typeRef.Type.Fullname != "System.Object") " is 154.
Long Statement,SharpDox.Build.Roslyn.Parser.ProjectParser,TypeParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\TypeParser.cs,AddParsedNestedTypes,The length of the statement  "                    if (sdType.NestedTypes.SingleOrDefault((i => i.Type.Identifier == typeRef.Type.Identifier)) == null && typeRef.Type.Fullname != "System.Object") " is 144.
Long Statement,SharpDox.Build.Roslyn.MethodVisitors,CSharpMethodVisitor,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\MethodVisitors\CSharpMethodVisitor.cs,ParseTargetExpression,The length of the statement  "                        calledType = new SDType(member.ContainingType.GetIdentifier()' member.ContainingType.Name' sdNamespace) { IsProjectStranger = true }; " is 133.
Long Statement,SharpDox.Build.Roslyn.MethodVisitors,CSharpMethodVisitor,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\MethodVisitors\CSharpMethodVisitor.cs,ParseTargetExpression,The length of the statement  "                        SDMethod sdMethod = sdType.Methods.Concat(sdType.Constructors).SingleOrDefault(m => m.Identifier == method.GetIdentifier()); " is 124.
Complex Conditional,SharpDox.Build.Roslyn.Parser.ProjectParser,UseParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\UseParser.cs,ResolveCall,The conditional expression  "calledType != null && callerType != null && calledType.Identifier != callerType.Identifier && !calledType.IsProjectStranger && !callerType.IsProjectStranger"  is complex.
Magic Number,SharpDox.Build.Roslyn.Parser.ProjectParser,SeeParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\SeeParser.cs,ResolveAllSeeTokens,The following statement contains a magic number: foreach (var token in _seeTokens)              {                  var seeToken = ((SDSeeToken) token);                  var cref = XElement.Parse(seeToken.AttributeValue).Attributes().FirstOrDefault(a => a.Name == "cref");                  if (!string.IsNullOrEmpty(cref?.Value) && !cref.Value.StartsWith("!:"))                  {                      var cleanedRef = cref.Value.Substring(2);                      var splitted = cleanedRef.Split('.');                      switch (cref.Value[0])                      {                          case 'T':                              seeToken.Name = splitted.Last();                              seeToken.Namespace = string.Join("."' splitted.Take(splitted.Length - 1));                              seeToken.Text = splitted.Last();                              seeToken.Identifier = $"{seeToken.Namespace}.{seeToken.Name}";                                if (cleanedRef.Contains('`'))                              {                                  var splittedName = seeToken.Name.Split('`');                                  var type = _sdRepository.GetAllTypes().FirstOrDefault(                                      t => t.Namespace.Fullname == seeToken.Namespace &&                                           t.Name == splittedName[0] && t.TypeArguments.Count == int.Parse(splittedName[1]));                                    seeToken.Identifier = type?.Identifier;                                  seeToken.Name = type != null ? type.Name : $"Missing: {seeToken.AttributeValue}";                                  seeToken.Text = seeToken.Name;                              }                              break;                          default:                              //TODO See parsing' if type is generic                              seeToken.Name = splitted.Last();                                var declaringType = string.Empty;                              var typeNamespace = string.Empty;                                if (splitted.Length >= 2)                              {                                  typeNamespace = string.Join("."' splitted.Take(splitted.Length - 2));                                  declaringType = splitted[splitted.Length - 2];                              }                                seeToken.Namespace = typeNamespace;                              seeToken.DeclaringType = declaringType;                              seeToken.Text = splitted.Last();                              seeToken.Identifier = $"{seeToken.Namespace}.{seeToken.DeclaringType}.{seeToken.Name}";                                if (seeToken.Name.Contains('`'))                              {                                  var splittedName = seeToken.Name.Replace("("' string.Empty).Replace(")"' string.Empty).Split(new [] {"`"}' StringSplitOptions.RemoveEmptyEntries);                                  var sdMethod = _sdRepository.GetAllMethods().FirstOrDefault(                                      m => m.Namespace == seeToken.Namespace &&                                      m.Name == splittedName[0] && m.TypeParameters.Count == int.Parse(splittedName[1]) &&                                      m.Parameters.Count == splittedName.Length - 2);                                    seeToken.Identifier = sdMethod?.Identifier;                                  seeToken.Name = sdMethod != null ? sdMethod.Name : $"Missing: {seeToken.AttributeValue}";                                  seeToken.Text = seeToken.Name;                              }                              break;                      }                  }              }
Magic Number,SharpDox.Build.Roslyn.Parser.ProjectParser,SeeParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\SeeParser.cs,ResolveAllSeeTokens,The following statement contains a magic number: foreach (var token in _seeTokens)              {                  var seeToken = ((SDSeeToken) token);                  var cref = XElement.Parse(seeToken.AttributeValue).Attributes().FirstOrDefault(a => a.Name == "cref");                  if (!string.IsNullOrEmpty(cref?.Value) && !cref.Value.StartsWith("!:"))                  {                      var cleanedRef = cref.Value.Substring(2);                      var splitted = cleanedRef.Split('.');                      switch (cref.Value[0])                      {                          case 'T':                              seeToken.Name = splitted.Last();                              seeToken.Namespace = string.Join("."' splitted.Take(splitted.Length - 1));                              seeToken.Text = splitted.Last();                              seeToken.Identifier = $"{seeToken.Namespace}.{seeToken.Name}";                                if (cleanedRef.Contains('`'))                              {                                  var splittedName = seeToken.Name.Split('`');                                  var type = _sdRepository.GetAllTypes().FirstOrDefault(                                      t => t.Namespace.Fullname == seeToken.Namespace &&                                           t.Name == splittedName[0] && t.TypeArguments.Count == int.Parse(splittedName[1]));                                    seeToken.Identifier = type?.Identifier;                                  seeToken.Name = type != null ? type.Name : $"Missing: {seeToken.AttributeValue}";                                  seeToken.Text = seeToken.Name;                              }                              break;                          default:                              //TODO See parsing' if type is generic                              seeToken.Name = splitted.Last();                                var declaringType = string.Empty;                              var typeNamespace = string.Empty;                                if (splitted.Length >= 2)                              {                                  typeNamespace = string.Join("."' splitted.Take(splitted.Length - 2));                                  declaringType = splitted[splitted.Length - 2];                              }                                seeToken.Namespace = typeNamespace;                              seeToken.DeclaringType = declaringType;                              seeToken.Text = splitted.Last();                              seeToken.Identifier = $"{seeToken.Namespace}.{seeToken.DeclaringType}.{seeToken.Name}";                                if (seeToken.Name.Contains('`'))                              {                                  var splittedName = seeToken.Name.Replace("("' string.Empty).Replace(")"' string.Empty).Split(new [] {"`"}' StringSplitOptions.RemoveEmptyEntries);                                  var sdMethod = _sdRepository.GetAllMethods().FirstOrDefault(                                      m => m.Namespace == seeToken.Namespace &&                                      m.Name == splittedName[0] && m.TypeParameters.Count == int.Parse(splittedName[1]) &&                                      m.Parameters.Count == splittedName.Length - 2);                                    seeToken.Identifier = sdMethod?.Identifier;                                  seeToken.Name = sdMethod != null ? sdMethod.Name : $"Missing: {seeToken.AttributeValue}";                                  seeToken.Text = seeToken.Name;                              }                              break;                      }                  }              }
Magic Number,SharpDox.Build.Roslyn.Parser.ProjectParser,SeeParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\SeeParser.cs,ResolveAllSeeTokens,The following statement contains a magic number: foreach (var token in _seeTokens)              {                  var seeToken = ((SDSeeToken) token);                  var cref = XElement.Parse(seeToken.AttributeValue).Attributes().FirstOrDefault(a => a.Name == "cref");                  if (!string.IsNullOrEmpty(cref?.Value) && !cref.Value.StartsWith("!:"))                  {                      var cleanedRef = cref.Value.Substring(2);                      var splitted = cleanedRef.Split('.');                      switch (cref.Value[0])                      {                          case 'T':                              seeToken.Name = splitted.Last();                              seeToken.Namespace = string.Join("."' splitted.Take(splitted.Length - 1));                              seeToken.Text = splitted.Last();                              seeToken.Identifier = $"{seeToken.Namespace}.{seeToken.Name}";                                if (cleanedRef.Contains('`'))                              {                                  var splittedName = seeToken.Name.Split('`');                                  var type = _sdRepository.GetAllTypes().FirstOrDefault(                                      t => t.Namespace.Fullname == seeToken.Namespace &&                                           t.Name == splittedName[0] && t.TypeArguments.Count == int.Parse(splittedName[1]));                                    seeToken.Identifier = type?.Identifier;                                  seeToken.Name = type != null ? type.Name : $"Missing: {seeToken.AttributeValue}";                                  seeToken.Text = seeToken.Name;                              }                              break;                          default:                              //TODO See parsing' if type is generic                              seeToken.Name = splitted.Last();                                var declaringType = string.Empty;                              var typeNamespace = string.Empty;                                if (splitted.Length >= 2)                              {                                  typeNamespace = string.Join("."' splitted.Take(splitted.Length - 2));                                  declaringType = splitted[splitted.Length - 2];                              }                                seeToken.Namespace = typeNamespace;                              seeToken.DeclaringType = declaringType;                              seeToken.Text = splitted.Last();                              seeToken.Identifier = $"{seeToken.Namespace}.{seeToken.DeclaringType}.{seeToken.Name}";                                if (seeToken.Name.Contains('`'))                              {                                  var splittedName = seeToken.Name.Replace("("' string.Empty).Replace(")"' string.Empty).Split(new [] {"`"}' StringSplitOptions.RemoveEmptyEntries);                                  var sdMethod = _sdRepository.GetAllMethods().FirstOrDefault(                                      m => m.Namespace == seeToken.Namespace &&                                      m.Name == splittedName[0] && m.TypeParameters.Count == int.Parse(splittedName[1]) &&                                      m.Parameters.Count == splittedName.Length - 2);                                    seeToken.Identifier = sdMethod?.Identifier;                                  seeToken.Name = sdMethod != null ? sdMethod.Name : $"Missing: {seeToken.AttributeValue}";                                  seeToken.Text = seeToken.Name;                              }                              break;                      }                  }              }
Magic Number,SharpDox.Build.Roslyn.Parser.ProjectParser,SeeParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\SeeParser.cs,ResolveAllSeeTokens,The following statement contains a magic number: foreach (var token in _seeTokens)              {                  var seeToken = ((SDSeeToken) token);                  var cref = XElement.Parse(seeToken.AttributeValue).Attributes().FirstOrDefault(a => a.Name == "cref");                  if (!string.IsNullOrEmpty(cref?.Value) && !cref.Value.StartsWith("!:"))                  {                      var cleanedRef = cref.Value.Substring(2);                      var splitted = cleanedRef.Split('.');                      switch (cref.Value[0])                      {                          case 'T':                              seeToken.Name = splitted.Last();                              seeToken.Namespace = string.Join("."' splitted.Take(splitted.Length - 1));                              seeToken.Text = splitted.Last();                              seeToken.Identifier = $"{seeToken.Namespace}.{seeToken.Name}";                                if (cleanedRef.Contains('`'))                              {                                  var splittedName = seeToken.Name.Split('`');                                  var type = _sdRepository.GetAllTypes().FirstOrDefault(                                      t => t.Namespace.Fullname == seeToken.Namespace &&                                           t.Name == splittedName[0] && t.TypeArguments.Count == int.Parse(splittedName[1]));                                    seeToken.Identifier = type?.Identifier;                                  seeToken.Name = type != null ? type.Name : $"Missing: {seeToken.AttributeValue}";                                  seeToken.Text = seeToken.Name;                              }                              break;                          default:                              //TODO See parsing' if type is generic                              seeToken.Name = splitted.Last();                                var declaringType = string.Empty;                              var typeNamespace = string.Empty;                                if (splitted.Length >= 2)                              {                                  typeNamespace = string.Join("."' splitted.Take(splitted.Length - 2));                                  declaringType = splitted[splitted.Length - 2];                              }                                seeToken.Namespace = typeNamespace;                              seeToken.DeclaringType = declaringType;                              seeToken.Text = splitted.Last();                              seeToken.Identifier = $"{seeToken.Namespace}.{seeToken.DeclaringType}.{seeToken.Name}";                                if (seeToken.Name.Contains('`'))                              {                                  var splittedName = seeToken.Name.Replace("("' string.Empty).Replace(")"' string.Empty).Split(new [] {"`"}' StringSplitOptions.RemoveEmptyEntries);                                  var sdMethod = _sdRepository.GetAllMethods().FirstOrDefault(                                      m => m.Namespace == seeToken.Namespace &&                                      m.Name == splittedName[0] && m.TypeParameters.Count == int.Parse(splittedName[1]) &&                                      m.Parameters.Count == splittedName.Length - 2);                                    seeToken.Identifier = sdMethod?.Identifier;                                  seeToken.Name = sdMethod != null ? sdMethod.Name : $"Missing: {seeToken.AttributeValue}";                                  seeToken.Text = seeToken.Name;                              }                              break;                      }                  }              }
Magic Number,SharpDox.Build.Roslyn.Parser.ProjectParser,SeeParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\SeeParser.cs,ResolveAllSeeTokens,The following statement contains a magic number: foreach (var token in _seeTokens)              {                  var seeToken = ((SDSeeToken) token);                  var cref = XElement.Parse(seeToken.AttributeValue).Attributes().FirstOrDefault(a => a.Name == "cref");                  if (!string.IsNullOrEmpty(cref?.Value) && !cref.Value.StartsWith("!:"))                  {                      var cleanedRef = cref.Value.Substring(2);                      var splitted = cleanedRef.Split('.');                      switch (cref.Value[0])                      {                          case 'T':                              seeToken.Name = splitted.Last();                              seeToken.Namespace = string.Join("."' splitted.Take(splitted.Length - 1));                              seeToken.Text = splitted.Last();                              seeToken.Identifier = $"{seeToken.Namespace}.{seeToken.Name}";                                if (cleanedRef.Contains('`'))                              {                                  var splittedName = seeToken.Name.Split('`');                                  var type = _sdRepository.GetAllTypes().FirstOrDefault(                                      t => t.Namespace.Fullname == seeToken.Namespace &&                                           t.Name == splittedName[0] && t.TypeArguments.Count == int.Parse(splittedName[1]));                                    seeToken.Identifier = type?.Identifier;                                  seeToken.Name = type != null ? type.Name : $"Missing: {seeToken.AttributeValue}";                                  seeToken.Text = seeToken.Name;                              }                              break;                          default:                              //TODO See parsing' if type is generic                              seeToken.Name = splitted.Last();                                var declaringType = string.Empty;                              var typeNamespace = string.Empty;                                if (splitted.Length >= 2)                              {                                  typeNamespace = string.Join("."' splitted.Take(splitted.Length - 2));                                  declaringType = splitted[splitted.Length - 2];                              }                                seeToken.Namespace = typeNamespace;                              seeToken.DeclaringType = declaringType;                              seeToken.Text = splitted.Last();                              seeToken.Identifier = $"{seeToken.Namespace}.{seeToken.DeclaringType}.{seeToken.Name}";                                if (seeToken.Name.Contains('`'))                              {                                  var splittedName = seeToken.Name.Replace("("' string.Empty).Replace(")"' string.Empty).Split(new [] {"`"}' StringSplitOptions.RemoveEmptyEntries);                                  var sdMethod = _sdRepository.GetAllMethods().FirstOrDefault(                                      m => m.Namespace == seeToken.Namespace &&                                      m.Name == splittedName[0] && m.TypeParameters.Count == int.Parse(splittedName[1]) &&                                      m.Parameters.Count == splittedName.Length - 2);                                    seeToken.Identifier = sdMethod?.Identifier;                                  seeToken.Name = sdMethod != null ? sdMethod.Name : $"Missing: {seeToken.AttributeValue}";                                  seeToken.Text = seeToken.Name;                              }                              break;                      }                  }              }
Magic Number,SharpDox.Build.Roslyn.Parser.ProjectParser,NamespaceParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\NamespaceParser.cs,GetParsedNamespace,The following statement contains a magic number: foreach (var file in descriptionFiles)              {                  if (!string.IsNullOrEmpty(namespaceSymbol.ToDisplayString().Trim()))                  {                      var splitted = Path.GetFileName(file).ToLower().Replace(namespaceSymbol.ToDisplayString().ToLower()' " ").Split('.');                      if (splitted.Length > 0 && splitted[0].Length == 2 && CultureInfo.GetCultures(CultureTypes.AllCultures).Any(c => c.TwoLetterISOLanguageName == splitted[0]))                      {                          descriptions.Add(splitted[0]' new SDTemplate(File.ReadAllText(file)' ParserOptions.Tokens));                          ExecuteOnDocLanguageFound(splitted[0].ToLower());                      }                      else if (splitted.Length > 0 && string.IsNullOrEmpty(splitted[0].Trim()))                      {                          descriptions.Add("default"' new SDTemplate(File.ReadAllText(file)' ParserOptions.Tokens));                      }                  }              }
Magic Number,SharpDox.Build.Roslyn,RoslynParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\RoslynParser.cs,ParseProjects,The following statement contains a magic number: for (int i = 0; i < projects.Count; i++)              {                  var project = projects[i];                  ExecuteOnStepMessage(string.Format(_parserStrings.CompilingAndParsing' project.Name));                  ExecuteOnStepProgress((int)((double)i / projects.Count * 50));                    var projectCompilation = project.GetCompilationAsync().Result;                  var targetFx = _targetFxParser.GetTargetFx(project.FilePath);                  var sdRepository = parserOptions.SDSolution.GetExistingOrNew(targetFx);                                    parserOptions.SDRepository = sdRepository;                    var nparser = new NamespaceParser(parserOptions);                  nparser.ParseProjectNamespacesRecursively(projectCompilation.Assembly.GlobalNamespace);                    if (!_seeTokens.ContainsKey(targetFx))                  {                      _seeTokens.Add(targetFx' new List<SDToken>());                  }                  _seeTokens[targetFx].AddRange(parserOptions.SeeTokens);              }
Magic Number,SharpDox.Build.Roslyn,RoslynParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\RoslynParser.cs,ParseProjects,The following statement contains a magic number: ExecuteOnStepProgress(40);
Magic Number,SharpDox.Build.Roslyn,RoslynParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\RoslynParser.cs,CleanUpNamespaces,The following statement contains a magic number: for(int i = 0; i < sdSolution.Repositories.Count; i++)              {                  var sdRepository = sdSolution.Repositories[i];                  ExecuteOnStepMessage(string.Format(_parserStrings.CleanUp' sdRepository.TargetFx.Name));                  ExecuteOnStepProgress((int)((double)i / sdSolution.Repositories.Count * 10) + 50);                    foreach (var sdNamespace in sdRepository.GetAllNamespaces())                  {                      if (sdNamespace.Types.Count == 0) sdRepository.RemoveNamespace(sdNamespace);                  }              }
Magic Number,SharpDox.Build.Roslyn,RoslynParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\RoslynParser.cs,CleanUpNamespaces,The following statement contains a magic number: for(int i = 0; i < sdSolution.Repositories.Count; i++)              {                  var sdRepository = sdSolution.Repositories[i];                  ExecuteOnStepMessage(string.Format(_parserStrings.CleanUp' sdRepository.TargetFx.Name));                  ExecuteOnStepProgress((int)((double)i / sdSolution.Repositories.Count * 10) + 50);                    foreach (var sdNamespace in sdRepository.GetAllNamespaces())                  {                      if (sdNamespace.Types.Count == 0) sdRepository.RemoveNamespace(sdNamespace);                  }              }
Magic Number,SharpDox.Build.Roslyn,RoslynParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\RoslynParser.cs,CleanUpNamespaces,The following statement contains a magic number: ExecuteOnStepProgress(50);
Magic Number,SharpDox.Build.Roslyn,RoslynParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\RoslynParser.cs,ParseMethodCalls,The following statement contains a magic number: for (int i = 0; i < parserOptions.SDSolution.Repositories.Count; i++)              {                  var sdRepository = parserOptions.SDSolution.Repositories[i];                  ExecuteOnStepMessage(string.Format(_parserStrings.ParsingMethod' sdRepository.TargetFx.Name));                  ExecuteOnStepProgress((int)((double)i / parserOptions.SDSolution.Repositories.Count * 40) + 60);                    var methodParser = new MethodCallParser(parserOptions);                  methodParser.ParseMethodCalls();              }
Magic Number,SharpDox.Build.Roslyn,RoslynParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\RoslynParser.cs,ParseMethodCalls,The following statement contains a magic number: for (int i = 0; i < parserOptions.SDSolution.Repositories.Count; i++)              {                  var sdRepository = parserOptions.SDSolution.Repositories[i];                  ExecuteOnStepMessage(string.Format(_parserStrings.ParsingMethod' sdRepository.TargetFx.Name));                  ExecuteOnStepProgress((int)((double)i / parserOptions.SDSolution.Repositories.Count * 40) + 60);                    var methodParser = new MethodCallParser(parserOptions);                  methodParser.ParseMethodCalls();              }
Magic Number,SharpDox.Build.Roslyn,RoslynParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\RoslynParser.cs,ResolveUses,The following statement contains a magic number: for (int i = 0; i < parserOptions.SDSolution.Repositories.Count; i++)              {                  var sdRepository = parserOptions.SDSolution.Repositories[i];                  ExecuteOnStepMessage(string.Format(_parserStrings.ParsingUseings' sdRepository.TargetFx.Name));                  ExecuteOnStepProgress((int)((double)i / parserOptions.SDSolution.Repositories.Count * 40) + 60);                    var useParser = new UseParser(sdRepository);                  useParser.ResolveAllUses();              }
Magic Number,SharpDox.Build.Roslyn,RoslynParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\RoslynParser.cs,ResolveUses,The following statement contains a magic number: for (int i = 0; i < parserOptions.SDSolution.Repositories.Count; i++)              {                  var sdRepository = parserOptions.SDSolution.Repositories[i];                  ExecuteOnStepMessage(string.Format(_parserStrings.ParsingUseings' sdRepository.TargetFx.Name));                  ExecuteOnStepProgress((int)((double)i / parserOptions.SDSolution.Repositories.Count * 40) + 60);                    var useParser = new UseParser(sdRepository);                  useParser.ResolveAllUses();              }
Magic Number,SharpDox.Build.Roslyn,RoslynParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\RoslynParser.cs,ResolveSeeTokens,The following statement contains a magic number: for (int i = 0; i < parserOptions.SDSolution.Repositories.Count; i++)              {                  var sdRepository = parserOptions.SDSolution.Repositories[i];                  ExecuteOnStepMessage(string.Format(_parserStrings.ParsingSeeTokens' sdRepository.TargetFx.Name));                  ExecuteOnStepProgress((int) ((double) i/parserOptions.SDSolution.Repositories.Count*40) + 60);                                    var seeParser = new SeeParser(sdRepository' _seeTokens[sdRepository.TargetFx]);                  seeParser.ResolveAllSeeTokens();              }
Magic Number,SharpDox.Build.Roslyn,RoslynParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\RoslynParser.cs,ResolveSeeTokens,The following statement contains a magic number: for (int i = 0; i < parserOptions.SDSolution.Repositories.Count; i++)              {                  var sdRepository = parserOptions.SDSolution.Repositories[i];                  ExecuteOnStepMessage(string.Format(_parserStrings.ParsingSeeTokens' sdRepository.TargetFx.Name));                  ExecuteOnStepProgress((int) ((double) i/parserOptions.SDSolution.Repositories.Count*40) + 60);                                    var seeParser = new SeeParser(sdRepository' _seeTokens[sdRepository.TargetFx]);                  seeParser.ResolveAllSeeTokens();              }
Missing Default,SharpDox.Build.Roslyn.Parser.ProjectParser,DocumentationParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\DocumentationParser.cs,ParseDocumentation,The following switch statement is missing a default case: switch (child.Name.LocalName.ToLower())                  {                      case "typeparam":                          var typeparamKey = child.Attribute("name")?.Value ?? "typeparam";                          if (!sdDocumentation.TypeParams.ContainsKey(typeparamKey))                              sdDocumentation.TypeParams.Add(typeparamKey' ParseContentTokens(child' multilang));                          break;                      case "param":                          var paramKey = child.Attribute("name")?.Value ?? "param";                          if (!sdDocumentation.Params.ContainsKey(paramKey))                              sdDocumentation.Params.Add(paramKey' ParseContentTokens(child' multilang));                          break;                      case "exception":                          var exKey = child.Attribute("cref")?.Value ?? "exception";                          if (!sdDocumentation.Exceptions.ContainsKey(exKey))                              sdDocumentation.Exceptions.Add(exKey' ParseContentTokens(child' multilang));                          break;                      case "summary":                          sdDocumentation.Summary = ParseContentTokens(child' multilang);                          break;                      case "remarks":                          sdDocumentation.Remarks = ParseContentTokens(child' multilang);                          break;                      case "example":                          sdDocumentation.Example = ParseContentTokens(child' multilang);                          break;                      case "returns":                          AddResultsSection(sdDocumentation.Returns' child' multilang);                          break;                      case "seealso":                          var seeToken = new SDSeeToken(child.ToString());                          _seeTokens.Add(seeToken);                          sdDocumentation.SeeAlsos.Add(seeToken);                          break;                  }
Missing Default,SharpDox.Build.Roslyn.Parser.ProjectParser,DocumentationParser,C:\repos\Geaz_sharpDox\src\Libraries\SharpDox.Build.Roslyn\Parser\ProjectParser\DocumentationParser.cs,ParseContentTokens,The following switch statement is missing a default case: switch (nodeElement.Name.LocalName.ToLower())                      {                          case "see":                              var seeToken = new SDSeeToken(nodeElement.ToString());                              _seeTokens.Add(seeToken);                              content.Add(seeToken);                              break;                          case "typeparamref":                              content.Add(new SDToken { Role = SDTokenRole.TypeParamRef' Text = nodeElement.Attribute("name")?.Value });                              break;                          case "paramref":                              content.Add(new SDToken { Role = SDTokenRole.ParamRef' Text = nodeElement.Attribute("name")?.Value });                              break;                          case "code":                              var workspace = MSBuildWorkspace.Create();                              var formattedResult = Formatter.Format(CSharpSyntaxTree.ParseText(nodeElement.Value' CSharpParseOptions.Default).GetRoot()' workspace);                              content.Add(new SDCodeToken { Text = formattedResult.ToString()' IsInline = false });                              break;                          case "c":                              content.Add(new SDCodeToken { Text = nodeElement.Value' IsInline = true });                              break;                          case "para":                              content.Add(new SDToken { Text = nodeElement.Value' Role = SDTokenRole.Paragraph });                              break;                      }
