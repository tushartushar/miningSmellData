Implementation smell,Namespace,Class,File,Method,Description
Long Method,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_fast,The method has 114 lines of code.
Long Method,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_slow,The method has 146 lines of code.
Long Method,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The method has 169 lines of code.
Long Method,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The method has 494 lines of code.
Long Method,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The method has 349 lines of code.
Long Method,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The method has 232 lines of code.
Long Method,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The method has 196 lines of code.
Long Method,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The method has 214 lines of code.
Complex Method,VncSharp,RemoteDesktop,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,SyncModifierKeyState,Cyclomatic complexity of the method is 9
Complex Method,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,Cyclomatic complexity of the method is 9
Complex Method,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,Connect,Cyclomatic complexity of the method is 9
Complex Method,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,GetRfbUpdates,Cyclomatic complexity of the method is 11
Complex Method,VncSharp.Encodings,HextileRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\HextileRectangle.cs,Decode,Cyclomatic complexity of the method is 9
Complex Method,VncSharp.Encodings,ZrleRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,Decode,Cyclomatic complexity of the method is 9
Complex Method,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,Cyclomatic complexity of the method is 10
Complex Method,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,Cyclomatic complexity of the method is 10
Complex Method,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_stored,Cyclomatic complexity of the method is 11
Complex Method,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_fast,Cyclomatic complexity of the method is 14
Complex Method,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_slow,Cyclomatic complexity of the method is 18
Complex Method,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,Cyclomatic complexity of the method is 26
Complex Method,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,Cyclomatic complexity of the method is 52
Complex Method,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,inflate_flush,Cyclomatic complexity of the method is 9
Complex Method,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,Cyclomatic complexity of the method is 43
Complex Method,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,Cyclomatic complexity of the method is 36
Complex Method,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflateSync,Cyclomatic complexity of the method is 8
Complex Method,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,Cyclomatic complexity of the method is 26
Complex Method,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,inflate_trees_dynamic,Cyclomatic complexity of the method is 8
Complex Method,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,Cyclomatic complexity of the method is 12
Long Parameter List,VncSharp,NativeMethods,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\NativeMethods.cs,ToAscii,The method has 5 parameters. Parameters: uVirtKey' uScanCode' lpKeyState' lpwTransKey' fuState
Long Parameter List,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The method has 5 parameters. Parameters: b' width' height' bitsPerPixel' depth
Long Parameter List,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteFramebufferUpdateRequest,The method has 5 parameters. Parameters: x' y' width' height' incremental
Long Parameter List,VncSharp.Encodings,ZrleRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedPixels,The method has 5 parameters. Parameters: tw' th' palette' palSize' tile
Long Parameter List,VncSharp.Encodings,ZrleRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedRLEPixels,The method has 6 parameters. Parameters: tx' ty' tw' th' palette' tile
Long Parameter List,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The method has 6 parameters. Parameters: strm' level' method' windowBits' memLevel' strategy
Long Parameter List,VncSharp.zlib.NET,Config,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Config,The method has 5 parameters. Parameters: good_length' max_lazy' nice_length' max_chain' func
Long Parameter List,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,InfCodes,The method has 7 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' z
Long Parameter List,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,InfCodes,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The method has 8 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' s' z
Long Parameter List,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The method has 11 parameters. Parameters: b' bindex' n' s' d' e' t' m' hp' hn' v
Long Parameter List,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,inflate_trees_bits,The method has 5 parameters. Parameters: c' bb' tb' hp' z
Long Parameter List,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,inflate_trees_dynamic,The method has 9 parameters. Parameters: nl' nd' c' bl' bd' tl' td' hp' z
Long Parameter List,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,inflate_trees_fixed,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,VncSharp.zlib.NET,StaticTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\StaticTree.cs,StaticTree,The method has 5 parameters. Parameters: static_tree' extra_bits' extra_base' elems' max_length
Long Identifier,VncSharp,KeyboardHook,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\KeyboardHook.cs,,The length of the parameter LowLevelKeyboardProcStaticDelegate is 34.
Long Statement,VncSharp,KeyboardHook,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\KeyboardHook.cs,SetHook,The length of the statement  "            var hook = NativeMethods.SetWindowsHookEx(NativeMethods.WH_KEYBOARD_LL' LowLevelKeyboardProcStaticDelegate' NativeMethods.GetModuleHandle(curModule.ModuleName)' 0); " is 164.
Long Statement,VncSharp,KeyboardHook,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\KeyboardHook.cs,ModifierKeysMatch,The length of the statement  "            if ((requestedKeys & ModifierKeys.Control) != 0) pressedKeys &= ~(ModifierKeys.LeftControl | ModifierKeys.RightControl); " is 120.
Long Statement,VncSharp,KeyNotificationEntry,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\KeyboardHook.cs,Equals,The length of the statement  "                return obj != null && WindowHandle == obj.WindowHandle && KeyCode == obj.KeyCode && ModifierKeys == obj.ModifierKeys && Block == obj.Block; " is 139.
Long Statement,VncSharp,VncScaledDesktopPolicy,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncScaledDesktopPolicy.cs,AdjustUpdateRectangle,The length of the statement  "            var adjusted = new Rectangle(AdjusteNormalToScaled(updateRectangle.X) + (remoteDesktop.ClientRectangle.Width - scaledSize.Width) / 2' " is 133.
Long Statement,VncSharp,VncScaledDesktopPolicy,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncScaledDesktopPolicy.cs,GetScaledSize,The length of the statement  "			return (double)s.Width / vnc.Framebuffer.Width <= (double)s.Height / vnc.Framebuffer.Height ? new Size(s.Width' (int)((double)s.Width / vnc.Framebuffer.Width * vnc.Framebuffer.Height)) : new Size((int)((double)s.Height / vnc.Framebuffer.Height * vnc.Framebuffer.Width)' s.Height); " is 280.
Long Statement,VncSharp,RemoteDesktop,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,TranslateVirtualKey,The length of the statement  "            var charCount = NativeMethods.ToAscii(virtualKey' NativeMethods.MapVirtualKey(virtualKey' 0)' keyboardState' charResult' 0); " is 124.
Long Statement,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,Connect,The length of the statement  "			if (display < 0) throw new ArgumentOutOfRangeException(nameof(display)' display' "Display number must be non-negative."); " is 121.
Long Statement,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,Connect,The length of the statement  "			        throw new VncProtocolException("Connection Failed. The server rejected the connection for the following reason: " + rfb.ReadSecurityFailureReason()); " is 149.
Long Statement,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,Connect,The length of the statement  "			        throw new VncProtocolException("Unable to Connecto to the Server. The Server rejected the connection for the following reason: " + rfb.ReadSecurityFailureReason()); " is 164.
Long Statement,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,Authenticate,The length of the statement  "				throw new NotSupportedException("Unable to Authenticate with Server. The Server uses an Authentication scheme unknown to the client."); " is 135.
Long Statement,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,longest_match,The length of the statement  "				if (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan] || window[++match] != window[scan + 1]) " is 158.
Long Statement,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,longest_match,The length of the statement  "				while (window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend); " is 318.
Long Statement,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The length of the statement  "			if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) " is 177.
Long Statement,VncSharp.zlib.NET,ZStream,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\ZStream.cs,flush_pending,The length of the statement  "			if (dstate.pending_buf.Length <= dstate.pending_out || next_out.Length <= next_out_index || dstate.pending_buf.Length < dstate.pending_out + len || next_out.Length < next_out_index + len) " is 187.
Long Statement,VncSharp.zlib.NET,ZStream,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\ZStream.cs,flush_pending,The length of the statement  "				//System.Console.Out.WriteLine(dstate.pending_buf.Length + "' " + dstate.pending_out + "' " + next_out.Length + "' " + next_out_index + "' " + len); " is 148.
Complex Conditional,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The conditional expression  "b[0] == 82 &&		// R  					 b[1] == 70 &&		// F  					 b[2] == 66 &&		// B  					 b[3] == 32 &&		// (space)  					 b[4] == 48 &&		// 0  					 b[5] == 48 &&		// 0  					 b[6] == 52 &&		// 4  					 b[7] == 46 &&		// .  					 b[8] == 48 &&		// 0  					 b[9] == 48 &&		// 0  					 b[10] == 49 &&		// 1  					 b[11] == 10"  is complex.
Complex Conditional,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The conditional expression  "b[0]  == 0x52 &&					// R  				b[1]  == 0x46 &&					// F  				b[2]  == 0x42 &&					// B  				b[3]  == 0x20 &&					// (space)  				b[4]  == 0x30 &&					// 0  				b[5]  == 0x30 &&					// 0  				b[6]  == 0x33 &&					// 3  				b[7]  == 0x2e &&					// .  				(b[8]  == 0x30 ||					// 0  				 b[8]  == 0x38) &&					// BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					// 0  				 b[9] == 0x38) &&					// BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					// 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||				 	// BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a"  is complex.
Complex Conditional,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_slow,The conditional expression  "match_length <= 5 && (strategy == Z_FILTERED || match_length == MIN_MATCH && strstart - match_start > 4096)"  is complex.
Complex Conditional,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,longest_match,The conditional expression  "window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan] || window[++match] != window[scan + 1]"  is complex.
Complex Conditional,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The conditional expression  "memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateParams,The conditional expression  "_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The conditional expression  "strm.next_out == null || strm.next_in == null && strm.avail_in != 0 || status == FINISH_STATE && flush != Z_FINISH"  is complex.
Complex Conditional,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The conditional expression  "strm.avail_in != 0 || lookahead != 0 || flush != Z_NO_FLUSH && status != FINISH_STATE"  is complex.
Complex Conditional,VncSharp.zlib.NET,ZStream,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\ZStream.cs,flush_pending,The conditional expression  "dstate.pending_buf.Length <= dstate.pending_out || next_out.Length <= next_out_index || dstate.pending_buf.Length < dstate.pending_out + len || next_out.Length < next_out_index + len"  is complex.
Empty Catch Block,VncSharp,ZRLECompressedReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The method has an empty catch block.
Empty Catch Block,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,VncSharp.zlib.NET,ZOutputStream,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\ZOutputStream.cs,finish,The method has an empty catch block.
Empty Catch Block,VncSharp.zlib.NET,ZOutputStream,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\ZOutputStream.cs,Close,The method has an empty catch block.
Magic Number,VncSharp,VncDesignModeDesktopPolicy,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncDesignModeDesktopPolicy.cs,RepositionImage,The following statement contains a magic number: x = (remoteDesktop.ClientRectangle.Width - desktopImage.Width) / 2;
Magic Number,VncSharp,VncDesignModeDesktopPolicy,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncDesignModeDesktopPolicy.cs,RepositionImage,The following statement contains a magic number: y = (remoteDesktop.ClientRectangle.Height - desktopImage.Height) / 2;
Magic Number,VncSharp,VncScaledDesktopPolicy,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncScaledDesktopPolicy.cs,AdjustUpdateRectangle,The following statement contains a magic number: var adjusted = new Rectangle(AdjusteNormalToScaled(updateRectangle.X) + (remoteDesktop.ClientRectangle.Width - scaledSize.Width) / 2'                                                 AdjusteNormalToScaled(updateRectangle.Y) + (remoteDesktop.ClientRectangle.Height - scaledSize.Height) / 2'                                                 AdjusteNormalToScaled(updateRectangle.Width)'                                                 AdjusteNormalToScaled(updateRectangle.Height));
Magic Number,VncSharp,VncScaledDesktopPolicy,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncScaledDesktopPolicy.cs,AdjustUpdateRectangle,The following statement contains a magic number: var adjusted = new Rectangle(AdjusteNormalToScaled(updateRectangle.X) + (remoteDesktop.ClientRectangle.Width - scaledSize.Width) / 2'                                                 AdjusteNormalToScaled(updateRectangle.Y) + (remoteDesktop.ClientRectangle.Height - scaledSize.Height) / 2'                                                 AdjusteNormalToScaled(updateRectangle.Width)'                                                 AdjusteNormalToScaled(updateRectangle.Height));
Magic Number,VncSharp,VncScaledDesktopPolicy,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncScaledDesktopPolicy.cs,GetScaledMouse,The following statement contains a magic number: src.X = AdjusteScaledToNormal(src.X - (remoteDesktop.ClientRectangle.Width - scaledSize.Width) / 2);
Magic Number,VncSharp,VncScaledDesktopPolicy,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncScaledDesktopPolicy.cs,GetScaledMouse,The following statement contains a magic number: src.Y = AdjusteScaledToNormal(src.Y - (remoteDesktop.ClientRectangle.Height - scaledSize.Height) / 2);
Magic Number,VncSharp,VncScaledDesktopPolicy,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncScaledDesktopPolicy.cs,GetScaledRectangle,The following statement contains a magic number: return new Rectangle((rect.Width - scaledSize.Width) / 2'                                   (rect.Height - scaledSize.Height) / 2'                                    scaledSize.Width'                                    scaledSize.Height);
Magic Number,VncSharp,VncScaledDesktopPolicy,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncScaledDesktopPolicy.cs,GetScaledRectangle,The following statement contains a magic number: return new Rectangle((rect.Width - scaledSize.Width) / 2'                                   (rect.Height - scaledSize.Height) / 2'                                    scaledSize.Width'                                    scaledSize.Height);
Magic Number,VncSharp,VncClippedDesktopPolicy,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClippedDesktopPolicy.cs,UpdateRemotePointer,The following statement contains a magic number: adjusted.X = current.X - (remoteDesktop.ClientRectangle.Width - remoteDesktop.Desktop.Width) / 2;
Magic Number,VncSharp,VncClippedDesktopPolicy,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClippedDesktopPolicy.cs,UpdateRemotePointer,The following statement contains a magic number: adjusted.Y = current.Y - (remoteDesktop.ClientRectangle.Height - remoteDesktop.Desktop.Height) / 2;
Magic Number,VncSharp,VncClippedDesktopPolicy,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClippedDesktopPolicy.cs,AdjustUpdateRectangle,The following statement contains a magic number: x = updateRectangle.X + (remoteDesktop.ClientRectangle.Width - remoteDesktop.Desktop.Width) / 2;
Magic Number,VncSharp,VncClippedDesktopPolicy,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClippedDesktopPolicy.cs,AdjustUpdateRectangle,The following statement contains a magic number: y = updateRectangle.Y + (remoteDesktop.ClientRectangle.Height - remoteDesktop.Desktop.Height) / 2;
Magic Number,VncSharp,VncClippedDesktopPolicy,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClippedDesktopPolicy.cs,RepositionImage,The following statement contains a magic number: x = (remoteDesktop.ClientRectangle.Width - desktopImage.Width) / 2;
Magic Number,VncSharp,VncClippedDesktopPolicy,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClippedDesktopPolicy.cs,RepositionImage,The following statement contains a magic number: y = (remoteDesktop.ClientRectangle.Height - desktopImage.Height) / 2;
Magic Number,VncSharp,VncClippedDesktopPolicy,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClippedDesktopPolicy.cs,GetMouseMoveRectangle,The following statement contains a magic number: desktopRect.X = (remoteDesktop.ClientRectangle.Width - remoteDesktop.Desktop.Width) / 2;
Magic Number,VncSharp,VncClippedDesktopPolicy,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClippedDesktopPolicy.cs,GetMouseMoveRectangle,The following statement contains a magic number: desktopRect.Y = (remoteDesktop.ClientRectangle.Height - remoteDesktop.Desktop.Height) / 2;
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: var b = new byte[16];
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[2]  = (byte) (BigEndian ? 1 : 0);
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[3]  = (byte) (TrueColour ? 1 : 0);
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[4]  = (byte) ((RedMax >> 8) & 0xff);
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[4]  = (byte) ((RedMax >> 8) & 0xff);
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[5]  = (byte) (RedMax & 0xff);
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[6]  = (byte) ((GreenMax >> 8) & 0xff);
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[6]  = (byte) ((GreenMax >> 8) & 0xff);
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[7]  = (byte) (GreenMax & 0xff);
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[8]  = (byte) ((BlueMax >> 8) & 0xff);
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[8]  = (byte) ((BlueMax >> 8) & 0xff);
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[9]  = (byte) (BlueMax & 0xff);
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[10] = (byte) RedShift;
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[11] = (byte) GreenShift;
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[12] = (byte) BlueShift;
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: b.Length != 16
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: buffer.BitsPerPixel     = 16;
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: buffer.Depth            = 16;
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: buffer.BigEndian        = b[2] != 0;
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: buffer.RedMax           = 31;
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: buffer.GreenMax         = 63;
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: buffer.BlueMax          = 31;
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: buffer.RedShift         = 11;
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: buffer.GreenShift       = 5;
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: (bitsPerPixel == 16) && (depth == 16)
Magic Number,VncSharp,Framebuffer,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: (bitsPerPixel == 16) && (depth == 16)
Magic Number,VncSharp,PasswordDialog,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.Location = new System.Drawing.Point(144' 8);
Magic Number,VncSharp,PasswordDialog,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.Location = new System.Drawing.Point(144' 8);
Magic Number,VncSharp,PasswordDialog,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.Size = new System.Drawing.Size(64' 23);
Magic Number,VncSharp,PasswordDialog,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.Size = new System.Drawing.Size(64' 23);
Magic Number,VncSharp,PasswordDialog,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point(144' 40);
Magic Number,VncSharp,PasswordDialog,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point(144' 40);
Magic Number,VncSharp,PasswordDialog,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size(64' 23);
Magic Number,VncSharp,PasswordDialog,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size(64' 23);
Magic Number,VncSharp,PasswordDialog,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.TabIndex = 2;
Magic Number,VncSharp,PasswordDialog,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.txtPassword.Location = new System.Drawing.Point(16' 16);
Magic Number,VncSharp,PasswordDialog,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.txtPassword.Location = new System.Drawing.Point(16' 16);
Magic Number,VncSharp,PasswordDialog,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.txtPassword.Size = new System.Drawing.Size(112' 20);
Magic Number,VncSharp,PasswordDialog,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.txtPassword.Size = new System.Drawing.Size(112' 20);
Magic Number,VncSharp,PasswordDialog,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleBaseSize = new System.Drawing.Size(5' 13);
Magic Number,VncSharp,PasswordDialog,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleBaseSize = new System.Drawing.Size(5' 13);
Magic Number,VncSharp,PasswordDialog,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(216' 73);
Magic Number,VncSharp,PasswordDialog,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(216' 73);
Magic Number,VncSharp,RemoteDesktop,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,DrawDesktopMessage,The following statement contains a magic number: g.DrawString(message'                      new Font("Arial"' 12)'                      new SolidBrush(Color.White)'                      new PointF(vnc.Framebuffer.Width / 2' vnc.Framebuffer.Height / 2)' format);
Magic Number,VncSharp,RemoteDesktop,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,DrawDesktopMessage,The following statement contains a magic number: g.DrawString(message'                      new Font("Arial"' 12)'                      new SolidBrush(Color.White)'                      new PointF(vnc.Framebuffer.Width / 2' vnc.Framebuffer.Height / 2)' format);
Magic Number,VncSharp,RemoteDesktop,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,DrawDesktopMessage,The following statement contains a magic number: g.DrawString(message'                      new Font("Arial"' 12)'                      new SolidBrush(Color.White)'                      new PointF(vnc.Framebuffer.Width / 2' vnc.Framebuffer.Height / 2)' format);
Magic Number,VncSharp,RemoteDesktop,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,OnMouseWheel,The following statement contains a magic number: mask += 8;
Magic Number,VncSharp,RemoteDesktop,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,UpdateRemotePointer,The following statement contains a magic number: mask += 2;
Magic Number,VncSharp,RemoteDesktop,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,UpdateRemotePointer,The following statement contains a magic number: mask += 4;
Magic Number,VncSharp,RemoteDesktop,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,TranslateVirtualKey,The following statement contains a magic number: var keyboardState = new byte[256];
Magic Number,VncSharp,RemoteDesktop,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,TranslateVirtualKey,The following statement contains a magic number: var charResult = new byte[2];
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: var b = Reader.ReadBytes(12);
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: x < 12
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: x < 12
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteProtocolVersion,The following statement contains a magic number: Debug.Assert(verMinor == 3 || verMinor == 7 || verMinor == 8' "Wrong Protocol Version!"'  				$"Protocol Version should be 3.3' 3.7' or 3.8 but is {verMajor}.{verMinor}");
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteProtocolVersion,The following statement contains a magic number: Debug.Assert(verMinor == 3 || verMinor == 7 || verMinor == 8' "Wrong Protocol Version!"'  				$"Protocol Version should be 3.3' 3.7' or 3.8 but is {verMajor}.{verMinor}");
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteProtocolVersion,The following statement contains a magic number: Debug.Assert(verMinor == 3 || verMinor == 7 || verMinor == 8' "Wrong Protocol Version!"'  				$"Protocol Version should be 3.3' 3.7' or 3.8 but is {verMajor}.{verMinor}");
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteProxyAddress,The following statement contains a magic number: var proxyMessage = new byte[250];
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadSecurityTypes,The following statement contains a magic number: verMinor == 3
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteSecurityType,The following statement contains a magic number: verMinor < 7
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadSecurityChallenge,The following statement contains a magic number: return Reader.ReadBytes(16);
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadServerInit,The following statement contains a magic number: var buffer = Framebuffer.FromPixelFormat(Reader.ReadBytes(16)' w' h' bitsPerPixel' depth);
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteSetPixelFormat,The following statement contains a magic number: byte[] buff = new byte[20];
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteSetPixelFormat,The following statement contains a magic number: buff[2] = 0x00;
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteSetPixelFormat,The following statement contains a magic number: buff[3] = 0x00;
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteSetPixelFormat,The following statement contains a magic number: buffer.ToPixelFormat().CopyTo(buff' 4);
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteSetEncodings,The following statement contains a magic number: byte[] buff = new byte[(encodings.Length*4) + 4];
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteSetEncodings,The following statement contains a magic number: byte[] buff = new byte[(encodings.Length*4) + 4];
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteSetEncodings,The following statement contains a magic number: BitConverter.GetBytes((ushort)encodings.Length).Reverse().ToArray().CopyTo(buff' 2);
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteSetEncodings,The following statement contains a magic number: BitConverter.GetBytes(t).Reverse().ToArray().CopyTo(buff' 4+x);
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteSetEncodings,The following statement contains a magic number: x+=4;
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteFramebufferUpdateRequest,The following statement contains a magic number: byte[] buff = new byte[10];
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteFramebufferUpdateRequest,The following statement contains a magic number: BitConverter.GetBytes((ushort)x).Reverse().ToArray().CopyTo(buff' 2);
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteFramebufferUpdateRequest,The following statement contains a magic number: BitConverter.GetBytes((ushort)y).Reverse().ToArray().CopyTo(buff' 4);
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteFramebufferUpdateRequest,The following statement contains a magic number: BitConverter.GetBytes((ushort)width).Reverse().ToArray().CopyTo(buff' 6);
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteFramebufferUpdateRequest,The following statement contains a magic number: BitConverter.GetBytes((ushort)height).Reverse().ToArray().CopyTo(buff' 8);
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteKeyEvent,The following statement contains a magic number: byte[] buff = new byte[8];
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteKeyEvent,The following statement contains a magic number: buff[2] = 0x00;
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteKeyEvent,The following statement contains a magic number: buff[3] = 0x00;
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteKeyEvent,The following statement contains a magic number: BitConverter.GetBytes(keysym).Reverse().ToArray().CopyTo(buff' 4);
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WritePointerEvent,The following statement contains a magic number: byte[] buff = new byte[6];
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WritePointerEvent,The following statement contains a magic number: BitConverter.GetBytes((ushort)point.X).Reverse().ToArray().CopyTo(buff' 2);
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WritePointerEvent,The following statement contains a magic number: BitConverter.GetBytes((ushort)point.Y).Reverse().ToArray().CopyTo(buff' 4);
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteClientCutText,The following statement contains a magic number: byte[] buff = new byte[text.Length + 8];
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteClientCutText,The following statement contains a magic number: buff[2] = 0x00;
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteClientCutText,The following statement contains a magic number: buff[3] = 0x00;
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteClientCutText,The following statement contains a magic number: BitConverter.GetBytes((uint)text.Length).Reverse().ToArray().CopyTo(buff' 4);
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteClientCutText,The following statement contains a magic number: GetBytes(text).CopyTo(buff' 8);
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadColourMapEntry,The following statement contains a magic number: MapEntries[firstColor' 2] = (byte)(ReadUInt16() * byte.MaxValue / ushort.MaxValue);
Magic Number,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadServerCutText,The following statement contains a magic number: ReadPadding(3);
Magic Number,VncSharp,BigEndianBinaryReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadUInt16,The following statement contains a magic number: FillBuff(2);
Magic Number,VncSharp,BigEndianBinaryReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadUInt16,The following statement contains a magic number: return (ushort)(buff[1] | (uint)buff[0] << 8);
Magic Number,VncSharp,BigEndianBinaryReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadInt16,The following statement contains a magic number: FillBuff(2);
Magic Number,VncSharp,BigEndianBinaryReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadInt16,The following statement contains a magic number: return (short)(buff[1] & 0xFF | buff[0] << 8);
Magic Number,VncSharp,BigEndianBinaryReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadUInt32,The following statement contains a magic number: FillBuff(4);
Magic Number,VncSharp,BigEndianBinaryReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadUInt32,The following statement contains a magic number: return (uint)buff[3] & 0xFF | (uint)buff[2] << 8 | (uint)buff[1] << 16 | (uint)buff[0] << 24;
Magic Number,VncSharp,BigEndianBinaryReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadUInt32,The following statement contains a magic number: return (uint)buff[3] & 0xFF | (uint)buff[2] << 8 | (uint)buff[1] << 16 | (uint)buff[0] << 24;
Magic Number,VncSharp,BigEndianBinaryReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadUInt32,The following statement contains a magic number: return (uint)buff[3] & 0xFF | (uint)buff[2] << 8 | (uint)buff[1] << 16 | (uint)buff[0] << 24;
Magic Number,VncSharp,BigEndianBinaryReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadUInt32,The following statement contains a magic number: return (uint)buff[3] & 0xFF | (uint)buff[2] << 8 | (uint)buff[1] << 16 | (uint)buff[0] << 24;
Magic Number,VncSharp,BigEndianBinaryReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadUInt32,The following statement contains a magic number: return (uint)buff[3] & 0xFF | (uint)buff[2] << 8 | (uint)buff[1] << 16 | (uint)buff[0] << 24;
Magic Number,VncSharp,BigEndianBinaryReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadInt32,The following statement contains a magic number: FillBuff(4);
Magic Number,VncSharp,BigEndianBinaryReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadInt32,The following statement contains a magic number: return buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,BigEndianBinaryReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadInt32,The following statement contains a magic number: return buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,BigEndianBinaryReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadInt32,The following statement contains a magic number: return buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,BigEndianBinaryReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadInt32,The following statement contains a magic number: return buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,BigEndianBinaryReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadInt32,The following statement contains a magic number: return buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,ZRLECompressedReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: var buff = new byte[4];
Magic Number,VncSharp,ZRLECompressedReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: BaseStream.Read(buff' 0' 4) != 4
Magic Number,VncSharp,ZRLECompressedReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: BaseStream.Read(buff' 0' 4) != 4
Magic Number,VncSharp,ZRLECompressedReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: var compressedBufferSize = buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,ZRLECompressedReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: var compressedBufferSize = buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,ZRLECompressedReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: var compressedBufferSize = buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,ZRLECompressedReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: var compressedBufferSize = buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,ZRLECompressedReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: var compressedBufferSize = buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,ZRLECompressedReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: compressedBufferSize > 64 * 1024 * 1024
Magic Number,VncSharp,ZRLECompressedReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: compressedBufferSize > 64 * 1024 * 1024
Magic Number,VncSharp,ZRLECompressedReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: compressedBufferSize > 64 * 1024 * 1024
Magic Number,VncSharp,ZRLECompressedReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: const int maxBufferSize = 64 * 1024;
Magic Number,VncSharp,ZRLECompressedReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: const int maxBufferSize = 64 * 1024;
Magic Number,VncSharp,ZRLECompressedReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: netStream.ReadTimeout = 15000;
Magic Number,VncSharp,ZRLECompressedReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: int toRead = (bytesToRead > 1024) ? 1024 : bytesToRead;
Magic Number,VncSharp,ZRLECompressedReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: int toRead = (bytesToRead > 1024) ? 1024 : bytesToRead;
Magic Number,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,Connect,The following statement contains a magic number: rfb.ServerVersion != 3.8f || securityType != 1
Magic Number,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,Connect,The following statement contains a magic number: return Connect(host' 0' 5900);
Magic Number,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,Connect,The following statement contains a magic number: return Connect(host' display' 5900);
Magic Number,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,GetSupportedSecurityType,The following statement contains a magic number: types[i] == 1  	// None  					|| types[i] == 2
Magic Number,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,Authenticate,The following statement contains a magic number: securityType == 2
Magic Number,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,Authenticate,The following statement contains a magic number: rfb.ServerVersion == 3.8
Magic Number,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: var key = new byte[8];
Magic Number,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: Encoding.ASCII.GetBytes(password' 0' password.Length >= 8 ? 8 : password.Length' key' 0);
Magic Number,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: Encoding.ASCII.GetBytes(password' 0' password.Length >= 8 ? 8 : password.Length' key' 0);
Magic Number,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: key[i] = (byte)( ((key[i] & 0x01) << 7) |                                   ((key[i] & 0x02) << 5) |                                   ((key[i] & 0x04) << 3) |                                   ((key[i] & 0x08) << 1) |                                   ((key[i] & 0x10) >> 1) |                                   ((key[i] & 0x20) >> 3) |                                   ((key[i] & 0x40) >> 5) |                                   ((key[i] & 0x80) >> 7)  );
Magic Number,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: key[i] = (byte)( ((key[i] & 0x01) << 7) |                                   ((key[i] & 0x02) << 5) |                                   ((key[i] & 0x04) << 3) |                                   ((key[i] & 0x08) << 1) |                                   ((key[i] & 0x10) >> 1) |                                   ((key[i] & 0x20) >> 3) |                                   ((key[i] & 0x40) >> 5) |                                   ((key[i] & 0x80) >> 7)  );
Magic Number,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: key[i] = (byte)( ((key[i] & 0x01) << 7) |                                   ((key[i] & 0x02) << 5) |                                   ((key[i] & 0x04) << 3) |                                   ((key[i] & 0x08) << 1) |                                   ((key[i] & 0x10) >> 1) |                                   ((key[i] & 0x20) >> 3) |                                   ((key[i] & 0x40) >> 5) |                                   ((key[i] & 0x80) >> 7)  );
Magic Number,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: key[i] = (byte)( ((key[i] & 0x01) << 7) |                                   ((key[i] & 0x02) << 5) |                                   ((key[i] & 0x04) << 3) |                                   ((key[i] & 0x08) << 1) |                                   ((key[i] & 0x10) >> 1) |                                   ((key[i] & 0x20) >> 3) |                                   ((key[i] & 0x40) >> 5) |                                   ((key[i] & 0x80) >> 7)  );
Magic Number,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: key[i] = (byte)( ((key[i] & 0x01) << 7) |                                   ((key[i] & 0x02) << 5) |                                   ((key[i] & 0x04) << 3) |                                   ((key[i] & 0x08) << 1) |                                   ((key[i] & 0x10) >> 1) |                                   ((key[i] & 0x20) >> 3) |                                   ((key[i] & 0x40) >> 5) |                                   ((key[i] & 0x80) >> 7)  );
Magic Number,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: key[i] = (byte)( ((key[i] & 0x01) << 7) |                                   ((key[i] & 0x02) << 5) |                                   ((key[i] & 0x04) << 3) |                                   ((key[i] & 0x08) << 1) |                                   ((key[i] & 0x10) >> 1) |                                   ((key[i] & 0x20) >> 3) |                                   ((key[i] & 0x40) >> 5) |                                   ((key[i] & 0x80) >> 7)  );
Magic Number,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: i < 8
Magic Number,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: var response = new byte[16];
Magic Number,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,Disconnect,The following statement contains a magic number: worker.Join(3000);
Magic Number,VncSharp.Encodings,CPixelReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\CPixelReader.cs,ReadPixel,The following statement contains a magic number: var b = reader.ReadBytes(3);
Magic Number,VncSharp.Encodings,CPixelReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\CPixelReader.cs,ReadPixel,The following statement contains a magic number: return ToGdiPlusOrder(b[2]' b[1]' b[0]);
Magic Number,VncSharp.Encodings,EncodedRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\EncodedRectangle.cs,EncodedRectangle,The following statement contains a magic number: switch (framebuffer.BitsPerPixel)  			{  				case 32:  					if (encoding == RfbProtocol.ZRLE_ENCODING)  					{  						preader = new CPixelReader(reader' framebuffer);  					}  					else  					{  						preader = new PixelReader32(reader' framebuffer);  					}  					break;  				case 16:  					preader = new PixelReader16(reader' framebuffer);  					break;  				case 8:  					preader = new PixelReader8(reader' framebuffer' rfb);  					break;  				default:  					throw new ArgumentOutOfRangeException("BitsPerPixel"' framebuffer.BitsPerPixel' "Valid VNC Pixel Widths are 8' 16 or 32 bits.");  			}
Magic Number,VncSharp.Encodings,EncodedRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\EncodedRectangle.cs,EncodedRectangle,The following statement contains a magic number: switch (framebuffer.BitsPerPixel)  			{  				case 32:  					if (encoding == RfbProtocol.ZRLE_ENCODING)  					{  						preader = new CPixelReader(reader' framebuffer);  					}  					else  					{  						preader = new PixelReader32(reader' framebuffer);  					}  					break;  				case 16:  					preader = new PixelReader16(reader' framebuffer);  					break;  				case 8:  					preader = new PixelReader8(reader' framebuffer' rfb);  					break;  				default:  					throw new ArgumentOutOfRangeException("BitsPerPixel"' framebuffer.BitsPerPixel' "Valid VNC Pixel Widths are 8' 16 or 32 bits.");  			}
Magic Number,VncSharp.Encodings,EncodedRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\EncodedRectangle.cs,EncodedRectangle,The following statement contains a magic number: switch (framebuffer.BitsPerPixel)  			{  				case 32:  					if (encoding == RfbProtocol.ZRLE_ENCODING)  					{  						preader = new CPixelReader(reader' framebuffer);  					}  					else  					{  						preader = new PixelReader32(reader' framebuffer);  					}  					break;  				case 16:  					preader = new PixelReader16(reader' framebuffer);  					break;  				case 8:  					preader = new PixelReader8(reader' framebuffer' rfb);  					break;  				default:  					throw new ArgumentOutOfRangeException("BitsPerPixel"' framebuffer.BitsPerPixel' "Valid VNC Pixel Widths are 8' 16 or 32 bits.");  			}
Magic Number,VncSharp.Encodings,HextileRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\HextileRectangle.cs,Decode,The following statement contains a magic number: var th = rectangle.Height - ty < 16 ? rectangle.Height - ty : 16;
Magic Number,VncSharp.Encodings,HextileRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\HextileRectangle.cs,Decode,The following statement contains a magic number: var th = rectangle.Height - ty < 16 ? rectangle.Height - ty : 16;
Magic Number,VncSharp.Encodings,HextileRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\HextileRectangle.cs,Decode,The following statement contains a magic number: var tw = rectangle.Width - tx < 16 ? rectangle.Width - tx : 16;
Magic Number,VncSharp.Encodings,HextileRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\HextileRectangle.cs,Decode,The following statement contains a magic number: var tw = rectangle.Width - tx < 16 ? rectangle.Width - tx : 16;
Magic Number,VncSharp.Encodings,PixelReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader.cs,ToGdiPlusOrder,The following statement contains a magic number: return blue & 0xFF | green << 8 | red << 16 | 0xFF << 24;
Magic Number,VncSharp.Encodings,PixelReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader.cs,ToGdiPlusOrder,The following statement contains a magic number: return blue & 0xFF | green << 8 | red << 16 | 0xFF << 24;
Magic Number,VncSharp.Encodings,PixelReader,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader.cs,ToGdiPlusOrder,The following statement contains a magic number: return blue & 0xFF | green << 8 | red << 16 | 0xFF << 24;
Magic Number,VncSharp.Encodings,PixelReader16,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader16.cs,ReadPixel,The following statement contains a magic number: var b = reader.ReadBytes(2);
Magic Number,VncSharp.Encodings,PixelReader16,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader16.cs,ReadPixel,The following statement contains a magic number: var pixel = (ushort)((uint)b[0] & 0xFF | (uint)b[1] << 8);
Magic Number,VncSharp.Encodings,PixelReader16,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader16.cs,ReadPixel,The following statement contains a magic number: var red = (byte)(((pixel >> framebuffer.RedShift) & framebuffer.RedMax) * 255 / framebuffer.RedMax);
Magic Number,VncSharp.Encodings,PixelReader16,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader16.cs,ReadPixel,The following statement contains a magic number: var green = (byte)(((pixel >> framebuffer.GreenShift) & framebuffer.GreenMax) * 255 / framebuffer.GreenMax);
Magic Number,VncSharp.Encodings,PixelReader16,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader16.cs,ReadPixel,The following statement contains a magic number: var blue = (byte)(((pixel >> framebuffer.BlueShift) & framebuffer.BlueMax) * 255 / framebuffer.BlueMax);
Magic Number,VncSharp.Encodings,PixelReader32,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader32.cs,ReadPixel,The following statement contains a magic number: var b = reader.ReadBytes(4);
Magic Number,VncSharp.Encodings,PixelReader32,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader32.cs,ReadPixel,The following statement contains a magic number: var pixel = (uint)b[0] & 0xFF |                            (uint)b[1] << 8   |                            (uint)b[2] << 16  |                            (uint)b[3] << 24;
Magic Number,VncSharp.Encodings,PixelReader32,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader32.cs,ReadPixel,The following statement contains a magic number: var pixel = (uint)b[0] & 0xFF |                            (uint)b[1] << 8   |                            (uint)b[2] << 16  |                            (uint)b[3] << 24;
Magic Number,VncSharp.Encodings,PixelReader32,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader32.cs,ReadPixel,The following statement contains a magic number: var pixel = (uint)b[0] & 0xFF |                            (uint)b[1] << 8   |                            (uint)b[2] << 16  |                            (uint)b[3] << 24;
Magic Number,VncSharp.Encodings,PixelReader32,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader32.cs,ReadPixel,The following statement contains a magic number: var pixel = (uint)b[0] & 0xFF |                            (uint)b[1] << 8   |                            (uint)b[2] << 16  |                            (uint)b[3] << 24;
Magic Number,VncSharp.Encodings,PixelReader32,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader32.cs,ReadPixel,The following statement contains a magic number: var pixel = (uint)b[0] & 0xFF |                            (uint)b[1] << 8   |                            (uint)b[2] << 16  |                            (uint)b[3] << 24;
Magic Number,VncSharp.Encodings,PixelReader8,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader8.cs,ReadPixel,The following statement contains a magic number: return ToGdiPlusOrder((byte)rfb.MapEntries[idx' 0]' (byte)rfb.MapEntries[idx' 1]' (byte)rfb.MapEntries[idx' 2]);
Magic Number,VncSharp.Encodings,ZrleRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,Decode,The following statement contains a magic number: subencoding >= 17 && subencoding <= 127 || subencoding == 129
Magic Number,VncSharp.Encodings,ZrleRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,Decode,The following statement contains a magic number: subencoding >= 17 && subencoding <= 127 || subencoding == 129
Magic Number,VncSharp.Encodings,ZrleRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,Decode,The following statement contains a magic number: subencoding >= 17 && subencoding <= 127 || subencoding == 129
Magic Number,VncSharp.Encodings,ZrleRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,Decode,The following statement contains a magic number: var isRLE = (subencoding & 128) != 0;
Magic Number,VncSharp.Encodings,ZrleRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,Decode,The following statement contains a magic number: var paletteSize = subencoding & 127;
Magic Number,VncSharp.Encodings,ZrleRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedPixels,The following statement contains a magic number: var bppp = palSize > 16 ? 8 :  			    (palSize > 4 ? 4 : (palSize > 2 ? 2 : 1));
Magic Number,VncSharp.Encodings,ZrleRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedPixels,The following statement contains a magic number: var bppp = palSize > 16 ? 8 :  			    (palSize > 4 ? 4 : (palSize > 2 ? 2 : 1));
Magic Number,VncSharp.Encodings,ZrleRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedPixels,The following statement contains a magic number: var bppp = palSize > 16 ? 8 :  			    (palSize > 4 ? 4 : (palSize > 2 ? 2 : 1));
Magic Number,VncSharp.Encodings,ZrleRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedPixels,The following statement contains a magic number: var bppp = palSize > 16 ? 8 :  			    (palSize > 4 ? 4 : (palSize > 2 ? 2 : 1));
Magic Number,VncSharp.Encodings,ZrleRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedPixels,The following statement contains a magic number: var bppp = palSize > 16 ? 8 :  			    (palSize > 4 ? 4 : (palSize > 2 ? 2 : 1));
Magic Number,VncSharp.Encodings,ZrleRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedPixels,The following statement contains a magic number: var bppp = palSize > 16 ? 8 :  			    (palSize > 4 ? 4 : (palSize > 2 ? 2 : 1));
Magic Number,VncSharp.Encodings,ZrleRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedPixels,The following statement contains a magic number: nbits = 8;
Magic Number,VncSharp.Encodings,ZrleRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedPixels,The following statement contains a magic number: var index = (b >> nbits) & ((1 << bppp) - 1) & 127;
Magic Number,VncSharp.Encodings,ZrleRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedRLEPixels,The following statement contains a magic number: (index & 128) != 0
Magic Number,VncSharp.Encodings,ZrleRectangle,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedRLEPixels,The following statement contains a magic number: index &= 127;
Magic Number,VncSharp.zlib.NET,Adler32,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Adler32.cs,adler32,The following statement contains a magic number: var s2 = (adler >> 16) & 0xffff;
Magic Number,VncSharp.zlib.NET,Adler32,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Adler32.cs,adler32,The following statement contains a magic number: k -= 16;
Magic Number,VncSharp.zlib.NET,Adler32,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Adler32.cs,adler32,The following statement contains a magic number: k >= 16
Magic Number,VncSharp.zlib.NET,Adler32,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Adler32.cs,adler32,The following statement contains a magic number: return (s2 << 16) | s1;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: dyn_ltree = new short[HEAP_SIZE * 2];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,lm_init,The following statement contains a magic number: window_size = 2 * w_size;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,tr_init,The following statement contains a magic number: last_eob_len = 8;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,init_block,The following statement contains a magic number: dyn_ltree[i * 2] = 0;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,init_block,The following statement contains a magic number: dyn_dtree[i * 2] = 0;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,init_block,The following statement contains a magic number: bl_tree[i * 2] = 0;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,init_block,The following statement contains a magic number: dyn_ltree[END_BLOCK * 2] = 1;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,smaller,The following statement contains a magic number: return tree[n * 2] < tree[m * 2] || tree[n * 2] == tree[m * 2] && depth[n] <= depth[m];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,smaller,The following statement contains a magic number: return tree[n * 2] < tree[m * 2] || tree[n * 2] == tree[m * 2] && depth[n] <= depth[m];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,smaller,The following statement contains a magic number: return tree[n * 2] < tree[m * 2] || tree[n * 2] == tree[m * 2] && depth[n] <= depth[m];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,smaller,The following statement contains a magic number: return tree[n * 2] < tree[m * 2] || tree[n * 2] == tree[m * 2] && depth[n] <= depth[m];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: int nextlen = tree[0 * 2 + 1];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: var max_count = 7;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: var min_count = 4;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 138;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 3;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: tree[(max_code + 1) * 2 + 1] = (short) SupportClass.Identity(0xffff);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: nextlen = tree[(n + 1) * 2 + 1];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 138;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 3;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,build_bl_tree,The following statement contains a magic number: bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,build_bl_tree,The following statement contains a magic number: max_blindex >= 3
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(dcodes - 1' 5);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: int nextlen = tree[0 * 2 + 1];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: var max_count = 7;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: var min_count = 4;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 138;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 3;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: nextlen = tree[(n + 1) * 2 + 1];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 138;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 3;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,put_short,The following statement contains a magic number: put_byte((byte) SupportClass.URShift(w' 8));
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,putShortMSB,The following statement contains a magic number: put_byte((byte) (b >> 8));
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_code,The following statement contains a magic number: send_bits(tree[c * 2] & 0xffff' tree[c * 2 + 1] & 0xffff);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_code,The following statement contains a magic number: send_bits(tree[c * 2] & 0xffff' tree[c * 2 + 1] & 0xffff);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits(STATIC_TREES << 1' 3);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits(STATIC_TREES << 1' 3);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_align,The following statement contains a magic number: 1 + last_eob_len + 10 - bi_valid < 9
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_align,The following statement contains a magic number: 1 + last_eob_len + 10 - bi_valid < 9
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_align,The following statement contains a magic number: last_eob_len = 7;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2] = (byte) SupportClass.URShift(dist' 8);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2] = (byte) SupportClass.URShift(dist' 8);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2 + 1] = (byte) dist;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: dyn_ltree[lc * 2]++;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: var out_length = last_lit * 8;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length = (int) (out_length + dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length = (int) (out_length + dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length = SupportClass.URShift(out_length' 3);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: matches < last_lit / 2 && out_length < in_length / 2
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: matches < last_lit / 2 && out_length < in_length / 2
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: (last_lit & 0x1fff) == 0 && level > 2
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,compress_block,The following statement contains a magic number: dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,compress_block,The following statement contains a magic number: dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,compress_block,The following statement contains a magic number: dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,compress_block,The following statement contains a magic number: last_eob_len = ltree[END_BLOCK * 2 + 1];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,set_data_type,The following statement contains a magic number: bin_freq += dyn_ltree[n * 2];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,set_data_type,The following statement contains a magic number: n < 7
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,set_data_type,The following statement contains a magic number: ascii_freq += dyn_ltree[n * 2];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,set_data_type,The following statement contains a magic number: n < 128
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,set_data_type,The following statement contains a magic number: bin_freq += dyn_ltree[n * 2];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,set_data_type,The following statement contains a magic number: data_type = (byte) (bin_freq > SupportClass.URShift(ascii_freq' 2)?Z_BINARY:Z_ASCII);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,bi_flush,The following statement contains a magic number: bi_valid == 16
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,bi_windup,The following statement contains a magic number: bi_valid > 8
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,copy_block,The following statement contains a magic number: last_eob_len = 8;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_stored,The following statement contains a magic number: max_block_size = pending_buf_size - 5;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_stored,The following statement contains a magic number: max_block_size > pending_buf_size - 5
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_stored_block,The following statement contains a magic number: send_bits((STORED_BLOCK << 1) + (eof?1:0)' 3);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = SupportClass.URShift(opt_len + 3 + 7' 3);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = SupportClass.URShift(opt_len + 3 + 7' 3);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = SupportClass.URShift(opt_len + 3 + 7' 3);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = SupportClass.URShift(static_len + 3 + 7' 3);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = SupportClass.URShift(static_len + 3 + 7' 3);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = SupportClass.URShift(static_len + 3 + 7' 3);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_flush_block,The following statement contains a magic number: stored_len + 4 <= opt_lenb && buf != - 1
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_slow,The following statement contains a magic number: match_length <= 5 && (strategy == Z_FILTERED || match_length == MIN_MATCH && strstart - match_start > 4096)
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_slow,The following statement contains a magic number: match_length <= 5 && (strategy == Z_FILTERED || match_length == MIN_MATCH && strstart - match_start > 4096)
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_slow,The following statement contains a magic number: prev_length -= 2;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,longest_match,The following statement contains a magic number: chain_length >>= 2;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,longest_match,The following statement contains a magic number: scan += 2;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: level = 6;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: hash_bits = memLevel + 7;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: window = new byte[w_size * 2];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: lit_bufsize = 1 << (memLevel + 6);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: pending_buf = new byte[lit_bufsize * 4];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: pending_buf_size = lit_bufsize * 4;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: l_buf = (1 + 2) * lit_bufsize;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateParams,The following statement contains a magic number: _level = 6;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateParams,The following statement contains a magic number: _level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: level_flags = 3;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: level_flags > 3
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: header |= level_flags << 6;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: header += 31 - header % 31;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: header += 31 - header % 31;
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: putShortMSB((int) SupportClass.URShift(strm.adler' 16));
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: putShortMSB((int) SupportClass.URShift(strm.adler' 16));
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table = new Config[10];
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Config(4' 4' 8' 4' FAST);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Config(4' 4' 8' 4' FAST);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Config(4' 4' 8' 4' FAST);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Config(4' 4' 8' 4' FAST);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Config(4' 5' 16' 8' FAST);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Config(4' 5' 16' 8' FAST);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Config(4' 5' 16' 8' FAST);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Config(4' 5' 16' 8' FAST);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Config(4' 5' 16' 8' FAST);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Config(4' 6' 32' 32' FAST);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Config(4' 6' 32' 32' FAST);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Config(4' 6' 32' 32' FAST);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Config(4' 6' 32' 32' FAST);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Config(4' 6' 32' 32' FAST);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Config(4' 4' 16' 16' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Config(4' 4' 16' 16' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Config(4' 4' 16' 16' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Config(4' 4' 16' 16' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Config(4' 4' 16' 16' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Config(8' 16' 32' 32' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Config(8' 16' 32' 32' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Config(8' 16' 32' 32' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Config(8' 16' 32' 32' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Config(8' 16' 32' 32' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Config(8' 16' 128' 128' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Config(8' 16' 128' 128' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Config(8' 16' 128' 128' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Config(8' 16' 128' 128' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Config(8' 16' 128' 128' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Config(8' 32' 128' 256' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Config(8' 32' 128' 256' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Config(8' 32' 128' 256' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Config(8' 32' 128' 256' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Config(8' 32' 128' 256' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Config(32' 128' 258' 1024' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Config(32' 128' 258' 1024' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Config(32' 128' 258' 1024' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Config(32' 128' 258' 1024' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Config(32' 128' 258' 1024' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Config(32' 258' 258' 4096' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Config(32' 258' 258' 4096' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Config(32' 258' 258' 4096' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Config(32' 258' 258' 4096' SLOW);
Magic Number,VncSharp.zlib.NET,Deflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Config(32' 258' 258' 4096' SLOW);
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,InfBlocks,The following statement contains a magic number: hufts = new int[MANY * 3];
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: k += 8;
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: k < 20
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= tp[(tp_index + t) * 3 + 1];
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= tp[(tp_index + t) * 3 + 1];
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: (e = tp[(tp_index + t) * 3]) == 0
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= tp[(tp_index + t) * 3 + 1];
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= tp[(tp_index + t) * 3 + 1];
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: e &= 15;
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: k += 8;
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: k < 15
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: e = tp[(tp_index + t) * 3];
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= tp[(tp_index + t) * 3 + 1];
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= tp[(tp_index + t) * 3 + 1];
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: e &= 15;
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: k += 8;
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: q - r > 0 && 2 > q - r
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: (e & 16) != 0
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: t += tp[(tp_index + t) * 3 + 2];
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: t += tp[(tp_index + t) * 3 + 2];
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: e = tp[(tp_index + t) * 3];
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: (e & 64) == 0
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: (e & 16) != 0
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: t += tp[(tp_index + t) * 3 + 2];
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: t += tp[(tp_index + t) * 3 + 2];
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= tp[(tp_index + t) * 3 + 1];
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= tp[(tp_index + t) * 3 + 1];
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: (e = tp[(tp_index + t) * 3]) == 0
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: (e & 64) == 0
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = k >> 3 < c?k >> 3:c;
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = k >> 3 < c?k >> 3:c;
Magic Number,VncSharp.zlib.NET,InfCodes,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= c << 3;
Magic Number,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflateInit,The following statement contains a magic number: w < 8 || w > 15
Magic Number,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflateInit,The following statement contains a magic number: w < 8 || w > 15
Magic Number,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}
Magic Number,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflateSync,The following statement contains a magic number: n != 0 && m < 4
Magic Number,VncSharp.zlib.NET,Inflate,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflateSync,The following statement contains a magic number: m != 4
Magic Number,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: var r = new int[3];
Magic Number,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: xp = 2;
Magic Number,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: r[2] = q - u[h - 1] - j;
Magic Number,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);
Magic Number,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);
Magic Number,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: r[0] = 128 + 64;
Magic Number,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: r[0] = 128 + 64;
Magic Number,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (q + j) * 3' 3);
Magic Number,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (q + j) * 3' 3);
Magic Number,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: var v = new int[19];
Magic Number,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: var v = new int[288];
Magic Number,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: r = huft_build(c' 0' nl' 257' cplens' cplext' tl' bl' hp' hn' v);
Magic Number,VncSharp.zlib.NET,InfTree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: r != Z_OK || bd[0] == 0 && nl > 257
Magic Number,VncSharp.zlib.NET,SupportClass,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\SupportClass.cs,URShift,The following statement contains a magic number: return (number >> bits) + (2 << ~bits);
Magic Number,VncSharp.zlib.NET,SupportClass,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\SupportClass.cs,URShift,The following statement contains a magic number: return (number >> bits) + (2L << ~bits);
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,d_code,The following statement contains a magic number: return dist < 256?_dist_code[dist]:_dist_code[256 + SupportClass.URShift(dist' 7)];
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,d_code,The following statement contains a magic number: return dist < 256?_dist_code[dist]:_dist_code[256 + SupportClass.URShift(dist' 7)];
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,d_code,The following statement contains a magic number: return dist < 256?_dist_code[dist]:_dist_code[256 + SupportClass.URShift(dist' 7)];
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[s.heap[s.heap_max] * 2 + 1] = 0;
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[n * 2 + 1] = (short) bits;
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: f = tree[n * 2];
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: s.static_len += f * (stree[n * 2 + 1] + xbits);
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: s.bl_count[bits + 1] = (short) (s.bl_count[bits + 1] + 2);
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: overflow -= 2;
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: s.opt_len = (int) (s.opt_len + (bits - (long) tree[m * 2 + 1]) * tree[m * 2]);
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: s.opt_len = (int) (s.opt_len + (bits - (long) tree[m * 2 + 1]) * tree[m * 2]);
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[m * 2 + 1] = (short) bits;
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[m * 2 + 1] != bits
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: tree[n * 2] != 0
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: node = s.heap[++s.heap_len] = max_code < 2?++max_code:0;
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = 1;
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: s.static_len -= stree[node * 2 + 1];
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: s.heap_len < 2
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_codes,The following statement contains a magic number: int len = tree[n * 2 + 1];
Magic Number,VncSharp.zlib.NET,Tree,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_codes,The following statement contains a magic number: tree[n * 2] = (short) bi_reverse(next_code[len]++' len);
Magic Number,VncSharp.zlib.NET,ZInputStream,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\ZInputStream.cs,skip,The following statement contains a magic number: var len = 512;
Missing Default,VncSharp,KeyboardHook,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\KeyboardHook.cs,LowLevelKeyboardProc,The following switch statement is missing a default case: switch (wParamInt)              {                  case NativeMethods.WM_KEYDOWN:                  case NativeMethods.WM_SYSKEYDOWN:                  case NativeMethods.WM_KEYUP:                  case NativeMethods.WM_SYSKEYUP:                      result = OnKey(wParamInt' lParam);                      break;              }
Missing Default,VncSharp,RemoteDesktop,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,SendSpecialKeys,The following switch statement is missing a default case: switch (keys)              {                  case SpecialKeys.Ctrl:                      PressKeys(new uint[] {0xffe3}' release); // CTRL' but don't release                      break;                  case SpecialKeys.Alt:                      PressKeys(new uint[] {0xffe9}' release); // ALT' but don't release                      break;                  case SpecialKeys.CtrlAltDel:                      PressKeys(new uint[] {0xffe3' 0xffe9' 0xffff}' release); // CTRL' ALT' DEL                      break;                  case SpecialKeys.AltF4:                      PressKeys(new uint[] {0xffe9' 0xffc1}' release); // ALT' F4                      break;                  case SpecialKeys.CtrlEsc:                      PressKeys(new uint[] {0xffe3' 0xff1b}' release); // CTRL' ESC                      break;                  // TODO: are there more I should support???              }
Missing Default,VncSharp,RfbProtocol,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following switch statement is missing a default case: switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}
Missing Default,VncSharp,VncClient,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\VncClient.cs,GetRfbUpdates,The following switch statement is missing a default case: switch (rfb.ReadServerMessageType()) {                          case RfbProtocol.FRAMEBUFFER_UPDATE:                              var rectangles = rfb.ReadFramebufferUpdate();                                if (CheckIfThreadDone())                                  break;                                // TODO: consider gathering all update rectangles in a batch and *then* posting the event back to the main thread.                              for (var i = 0; i < rectangles; ++i) {                                  // Get the update rectangle's info                                  rfb.ReadFramebufferUpdateRectHeader(out Rectangle rectangle' out int enc);                                    // Build a derived EncodedRectangle type and pull-down all the pixel info                                  var er = factory.Build(rectangle' enc);                                  er.Decode();                                    // Let the UI know that an updated rectangle is available' but check                                  // to see if the user closed things down first.                                  if (CheckIfThreadDone() || VncUpdate == null) continue;                                  var e = new VncEventArgs(er);                                    // In order to play nicely with WinForms controls' we do a check here to                                   // see if it is necessary to synchronize this event with the UI thread.                                  var control = VncUpdate.Target as Control;                                  if (control != null) {                                      control.Invoke(VncUpdate' this' e);                                  } else {                                      // Target is not a WinForms control' so do it on this thread...                                      VncUpdate(this' new VncEventArgs(er));                                  }                              }                              break;                          case RfbProtocol.BELL:                              Beep();                              break;                          case RfbProtocol.SERVER_CUT_TEXT:                              if (CheckIfThreadDone())                                  break;                              // TODO: This is invasive' should there be a bool property allowing this message to be ignored?                              Clipboard.SetDataObject(rfb.ReadServerCutText().Replace("\n"' Environment.NewLine)' true);                              OnServerCutText();                              break;                          case RfbProtocol.SET_COLOUR_MAP_ENTRIES:                              rfb.ReadColourMapEntry();                              break;                      }
Missing Default,VncSharp.zlib.NET,InfBlocks,D:\research\architectureSmells\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following switch statement is missing a default case: switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}
