Implementation smell,Namespace,Class,File,Method,Description
Long Method,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_fast,The method has 114 lines of code.
Long Method,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_slow,The method has 146 lines of code.
Long Method,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The method has 169 lines of code.
Long Method,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The method has 494 lines of code.
Long Method,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The method has 349 lines of code.
Long Method,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The method has 232 lines of code.
Long Method,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The method has 196 lines of code.
Long Method,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The method has 214 lines of code.
Complex Method,VncSharp,RemoteDesktop,C:\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,SyncModifierKeyState,Cyclomatic complexity of the method is 9
Complex Method,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,Connect,Cyclomatic complexity of the method is 9
Complex Method,VncSharp.Encodings,ZrleRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,Decode,Cyclomatic complexity of the method is 8
Complex Method,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_stored,Cyclomatic complexity of the method is 11
Complex Method,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_fast,Cyclomatic complexity of the method is 14
Complex Method,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_slow,Cyclomatic complexity of the method is 15
Complex Method,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,Cyclomatic complexity of the method is 21
Complex Method,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,inflate_flush,Cyclomatic complexity of the method is 9
Complex Method,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,Cyclomatic complexity of the method is 25
Complex Method,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,Cyclomatic complexity of the method is 12
Long Parameter List,VncSharp,NativeMethods,C:\repos\humphd_VncSharp\VncSharp\NativeMethods.cs,ToAscii,The method has 5 parameters. Parameters: uVirtKey' uScanCode' lpKeyState' lpwTransKey' fuState
Long Parameter List,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteFramebufferUpdateRequest,The method has 5 parameters. Parameters: x' y' width' height' incremental
Long Parameter List,VncSharp.Encodings,ZrleRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedPixels,The method has 5 parameters. Parameters: tw' th' palette' palSize' tile
Long Parameter List,VncSharp.Encodings,ZrleRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedRLEPixels,The method has 6 parameters. Parameters: tx' ty' tw' th' palette' tile
Long Parameter List,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The method has 6 parameters. Parameters: strm' level' method' windowBits' memLevel' strategy
Long Parameter List,VncSharp.zlib.NET,Config,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Config,The method has 5 parameters. Parameters: good_length' max_lazy' nice_length' max_chain' func
Long Parameter List,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,InfCodes,The method has 7 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' z
Long Parameter List,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,InfCodes,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The method has 8 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' s' z
Long Parameter List,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The method has 11 parameters. Parameters: b' bindex' n' s' d' e' t' m' hp' hn' v
Long Parameter List,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,inflate_trees_bits,The method has 5 parameters. Parameters: c' bb' tb' hp' z
Long Parameter List,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,inflate_trees_dynamic,The method has 9 parameters. Parameters: nl' nd' c' bl' bd' tl' td' hp' z
Long Parameter List,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,inflate_trees_fixed,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,VncSharp.zlib.NET,StaticTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\StaticTree.cs,StaticTree,The method has 5 parameters. Parameters: static_tree' extra_bits' extra_base' elems' max_length
Long Identifier,VncSharp,KeyboardHook,C:\repos\humphd_VncSharp\VncSharp\KeyboardHook.cs,,The length of the parameter LowLevelKeyboardProcStaticDelegate is 34.
Long Statement,VncSharp,KeyboardHook,C:\repos\humphd_VncSharp\VncSharp\KeyboardHook.cs,SetHook,The length of the statement  "            var hook = NativeMethods.SetWindowsHookEx(NativeMethods.WH_KEYBOARD_LL' LowLevelKeyboardProcStaticDelegate' NativeMethods.GetModuleHandle(curModule.ModuleName)' 0); " is 164.
Long Statement,VncSharp,KeyboardHook,C:\repos\humphd_VncSharp\VncSharp\KeyboardHook.cs,ModifierKeysMatch,The length of the statement  "            if ((requestedKeys & ModifierKeys.Control) != 0) pressedKeys &= ~(ModifierKeys.LeftControl | ModifierKeys.RightControl); " is 120.
Long Statement,VncSharp,KeyNotificationEntry,C:\repos\humphd_VncSharp\VncSharp\KeyboardHook.cs,Equals,The length of the statement  "                return obj != null && WindowHandle == obj.WindowHandle && KeyCode == obj.KeyCode && ModifierKeys == obj.ModifierKeys && Block == obj.Block; " is 139.
Long Statement,VncSharp,VncScaledDesktopPolicy,C:\repos\humphd_VncSharp\VncSharp\VncScaledDesktopPolicy.cs,AdjustUpdateRectangle,The length of the statement  "            var adjusted = new Rectangle(AdjusteNormalToScaled(updateRectangle.X) + (remoteDesktop.ClientRectangle.Width - scaledSize.Width) / 2' " is 133.
Long Statement,VncSharp,VncScaledDesktopPolicy,C:\repos\humphd_VncSharp\VncSharp\VncScaledDesktopPolicy.cs,GetScaledSize,The length of the statement  "			return (double)s.Width / vnc.Framebuffer.Width <= (double)s.Height / vnc.Framebuffer.Height ? new Size(s.Width' (int)((double)s.Width / vnc.Framebuffer.Width * vnc.Framebuffer.Height)) : new Size((int)((double)s.Height / vnc.Framebuffer.Height * vnc.Framebuffer.Width)' s.Height); " is 280.
Long Statement,VncSharp,RemoteDesktop,C:\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,TranslateVirtualKey,The length of the statement  "            var charCount = NativeMethods.ToAscii(virtualKey' NativeMethods.MapVirtualKey(virtualKey' 0)' keyboardState' charResult' 0); " is 124.
Long Statement,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,Connect,The length of the statement  "			if (display < 0) throw new ArgumentOutOfRangeException(nameof(display)' display' "Display number must be non-negative."); " is 121.
Long Statement,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,Connect,The length of the statement  "			        throw new VncProtocolException("Connection Failed. The server rejected the connection for the following reason: " + rfb.ReadSecurityFailureReason()); " is 149.
Long Statement,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,Connect,The length of the statement  "			        throw new VncProtocolException("Unable to Connecto to the Server. The Server rejected the connection for the following reason: " + rfb.ReadSecurityFailureReason()); " is 164.
Long Statement,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,Authenticate,The length of the statement  "				throw new NotSupportedException("Unable to Authenticate with Server. The Server uses an Authentication scheme unknown to the client."); " is 135.
Long Statement,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,longest_match,The length of the statement  "				if (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan] || window[++match] != window[scan + 1]) " is 158.
Long Statement,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,longest_match,The length of the statement  "				while (window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend); " is 318.
Long Statement,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The length of the statement  "			if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) " is 177.
Long Statement,VncSharp.zlib.NET,ZStream,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\ZStream.cs,flush_pending,The length of the statement  "			if (dstate.pending_buf.Length <= dstate.pending_out || next_out.Length <= next_out_index || dstate.pending_buf.Length < dstate.pending_out + len || next_out.Length < next_out_index + len) " is 187.
Long Statement,VncSharp.zlib.NET,ZStream,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\ZStream.cs,flush_pending,The length of the statement  "				//System.Console.Out.WriteLine(dstate.pending_buf.Length + "' " + dstate.pending_out + "' " + next_out.Length + "' " + next_out_index + "' " + len); " is 148.
Complex Conditional,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The conditional expression  "b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a"  is complex.
Complex Conditional,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_slow,The conditional expression  "match_length <= 5 && (strategy == Z_FILTERED || match_length == MIN_MATCH && strstart - match_start > 4096)"  is complex.
Complex Conditional,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,longest_match,The conditional expression  "window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan] || window[++match] != window[scan + 1]"  is complex.
Complex Conditional,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The conditional expression  "memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateParams,The conditional expression  "_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The conditional expression  "strm.next_out == null || strm.next_in == null && strm.avail_in != 0 || status == FINISH_STATE && flush != Z_FINISH"  is complex.
Complex Conditional,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The conditional expression  "strm.avail_in != 0 || lookahead != 0 || flush != Z_NO_FLUSH && status != FINISH_STATE"  is complex.
Complex Conditional,VncSharp.zlib.NET,ZStream,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\ZStream.cs,flush_pending,The conditional expression  "dstate.pending_buf.Length <= dstate.pending_out || next_out.Length <= next_out_index || dstate.pending_buf.Length < dstate.pending_out + len || next_out.Length < next_out_index + len"  is complex.
Empty Catch Block,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,Disconnect,The method has an empty catch block.
Empty Catch Block,VncSharp.zlib.NET,ZOutputStream,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\ZOutputStream.cs,finish,The method has an empty catch block.
Empty Catch Block,VncSharp.zlib.NET,ZOutputStream,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\ZOutputStream.cs,Close,The method has an empty catch block.
Magic Number,VncSharp,VncDesignModeDesktopPolicy,C:\repos\humphd_VncSharp\VncSharp\VncDesignModeDesktopPolicy.cs,RepositionImage,The following statement contains a magic number: if (remoteDesktop.ClientSize.Width > desktopImage.Width) {  				x = (remoteDesktop.ClientRectangle.Width - desktopImage.Width) / 2;  			} else {  				x = remoteDesktop.DisplayRectangle.X;  			}
Magic Number,VncSharp,VncDesignModeDesktopPolicy,C:\repos\humphd_VncSharp\VncSharp\VncDesignModeDesktopPolicy.cs,RepositionImage,The following statement contains a magic number: if (remoteDesktop.ClientSize.Height > desktopImage.Height ) {  				y = (remoteDesktop.ClientRectangle.Height - desktopImage.Height) / 2;  			} else {  				y = remoteDesktop.DisplayRectangle.Y;  			}
Magic Number,VncSharp,VncScaledDesktopPolicy,C:\repos\humphd_VncSharp\VncSharp\VncScaledDesktopPolicy.cs,AdjustUpdateRectangle,The following statement contains a magic number: var adjusted = new Rectangle(AdjusteNormalToScaled(updateRectangle.X) + (remoteDesktop.ClientRectangle.Width - scaledSize.Width) / 2'                                                 AdjusteNormalToScaled(updateRectangle.Y) + (remoteDesktop.ClientRectangle.Height - scaledSize.Height) / 2'                                                 AdjusteNormalToScaled(updateRectangle.Width)'                                                 AdjusteNormalToScaled(updateRectangle.Height));
Magic Number,VncSharp,VncScaledDesktopPolicy,C:\repos\humphd_VncSharp\VncSharp\VncScaledDesktopPolicy.cs,AdjustUpdateRectangle,The following statement contains a magic number: var adjusted = new Rectangle(AdjusteNormalToScaled(updateRectangle.X) + (remoteDesktop.ClientRectangle.Width - scaledSize.Width) / 2'                                                 AdjusteNormalToScaled(updateRectangle.Y) + (remoteDesktop.ClientRectangle.Height - scaledSize.Height) / 2'                                                 AdjusteNormalToScaled(updateRectangle.Width)'                                                 AdjusteNormalToScaled(updateRectangle.Height));
Magic Number,VncSharp,VncScaledDesktopPolicy,C:\repos\humphd_VncSharp\VncSharp\VncScaledDesktopPolicy.cs,GetScaledMouse,The following statement contains a magic number: src.X = AdjusteScaledToNormal(src.X - (remoteDesktop.ClientRectangle.Width - scaledSize.Width) / 2);
Magic Number,VncSharp,VncScaledDesktopPolicy,C:\repos\humphd_VncSharp\VncSharp\VncScaledDesktopPolicy.cs,GetScaledMouse,The following statement contains a magic number: src.Y = AdjusteScaledToNormal(src.Y - (remoteDesktop.ClientRectangle.Height - scaledSize.Height) / 2);
Magic Number,VncSharp,VncScaledDesktopPolicy,C:\repos\humphd_VncSharp\VncSharp\VncScaledDesktopPolicy.cs,GetScaledRectangle,The following statement contains a magic number: return new Rectangle((rect.Width - scaledSize.Width) / 2'                                   (rect.Height - scaledSize.Height) / 2'                                    scaledSize.Width'                                    scaledSize.Height);
Magic Number,VncSharp,VncScaledDesktopPolicy,C:\repos\humphd_VncSharp\VncSharp\VncScaledDesktopPolicy.cs,GetScaledRectangle,The following statement contains a magic number: return new Rectangle((rect.Width - scaledSize.Width) / 2'                                   (rect.Height - scaledSize.Height) / 2'                                    scaledSize.Width'                                    scaledSize.Height);
Magic Number,VncSharp,VncClippedDesktopPolicy,C:\repos\humphd_VncSharp\VncSharp\VncClippedDesktopPolicy.cs,UpdateRemotePointer,The following statement contains a magic number: if (remoteDesktop.ClientSize.Width > remoteDesktop.Desktop.Size.Width) {  			    adjusted.X = current.X - (remoteDesktop.ClientRectangle.Width - remoteDesktop.Desktop.Width) / 2;  			} else {  				adjusted.X = current.X - remoteDesktop.AutoScrollPosition.X;  			}
Magic Number,VncSharp,VncClippedDesktopPolicy,C:\repos\humphd_VncSharp\VncSharp\VncClippedDesktopPolicy.cs,UpdateRemotePointer,The following statement contains a magic number: if (remoteDesktop.ClientSize.Height > remoteDesktop.Desktop.Size.Height ) {  				adjusted.Y = current.Y - (remoteDesktop.ClientRectangle.Height - remoteDesktop.Desktop.Height) / 2;  			} else {  				adjusted.Y = current.Y - remoteDesktop.AutoScrollPosition.Y;  			}
Magic Number,VncSharp,VncClippedDesktopPolicy,C:\repos\humphd_VncSharp\VncSharp\VncClippedDesktopPolicy.cs,AdjustUpdateRectangle,The following statement contains a magic number: if (remoteDesktop.ClientSize.Width > remoteDesktop.Desktop.Size.Width) {  				x = updateRectangle.X + (remoteDesktop.ClientRectangle.Width - remoteDesktop.Desktop.Width) / 2;  			} else {  				x = updateRectangle.X + remoteDesktop.AutoScrollPosition.X;  			}
Magic Number,VncSharp,VncClippedDesktopPolicy,C:\repos\humphd_VncSharp\VncSharp\VncClippedDesktopPolicy.cs,AdjustUpdateRectangle,The following statement contains a magic number: if (remoteDesktop.ClientSize.Height > remoteDesktop.Desktop.Size.Height ) {  				y = updateRectangle.Y + (remoteDesktop.ClientRectangle.Height - remoteDesktop.Desktop.Height) / 2;  			} else {  				y = updateRectangle.Y + remoteDesktop.AutoScrollPosition.Y;  			}
Magic Number,VncSharp,VncClippedDesktopPolicy,C:\repos\humphd_VncSharp\VncSharp\VncClippedDesktopPolicy.cs,RepositionImage,The following statement contains a magic number: if (remoteDesktop.ClientSize.Width > desktopImage.Width) {  				x = (remoteDesktop.ClientRectangle.Width - desktopImage.Width) / 2;  			} else {  				x = remoteDesktop.DisplayRectangle.X;  			}
Magic Number,VncSharp,VncClippedDesktopPolicy,C:\repos\humphd_VncSharp\VncSharp\VncClippedDesktopPolicy.cs,RepositionImage,The following statement contains a magic number: if (remoteDesktop.ClientSize.Height > desktopImage.Height ) {  				y = (remoteDesktop.ClientRectangle.Height - desktopImage.Height) / 2;  			} else {  				y = remoteDesktop.DisplayRectangle.Y;  			}
Magic Number,VncSharp,VncClippedDesktopPolicy,C:\repos\humphd_VncSharp\VncSharp\VncClippedDesktopPolicy.cs,GetMouseMoveRectangle,The following statement contains a magic number: if (remoteDesktop.ClientSize.Width > remoteDesktop.Desktop.Size.Width) {  				desktopRect.X = (remoteDesktop.ClientRectangle.Width - remoteDesktop.Desktop.Width) / 2;  			}
Magic Number,VncSharp,VncClippedDesktopPolicy,C:\repos\humphd_VncSharp\VncSharp\VncClippedDesktopPolicy.cs,GetMouseMoveRectangle,The following statement contains a magic number: if (remoteDesktop.ClientSize.Height > remoteDesktop.Desktop.Size.Height) {                  desktopRect.Y = (remoteDesktop.ClientRectangle.Height - remoteDesktop.Desktop.Height) / 2;              }
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: var b = new byte[16];
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[2]  = (byte) (BigEndian ? 1 : 0);
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[3]  = (byte) (TrueColour ? 1 : 0);
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[4]  = (byte) ((RedMax >> 8) & 0xff);
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[4]  = (byte) ((RedMax >> 8) & 0xff);
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[5]  = (byte) (RedMax & 0xff);
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[6]  = (byte) ((GreenMax >> 8) & 0xff);
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[6]  = (byte) ((GreenMax >> 8) & 0xff);
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[7]  = (byte) (GreenMax & 0xff);
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[8]  = (byte) ((BlueMax >> 8) & 0xff);
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[8]  = (byte) ((BlueMax >> 8) & 0xff);
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[9]  = (byte) (BlueMax & 0xff);
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[10] = (byte) RedShift;
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[11] = (byte) GreenShift;
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,ToPixelFormat,The following statement contains a magic number: b[12] = (byte) BlueShift;
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: if (b.Length != 16)  				throw new ArgumentException("Length of b must be 16 bytes.");
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: var buffer = new Framebuffer(width' height)  		    {  		        BitsPerPixel = b[0]'  		        Depth = b[1]'  		        BigEndian = b[2] != 0'  		        TrueColour = b[3] != 0'  		        RedMax = b[5] | b[4] << 8'  		        GreenMax = b[7] | b[6] << 8'  		        BlueMax = b[9] | b[8] << 8'  		        RedShift = b[10]'  		        GreenShift = b[11]'  		        BlueShift = b[12]  		    };
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: var buffer = new Framebuffer(width' height)  		    {  		        BitsPerPixel = b[0]'  		        Depth = b[1]'  		        BigEndian = b[2] != 0'  		        TrueColour = b[3] != 0'  		        RedMax = b[5] | b[4] << 8'  		        GreenMax = b[7] | b[6] << 8'  		        BlueMax = b[9] | b[8] << 8'  		        RedShift = b[10]'  		        GreenShift = b[11]'  		        BlueShift = b[12]  		    };
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: var buffer = new Framebuffer(width' height)  		    {  		        BitsPerPixel = b[0]'  		        Depth = b[1]'  		        BigEndian = b[2] != 0'  		        TrueColour = b[3] != 0'  		        RedMax = b[5] | b[4] << 8'  		        GreenMax = b[7] | b[6] << 8'  		        BlueMax = b[9] | b[8] << 8'  		        RedShift = b[10]'  		        GreenShift = b[11]'  		        BlueShift = b[12]  		    };
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: var buffer = new Framebuffer(width' height)  		    {  		        BitsPerPixel = b[0]'  		        Depth = b[1]'  		        BigEndian = b[2] != 0'  		        TrueColour = b[3] != 0'  		        RedMax = b[5] | b[4] << 8'  		        GreenMax = b[7] | b[6] << 8'  		        BlueMax = b[9] | b[8] << 8'  		        RedShift = b[10]'  		        GreenShift = b[11]'  		        BlueShift = b[12]  		    };
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: var buffer = new Framebuffer(width' height)  		    {  		        BitsPerPixel = b[0]'  		        Depth = b[1]'  		        BigEndian = b[2] != 0'  		        TrueColour = b[3] != 0'  		        RedMax = b[5] | b[4] << 8'  		        GreenMax = b[7] | b[6] << 8'  		        BlueMax = b[9] | b[8] << 8'  		        RedShift = b[10]'  		        GreenShift = b[11]'  		        BlueShift = b[12]  		    };
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: var buffer = new Framebuffer(width' height)  		    {  		        BitsPerPixel = b[0]'  		        Depth = b[1]'  		        BigEndian = b[2] != 0'  		        TrueColour = b[3] != 0'  		        RedMax = b[5] | b[4] << 8'  		        GreenMax = b[7] | b[6] << 8'  		        BlueMax = b[9] | b[8] << 8'  		        RedShift = b[10]'  		        GreenShift = b[11]'  		        BlueShift = b[12]  		    };
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: var buffer = new Framebuffer(width' height)  		    {  		        BitsPerPixel = b[0]'  		        Depth = b[1]'  		        BigEndian = b[2] != 0'  		        TrueColour = b[3] != 0'  		        RedMax = b[5] | b[4] << 8'  		        GreenMax = b[7] | b[6] << 8'  		        BlueMax = b[9] | b[8] << 8'  		        RedShift = b[10]'  		        GreenShift = b[11]'  		        BlueShift = b[12]  		    };
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: var buffer = new Framebuffer(width' height)  		    {  		        BitsPerPixel = b[0]'  		        Depth = b[1]'  		        BigEndian = b[2] != 0'  		        TrueColour = b[3] != 0'  		        RedMax = b[5] | b[4] << 8'  		        GreenMax = b[7] | b[6] << 8'  		        BlueMax = b[9] | b[8] << 8'  		        RedShift = b[10]'  		        GreenShift = b[11]'  		        BlueShift = b[12]  		    };
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: var buffer = new Framebuffer(width' height)  		    {  		        BitsPerPixel = b[0]'  		        Depth = b[1]'  		        BigEndian = b[2] != 0'  		        TrueColour = b[3] != 0'  		        RedMax = b[5] | b[4] << 8'  		        GreenMax = b[7] | b[6] << 8'  		        BlueMax = b[9] | b[8] << 8'  		        RedShift = b[10]'  		        GreenShift = b[11]'  		        BlueShift = b[12]  		    };
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: var buffer = new Framebuffer(width' height)  		    {  		        BitsPerPixel = b[0]'  		        Depth = b[1]'  		        BigEndian = b[2] != 0'  		        TrueColour = b[3] != 0'  		        RedMax = b[5] | b[4] << 8'  		        GreenMax = b[7] | b[6] << 8'  		        BlueMax = b[9] | b[8] << 8'  		        RedShift = b[10]'  		        GreenShift = b[11]'  		        BlueShift = b[12]  		    };
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: var buffer = new Framebuffer(width' height)  		    {  		        BitsPerPixel = b[0]'  		        Depth = b[1]'  		        BigEndian = b[2] != 0'  		        TrueColour = b[3] != 0'  		        RedMax = b[5] | b[4] << 8'  		        GreenMax = b[7] | b[6] << 8'  		        BlueMax = b[9] | b[8] << 8'  		        RedShift = b[10]'  		        GreenShift = b[11]'  		        BlueShift = b[12]  		    };
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: var buffer = new Framebuffer(width' height)  		    {  		        BitsPerPixel = b[0]'  		        Depth = b[1]'  		        BigEndian = b[2] != 0'  		        TrueColour = b[3] != 0'  		        RedMax = b[5] | b[4] << 8'  		        GreenMax = b[7] | b[6] << 8'  		        BlueMax = b[9] | b[8] << 8'  		        RedShift = b[10]'  		        GreenShift = b[11]'  		        BlueShift = b[12]  		    };
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: var buffer = new Framebuffer(width' height)  		    {  		        BitsPerPixel = b[0]'  		        Depth = b[1]'  		        BigEndian = b[2] != 0'  		        TrueColour = b[3] != 0'  		        RedMax = b[5] | b[4] << 8'  		        GreenMax = b[7] | b[6] << 8'  		        BlueMax = b[9] | b[8] << 8'  		        RedShift = b[10]'  		        GreenShift = b[11]'  		        BlueShift = b[12]  		    };
Magic Number,VncSharp,Framebuffer,C:\repos\humphd_VncSharp\VncSharp\Framebuffer.cs,FromPixelFormat,The following statement contains a magic number: var buffer = new Framebuffer(width' height)  		    {  		        BitsPerPixel = b[0]'  		        Depth = b[1]'  		        BigEndian = b[2] != 0'  		        TrueColour = b[3] != 0'  		        RedMax = b[5] | b[4] << 8'  		        GreenMax = b[7] | b[6] << 8'  		        BlueMax = b[9] | b[8] << 8'  		        RedShift = b[10]'  		        GreenShift = b[11]'  		        BlueShift = b[12]  		    };
Magic Number,VncSharp,PasswordDialog,C:\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.Location = new System.Drawing.Point(144' 8);
Magic Number,VncSharp,PasswordDialog,C:\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.Location = new System.Drawing.Point(144' 8);
Magic Number,VncSharp,PasswordDialog,C:\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.Size = new System.Drawing.Size(64' 23);
Magic Number,VncSharp,PasswordDialog,C:\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnOk.Size = new System.Drawing.Size(64' 23);
Magic Number,VncSharp,PasswordDialog,C:\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point(144' 40);
Magic Number,VncSharp,PasswordDialog,C:\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Location = new System.Drawing.Point(144' 40);
Magic Number,VncSharp,PasswordDialog,C:\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size(64' 23);
Magic Number,VncSharp,PasswordDialog,C:\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.Size = new System.Drawing.Size(64' 23);
Magic Number,VncSharp,PasswordDialog,C:\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.btnCancel.TabIndex = 2;
Magic Number,VncSharp,PasswordDialog,C:\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.txtPassword.Location = new System.Drawing.Point(16' 16);
Magic Number,VncSharp,PasswordDialog,C:\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.txtPassword.Location = new System.Drawing.Point(16' 16);
Magic Number,VncSharp,PasswordDialog,C:\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.txtPassword.Size = new System.Drawing.Size(112' 20);
Magic Number,VncSharp,PasswordDialog,C:\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.txtPassword.Size = new System.Drawing.Size(112' 20);
Magic Number,VncSharp,PasswordDialog,C:\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleBaseSize = new System.Drawing.Size(5' 13);
Magic Number,VncSharp,PasswordDialog,C:\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleBaseSize = new System.Drawing.Size(5' 13);
Magic Number,VncSharp,PasswordDialog,C:\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(216' 73);
Magic Number,VncSharp,PasswordDialog,C:\repos\humphd_VncSharp\VncSharp\PasswordDialog.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(216' 73);
Magic Number,VncSharp,RemoteDesktop,C:\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,DrawDesktopMessage,The following statement contains a magic number: using (var g = Graphics.FromImage(desktop))              {                  g.FillRectangle(Brushes.Black' vnc.Framebuffer.Rectangle);                    var format = new StringFormat                  {                      Alignment = StringAlignment.Center'                      LineAlignment = StringAlignment.Center                  };                    g.DrawString(message'                      new Font("Arial"' 12)'                      new SolidBrush(Color.White)'                      new PointF(vnc.Framebuffer.Width / 2' vnc.Framebuffer.Height / 2)' format);              }
Magic Number,VncSharp,RemoteDesktop,C:\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,DrawDesktopMessage,The following statement contains a magic number: using (var g = Graphics.FromImage(desktop))              {                  g.FillRectangle(Brushes.Black' vnc.Framebuffer.Rectangle);                    var format = new StringFormat                  {                      Alignment = StringAlignment.Center'                      LineAlignment = StringAlignment.Center                  };                    g.DrawString(message'                      new Font("Arial"' 12)'                      new SolidBrush(Color.White)'                      new PointF(vnc.Framebuffer.Width / 2' vnc.Framebuffer.Height / 2)' format);              }
Magic Number,VncSharp,RemoteDesktop,C:\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,DrawDesktopMessage,The following statement contains a magic number: using (var g = Graphics.FromImage(desktop))              {                  g.FillRectangle(Brushes.Black' vnc.Framebuffer.Rectangle);                    var format = new StringFormat                  {                      Alignment = StringAlignment.Center'                      LineAlignment = StringAlignment.Center                  };                    g.DrawString(message'                      new Font("Arial"' 12)'                      new SolidBrush(Color.White)'                      new PointF(vnc.Framebuffer.Width / 2' vnc.Framebuffer.Height / 2)' format);              }
Magic Number,VncSharp,RemoteDesktop,C:\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,OnMouseWheel,The following statement contains a magic number: if (!DesignMode && IsConnected)              {                  var current = PointToClient(MousePosition);                  byte mask = 0;                    // mouse was scrolled forward                  if (mea.Delta > 0)                      mask += 8;                  else if (mea.Delta < 0)                      mask += 16;                    vnc.WritePointerEvent(mask' desktopPolicy.GetMouseMovePoint(current));              }
Magic Number,VncSharp,RemoteDesktop,C:\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,OnMouseWheel,The following statement contains a magic number: if (!DesignMode && IsConnected)              {                  var current = PointToClient(MousePosition);                  byte mask = 0;                    // mouse was scrolled forward                  if (mea.Delta > 0)                      mask += 8;                  else if (mea.Delta < 0)                      mask += 16;                    vnc.WritePointerEvent(mask' desktopPolicy.GetMouseMovePoint(current));              }
Magic Number,VncSharp,RemoteDesktop,C:\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,UpdateRemotePointer,The following statement contains a magic number: if (MouseButtons == MouseButtons.Middle) mask += 2;
Magic Number,VncSharp,RemoteDesktop,C:\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,UpdateRemotePointer,The following statement contains a magic number: if (MouseButtons == MouseButtons.Right) mask += 4;
Magic Number,VncSharp,RemoteDesktop,C:\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,TranslateVirtualKey,The following statement contains a magic number: var keyboardState = new byte[256];
Magic Number,VncSharp,RemoteDesktop,C:\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,TranslateVirtualKey,The following statement contains a magic number: var charResult = new byte[2];
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: var b = Reader.ReadBytes(12);
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following statement contains a magic number: if (Encoding.ASCII.GetString(b) == RFB_VERSION_ZERO) // Repeater functionality  			{  				verMajor = 0;  				verMinor = 0;  			}  			else if (   				b[0]  == 0x52 &&					 // R  				b[1]  == 0x46 &&					 // F  				b[2]  == 0x42 &&					 // B  				b[3]  == 0x20 &&					 // (space)  				b[4]  == 0x30 &&					 // 0  				b[5]  == 0x30 &&					 // 0  				b[6]  == 0x33 &&					 // 3  				b[7]  == 0x2e &&					 // .  				(b[8]  == 0x30 ||					 // 0  				 b[8]  == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[9] == 0x30 ||					  // 0  				 b[9] == 0x38) &&					 // BUG FIX: Apple reports 8   				(b[10] == 0x33 ||					 // 3' 7' OR 8 are all valid and possible  				 b[10] == 0x36 ||					 // BUG FIX: UltraVNC reports protocol version 3.6!  				 b[10] == 0x37 ||					   				 b[10] == 0x38 ||					   				 b[10] == 0x39) &&					// BUG FIX: Apple reports 9					  				b[11] == 0x0a)						 // \n  			{  				// Since we only currently support the 3.x protocols' this can be assumed here.  				// If and when 4.x comes out' this will need to be fixed--however' the entire   				// protocol will need to be updated then anyway :)  				verMajor = 3;    				// Figure out which version of the protocol this is:  			    // ReSharper disable once SwitchStatementMissingSomeCases  				switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}  			} else {  				throw new NotSupportedException("Only versions 3.3' 3.7' and 3.8 of the RFB Protocol are supported.");  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteProtocolVersion,The following statement contains a magic number: Debug.Assert(verMinor == 3 || verMinor == 7 || verMinor == 8' "Wrong Protocol Version!"'  			    $"Protocol Version should be 3.3' 3.7' or 3.8 but is {verMajor}.{verMinor}");
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteProtocolVersion,The following statement contains a magic number: Debug.Assert(verMinor == 3 || verMinor == 7 || verMinor == 8' "Wrong Protocol Version!"'  			    $"Protocol Version should be 3.3' 3.7' or 3.8 but is {verMajor}.{verMinor}");
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteProtocolVersion,The following statement contains a magic number: Debug.Assert(verMinor == 3 || verMinor == 7 || verMinor == 8' "Wrong Protocol Version!"'  			    $"Protocol Version should be 3.3' 3.7' or 3.8 but is {verMajor}.{verMinor}");
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteProxyAddress,The following statement contains a magic number: var proxyMessage = new byte[250];
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadSecurityTypes,The following statement contains a magic number: if (verMinor == 3) {  				types = new[] { (byte) Reader.ReadUInt32() };  			} else {  				var num = Reader.ReadByte();  				types = new byte[num];  				  				for (var i = 0; i < num; ++i) {  					types[i] = Reader.ReadByte();  				}  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteSecurityType,The following statement contains a magic number: if (verMinor < 7) return;
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadSecurityChallenge,The following statement contains a magic number: return Reader.ReadBytes(16);
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadServerInit,The following statement contains a magic number: var buffer = Framebuffer.FromPixelFormat(Reader.ReadBytes(16)' w' h);
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteSetPixelFormat,The following statement contains a magic number: WritePadding(3);
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteKeyEvent,The following statement contains a magic number: WritePadding(2);
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,WriteClientCutText,The following statement contains a magic number: WritePadding(3);
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadColourMapEntry,The following statement contains a magic number: for (var i = 0; i < nbColors; i++' firstColor++)  			{  				MapEntries[firstColor' 0] = (byte)(ReadUInt16() * byte.MaxValue / ushort.MaxValue);	// R  				MapEntries[firstColor' 1] = (byte)(ReadUInt16() * byte.MaxValue / ushort.MaxValue);	// G  				MapEntries[firstColor' 2] = (byte)(ReadUInt16() * byte.MaxValue / ushort.MaxValue);	// B  			}
Magic Number,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadServerCutText,The following statement contains a magic number: ReadPadding(3);
Magic Number,VncSharp,BigEndianBinaryReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadUInt16,The following statement contains a magic number: FillBuff(2);
Magic Number,VncSharp,BigEndianBinaryReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadUInt16,The following statement contains a magic number: return (ushort)(buff[1] | (uint)buff[0] << 8);
Magic Number,VncSharp,BigEndianBinaryReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadInt16,The following statement contains a magic number: FillBuff(2);
Magic Number,VncSharp,BigEndianBinaryReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadInt16,The following statement contains a magic number: return (short)(buff[1] & 0xFF | buff[0] << 8);
Magic Number,VncSharp,BigEndianBinaryReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadUInt32,The following statement contains a magic number: FillBuff(4);
Magic Number,VncSharp,BigEndianBinaryReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadUInt32,The following statement contains a magic number: return (uint)buff[3] & 0xFF | (uint)buff[2] << 8 | (uint)buff[1] << 16 | (uint)buff[0] << 24;
Magic Number,VncSharp,BigEndianBinaryReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadUInt32,The following statement contains a magic number: return (uint)buff[3] & 0xFF | (uint)buff[2] << 8 | (uint)buff[1] << 16 | (uint)buff[0] << 24;
Magic Number,VncSharp,BigEndianBinaryReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadUInt32,The following statement contains a magic number: return (uint)buff[3] & 0xFF | (uint)buff[2] << 8 | (uint)buff[1] << 16 | (uint)buff[0] << 24;
Magic Number,VncSharp,BigEndianBinaryReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadUInt32,The following statement contains a magic number: return (uint)buff[3] & 0xFF | (uint)buff[2] << 8 | (uint)buff[1] << 16 | (uint)buff[0] << 24;
Magic Number,VncSharp,BigEndianBinaryReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadUInt32,The following statement contains a magic number: return (uint)buff[3] & 0xFF | (uint)buff[2] << 8 | (uint)buff[1] << 16 | (uint)buff[0] << 24;
Magic Number,VncSharp,BigEndianBinaryReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadInt32,The following statement contains a magic number: FillBuff(4);
Magic Number,VncSharp,BigEndianBinaryReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadInt32,The following statement contains a magic number: return buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,BigEndianBinaryReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadInt32,The following statement contains a magic number: return buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,BigEndianBinaryReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadInt32,The following statement contains a magic number: return buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,BigEndianBinaryReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadInt32,The following statement contains a magic number: return buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,BigEndianBinaryReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadInt32,The following statement contains a magic number: return buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,ZRLECompressedReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: var buff = new byte[4];
Magic Number,VncSharp,ZRLECompressedReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: if (BaseStream.Read(buff' 0' 4) != 4)  					throw new Exception("ZRLE decoder: Invalid compressed stream size");
Magic Number,VncSharp,ZRLECompressedReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: if (BaseStream.Read(buff' 0' 4) != 4)  					throw new Exception("ZRLE decoder: Invalid compressed stream size");
Magic Number,VncSharp,ZRLECompressedReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: var compressedBufferSize = buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,ZRLECompressedReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: var compressedBufferSize = buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,ZRLECompressedReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: var compressedBufferSize = buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,ZRLECompressedReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: var compressedBufferSize = buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,ZRLECompressedReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: var compressedBufferSize = buff[3] | buff[2] << 8 | buff[1] << 16 | buff[0] << 24;
Magic Number,VncSharp,ZRLECompressedReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: if (compressedBufferSize > 64 * 1024 * 1024)  					throw new Exception("ZRLE decoder: Invalid compressed data size");
Magic Number,VncSharp,ZRLECompressedReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: if (compressedBufferSize > 64 * 1024 * 1024)  					throw new Exception("ZRLE decoder: Invalid compressed data size");
Magic Number,VncSharp,ZRLECompressedReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: if (compressedBufferSize > 64 * 1024 * 1024)  					throw new Exception("ZRLE decoder: Invalid compressed data size");
Magic Number,VncSharp,ZRLECompressedReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: const int maxBufferSize = 64 * 1024;
Magic Number,VncSharp,ZRLECompressedReader,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,DecodeStream,The following statement contains a magic number: const int maxBufferSize = 64 * 1024;
Magic Number,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,Connect,The following statement contains a magic number: return Connect(host' 0' 5900);
Magic Number,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,Connect,The following statement contains a magic number: return Connect(host' display' 5900);
Magic Number,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,GetSupportedSecurityType,The following statement contains a magic number: for (var i = 0; i < types.Length; ++i) {  				if (   types[i] == 1  	// None  					|| types[i] == 2	// VNC Authentication  // TODO: None of the following are currently supported -------------------  //					|| types[i] == 5	// RA2  //					|| types[i] == 6    // RA2ne  //					|| types[i] == 16   // Tight  //					|| types[i] == 17 	// Ultra  //					|| types[i] == 18 	// TLS  				   ) return types[i];  			}
Magic Number,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,Authenticate,The following statement contains a magic number: if (securityType == 2) {  				PerformVncAuthentication(password);  			} else {  				throw new NotSupportedException("Unable to Authenticate with Server. The Server uses an Authentication scheme unknown to the client.");  			}
Magic Number,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,Authenticate,The following statement contains a magic number: if (rfb.ServerVersion == 3.8) rfb.ReadSecurityFailureReason();
Magic Number,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: var key = new byte[8];
Magic Number,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: Encoding.ASCII.GetBytes(password' 0' password.Length >= 8 ? 8 : password.Length' key' 0);
Magic Number,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: Encoding.ASCII.GetBytes(password' 0' password.Length >= 8 ? 8 : password.Length' key' 0);
Magic Number,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: for (var i = 0; i < 8; i++)                  key[i] = (byte)( ((key[i] & 0x01) << 7) |                                   ((key[i] & 0x02) << 5) |                                   ((key[i] & 0x04) << 3) |                                   ((key[i] & 0x08) << 1) |                                   ((key[i] & 0x10) >> 1) |                                   ((key[i] & 0x20) >> 3) |                                   ((key[i] & 0x40) >> 5) |                                   ((key[i] & 0x80) >> 7)  );
Magic Number,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: for (var i = 0; i < 8; i++)                  key[i] = (byte)( ((key[i] & 0x01) << 7) |                                   ((key[i] & 0x02) << 5) |                                   ((key[i] & 0x04) << 3) |                                   ((key[i] & 0x08) << 1) |                                   ((key[i] & 0x10) >> 1) |                                   ((key[i] & 0x20) >> 3) |                                   ((key[i] & 0x40) >> 5) |                                   ((key[i] & 0x80) >> 7)  );
Magic Number,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: for (var i = 0; i < 8; i++)                  key[i] = (byte)( ((key[i] & 0x01) << 7) |                                   ((key[i] & 0x02) << 5) |                                   ((key[i] & 0x04) << 3) |                                   ((key[i] & 0x08) << 1) |                                   ((key[i] & 0x10) >> 1) |                                   ((key[i] & 0x20) >> 3) |                                   ((key[i] & 0x40) >> 5) |                                   ((key[i] & 0x80) >> 7)  );
Magic Number,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: for (var i = 0; i < 8; i++)                  key[i] = (byte)( ((key[i] & 0x01) << 7) |                                   ((key[i] & 0x02) << 5) |                                   ((key[i] & 0x04) << 3) |                                   ((key[i] & 0x08) << 1) |                                   ((key[i] & 0x10) >> 1) |                                   ((key[i] & 0x20) >> 3) |                                   ((key[i] & 0x40) >> 5) |                                   ((key[i] & 0x80) >> 7)  );
Magic Number,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: for (var i = 0; i < 8; i++)                  key[i] = (byte)( ((key[i] & 0x01) << 7) |                                   ((key[i] & 0x02) << 5) |                                   ((key[i] & 0x04) << 3) |                                   ((key[i] & 0x08) << 1) |                                   ((key[i] & 0x10) >> 1) |                                   ((key[i] & 0x20) >> 3) |                                   ((key[i] & 0x40) >> 5) |                                   ((key[i] & 0x80) >> 7)  );
Magic Number,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: for (var i = 0; i < 8; i++)                  key[i] = (byte)( ((key[i] & 0x01) << 7) |                                   ((key[i] & 0x02) << 5) |                                   ((key[i] & 0x04) << 3) |                                   ((key[i] & 0x08) << 1) |                                   ((key[i] & 0x10) >> 1) |                                   ((key[i] & 0x20) >> 3) |                                   ((key[i] & 0x40) >> 5) |                                   ((key[i] & 0x80) >> 7)  );
Magic Number,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: for (var i = 0; i < 8; i++)                  key[i] = (byte)( ((key[i] & 0x01) << 7) |                                   ((key[i] & 0x02) << 5) |                                   ((key[i] & 0x04) << 3) |                                   ((key[i] & 0x08) << 1) |                                   ((key[i] & 0x10) >> 1) |                                   ((key[i] & 0x20) >> 3) |                                   ((key[i] & 0x40) >> 5) |                                   ((key[i] & 0x80) >> 7)  );
Magic Number,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,EncryptChallenge,The following statement contains a magic number: var response = new byte[16];
Magic Number,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,Disconnect,The following statement contains a magic number: worker.Join(3000);
Magic Number,VncSharp.Encodings,CPixelReader,C:\repos\humphd_VncSharp\VncSharp\Encodings\CPixelReader.cs,ReadPixel,The following statement contains a magic number: var b = reader.ReadBytes(3);
Magic Number,VncSharp.Encodings,CPixelReader,C:\repos\humphd_VncSharp\VncSharp\Encodings\CPixelReader.cs,ReadPixel,The following statement contains a magic number: return ToGdiPlusOrder(b[2]' b[1]' b[0]);
Magic Number,VncSharp.Encodings,EncodedRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\EncodedRectangle.cs,EncodedRectangle,The following statement contains a magic number: switch (framebuffer.BitsPerPixel)  			{  				case 32:  					if (encoding == RfbProtocol.ZRLE_ENCODING)  					{  						preader = new CPixelReader(reader' framebuffer);  					}  					else  					{  						preader = new PixelReader32(reader' framebuffer);  					}  					break;  				case 16:  					preader = new PixelReader16(reader' framebuffer);  					break;  				case 8:  					preader = new PixelReader8(reader' framebuffer' rfb);  					break;  				default:  					throw new ArgumentOutOfRangeException("BitsPerPixel"' framebuffer.BitsPerPixel' "Valid VNC Pixel Widths are 8' 16 or 32 bits.");  			}
Magic Number,VncSharp.Encodings,EncodedRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\EncodedRectangle.cs,EncodedRectangle,The following statement contains a magic number: switch (framebuffer.BitsPerPixel)  			{  				case 32:  					if (encoding == RfbProtocol.ZRLE_ENCODING)  					{  						preader = new CPixelReader(reader' framebuffer);  					}  					else  					{  						preader = new PixelReader32(reader' framebuffer);  					}  					break;  				case 16:  					preader = new PixelReader16(reader' framebuffer);  					break;  				case 8:  					preader = new PixelReader8(reader' framebuffer' rfb);  					break;  				default:  					throw new ArgumentOutOfRangeException("BitsPerPixel"' framebuffer.BitsPerPixel' "Valid VNC Pixel Widths are 8' 16 or 32 bits.");  			}
Magic Number,VncSharp.Encodings,EncodedRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\EncodedRectangle.cs,EncodedRectangle,The following statement contains a magic number: switch (framebuffer.BitsPerPixel)  			{  				case 32:  					if (encoding == RfbProtocol.ZRLE_ENCODING)  					{  						preader = new CPixelReader(reader' framebuffer);  					}  					else  					{  						preader = new PixelReader32(reader' framebuffer);  					}  					break;  				case 16:  					preader = new PixelReader16(reader' framebuffer);  					break;  				case 8:  					preader = new PixelReader8(reader' framebuffer' rfb);  					break;  				default:  					throw new ArgumentOutOfRangeException("BitsPerPixel"' framebuffer.BitsPerPixel' "Valid VNC Pixel Widths are 8' 16 or 32 bits.");  			}
Magic Number,VncSharp.Encodings,HextileRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\HextileRectangle.cs,Decode,The following statement contains a magic number: for (var ty = 0; ty < rectangle.Height; ty += 16) {			  				// Tiles in the last row will often be less than 16 pixels high.  				// All others will be 16 high.  				var th = rectangle.Height - ty < 16 ? rectangle.Height - ty : 16;    				for (var tx = 0; tx < rectangle.Width; tx += 16) {				  					// Tiles in the list column will often be less than 16 pixels wide.  					// All others will be 16 wide.  					var tw = rectangle.Width - tx < 16 ? rectangle.Width - tx : 16;    					var tlStart = ty * rectangle.Width + tx;  					var tlOffset = rectangle.Width - tw;    					var subencoding = rfb.ReadByte();    					// See if Raw bit is set in subencoding' and if so' ignore all other bits  					if ((subencoding & RAW) != 0) {  						FillRectangle(new Rectangle(tx' ty' tw' th));  					} else {  						if ((subencoding & BACKGROUND_SPECIFIED) != 0) {  							backgroundPixelValue = preader.ReadPixel();  						}    						// Fill-in background colour  						FillRectangle(new Rectangle(tx' ty' tw' th)' backgroundPixelValue);  												  						if ((subencoding & FOREGROUND_SPECIFIED) != 0) {  							foregroundPixelValue = preader.ReadPixel();  						}    						if ((subencoding & ANY_SUBRECTS) != 0) {  							// Get the number of sub-rectangles in this tile  							numSubrects = rfb.ReadByte();    							for (var i = 0; i < numSubrects; i++) {  								if ((subencoding & SUBRECTS_COLOURED) != 0) {  									foregroundPixelValue = preader.ReadPixel();	// colour of this sub rectangle  								}    								xANDy = rfb.ReadByte();					// X-position (4 bits) and Y-Postion (4 bits) of this sub rectangle in the tile  								widthANDheight = rfb.ReadByte();		// Width (4 bits) and Height (4 bits) of this sub rectangle  								  								// Get the proper x' y' w' and h values out of xANDy and widthANDheight  								sx = (xANDy >> 4) & 0xf;  								sy = xANDy & 0xf;  								sw = ((widthANDheight >> 4) & 0xf) + 1;	// have to add 1 to get width  								sh = (widthANDheight & 0xf) + 1;		// same for height.    								FillRectangle(new Rectangle(tx + sx' ty + sy' sw' sh)' foregroundPixelValue);  							}  						}  					}  				}  			}
Magic Number,VncSharp.Encodings,HextileRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\HextileRectangle.cs,Decode,The following statement contains a magic number: for (var ty = 0; ty < rectangle.Height; ty += 16) {			  				// Tiles in the last row will often be less than 16 pixels high.  				// All others will be 16 high.  				var th = rectangle.Height - ty < 16 ? rectangle.Height - ty : 16;    				for (var tx = 0; tx < rectangle.Width; tx += 16) {				  					// Tiles in the list column will often be less than 16 pixels wide.  					// All others will be 16 wide.  					var tw = rectangle.Width - tx < 16 ? rectangle.Width - tx : 16;    					var tlStart = ty * rectangle.Width + tx;  					var tlOffset = rectangle.Width - tw;    					var subencoding = rfb.ReadByte();    					// See if Raw bit is set in subencoding' and if so' ignore all other bits  					if ((subencoding & RAW) != 0) {  						FillRectangle(new Rectangle(tx' ty' tw' th));  					} else {  						if ((subencoding & BACKGROUND_SPECIFIED) != 0) {  							backgroundPixelValue = preader.ReadPixel();  						}    						// Fill-in background colour  						FillRectangle(new Rectangle(tx' ty' tw' th)' backgroundPixelValue);  												  						if ((subencoding & FOREGROUND_SPECIFIED) != 0) {  							foregroundPixelValue = preader.ReadPixel();  						}    						if ((subencoding & ANY_SUBRECTS) != 0) {  							// Get the number of sub-rectangles in this tile  							numSubrects = rfb.ReadByte();    							for (var i = 0; i < numSubrects; i++) {  								if ((subencoding & SUBRECTS_COLOURED) != 0) {  									foregroundPixelValue = preader.ReadPixel();	// colour of this sub rectangle  								}    								xANDy = rfb.ReadByte();					// X-position (4 bits) and Y-Postion (4 bits) of this sub rectangle in the tile  								widthANDheight = rfb.ReadByte();		// Width (4 bits) and Height (4 bits) of this sub rectangle  								  								// Get the proper x' y' w' and h values out of xANDy and widthANDheight  								sx = (xANDy >> 4) & 0xf;  								sy = xANDy & 0xf;  								sw = ((widthANDheight >> 4) & 0xf) + 1;	// have to add 1 to get width  								sh = (widthANDheight & 0xf) + 1;		// same for height.    								FillRectangle(new Rectangle(tx + sx' ty + sy' sw' sh)' foregroundPixelValue);  							}  						}  					}  				}  			}
Magic Number,VncSharp.Encodings,HextileRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\HextileRectangle.cs,Decode,The following statement contains a magic number: for (var ty = 0; ty < rectangle.Height; ty += 16) {			  				// Tiles in the last row will often be less than 16 pixels high.  				// All others will be 16 high.  				var th = rectangle.Height - ty < 16 ? rectangle.Height - ty : 16;    				for (var tx = 0; tx < rectangle.Width; tx += 16) {				  					// Tiles in the list column will often be less than 16 pixels wide.  					// All others will be 16 wide.  					var tw = rectangle.Width - tx < 16 ? rectangle.Width - tx : 16;    					var tlStart = ty * rectangle.Width + tx;  					var tlOffset = rectangle.Width - tw;    					var subencoding = rfb.ReadByte();    					// See if Raw bit is set in subencoding' and if so' ignore all other bits  					if ((subencoding & RAW) != 0) {  						FillRectangle(new Rectangle(tx' ty' tw' th));  					} else {  						if ((subencoding & BACKGROUND_SPECIFIED) != 0) {  							backgroundPixelValue = preader.ReadPixel();  						}    						// Fill-in background colour  						FillRectangle(new Rectangle(tx' ty' tw' th)' backgroundPixelValue);  												  						if ((subencoding & FOREGROUND_SPECIFIED) != 0) {  							foregroundPixelValue = preader.ReadPixel();  						}    						if ((subencoding & ANY_SUBRECTS) != 0) {  							// Get the number of sub-rectangles in this tile  							numSubrects = rfb.ReadByte();    							for (var i = 0; i < numSubrects; i++) {  								if ((subencoding & SUBRECTS_COLOURED) != 0) {  									foregroundPixelValue = preader.ReadPixel();	// colour of this sub rectangle  								}    								xANDy = rfb.ReadByte();					// X-position (4 bits) and Y-Postion (4 bits) of this sub rectangle in the tile  								widthANDheight = rfb.ReadByte();		// Width (4 bits) and Height (4 bits) of this sub rectangle  								  								// Get the proper x' y' w' and h values out of xANDy and widthANDheight  								sx = (xANDy >> 4) & 0xf;  								sy = xANDy & 0xf;  								sw = ((widthANDheight >> 4) & 0xf) + 1;	// have to add 1 to get width  								sh = (widthANDheight & 0xf) + 1;		// same for height.    								FillRectangle(new Rectangle(tx + sx' ty + sy' sw' sh)' foregroundPixelValue);  							}  						}  					}  				}  			}
Magic Number,VncSharp.Encodings,HextileRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\HextileRectangle.cs,Decode,The following statement contains a magic number: for (var ty = 0; ty < rectangle.Height; ty += 16) {			  				// Tiles in the last row will often be less than 16 pixels high.  				// All others will be 16 high.  				var th = rectangle.Height - ty < 16 ? rectangle.Height - ty : 16;    				for (var tx = 0; tx < rectangle.Width; tx += 16) {				  					// Tiles in the list column will often be less than 16 pixels wide.  					// All others will be 16 wide.  					var tw = rectangle.Width - tx < 16 ? rectangle.Width - tx : 16;    					var tlStart = ty * rectangle.Width + tx;  					var tlOffset = rectangle.Width - tw;    					var subencoding = rfb.ReadByte();    					// See if Raw bit is set in subencoding' and if so' ignore all other bits  					if ((subencoding & RAW) != 0) {  						FillRectangle(new Rectangle(tx' ty' tw' th));  					} else {  						if ((subencoding & BACKGROUND_SPECIFIED) != 0) {  							backgroundPixelValue = preader.ReadPixel();  						}    						// Fill-in background colour  						FillRectangle(new Rectangle(tx' ty' tw' th)' backgroundPixelValue);  												  						if ((subencoding & FOREGROUND_SPECIFIED) != 0) {  							foregroundPixelValue = preader.ReadPixel();  						}    						if ((subencoding & ANY_SUBRECTS) != 0) {  							// Get the number of sub-rectangles in this tile  							numSubrects = rfb.ReadByte();    							for (var i = 0; i < numSubrects; i++) {  								if ((subencoding & SUBRECTS_COLOURED) != 0) {  									foregroundPixelValue = preader.ReadPixel();	// colour of this sub rectangle  								}    								xANDy = rfb.ReadByte();					// X-position (4 bits) and Y-Postion (4 bits) of this sub rectangle in the tile  								widthANDheight = rfb.ReadByte();		// Width (4 bits) and Height (4 bits) of this sub rectangle  								  								// Get the proper x' y' w' and h values out of xANDy and widthANDheight  								sx = (xANDy >> 4) & 0xf;  								sy = xANDy & 0xf;  								sw = ((widthANDheight >> 4) & 0xf) + 1;	// have to add 1 to get width  								sh = (widthANDheight & 0xf) + 1;		// same for height.    								FillRectangle(new Rectangle(tx + sx' ty + sy' sw' sh)' foregroundPixelValue);  							}  						}  					}  				}  			}
Magic Number,VncSharp.Encodings,HextileRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\HextileRectangle.cs,Decode,The following statement contains a magic number: for (var ty = 0; ty < rectangle.Height; ty += 16) {			  				// Tiles in the last row will often be less than 16 pixels high.  				// All others will be 16 high.  				var th = rectangle.Height - ty < 16 ? rectangle.Height - ty : 16;    				for (var tx = 0; tx < rectangle.Width; tx += 16) {				  					// Tiles in the list column will often be less than 16 pixels wide.  					// All others will be 16 wide.  					var tw = rectangle.Width - tx < 16 ? rectangle.Width - tx : 16;    					var tlStart = ty * rectangle.Width + tx;  					var tlOffset = rectangle.Width - tw;    					var subencoding = rfb.ReadByte();    					// See if Raw bit is set in subencoding' and if so' ignore all other bits  					if ((subencoding & RAW) != 0) {  						FillRectangle(new Rectangle(tx' ty' tw' th));  					} else {  						if ((subencoding & BACKGROUND_SPECIFIED) != 0) {  							backgroundPixelValue = preader.ReadPixel();  						}    						// Fill-in background colour  						FillRectangle(new Rectangle(tx' ty' tw' th)' backgroundPixelValue);  												  						if ((subencoding & FOREGROUND_SPECIFIED) != 0) {  							foregroundPixelValue = preader.ReadPixel();  						}    						if ((subencoding & ANY_SUBRECTS) != 0) {  							// Get the number of sub-rectangles in this tile  							numSubrects = rfb.ReadByte();    							for (var i = 0; i < numSubrects; i++) {  								if ((subencoding & SUBRECTS_COLOURED) != 0) {  									foregroundPixelValue = preader.ReadPixel();	// colour of this sub rectangle  								}    								xANDy = rfb.ReadByte();					// X-position (4 bits) and Y-Postion (4 bits) of this sub rectangle in the tile  								widthANDheight = rfb.ReadByte();		// Width (4 bits) and Height (4 bits) of this sub rectangle  								  								// Get the proper x' y' w' and h values out of xANDy and widthANDheight  								sx = (xANDy >> 4) & 0xf;  								sy = xANDy & 0xf;  								sw = ((widthANDheight >> 4) & 0xf) + 1;	// have to add 1 to get width  								sh = (widthANDheight & 0xf) + 1;		// same for height.    								FillRectangle(new Rectangle(tx + sx' ty + sy' sw' sh)' foregroundPixelValue);  							}  						}  					}  				}  			}
Magic Number,VncSharp.Encodings,HextileRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\HextileRectangle.cs,Decode,The following statement contains a magic number: for (var ty = 0; ty < rectangle.Height; ty += 16) {			  				// Tiles in the last row will often be less than 16 pixels high.  				// All others will be 16 high.  				var th = rectangle.Height - ty < 16 ? rectangle.Height - ty : 16;    				for (var tx = 0; tx < rectangle.Width; tx += 16) {				  					// Tiles in the list column will often be less than 16 pixels wide.  					// All others will be 16 wide.  					var tw = rectangle.Width - tx < 16 ? rectangle.Width - tx : 16;    					var tlStart = ty * rectangle.Width + tx;  					var tlOffset = rectangle.Width - tw;    					var subencoding = rfb.ReadByte();    					// See if Raw bit is set in subencoding' and if so' ignore all other bits  					if ((subencoding & RAW) != 0) {  						FillRectangle(new Rectangle(tx' ty' tw' th));  					} else {  						if ((subencoding & BACKGROUND_SPECIFIED) != 0) {  							backgroundPixelValue = preader.ReadPixel();  						}    						// Fill-in background colour  						FillRectangle(new Rectangle(tx' ty' tw' th)' backgroundPixelValue);  												  						if ((subencoding & FOREGROUND_SPECIFIED) != 0) {  							foregroundPixelValue = preader.ReadPixel();  						}    						if ((subencoding & ANY_SUBRECTS) != 0) {  							// Get the number of sub-rectangles in this tile  							numSubrects = rfb.ReadByte();    							for (var i = 0; i < numSubrects; i++) {  								if ((subencoding & SUBRECTS_COLOURED) != 0) {  									foregroundPixelValue = preader.ReadPixel();	// colour of this sub rectangle  								}    								xANDy = rfb.ReadByte();					// X-position (4 bits) and Y-Postion (4 bits) of this sub rectangle in the tile  								widthANDheight = rfb.ReadByte();		// Width (4 bits) and Height (4 bits) of this sub rectangle  								  								// Get the proper x' y' w' and h values out of xANDy and widthANDheight  								sx = (xANDy >> 4) & 0xf;  								sy = xANDy & 0xf;  								sw = ((widthANDheight >> 4) & 0xf) + 1;	// have to add 1 to get width  								sh = (widthANDheight & 0xf) + 1;		// same for height.    								FillRectangle(new Rectangle(tx + sx' ty + sy' sw' sh)' foregroundPixelValue);  							}  						}  					}  				}  			}
Magic Number,VncSharp.Encodings,HextileRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\HextileRectangle.cs,Decode,The following statement contains a magic number: for (var ty = 0; ty < rectangle.Height; ty += 16) {			  				// Tiles in the last row will often be less than 16 pixels high.  				// All others will be 16 high.  				var th = rectangle.Height - ty < 16 ? rectangle.Height - ty : 16;    				for (var tx = 0; tx < rectangle.Width; tx += 16) {				  					// Tiles in the list column will often be less than 16 pixels wide.  					// All others will be 16 wide.  					var tw = rectangle.Width - tx < 16 ? rectangle.Width - tx : 16;    					var tlStart = ty * rectangle.Width + tx;  					var tlOffset = rectangle.Width - tw;    					var subencoding = rfb.ReadByte();    					// See if Raw bit is set in subencoding' and if so' ignore all other bits  					if ((subencoding & RAW) != 0) {  						FillRectangle(new Rectangle(tx' ty' tw' th));  					} else {  						if ((subencoding & BACKGROUND_SPECIFIED) != 0) {  							backgroundPixelValue = preader.ReadPixel();  						}    						// Fill-in background colour  						FillRectangle(new Rectangle(tx' ty' tw' th)' backgroundPixelValue);  												  						if ((subencoding & FOREGROUND_SPECIFIED) != 0) {  							foregroundPixelValue = preader.ReadPixel();  						}    						if ((subencoding & ANY_SUBRECTS) != 0) {  							// Get the number of sub-rectangles in this tile  							numSubrects = rfb.ReadByte();    							for (var i = 0; i < numSubrects; i++) {  								if ((subencoding & SUBRECTS_COLOURED) != 0) {  									foregroundPixelValue = preader.ReadPixel();	// colour of this sub rectangle  								}    								xANDy = rfb.ReadByte();					// X-position (4 bits) and Y-Postion (4 bits) of this sub rectangle in the tile  								widthANDheight = rfb.ReadByte();		// Width (4 bits) and Height (4 bits) of this sub rectangle  								  								// Get the proper x' y' w' and h values out of xANDy and widthANDheight  								sx = (xANDy >> 4) & 0xf;  								sy = xANDy & 0xf;  								sw = ((widthANDheight >> 4) & 0xf) + 1;	// have to add 1 to get width  								sh = (widthANDheight & 0xf) + 1;		// same for height.    								FillRectangle(new Rectangle(tx + sx' ty + sy' sw' sh)' foregroundPixelValue);  							}  						}  					}  				}  			}
Magic Number,VncSharp.Encodings,HextileRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\HextileRectangle.cs,Decode,The following statement contains a magic number: for (var ty = 0; ty < rectangle.Height; ty += 16) {			  				// Tiles in the last row will often be less than 16 pixels high.  				// All others will be 16 high.  				var th = rectangle.Height - ty < 16 ? rectangle.Height - ty : 16;    				for (var tx = 0; tx < rectangle.Width; tx += 16) {				  					// Tiles in the list column will often be less than 16 pixels wide.  					// All others will be 16 wide.  					var tw = rectangle.Width - tx < 16 ? rectangle.Width - tx : 16;    					var tlStart = ty * rectangle.Width + tx;  					var tlOffset = rectangle.Width - tw;    					var subencoding = rfb.ReadByte();    					// See if Raw bit is set in subencoding' and if so' ignore all other bits  					if ((subencoding & RAW) != 0) {  						FillRectangle(new Rectangle(tx' ty' tw' th));  					} else {  						if ((subencoding & BACKGROUND_SPECIFIED) != 0) {  							backgroundPixelValue = preader.ReadPixel();  						}    						// Fill-in background colour  						FillRectangle(new Rectangle(tx' ty' tw' th)' backgroundPixelValue);  												  						if ((subencoding & FOREGROUND_SPECIFIED) != 0) {  							foregroundPixelValue = preader.ReadPixel();  						}    						if ((subencoding & ANY_SUBRECTS) != 0) {  							// Get the number of sub-rectangles in this tile  							numSubrects = rfb.ReadByte();    							for (var i = 0; i < numSubrects; i++) {  								if ((subencoding & SUBRECTS_COLOURED) != 0) {  									foregroundPixelValue = preader.ReadPixel();	// colour of this sub rectangle  								}    								xANDy = rfb.ReadByte();					// X-position (4 bits) and Y-Postion (4 bits) of this sub rectangle in the tile  								widthANDheight = rfb.ReadByte();		// Width (4 bits) and Height (4 bits) of this sub rectangle  								  								// Get the proper x' y' w' and h values out of xANDy and widthANDheight  								sx = (xANDy >> 4) & 0xf;  								sy = xANDy & 0xf;  								sw = ((widthANDheight >> 4) & 0xf) + 1;	// have to add 1 to get width  								sh = (widthANDheight & 0xf) + 1;		// same for height.    								FillRectangle(new Rectangle(tx + sx' ty + sy' sw' sh)' foregroundPixelValue);  							}  						}  					}  				}  			}
Magic Number,VncSharp.Encodings,PixelReader,C:\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader.cs,ToGdiPlusOrder,The following statement contains a magic number: return blue & 0xFF | green << 8 | red << 16 | 0xFF << 24;
Magic Number,VncSharp.Encodings,PixelReader,C:\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader.cs,ToGdiPlusOrder,The following statement contains a magic number: return blue & 0xFF | green << 8 | red << 16 | 0xFF << 24;
Magic Number,VncSharp.Encodings,PixelReader,C:\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader.cs,ToGdiPlusOrder,The following statement contains a magic number: return blue & 0xFF | green << 8 | red << 16 | 0xFF << 24;
Magic Number,VncSharp.Encodings,PixelReader16,C:\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader16.cs,ReadPixel,The following statement contains a magic number: var b = reader.ReadBytes(2);
Magic Number,VncSharp.Encodings,PixelReader16,C:\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader16.cs,ReadPixel,The following statement contains a magic number: var pixel = (ushort)((uint)b[0] & 0xFF | (uint)b[1] << 8);
Magic Number,VncSharp.Encodings,PixelReader16,C:\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader16.cs,ReadPixel,The following statement contains a magic number: var red = (byte)(((pixel >> framebuffer.RedShift) & framebuffer.RedMax) * 255 / framebuffer.RedMax);
Magic Number,VncSharp.Encodings,PixelReader16,C:\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader16.cs,ReadPixel,The following statement contains a magic number: var green = (byte)(((pixel >> framebuffer.GreenShift) & framebuffer.GreenMax) * 255 / framebuffer.GreenMax);
Magic Number,VncSharp.Encodings,PixelReader16,C:\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader16.cs,ReadPixel,The following statement contains a magic number: var blue = (byte)(((pixel >> framebuffer.BlueShift) & framebuffer.BlueMax) * 255 / framebuffer.BlueMax);
Magic Number,VncSharp.Encodings,PixelReader32,C:\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader32.cs,ReadPixel,The following statement contains a magic number: var b = reader.ReadBytes(4);
Magic Number,VncSharp.Encodings,PixelReader32,C:\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader32.cs,ReadPixel,The following statement contains a magic number: var pixel = (uint)b[0] & 0xFF |                            (uint)b[1] << 8   |                            (uint)b[2] << 16  |                            (uint)b[3] << 24;
Magic Number,VncSharp.Encodings,PixelReader32,C:\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader32.cs,ReadPixel,The following statement contains a magic number: var pixel = (uint)b[0] & 0xFF |                            (uint)b[1] << 8   |                            (uint)b[2] << 16  |                            (uint)b[3] << 24;
Magic Number,VncSharp.Encodings,PixelReader32,C:\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader32.cs,ReadPixel,The following statement contains a magic number: var pixel = (uint)b[0] & 0xFF |                            (uint)b[1] << 8   |                            (uint)b[2] << 16  |                            (uint)b[3] << 24;
Magic Number,VncSharp.Encodings,PixelReader32,C:\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader32.cs,ReadPixel,The following statement contains a magic number: var pixel = (uint)b[0] & 0xFF |                            (uint)b[1] << 8   |                            (uint)b[2] << 16  |                            (uint)b[3] << 24;
Magic Number,VncSharp.Encodings,PixelReader32,C:\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader32.cs,ReadPixel,The following statement contains a magic number: var pixel = (uint)b[0] & 0xFF |                            (uint)b[1] << 8   |                            (uint)b[2] << 16  |                            (uint)b[3] << 24;
Magic Number,VncSharp.Encodings,PixelReader8,C:\repos\humphd_VncSharp\VncSharp\Encodings\PixelReader8.cs,ReadPixel,The following statement contains a magic number: return ToGdiPlusOrder((byte)rfb.MapEntries[idx' 0]' (byte)rfb.MapEntries[idx' 1]' (byte)rfb.MapEntries[idx' 2]);
Magic Number,VncSharp.Encodings,ZrleRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,Decode,The following statement contains a magic number: for (var ty = 0; ty < rectangle.Height; ty += TILE_HEIGHT) {  				var th = Math.Min(rectangle.Height - ty' TILE_HEIGHT);    				for (var tx = 0; tx < rectangle.Width; tx += TILE_WIDTH) {  					var tw = Math.Min(rectangle.Width - tx' TILE_WIDTH);    					var subencoding = rfb.ZrleReader.ReadByte();    					if (subencoding >= 17 && subencoding <= 127 || subencoding == 129)  						throw new Exception("Invalid subencoding value");    					var isRLE = (subencoding & 128) != 0;  					var paletteSize = subencoding & 127;    					// Fill palette  					for (var i = 0; i < paletteSize; i++)  						palette[i] = preader.ReadPixel();    					if (paletteSize == 1) {  						// Solid tile  						FillRectangle(new Rectangle(tx' ty' tw' th)' palette[0]);  						continue;  					}    					if (!isRLE) {  						if (paletteSize == 0) {  							// Raw pixel data  							FillRectangle(new Rectangle(tx' ty' tw' th));  						} else {  							// Packed palette  							ReadZrlePackedPixels(tw' th' palette' paletteSize' tileBuffer);  							FillRectangle(new Rectangle(tx' ty' tw' th)' tileBuffer);  						}  					} else {  						if (paletteSize == 0) {  							// Plain RLE  							ReadZrlePlainRLEPixels(tw' th' tileBuffer);  							FillRectangle(new Rectangle(tx' ty' tw' th)' tileBuffer);  						} else {  							// Packed RLE palette  							ReadZrlePackedRLEPixels(tx' ty' tw' th' palette' tileBuffer);  							FillRectangle(new Rectangle(tx' ty' tw' th)' tileBuffer);  						}  					}  				}  			}
Magic Number,VncSharp.Encodings,ZrleRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,Decode,The following statement contains a magic number: for (var ty = 0; ty < rectangle.Height; ty += TILE_HEIGHT) {  				var th = Math.Min(rectangle.Height - ty' TILE_HEIGHT);    				for (var tx = 0; tx < rectangle.Width; tx += TILE_WIDTH) {  					var tw = Math.Min(rectangle.Width - tx' TILE_WIDTH);    					var subencoding = rfb.ZrleReader.ReadByte();    					if (subencoding >= 17 && subencoding <= 127 || subencoding == 129)  						throw new Exception("Invalid subencoding value");    					var isRLE = (subencoding & 128) != 0;  					var paletteSize = subencoding & 127;    					// Fill palette  					for (var i = 0; i < paletteSize; i++)  						palette[i] = preader.ReadPixel();    					if (paletteSize == 1) {  						// Solid tile  						FillRectangle(new Rectangle(tx' ty' tw' th)' palette[0]);  						continue;  					}    					if (!isRLE) {  						if (paletteSize == 0) {  							// Raw pixel data  							FillRectangle(new Rectangle(tx' ty' tw' th));  						} else {  							// Packed palette  							ReadZrlePackedPixels(tw' th' palette' paletteSize' tileBuffer);  							FillRectangle(new Rectangle(tx' ty' tw' th)' tileBuffer);  						}  					} else {  						if (paletteSize == 0) {  							// Plain RLE  							ReadZrlePlainRLEPixels(tw' th' tileBuffer);  							FillRectangle(new Rectangle(tx' ty' tw' th)' tileBuffer);  						} else {  							// Packed RLE palette  							ReadZrlePackedRLEPixels(tx' ty' tw' th' palette' tileBuffer);  							FillRectangle(new Rectangle(tx' ty' tw' th)' tileBuffer);  						}  					}  				}  			}
Magic Number,VncSharp.Encodings,ZrleRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,Decode,The following statement contains a magic number: for (var ty = 0; ty < rectangle.Height; ty += TILE_HEIGHT) {  				var th = Math.Min(rectangle.Height - ty' TILE_HEIGHT);    				for (var tx = 0; tx < rectangle.Width; tx += TILE_WIDTH) {  					var tw = Math.Min(rectangle.Width - tx' TILE_WIDTH);    					var subencoding = rfb.ZrleReader.ReadByte();    					if (subencoding >= 17 && subencoding <= 127 || subencoding == 129)  						throw new Exception("Invalid subencoding value");    					var isRLE = (subencoding & 128) != 0;  					var paletteSize = subencoding & 127;    					// Fill palette  					for (var i = 0; i < paletteSize; i++)  						palette[i] = preader.ReadPixel();    					if (paletteSize == 1) {  						// Solid tile  						FillRectangle(new Rectangle(tx' ty' tw' th)' palette[0]);  						continue;  					}    					if (!isRLE) {  						if (paletteSize == 0) {  							// Raw pixel data  							FillRectangle(new Rectangle(tx' ty' tw' th));  						} else {  							// Packed palette  							ReadZrlePackedPixels(tw' th' palette' paletteSize' tileBuffer);  							FillRectangle(new Rectangle(tx' ty' tw' th)' tileBuffer);  						}  					} else {  						if (paletteSize == 0) {  							// Plain RLE  							ReadZrlePlainRLEPixels(tw' th' tileBuffer);  							FillRectangle(new Rectangle(tx' ty' tw' th)' tileBuffer);  						} else {  							// Packed RLE palette  							ReadZrlePackedRLEPixels(tx' ty' tw' th' palette' tileBuffer);  							FillRectangle(new Rectangle(tx' ty' tw' th)' tileBuffer);  						}  					}  				}  			}
Magic Number,VncSharp.Encodings,ZrleRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,Decode,The following statement contains a magic number: for (var ty = 0; ty < rectangle.Height; ty += TILE_HEIGHT) {  				var th = Math.Min(rectangle.Height - ty' TILE_HEIGHT);    				for (var tx = 0; tx < rectangle.Width; tx += TILE_WIDTH) {  					var tw = Math.Min(rectangle.Width - tx' TILE_WIDTH);    					var subencoding = rfb.ZrleReader.ReadByte();    					if (subencoding >= 17 && subencoding <= 127 || subencoding == 129)  						throw new Exception("Invalid subencoding value");    					var isRLE = (subencoding & 128) != 0;  					var paletteSize = subencoding & 127;    					// Fill palette  					for (var i = 0; i < paletteSize; i++)  						palette[i] = preader.ReadPixel();    					if (paletteSize == 1) {  						// Solid tile  						FillRectangle(new Rectangle(tx' ty' tw' th)' palette[0]);  						continue;  					}    					if (!isRLE) {  						if (paletteSize == 0) {  							// Raw pixel data  							FillRectangle(new Rectangle(tx' ty' tw' th));  						} else {  							// Packed palette  							ReadZrlePackedPixels(tw' th' palette' paletteSize' tileBuffer);  							FillRectangle(new Rectangle(tx' ty' tw' th)' tileBuffer);  						}  					} else {  						if (paletteSize == 0) {  							// Plain RLE  							ReadZrlePlainRLEPixels(tw' th' tileBuffer);  							FillRectangle(new Rectangle(tx' ty' tw' th)' tileBuffer);  						} else {  							// Packed RLE palette  							ReadZrlePackedRLEPixels(tx' ty' tw' th' palette' tileBuffer);  							FillRectangle(new Rectangle(tx' ty' tw' th)' tileBuffer);  						}  					}  				}  			}
Magic Number,VncSharp.Encodings,ZrleRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,Decode,The following statement contains a magic number: for (var ty = 0; ty < rectangle.Height; ty += TILE_HEIGHT) {  				var th = Math.Min(rectangle.Height - ty' TILE_HEIGHT);    				for (var tx = 0; tx < rectangle.Width; tx += TILE_WIDTH) {  					var tw = Math.Min(rectangle.Width - tx' TILE_WIDTH);    					var subencoding = rfb.ZrleReader.ReadByte();    					if (subencoding >= 17 && subencoding <= 127 || subencoding == 129)  						throw new Exception("Invalid subencoding value");    					var isRLE = (subencoding & 128) != 0;  					var paletteSize = subencoding & 127;    					// Fill palette  					for (var i = 0; i < paletteSize; i++)  						palette[i] = preader.ReadPixel();    					if (paletteSize == 1) {  						// Solid tile  						FillRectangle(new Rectangle(tx' ty' tw' th)' palette[0]);  						continue;  					}    					if (!isRLE) {  						if (paletteSize == 0) {  							// Raw pixel data  							FillRectangle(new Rectangle(tx' ty' tw' th));  						} else {  							// Packed palette  							ReadZrlePackedPixels(tw' th' palette' paletteSize' tileBuffer);  							FillRectangle(new Rectangle(tx' ty' tw' th)' tileBuffer);  						}  					} else {  						if (paletteSize == 0) {  							// Plain RLE  							ReadZrlePlainRLEPixels(tw' th' tileBuffer);  							FillRectangle(new Rectangle(tx' ty' tw' th)' tileBuffer);  						} else {  							// Packed RLE palette  							ReadZrlePackedRLEPixels(tx' ty' tw' th' palette' tileBuffer);  							FillRectangle(new Rectangle(tx' ty' tw' th)' tileBuffer);  						}  					}  				}  			}
Magic Number,VncSharp.Encodings,ZrleRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedPixels,The following statement contains a magic number: var bppp = palSize > 16 ? 8 :  			    (palSize > 4 ? 4 : (palSize > 2 ? 2 : 1));
Magic Number,VncSharp.Encodings,ZrleRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedPixels,The following statement contains a magic number: var bppp = palSize > 16 ? 8 :  			    (palSize > 4 ? 4 : (palSize > 2 ? 2 : 1));
Magic Number,VncSharp.Encodings,ZrleRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedPixels,The following statement contains a magic number: var bppp = palSize > 16 ? 8 :  			    (palSize > 4 ? 4 : (palSize > 2 ? 2 : 1));
Magic Number,VncSharp.Encodings,ZrleRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedPixels,The following statement contains a magic number: var bppp = palSize > 16 ? 8 :  			    (palSize > 4 ? 4 : (palSize > 2 ? 2 : 1));
Magic Number,VncSharp.Encodings,ZrleRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedPixels,The following statement contains a magic number: var bppp = palSize > 16 ? 8 :  			    (palSize > 4 ? 4 : (palSize > 2 ? 2 : 1));
Magic Number,VncSharp.Encodings,ZrleRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedPixels,The following statement contains a magic number: var bppp = palSize > 16 ? 8 :  			    (palSize > 4 ? 4 : (palSize > 2 ? 2 : 1));
Magic Number,VncSharp.Encodings,ZrleRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedPixels,The following statement contains a magic number: for (var i = 0; i < th; i++) {  				var eol = ptr + tw;  				var b = 0;  				var nbits = 0;    				while (ptr < eol) {  					if (nbits == 0)	{  						b = rfb.ZrleReader.ReadByte();  						nbits = 8;  					}  					nbits -= bppp;  					var index = (b >> nbits) & ((1 << bppp) - 1) & 127;  					tile[ptr++] = palette[index];  				}  			}
Magic Number,VncSharp.Encodings,ZrleRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedPixels,The following statement contains a magic number: for (var i = 0; i < th; i++) {  				var eol = ptr + tw;  				var b = 0;  				var nbits = 0;    				while (ptr < eol) {  					if (nbits == 0)	{  						b = rfb.ZrleReader.ReadByte();  						nbits = 8;  					}  					nbits -= bppp;  					var index = (b >> nbits) & ((1 << bppp) - 1) & 127;  					tile[ptr++] = palette[index];  				}  			}
Magic Number,VncSharp.Encodings,ZrleRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedRLEPixels,The following statement contains a magic number: while (ptr < end) {  				int index = rfb.ZrleReader.ReadByte();  				var len = 1;  				if ((index & 128) != 0) {  					int b;  					do {  						b = rfb.ZrleReader.ReadByte();  						len += b;  					} while (b == byte.MaxValue);  				}    				index &= 127;    				while (len-- > 0) tile[ptr++] = palette[index];  			}
Magic Number,VncSharp.Encodings,ZrleRectangle,C:\repos\humphd_VncSharp\VncSharp\Encodings\ZrleRectangle.cs,ReadZrlePackedRLEPixels,The following statement contains a magic number: while (ptr < end) {  				int index = rfb.ZrleReader.ReadByte();  				var len = 1;  				if ((index & 128) != 0) {  					int b;  					do {  						b = rfb.ZrleReader.ReadByte();  						len += b;  					} while (b == byte.MaxValue);  				}    				index &= 127;    				while (len-- > 0) tile[ptr++] = palette[index];  			}
Magic Number,VncSharp.zlib.NET,Adler32,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Adler32.cs,adler32,The following statement contains a magic number: var s2 = (adler >> 16) & 0xffff;
Magic Number,VncSharp.zlib.NET,Adler32,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Adler32.cs,adler32,The following statement contains a magic number: while (len > 0)  			{  				k = len < NMAX?len:NMAX;  				len -= k;  				while (k >= 16)  				{  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					k -= 16;  				}  				if (k != 0)  				{  					do   					{  						s1 += buf[index++] & 0xff; s2 += s1;  					}  					while (--k != 0);  				}  				s1 %= BASE;  				s2 %= BASE;  			}
Magic Number,VncSharp.zlib.NET,Adler32,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Adler32.cs,adler32,The following statement contains a magic number: while (len > 0)  			{  				k = len < NMAX?len:NMAX;  				len -= k;  				while (k >= 16)  				{  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					s1 += buf[index++] & 0xff; s2 += s1;  					k -= 16;  				}  				if (k != 0)  				{  					do   					{  						s1 += buf[index++] & 0xff; s2 += s1;  					}  					while (--k != 0);  				}  				s1 %= BASE;  				s2 %= BASE;  			}
Magic Number,VncSharp.zlib.NET,Adler32,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Adler32.cs,adler32,The following statement contains a magic number: return (s2 << 16) | s1;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: dyn_ltree = new short[HEAP_SIZE * 2];
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,lm_init,The following statement contains a magic number: window_size = 2 * w_size;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,tr_init,The following statement contains a magic number: last_eob_len = 8;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,init_block,The following statement contains a magic number: for (var i = 0; i < L_CODES; i++)  				dyn_ltree[i * 2] = 0;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,init_block,The following statement contains a magic number: for (var i = 0; i < D_CODES; i++)  				dyn_dtree[i * 2] = 0;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,init_block,The following statement contains a magic number: for (var i = 0; i < BL_CODES; i++)  				bl_tree[i * 2] = 0;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,init_block,The following statement contains a magic number: dyn_ltree[END_BLOCK * 2] = 1;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,smaller,The following statement contains a magic number: return tree[n * 2] < tree[m * 2] || tree[n * 2] == tree[m * 2] && depth[n] <= depth[m];
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,smaller,The following statement contains a magic number: return tree[n * 2] < tree[m * 2] || tree[n * 2] == tree[m * 2] && depth[n] <= depth[m];
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,smaller,The following statement contains a magic number: return tree[n * 2] < tree[m * 2] || tree[n * 2] == tree[m * 2] && depth[n] <= depth[m];
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,smaller,The following statement contains a magic number: return tree[n * 2] < tree[m * 2] || tree[n * 2] == tree[m * 2] && depth[n] <= depth[m];
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: int nextlen = tree[0 * 2 + 1];
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: var max_count = 7;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: var min_count = 4;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0)  			{  				max_count = 138; min_count = 3;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0)  			{  				max_count = 138; min_count = 3;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: tree[(max_code + 1) * 2 + 1] = (short) SupportClass.Identity(0xffff);
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			            bl_tree[curlen * 2]++;  			        bl_tree[REP_3_6 * 2]++;  			    }  			    else if (count <= 10)  			    {  			        bl_tree[REPZ_3_10 * 2]++;  			    }  			    else  			    {  			        bl_tree[REPZ_11_138 * 2]++;  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			            bl_tree[curlen * 2]++;  			        bl_tree[REP_3_6 * 2]++;  			    }  			    else if (count <= 10)  			    {  			        bl_tree[REPZ_3_10 * 2]++;  			    }  			    else  			    {  			        bl_tree[REPZ_11_138 * 2]++;  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			            bl_tree[curlen * 2]++;  			        bl_tree[REP_3_6 * 2]++;  			    }  			    else if (count <= 10)  			    {  			        bl_tree[REPZ_3_10 * 2]++;  			    }  			    else  			    {  			        bl_tree[REPZ_11_138 * 2]++;  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			            bl_tree[curlen * 2]++;  			        bl_tree[REP_3_6 * 2]++;  			    }  			    else if (count <= 10)  			    {  			        bl_tree[REPZ_3_10 * 2]++;  			    }  			    else  			    {  			        bl_tree[REPZ_11_138 * 2]++;  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			            bl_tree[curlen * 2]++;  			        bl_tree[REP_3_6 * 2]++;  			    }  			    else if (count <= 10)  			    {  			        bl_tree[REPZ_3_10 * 2]++;  			    }  			    else  			    {  			        bl_tree[REPZ_11_138 * 2]++;  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			            bl_tree[curlen * 2]++;  			        bl_tree[REP_3_6 * 2]++;  			    }  			    else if (count <= 10)  			    {  			        bl_tree[REPZ_3_10 * 2]++;  			    }  			    else  			    {  			        bl_tree[REPZ_11_138 * 2]++;  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			            bl_tree[curlen * 2]++;  			        bl_tree[REP_3_6 * 2]++;  			    }  			    else if (count <= 10)  			    {  			        bl_tree[REPZ_3_10 * 2]++;  			    }  			    else  			    {  			        bl_tree[REPZ_11_138 * 2]++;  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			            bl_tree[curlen * 2]++;  			        bl_tree[REP_3_6 * 2]++;  			    }  			    else if (count <= 10)  			    {  			        bl_tree[REPZ_3_10 * 2]++;  			    }  			    else  			    {  			        bl_tree[REPZ_11_138 * 2]++;  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			            bl_tree[curlen * 2]++;  			        bl_tree[REP_3_6 * 2]++;  			    }  			    else if (count <= 10)  			    {  			        bl_tree[REPZ_3_10 * 2]++;  			    }  			    else  			    {  			        bl_tree[REPZ_11_138 * 2]++;  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			            bl_tree[curlen * 2]++;  			        bl_tree[REP_3_6 * 2]++;  			    }  			    else if (count <= 10)  			    {  			        bl_tree[REPZ_3_10 * 2]++;  			    }  			    else  			    {  			        bl_tree[REPZ_11_138 * 2]++;  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			            bl_tree[curlen * 2]++;  			        bl_tree[REP_3_6 * 2]++;  			    }  			    else if (count <= 10)  			    {  			        bl_tree[REPZ_3_10 * 2]++;  			    }  			    else  			    {  			        bl_tree[REPZ_11_138 * 2]++;  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			            bl_tree[curlen * 2]++;  			        bl_tree[REP_3_6 * 2]++;  			    }  			    else if (count <= 10)  			    {  			        bl_tree[REPZ_3_10 * 2]++;  			    }  			    else  			    {  			        bl_tree[REPZ_11_138 * 2]++;  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			            bl_tree[curlen * 2]++;  			        bl_tree[REP_3_6 * 2]++;  			    }  			    else if (count <= 10)  			    {  			        bl_tree[REPZ_3_10 * 2]++;  			    }  			    else  			    {  			        bl_tree[REPZ_11_138 * 2]++;  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        bl_tree[curlen * 2] = (short) (bl_tree[curlen * 2] + count);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			            bl_tree[curlen * 2]++;  			        bl_tree[REP_3_6 * 2]++;  			    }  			    else if (count <= 10)  			    {  			        bl_tree[REPZ_3_10 * 2]++;  			    }  			    else  			    {  			        bl_tree[REPZ_11_138 * 2]++;  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,build_bl_tree,The following statement contains a magic number: for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--)  			{  				if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0)  					break;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,build_bl_tree,The following statement contains a magic number: for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--)  			{  				if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0)  					break;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(dcodes - 1' 5);
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++)  			{  				send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++)  			{  				send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: int nextlen = tree[0 * 2 + 1];
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: var max_count = 7;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: var min_count = 4;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0)  			{  				max_count = 138; min_count = 3;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0)  			{  				max_count = 138; min_count = 3;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        do   			        {  			            send_code(curlen' bl_tree);  			        }  			        while (--count != 0);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			        {  			            send_code(curlen' bl_tree); count--;  			        }  			        send_code(REP_3_6' bl_tree);  			        send_bits(count - 3' 2);  			    }  			    else if (count <= 10)  			    {  			        send_code(REPZ_3_10' bl_tree);  			        send_bits(count - 3' 3);  			    }  			    else  			    {  			        send_code(REPZ_11_138' bl_tree);  			        send_bits(count - 11' 7);  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        do   			        {  			            send_code(curlen' bl_tree);  			        }  			        while (--count != 0);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			        {  			            send_code(curlen' bl_tree); count--;  			        }  			        send_code(REP_3_6' bl_tree);  			        send_bits(count - 3' 2);  			    }  			    else if (count <= 10)  			    {  			        send_code(REPZ_3_10' bl_tree);  			        send_bits(count - 3' 3);  			    }  			    else  			    {  			        send_code(REPZ_11_138' bl_tree);  			        send_bits(count - 11' 7);  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        do   			        {  			            send_code(curlen' bl_tree);  			        }  			        while (--count != 0);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			        {  			            send_code(curlen' bl_tree); count--;  			        }  			        send_code(REP_3_6' bl_tree);  			        send_bits(count - 3' 2);  			    }  			    else if (count <= 10)  			    {  			        send_code(REPZ_3_10' bl_tree);  			        send_bits(count - 3' 3);  			    }  			    else  			    {  			        send_code(REPZ_11_138' bl_tree);  			        send_bits(count - 11' 7);  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        do   			        {  			            send_code(curlen' bl_tree);  			        }  			        while (--count != 0);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			        {  			            send_code(curlen' bl_tree); count--;  			        }  			        send_code(REP_3_6' bl_tree);  			        send_bits(count - 3' 2);  			    }  			    else if (count <= 10)  			    {  			        send_code(REPZ_3_10' bl_tree);  			        send_bits(count - 3' 3);  			    }  			    else  			    {  			        send_code(REPZ_11_138' bl_tree);  			        send_bits(count - 11' 7);  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        do   			        {  			            send_code(curlen' bl_tree);  			        }  			        while (--count != 0);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			        {  			            send_code(curlen' bl_tree); count--;  			        }  			        send_code(REP_3_6' bl_tree);  			        send_bits(count - 3' 2);  			    }  			    else if (count <= 10)  			    {  			        send_code(REPZ_3_10' bl_tree);  			        send_bits(count - 3' 3);  			    }  			    else  			    {  			        send_code(REPZ_11_138' bl_tree);  			        send_bits(count - 11' 7);  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        do   			        {  			            send_code(curlen' bl_tree);  			        }  			        while (--count != 0);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			        {  			            send_code(curlen' bl_tree); count--;  			        }  			        send_code(REP_3_6' bl_tree);  			        send_bits(count - 3' 2);  			    }  			    else if (count <= 10)  			    {  			        send_code(REPZ_3_10' bl_tree);  			        send_bits(count - 3' 3);  			    }  			    else  			    {  			        send_code(REPZ_11_138' bl_tree);  			        send_bits(count - 11' 7);  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        do   			        {  			            send_code(curlen' bl_tree);  			        }  			        while (--count != 0);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			        {  			            send_code(curlen' bl_tree); count--;  			        }  			        send_code(REP_3_6' bl_tree);  			        send_bits(count - 3' 2);  			    }  			    else if (count <= 10)  			    {  			        send_code(REPZ_3_10' bl_tree);  			        send_bits(count - 3' 3);  			    }  			    else  			    {  			        send_code(REPZ_11_138' bl_tree);  			        send_bits(count - 11' 7);  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        do   			        {  			            send_code(curlen' bl_tree);  			        }  			        while (--count != 0);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			        {  			            send_code(curlen' bl_tree); count--;  			        }  			        send_code(REP_3_6' bl_tree);  			        send_bits(count - 3' 2);  			    }  			    else if (count <= 10)  			    {  			        send_code(REPZ_3_10' bl_tree);  			        send_bits(count - 3' 3);  			    }  			    else  			    {  			        send_code(REPZ_11_138' bl_tree);  			        send_bits(count - 11' 7);  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        do   			        {  			            send_code(curlen' bl_tree);  			        }  			        while (--count != 0);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			        {  			            send_code(curlen' bl_tree); count--;  			        }  			        send_code(REP_3_6' bl_tree);  			        send_bits(count - 3' 2);  			    }  			    else if (count <= 10)  			    {  			        send_code(REPZ_3_10' bl_tree);  			        send_bits(count - 3' 3);  			    }  			    else  			    {  			        send_code(REPZ_11_138' bl_tree);  			        send_bits(count - 11' 7);  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        do   			        {  			            send_code(curlen' bl_tree);  			        }  			        while (--count != 0);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			        {  			            send_code(curlen' bl_tree); count--;  			        }  			        send_code(REP_3_6' bl_tree);  			        send_bits(count - 3' 2);  			    }  			    else if (count <= 10)  			    {  			        send_code(REPZ_3_10' bl_tree);  			        send_bits(count - 3' 3);  			    }  			    else  			    {  			        send_code(REPZ_11_138' bl_tree);  			        send_bits(count - 11' 7);  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        do   			        {  			            send_code(curlen' bl_tree);  			        }  			        while (--count != 0);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			        {  			            send_code(curlen' bl_tree); count--;  			        }  			        send_code(REP_3_6' bl_tree);  			        send_bits(count - 3' 2);  			    }  			    else if (count <= 10)  			    {  			        send_code(REPZ_3_10' bl_tree);  			        send_bits(count - 3' 3);  			    }  			    else  			    {  			        send_code(REPZ_11_138' bl_tree);  			        send_bits(count - 11' 7);  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        do   			        {  			            send_code(curlen' bl_tree);  			        }  			        while (--count != 0);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			        {  			            send_code(curlen' bl_tree); count--;  			        }  			        send_code(REP_3_6' bl_tree);  			        send_bits(count - 3' 2);  			    }  			    else if (count <= 10)  			    {  			        send_code(REPZ_3_10' bl_tree);  			        send_bits(count - 3' 3);  			    }  			    else  			    {  			        send_code(REPZ_11_138' bl_tree);  			        send_bits(count - 11' 7);  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        do   			        {  			            send_code(curlen' bl_tree);  			        }  			        while (--count != 0);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			        {  			            send_code(curlen' bl_tree); count--;  			        }  			        send_code(REP_3_6' bl_tree);  			        send_bits(count - 3' 2);  			    }  			    else if (count <= 10)  			    {  			        send_code(REPZ_3_10' bl_tree);  			        send_bits(count - 3' 3);  			    }  			    else  			    {  			        send_code(REPZ_11_138' bl_tree);  			        send_bits(count - 11' 7);  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				curlen = nextlen; nextlen = tree[(n + 1) * 2 + 1];  				if (++count < max_count && curlen == nextlen)  				{  					continue;  				}  			    if (count < min_count)  			    {  			        do   			        {  			            send_code(curlen' bl_tree);  			        }  			        while (--count != 0);  			    }  			    else if (curlen != 0)  			    {  			        if (curlen != prevlen)  			        {  			            send_code(curlen' bl_tree); count--;  			        }  			        send_code(REP_3_6' bl_tree);  			        send_bits(count - 3' 2);  			    }  			    else if (count <= 10)  			    {  			        send_code(REPZ_3_10' bl_tree);  			        send_bits(count - 3' 3);  			    }  			    else  			    {  			        send_code(REPZ_11_138' bl_tree);  			        send_bits(count - 11' 7);  			    }  			    count = 0; prevlen = curlen;  				if (nextlen == 0)  				{  					max_count = 138; min_count = 3;  				}  				else if (curlen == nextlen)  				{  					max_count = 6; min_count = 3;  				}  				else  				{  					max_count = 7; min_count = 4;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,put_short,The following statement contains a magic number: put_byte((byte) SupportClass.URShift(w' 8));
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,putShortMSB,The following statement contains a magic number: put_byte((byte) (b >> 8));
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_code,The following statement contains a magic number: send_bits(tree[c * 2] & 0xffff' tree[c * 2 + 1] & 0xffff);
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,send_code,The following statement contains a magic number: send_bits(tree[c * 2] & 0xffff' tree[c * 2 + 1] & 0xffff);
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits(STATIC_TREES << 1' 3);
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)  			{  				send_bits(STATIC_TREES << 1' 3);  				send_code(END_BLOCK' StaticTree.static_ltree);  				bi_flush();  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)  			{  				send_bits(STATIC_TREES << 1' 3);  				send_code(END_BLOCK' StaticTree.static_ltree);  				bi_flush();  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9)  			{  				send_bits(STATIC_TREES << 1' 3);  				send_code(END_BLOCK' StaticTree.static_ltree);  				bi_flush();  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_align,The following statement contains a magic number: last_eob_len = 7;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2] = (byte) SupportClass.URShift(dist' 8);
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2] = (byte) SupportClass.URShift(dist' 8);
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2 + 1] = (byte) dist;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)  			{  				// lc is the unmatched char  				dyn_ltree[lc * 2]++;  			}  			else  			{  				matches++;  				// Here' lc is the match length - MIN_MATCH  				dist--; // dist = match distance - 1  				dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;  				dyn_dtree[Tree.d_code(dist) * 2]++;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)  			{  				// lc is the unmatched char  				dyn_ltree[lc * 2]++;  			}  			else  			{  				matches++;  				// Here' lc is the match length - MIN_MATCH  				dist--; // dist = match distance - 1  				dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;  				dyn_dtree[Tree.d_code(dist) * 2]++;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0)  			{  				// lc is the unmatched char  				dyn_ltree[lc * 2]++;  			}  			else  			{  				matches++;  				// Here' lc is the match length - MIN_MATCH  				dist--; // dist = match distance - 1  				dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;  				dyn_dtree[Tree.d_code(dist) * 2]++;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)  			{  				// Compute an upper bound for the compressed length  				var out_length = last_lit * 8;  				var in_length = strstart - block_start;  				int dcode;  				for (dcode = 0; dcode < D_CODES; dcode++)  				{  					out_length = (int) (out_length + dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));  				}  				out_length = SupportClass.URShift(out_length' 3);  				if (matches < last_lit / 2 && out_length < in_length / 2)  					return true;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)  			{  				// Compute an upper bound for the compressed length  				var out_length = last_lit * 8;  				var in_length = strstart - block_start;  				int dcode;  				for (dcode = 0; dcode < D_CODES; dcode++)  				{  					out_length = (int) (out_length + dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));  				}  				out_length = SupportClass.URShift(out_length' 3);  				if (matches < last_lit / 2 && out_length < in_length / 2)  					return true;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)  			{  				// Compute an upper bound for the compressed length  				var out_length = last_lit * 8;  				var in_length = strstart - block_start;  				int dcode;  				for (dcode = 0; dcode < D_CODES; dcode++)  				{  					out_length = (int) (out_length + dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));  				}  				out_length = SupportClass.URShift(out_length' 3);  				if (matches < last_lit / 2 && out_length < in_length / 2)  					return true;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)  			{  				// Compute an upper bound for the compressed length  				var out_length = last_lit * 8;  				var in_length = strstart - block_start;  				int dcode;  				for (dcode = 0; dcode < D_CODES; dcode++)  				{  					out_length = (int) (out_length + dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));  				}  				out_length = SupportClass.URShift(out_length' 3);  				if (matches < last_lit / 2 && out_length < in_length / 2)  					return true;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)  			{  				// Compute an upper bound for the compressed length  				var out_length = last_lit * 8;  				var in_length = strstart - block_start;  				int dcode;  				for (dcode = 0; dcode < D_CODES; dcode++)  				{  					out_length = (int) (out_length + dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));  				}  				out_length = SupportClass.URShift(out_length' 3);  				if (matches < last_lit / 2 && out_length < in_length / 2)  					return true;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2)  			{  				// Compute an upper bound for the compressed length  				var out_length = last_lit * 8;  				var in_length = strstart - block_start;  				int dcode;  				for (dcode = 0; dcode < D_CODES; dcode++)  				{  					out_length = (int) (out_length + dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));  				}  				out_length = SupportClass.URShift(out_length' 3);  				if (matches < last_lit / 2 && out_length < in_length / 2)  					return true;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,compress_block,The following statement contains a magic number: if (last_lit != 0)  			{  				do   				{  					dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);  					lc = pending_buf[l_buf + lx] & 0xff; lx++;  					  					if (dist == 0)  					{  						send_code(lc' ltree); // send a literal byte  					}  					else  					{  						// Here' lc is the match length - MIN_MATCH  						code = Tree._length_code[lc];  						  						send_code(code + LITERALS + 1' ltree); // send the length code  						extra = Tree.extra_lbits[code];  						if (extra != 0)  						{  							lc -= Tree.base_length[code];  							send_bits(lc' extra); // send the extra length bits  						}  						dist--; // dist is now the match distance - 1  						code = Tree.d_code(dist);  						  						send_code(code' dtree); // send the distance code  						extra = Tree.extra_dbits[code];  						if (extra != 0)  						{  							dist -= Tree.base_dist[code];  							send_bits(dist' extra); // send the extra distance bits  						}  					} // literal or match pair ?  					  					// Check that the overlay between pending_buf and d_buf+l_buf is ok:  				}  				while (lx < last_lit);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,compress_block,The following statement contains a magic number: if (last_lit != 0)  			{  				do   				{  					dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);  					lc = pending_buf[l_buf + lx] & 0xff; lx++;  					  					if (dist == 0)  					{  						send_code(lc' ltree); // send a literal byte  					}  					else  					{  						// Here' lc is the match length - MIN_MATCH  						code = Tree._length_code[lc];  						  						send_code(code + LITERALS + 1' ltree); // send the length code  						extra = Tree.extra_lbits[code];  						if (extra != 0)  						{  							lc -= Tree.base_length[code];  							send_bits(lc' extra); // send the extra length bits  						}  						dist--; // dist is now the match distance - 1  						code = Tree.d_code(dist);  						  						send_code(code' dtree); // send the distance code  						extra = Tree.extra_dbits[code];  						if (extra != 0)  						{  							dist -= Tree.base_dist[code];  							send_bits(dist' extra); // send the extra distance bits  						}  					} // literal or match pair ?  					  					// Check that the overlay between pending_buf and d_buf+l_buf is ok:  				}  				while (lx < last_lit);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,compress_block,The following statement contains a magic number: if (last_lit != 0)  			{  				do   				{  					dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);  					lc = pending_buf[l_buf + lx] & 0xff; lx++;  					  					if (dist == 0)  					{  						send_code(lc' ltree); // send a literal byte  					}  					else  					{  						// Here' lc is the match length - MIN_MATCH  						code = Tree._length_code[lc];  						  						send_code(code + LITERALS + 1' ltree); // send the length code  						extra = Tree.extra_lbits[code];  						if (extra != 0)  						{  							lc -= Tree.base_length[code];  							send_bits(lc' extra); // send the extra length bits  						}  						dist--; // dist is now the match distance - 1  						code = Tree.d_code(dist);  						  						send_code(code' dtree); // send the distance code  						extra = Tree.extra_dbits[code];  						if (extra != 0)  						{  							dist -= Tree.base_dist[code];  							send_bits(dist' extra); // send the extra distance bits  						}  					} // literal or match pair ?  					  					// Check that the overlay between pending_buf and d_buf+l_buf is ok:  				}  				while (lx < last_lit);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,compress_block,The following statement contains a magic number: last_eob_len = ltree[END_BLOCK * 2 + 1];
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 7)  			{  				bin_freq += dyn_ltree[n * 2]; n++;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 7)  			{  				bin_freq += dyn_ltree[n * 2]; n++;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 128)  			{  				ascii_freq += dyn_ltree[n * 2]; n++;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 128)  			{  				ascii_freq += dyn_ltree[n * 2]; n++;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < LITERALS)  			{  				bin_freq += dyn_ltree[n * 2]; n++;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,set_data_type,The following statement contains a magic number: data_type = (byte) (bin_freq > SupportClass.URShift(ascii_freq' 2)?Z_BINARY:Z_ASCII);
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)  			{  				put_short(bi_buf);  				bi_buf = 0;  				bi_valid = 0;  			}  			else if (bi_valid >= 8)  			{  				put_byte((byte) bi_buf);  				bi_buf = (short) SupportClass.URShift(bi_buf' 8);  				bi_valid -= 8;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)  			{  				put_short(bi_buf);  				bi_buf = 0;  				bi_valid = 0;  			}  			else if (bi_valid >= 8)  			{  				put_byte((byte) bi_buf);  				bi_buf = (short) SupportClass.URShift(bi_buf' 8);  				bi_valid -= 8;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)  			{  				put_short(bi_buf);  				bi_buf = 0;  				bi_valid = 0;  			}  			else if (bi_valid >= 8)  			{  				put_byte((byte) bi_buf);  				bi_buf = (short) SupportClass.URShift(bi_buf' 8);  				bi_valid -= 8;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16)  			{  				put_short(bi_buf);  				bi_buf = 0;  				bi_valid = 0;  			}  			else if (bi_valid >= 8)  			{  				put_byte((byte) bi_buf);  				bi_buf = (short) SupportClass.URShift(bi_buf' 8);  				bi_valid -= 8;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,bi_windup,The following statement contains a magic number: if (bi_valid > 8)  			{  				put_short(bi_buf);  			}  			else if (bi_valid > 0)  			{  				put_byte((byte) bi_buf);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,copy_block,The following statement contains a magic number: last_eob_len = 8;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_stored,The following statement contains a magic number: if (max_block_size > pending_buf_size - 5)  			{  				max_block_size = pending_buf_size - 5;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_stored,The following statement contains a magic number: if (max_block_size > pending_buf_size - 5)  			{  				max_block_size = pending_buf_size - 5;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_stored_block,The following statement contains a magic number: send_bits((STORED_BLOCK << 1) + (eof?1:0)' 3);
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  					set_data_type();  				  				// Construct the literal and distance trees  				l_desc.build_tree(this);  				  				d_desc.build_tree(this);  				  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = build_bl_tree();  				  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = SupportClass.URShift(opt_len + 3 + 7' 3);  				static_lenb = SupportClass.URShift(static_len + 3 + 7' 3);  				  				if (static_lenb <= opt_lenb)  					opt_lenb = static_lenb;  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5; // force a stored block  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  					set_data_type();  				  				// Construct the literal and distance trees  				l_desc.build_tree(this);  				  				d_desc.build_tree(this);  				  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = build_bl_tree();  				  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = SupportClass.URShift(opt_len + 3 + 7' 3);  				static_lenb = SupportClass.URShift(static_len + 3 + 7' 3);  				  				if (static_lenb <= opt_lenb)  					opt_lenb = static_lenb;  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5; // force a stored block  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  					set_data_type();  				  				// Construct the literal and distance trees  				l_desc.build_tree(this);  				  				d_desc.build_tree(this);  				  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = build_bl_tree();  				  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = SupportClass.URShift(opt_len + 3 + 7' 3);  				static_lenb = SupportClass.URShift(static_len + 3 + 7' 3);  				  				if (static_lenb <= opt_lenb)  					opt_lenb = static_lenb;  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5; // force a stored block  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  					set_data_type();  				  				// Construct the literal and distance trees  				l_desc.build_tree(this);  				  				d_desc.build_tree(this);  				  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = build_bl_tree();  				  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = SupportClass.URShift(opt_len + 3 + 7' 3);  				static_lenb = SupportClass.URShift(static_len + 3 + 7' 3);  				  				if (static_lenb <= opt_lenb)  					opt_lenb = static_lenb;  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5; // force a stored block  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  					set_data_type();  				  				// Construct the literal and distance trees  				l_desc.build_tree(this);  				  				d_desc.build_tree(this);  				  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = build_bl_tree();  				  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = SupportClass.URShift(opt_len + 3 + 7' 3);  				static_lenb = SupportClass.URShift(static_len + 3 + 7' 3);  				  				if (static_lenb <= opt_lenb)  					opt_lenb = static_lenb;  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5; // force a stored block  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  					set_data_type();  				  				// Construct the literal and distance trees  				l_desc.build_tree(this);  				  				d_desc.build_tree(this);  				  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = build_bl_tree();  				  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = SupportClass.URShift(opt_len + 3 + 7' 3);  				static_lenb = SupportClass.URShift(static_len + 3 + 7' 3);  				  				if (static_lenb <= opt_lenb)  					opt_lenb = static_lenb;  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5; // force a stored block  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0)  			{  				// Check if the file is ascii or binary  				if (data_type == Z_UNKNOWN)  					set_data_type();  				  				// Construct the literal and distance trees  				l_desc.build_tree(this);  				  				d_desc.build_tree(this);  				  				// At this point' opt_len and static_len are the total bit lengths of  				// the compressed block data' excluding the tree representations.  				  				// Build the bit length tree for the above two trees' and get the index  				// in bl_order of the last bit length code to send.  				max_blindex = build_bl_tree();  				  				// Determine the best encoding. Compute first the block length in bytes  				opt_lenb = SupportClass.URShift(opt_len + 3 + 7' 3);  				static_lenb = SupportClass.URShift(static_len + 3 + 7' 3);  				  				if (static_lenb <= opt_lenb)  					opt_lenb = static_lenb;  			}  			else  			{  				opt_lenb = static_lenb = stored_len + 5; // force a stored block  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != - 1)  			{  				// 4: two words for the lengths  				// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.  				// Otherwise we can't have processed more than WSIZE input bytes since  				// the last block flush' because compression would have been  				// successful. If LIT_BUFSIZE <= WSIZE' it is never too late to  				// transform a block into a stored block.  				_tr_stored_block(buf' stored_len' eof);  			}  			else if (static_lenb == opt_lenb)  			{  				send_bits((STATIC_TREES << 1) + (eof?1:0)' 3);  				compress_block(StaticTree.static_ltree' StaticTree.static_dtree);  			}  			else  			{  				send_bits((DYN_TREES << 1) + (eof?1:0)' 3);  				send_all_trees(l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);  				compress_block(dyn_ltree' dyn_dtree);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != - 1)  			{  				// 4: two words for the lengths  				// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.  				// Otherwise we can't have processed more than WSIZE input bytes since  				// the last block flush' because compression would have been  				// successful. If LIT_BUFSIZE <= WSIZE' it is never too late to  				// transform a block into a stored block.  				_tr_stored_block(buf' stored_len' eof);  			}  			else if (static_lenb == opt_lenb)  			{  				send_bits((STATIC_TREES << 1) + (eof?1:0)' 3);  				compress_block(StaticTree.static_ltree' StaticTree.static_dtree);  			}  			else  			{  				send_bits((DYN_TREES << 1) + (eof?1:0)' 3);  				send_all_trees(l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);  				compress_block(dyn_ltree' dyn_dtree);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != - 1)  			{  				// 4: two words for the lengths  				// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.  				// Otherwise we can't have processed more than WSIZE input bytes since  				// the last block flush' because compression would have been  				// successful. If LIT_BUFSIZE <= WSIZE' it is never too late to  				// transform a block into a stored block.  				_tr_stored_block(buf' stored_len' eof);  			}  			else if (static_lenb == opt_lenb)  			{  				send_bits((STATIC_TREES << 1) + (eof?1:0)' 3);  				compress_block(StaticTree.static_ltree' StaticTree.static_dtree);  			}  			else  			{  				send_bits((DYN_TREES << 1) + (eof?1:0)' 3);  				send_all_trees(l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);  				compress_block(dyn_ltree' dyn_dtree);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_slow,The following statement contains a magic number: while (true)  			{  				// Make sure that we always have enough lookahead' except  				// at the end of the input file. We need MAX_MATCH bytes  				// for the next match' plus MIN_MATCH bytes to insert the  				// string following the next match.  				  				if (lookahead < MIN_LOOKAHEAD)  				{  					fill_window();  					if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH)  					{  						return NeedMore;  					}  					if (lookahead == 0)  						break; // flush the current block  				}  				  				// Insert the string window[strstart .. strstart+2] in the  				// dictionary' and set hash_head to the head of the hash chain:  				  				if (lookahead >= MIN_MATCH)  				{  					ins_h = ((ins_h << hash_shift) ^ (window[strstart + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  					//	prev[strstart&w_mask]=hash_head=head[ins_h];  					hash_head = head[ins_h] & 0xffff;  					prev[strstart & w_mask] = head[ins_h];  					head[ins_h] = (short) strstart;  				}  				  				// Find the longest match' discarding those <= prev_length.  				prev_length = match_length; prev_match = match_start;  				match_length = MIN_MATCH - 1;  				  				if (hash_head != 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD)  				{  					// To simplify the code' we prevent matches with the string  					// of window index 0 (in particular we have to avoid a match  					// of the string with itself at the start of the input file).  					  					if (strategy != Z_HUFFMAN_ONLY)  					{  						match_length = longest_match(hash_head);  					}  					// longest_match() sets match_start  					  					if (match_length <= 5 && (strategy == Z_FILTERED || match_length == MIN_MATCH && strstart - match_start > 4096))  					{  						  						// If prev_match is also MIN_MATCH' match_start is garbage  						// but we will ignore the current match anyway.  						match_length = MIN_MATCH - 1;  					}  				}  				  				// If there was a match at the previous step and the current  				// match is not better' output the previous match:  				if (prev_length >= MIN_MATCH && match_length <= prev_length)  				{  					var max_insert = strstart + lookahead - MIN_MATCH;  					// Do not insert strings in hash table beyond this.  					  					//          check_match(strstart-1' prev_match' prev_length);  					  					bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);  					  					// Insert in hash table all strings up to the end of the match.  					// strstart-1 and strstart are already inserted. If there is not  					// enough lookahead' the last two strings are not inserted in  					// the hash table.  					lookahead -= prev_length - 1;  					prev_length -= 2;  					do   					{  						if (++strstart <= max_insert)  						{  							ins_h = ((ins_h << hash_shift) ^ (window[strstart + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  							//prev[strstart&w_mask]=hash_head=head[ins_h];  							hash_head = head[ins_h] & 0xffff;  							prev[strstart & w_mask] = head[ins_h];  							head[ins_h] = (short) strstart;  						}  					}  					while (--prev_length != 0);  					match_available = 0;  					match_length = MIN_MATCH - 1;  					strstart++;  					  					if (bflush)  					{  						flush_block_only(false);  						if (strm.avail_out == 0)  							return NeedMore;  					}  				}  				else if (match_available != 0)  				{  					  					// If there was no match at the previous position' output a  					// single literal. If there was a match but the current match  					// is longer' truncate the previous match to a single literal.  					  					bflush = _tr_tally(0' window[strstart - 1] & 0xff);  					  					if (bflush)  					{  						flush_block_only(false);  					}  					strstart++;  					lookahead--;  					if (strm.avail_out == 0)  						return NeedMore;  				}  				else  				{  					// There is no previous match to compare with' wait for  					// the next step to decide.  					  					match_available = 1;  					strstart++;  					lookahead--;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_slow,The following statement contains a magic number: while (true)  			{  				// Make sure that we always have enough lookahead' except  				// at the end of the input file. We need MAX_MATCH bytes  				// for the next match' plus MIN_MATCH bytes to insert the  				// string following the next match.  				  				if (lookahead < MIN_LOOKAHEAD)  				{  					fill_window();  					if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH)  					{  						return NeedMore;  					}  					if (lookahead == 0)  						break; // flush the current block  				}  				  				// Insert the string window[strstart .. strstart+2] in the  				// dictionary' and set hash_head to the head of the hash chain:  				  				if (lookahead >= MIN_MATCH)  				{  					ins_h = ((ins_h << hash_shift) ^ (window[strstart + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  					//	prev[strstart&w_mask]=hash_head=head[ins_h];  					hash_head = head[ins_h] & 0xffff;  					prev[strstart & w_mask] = head[ins_h];  					head[ins_h] = (short) strstart;  				}  				  				// Find the longest match' discarding those <= prev_length.  				prev_length = match_length; prev_match = match_start;  				match_length = MIN_MATCH - 1;  				  				if (hash_head != 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD)  				{  					// To simplify the code' we prevent matches with the string  					// of window index 0 (in particular we have to avoid a match  					// of the string with itself at the start of the input file).  					  					if (strategy != Z_HUFFMAN_ONLY)  					{  						match_length = longest_match(hash_head);  					}  					// longest_match() sets match_start  					  					if (match_length <= 5 && (strategy == Z_FILTERED || match_length == MIN_MATCH && strstart - match_start > 4096))  					{  						  						// If prev_match is also MIN_MATCH' match_start is garbage  						// but we will ignore the current match anyway.  						match_length = MIN_MATCH - 1;  					}  				}  				  				// If there was a match at the previous step and the current  				// match is not better' output the previous match:  				if (prev_length >= MIN_MATCH && match_length <= prev_length)  				{  					var max_insert = strstart + lookahead - MIN_MATCH;  					// Do not insert strings in hash table beyond this.  					  					//          check_match(strstart-1' prev_match' prev_length);  					  					bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);  					  					// Insert in hash table all strings up to the end of the match.  					// strstart-1 and strstart are already inserted. If there is not  					// enough lookahead' the last two strings are not inserted in  					// the hash table.  					lookahead -= prev_length - 1;  					prev_length -= 2;  					do   					{  						if (++strstart <= max_insert)  						{  							ins_h = ((ins_h << hash_shift) ^ (window[strstart + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  							//prev[strstart&w_mask]=hash_head=head[ins_h];  							hash_head = head[ins_h] & 0xffff;  							prev[strstart & w_mask] = head[ins_h];  							head[ins_h] = (short) strstart;  						}  					}  					while (--prev_length != 0);  					match_available = 0;  					match_length = MIN_MATCH - 1;  					strstart++;  					  					if (bflush)  					{  						flush_block_only(false);  						if (strm.avail_out == 0)  							return NeedMore;  					}  				}  				else if (match_available != 0)  				{  					  					// If there was no match at the previous position' output a  					// single literal. If there was a match but the current match  					// is longer' truncate the previous match to a single literal.  					  					bflush = _tr_tally(0' window[strstart - 1] & 0xff);  					  					if (bflush)  					{  						flush_block_only(false);  					}  					strstart++;  					lookahead--;  					if (strm.avail_out == 0)  						return NeedMore;  				}  				else  				{  					// There is no previous match to compare with' wait for  					// the next step to decide.  					  					match_available = 1;  					strstart++;  					lookahead--;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate_slow,The following statement contains a magic number: while (true)  			{  				// Make sure that we always have enough lookahead' except  				// at the end of the input file. We need MAX_MATCH bytes  				// for the next match' plus MIN_MATCH bytes to insert the  				// string following the next match.  				  				if (lookahead < MIN_LOOKAHEAD)  				{  					fill_window();  					if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH)  					{  						return NeedMore;  					}  					if (lookahead == 0)  						break; // flush the current block  				}  				  				// Insert the string window[strstart .. strstart+2] in the  				// dictionary' and set hash_head to the head of the hash chain:  				  				if (lookahead >= MIN_MATCH)  				{  					ins_h = ((ins_h << hash_shift) ^ (window[strstart + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  					//	prev[strstart&w_mask]=hash_head=head[ins_h];  					hash_head = head[ins_h] & 0xffff;  					prev[strstart & w_mask] = head[ins_h];  					head[ins_h] = (short) strstart;  				}  				  				// Find the longest match' discarding those <= prev_length.  				prev_length = match_length; prev_match = match_start;  				match_length = MIN_MATCH - 1;  				  				if (hash_head != 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD)  				{  					// To simplify the code' we prevent matches with the string  					// of window index 0 (in particular we have to avoid a match  					// of the string with itself at the start of the input file).  					  					if (strategy != Z_HUFFMAN_ONLY)  					{  						match_length = longest_match(hash_head);  					}  					// longest_match() sets match_start  					  					if (match_length <= 5 && (strategy == Z_FILTERED || match_length == MIN_MATCH && strstart - match_start > 4096))  					{  						  						// If prev_match is also MIN_MATCH' match_start is garbage  						// but we will ignore the current match anyway.  						match_length = MIN_MATCH - 1;  					}  				}  				  				// If there was a match at the previous step and the current  				// match is not better' output the previous match:  				if (prev_length >= MIN_MATCH && match_length <= prev_length)  				{  					var max_insert = strstart + lookahead - MIN_MATCH;  					// Do not insert strings in hash table beyond this.  					  					//          check_match(strstart-1' prev_match' prev_length);  					  					bflush = _tr_tally(strstart - 1 - prev_match' prev_length - MIN_MATCH);  					  					// Insert in hash table all strings up to the end of the match.  					// strstart-1 and strstart are already inserted. If there is not  					// enough lookahead' the last two strings are not inserted in  					// the hash table.  					lookahead -= prev_length - 1;  					prev_length -= 2;  					do   					{  						if (++strstart <= max_insert)  						{  							ins_h = ((ins_h << hash_shift) ^ (window[strstart + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  							//prev[strstart&w_mask]=hash_head=head[ins_h];  							hash_head = head[ins_h] & 0xffff;  							prev[strstart & w_mask] = head[ins_h];  							head[ins_h] = (short) strstart;  						}  					}  					while (--prev_length != 0);  					match_available = 0;  					match_length = MIN_MATCH - 1;  					strstart++;  					  					if (bflush)  					{  						flush_block_only(false);  						if (strm.avail_out == 0)  							return NeedMore;  					}  				}  				else if (match_available != 0)  				{  					  					// If there was no match at the previous position' output a  					// single literal. If there was a match but the current match  					// is longer' truncate the previous match to a single literal.  					  					bflush = _tr_tally(0' window[strstart - 1] & 0xff);  					  					if (bflush)  					{  						flush_block_only(false);  					}  					strstart++;  					lookahead--;  					if (strm.avail_out == 0)  						return NeedMore;  				}  				else  				{  					// There is no previous match to compare with' wait for  					// the next step to decide.  					  					match_available = 1;  					strstart++;  					lookahead--;  				}  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,longest_match,The following statement contains a magic number: if (prev_length >= good_match)  			{  				chain_length >>= 2;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,longest_match,The following statement contains a magic number: do   			{  				match = cur_match;  				  				// Skip to next match if the match length cannot increase  				// or if the match length is less than 2:  				if (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan] || window[++match] != window[scan + 1])  					continue;  				  				// The check at best_len-1 can be removed because it will be made  				// again later. (This heuristic is not always a win.)  				// It is not necessary to compare scan[2] and match[2] since they  				// are always equal when the other bytes match' given that  				// the hash keys are equal and that HASH_BITS >= 8.  				scan += 2; match++;  				  				// We check for insufficient lookahead only every 8th comparison;  				// the 256th check will be made at strstart+258.  				do   				{  				}  				while (window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend);  				  				len = MAX_MATCH - (strend - scan);  				scan = strend - MAX_MATCH;  				  				if (len > best_len)  				{  					match_start = cur_match;  					best_len = len;  					if (len >= nice_match)  						break;  					scan_end1 = window[scan + best_len - 1];  					scan_end = window[scan + best_len];  				}  			}  			while ((cur_match = prev[cur_match & wmask] & 0xffff) > limit && --chain_length != 0);
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: if (level == Z_DEFAULT_COMPRESSION)  				level = 6;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY)  			{  				return Z_STREAM_ERROR;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY)  			{  				return Z_STREAM_ERROR;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY)  			{  				return Z_STREAM_ERROR;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: hash_bits = memLevel + 7;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: window = new byte[w_size * 2];
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: lit_bufsize = 1 << (memLevel + 6);
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: pending_buf = new byte[lit_bufsize * 4];
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: pending_buf_size = lit_bufsize * 4;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateInit2,The following statement contains a magic number: l_buf = (1 + 2) * lit_bufsize;
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateParams,The following statement contains a magic number: if (_level == Z_DEFAULT_COMPRESSION)  			{  				_level = 6;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflateParams,The following statement contains a magic number: if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY)  			{  				return Z_STREAM_ERROR;  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				var level_flags = ((level - 1) & 0xff) >> 1;  				  				if (level_flags > 3)  					level_flags = 3;  				header |= level_flags << 6;  				if (strstart != 0)  					header |= PRESET_DICT;  				header += 31 - header % 31;  				  				status = BUSY_STATE;  				putShortMSB(header);  				  				  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					putShortMSB((int) SupportClass.URShift(strm.adler' 16));  					putShortMSB((int) (strm.adler & 0xffff));  				}  				strm.adler = strm._adler.adler32(0' null' 0' 0);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				var level_flags = ((level - 1) & 0xff) >> 1;  				  				if (level_flags > 3)  					level_flags = 3;  				header |= level_flags << 6;  				if (strstart != 0)  					header |= PRESET_DICT;  				header += 31 - header % 31;  				  				status = BUSY_STATE;  				putShortMSB(header);  				  				  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					putShortMSB((int) SupportClass.URShift(strm.adler' 16));  					putShortMSB((int) (strm.adler & 0xffff));  				}  				strm.adler = strm._adler.adler32(0' null' 0' 0);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				var level_flags = ((level - 1) & 0xff) >> 1;  				  				if (level_flags > 3)  					level_flags = 3;  				header |= level_flags << 6;  				if (strstart != 0)  					header |= PRESET_DICT;  				header += 31 - header % 31;  				  				status = BUSY_STATE;  				putShortMSB(header);  				  				  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					putShortMSB((int) SupportClass.URShift(strm.adler' 16));  					putShortMSB((int) (strm.adler & 0xffff));  				}  				strm.adler = strm._adler.adler32(0' null' 0' 0);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				var level_flags = ((level - 1) & 0xff) >> 1;  				  				if (level_flags > 3)  					level_flags = 3;  				header |= level_flags << 6;  				if (strstart != 0)  					header |= PRESET_DICT;  				header += 31 - header % 31;  				  				status = BUSY_STATE;  				putShortMSB(header);  				  				  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					putShortMSB((int) SupportClass.URShift(strm.adler' 16));  					putShortMSB((int) (strm.adler & 0xffff));  				}  				strm.adler = strm._adler.adler32(0' null' 0' 0);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				var level_flags = ((level - 1) & 0xff) >> 1;  				  				if (level_flags > 3)  					level_flags = 3;  				header |= level_flags << 6;  				if (strstart != 0)  					header |= PRESET_DICT;  				header += 31 - header % 31;  				  				status = BUSY_STATE;  				putShortMSB(header);  				  				  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					putShortMSB((int) SupportClass.URShift(strm.adler' 16));  					putShortMSB((int) (strm.adler & 0xffff));  				}  				strm.adler = strm._adler.adler32(0' null' 0' 0);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				var level_flags = ((level - 1) & 0xff) >> 1;  				  				if (level_flags > 3)  					level_flags = 3;  				header |= level_flags << 6;  				if (strstart != 0)  					header |= PRESET_DICT;  				header += 31 - header % 31;  				  				status = BUSY_STATE;  				putShortMSB(header);  				  				  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					putShortMSB((int) SupportClass.URShift(strm.adler' 16));  					putShortMSB((int) (strm.adler & 0xffff));  				}  				strm.adler = strm._adler.adler32(0' null' 0' 0);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				var level_flags = ((level - 1) & 0xff) >> 1;  				  				if (level_flags > 3)  					level_flags = 3;  				header |= level_flags << 6;  				if (strstart != 0)  					header |= PRESET_DICT;  				header += 31 - header % 31;  				  				status = BUSY_STATE;  				putShortMSB(header);  				  				  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					putShortMSB((int) SupportClass.URShift(strm.adler' 16));  					putShortMSB((int) (strm.adler & 0xffff));  				}  				strm.adler = strm._adler.adler32(0' null' 0' 0);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				var level_flags = ((level - 1) & 0xff) >> 1;  				  				if (level_flags > 3)  					level_flags = 3;  				header |= level_flags << 6;  				if (strstart != 0)  					header |= PRESET_DICT;  				header += 31 - header % 31;  				  				status = BUSY_STATE;  				putShortMSB(header);  				  				  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					putShortMSB((int) SupportClass.URShift(strm.adler' 16));  					putShortMSB((int) (strm.adler & 0xffff));  				}  				strm.adler = strm._adler.adler32(0' null' 0' 0);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE)  			{  				var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  				var level_flags = ((level - 1) & 0xff) >> 1;  				  				if (level_flags > 3)  					level_flags = 3;  				header |= level_flags << 6;  				if (strstart != 0)  					header |= PRESET_DICT;  				header += 31 - header % 31;  				  				status = BUSY_STATE;  				putShortMSB(header);  				  				  				// Save the adler32 of the preset dictionary:  				if (strstart != 0)  				{  					putShortMSB((int) SupportClass.URShift(strm.adler' 16));  					putShortMSB((int) (strm.adler & 0xffff));  				}  				strm.adler = strm._adler.adler32(0' null' 0' 0);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,deflate,The following statement contains a magic number: putShortMSB((int) SupportClass.URShift(strm.adler' 16));
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,Deflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Deflate.cs,Deflate,The following statement contains a magic number: {  				config_table = new Config[10];  				//                         good  lazy  nice  chain  				config_table[0] = new Config(0' 0' 0' 0' STORED);  				config_table[1] = new Config(4' 4' 8' 4' FAST);  				config_table[2] = new Config(4' 5' 16' 8' FAST);  				config_table[3] = new Config(4' 6' 32' 32' FAST);  				  				config_table[4] = new Config(4' 4' 16' 16' SLOW);  				config_table[5] = new Config(8' 16' 32' 32' SLOW);  				config_table[6] = new Config(8' 16' 128' 128' SLOW);  				config_table[7] = new Config(8' 32' 128' 256' SLOW);  				config_table[8] = new Config(32' 128' 258' 1024' SLOW);  				config_table[9] = new Config(32' 258' 258' 4096' SLOW);  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,InfBlocks,The following statement contains a magic number: hufts = new int[MANY * 3];
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					case TYPE:   						  						while (k < 3)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						t = b & 7;  						last = t & 1;  						  						switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  						break;  					  					case LENS:   						  						while (k < 32)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						if ((SupportClass.URShift(~ b' 16) & 0xffff) != (b & 0xffff))  						{  							mode = BAD;  							z.msg = "invalid stored block lengths";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						left = b & 0xffff;  						b = k = 0; // dump bits  						mode = left != 0?STORED:(last != 0?DRY:TYPE);  						break;  					  					case STORED:   						if (n == 0)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						if (m == 0)  						{  							if (q == end && read != 0)  							{  								q = 0; m = q < read?read - q - 1:end - q;  							}  							if (m == 0)  							{  								write = q;  								r = inflate_flush(z' r);  								q = write; m = q < read?read - q - 1:end - q;  								if (q == end && read != 0)  								{  									q = 0; m = q < read?read - q - 1:end - q;  								}  								if (m == 0)  								{  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						t = left;  						if (t > n)  							t = n;  						if (t > m)  							t = m;  						Array.Copy(z.next_in' p' window' q' t);  						p += t; n -= t;  						q += t; m -= t;  						if ((left -= t) != 0)  							break;  						mode = last != 0?DRY:TYPE;  						break;  					  					case TABLE:   						  						while (k < 14)  						{  							if (n != 0)  							{  								r = Z_OK;  							}  							else  							{  								bitb = b; bitk = k;  								z.avail_in = n;  								z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							;  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						table = t = b & 0x3fff;  						if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)  						{  							mode = BAD;  							z.msg = "too many length or distance symbols";  							r = Z_DATA_ERROR;  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  						blens = new int[t];  						  						{  							b = SupportClass.URShift(b' 14); k -= 14;  						}  						  						index = 0;  						mode = BTREE;  						goto case BTREE;  					  					case BTREE:   						while (index < 4 + SupportClass.URShift(table' 10))  						{  							while (k < 3)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							blens[border[index++]] = b & 7;  							  							{  								b = SupportClass.URShift(b' 3); k -= 3;  							}  						}  						  						while (index < 19)  						{  							blens[border[index++]] = 0;  						}  						  						bb[0] = 7;  						t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);  						if (t != Z_OK)  						{  							r = t;  							if (r == Z_DATA_ERROR)  							{  								blens = null;  								mode = BAD;  							}  							  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						  						index = 0;  						mode = DTREE;  						goto case DTREE;  					  					case DTREE:   						while (true)  						{  							t = table;  							if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))  							{  								break;  							}  							  							  							int i' j' c;  							  							t = bb[0];  							  							while (k < t)  							{  								if (n != 0)  								{  									r = Z_OK;  								}  								else  								{  									bitb = b; bitk = k;  									z.avail_in = n;  									z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								;  								n--;  								b |= (z.next_in[p++] & 0xff) << k;  								k += 8;  							}  							  							if (tb[0] == - 1)  							{  								//System.err.println("null...");  							}  							  							t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];  							c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];  							  							if (c < 16)  							{  								b = SupportClass.URShift(b' t); k -= t;  								blens[index++] = c;  							}  							else  							{  								// c == 16..18  								i = c == 18?7:c - 14;  								j = c == 18?11:3;  								  								while (k < t + i)  								{  									if (n != 0)  									{  										r = Z_OK;  									}  									else  									{  										bitb = b; bitk = k;  										z.avail_in = n;  										z.total_in += p - z.next_in_index; z.next_in_index = p;  										write = q;  										return inflate_flush(z' r);  									}  									;  									n--;  									b |= (z.next_in[p++] & 0xff) << k;  									k += 8;  								}  								  								b = SupportClass.URShift(b' t); k -= t;  								  								j += b & inflate_mask[i];  								  								b = SupportClass.URShift(b' i); k -= i;  								  								i = index;  								t = table;  								if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || c == 16 && i < 1)  								{  									blens = null;  									mode = BAD;  									z.msg = "invalid bit length repeat";  									r = Z_DATA_ERROR;  									  									bitb = b; bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									write = q;  									return inflate_flush(z' r);  								}  								  								c = c == 16?blens[i - 1]:0;  								do   								{  									blens[i++] = c;  								}  								while (--j != 0);  								index = i;  							}  						}  						  						tb[0] = - 1;  						{  							var bl = new int[1];  							var bd = new int[1];  							var tl = new int[1];  							var td = new int[1];  							  							  							bl[0] = 9; // must be <= 9 for lookahead assumptions  							bd[0] = 6; // must be <= 9 for lookahead assumptions  							t = table;  							t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  							if (t != Z_OK)  							{  								if (t == Z_DATA_ERROR)  								{  									blens = null;  									mode = BAD;  								}  								r = t;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}  							  							codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);  						}  						blens = null;  						mode = CODES;  						goto case CODES;  					  					case CODES:   						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						  						if ((r = codes.proc(this' z' r)) != Z_STREAM_END)  						{  							return inflate_flush(z' r);  						}  						r = Z_OK;  						codes.free(z);  						  						p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;  						q = write; m = q < read?read - q - 1:end - q;  						  						if (last == 0)  						{  							mode = TYPE;  							break;  						}  						mode = DRY;  						goto case DRY;  					  					case DRY:   						write = q;  						r = inflate_flush(z' r);  						q = write; m = q < read?read - q - 1:end - q;  						if (read != write)  						{  							bitb = b; bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							write = q;  							return inflate_flush(z' r);  						}  						mode = DONE;  						goto case DONE;  					  					case DONE:   						r = Z_STREAM_END;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					case BAD:   						r = Z_DATA_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						bitb = b; bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						write = q;  						return inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,proc,The following statement contains a magic number: while (true)  			{  				switch (mode)  				{  					  					// waiting for "i:"=input' "o:"=output' "x:"=nothing  					case START:  // x: set up for LEN  						if (m >= 258 && n >= 10)  						{  							  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  							  							p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;  							q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  							  							if (r != Z_OK)  							{  								mode = r == Z_STREAM_END?WASH:BADCODE;  								break;  							}  						}  						need = lbits;  						tree = ltree;  						tree_index = ltree_index;  						  						mode = LEN;  						goto case LEN;  					  					case LEN:  // i: get length/literal/eob next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--;  							b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b = SupportClass.URShift(b' tree[tindex + 1]);  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						  						if (e == 0)  						{  							// literal  							lit = tree[tindex + 2];  							mode = LIT;  							break;  						}  						if ((e & 16) != 0)  						{  							// length  							get_Renamed = e & 15;  							len = tree[tindex + 2];  							mode = LENEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						if ((e & 32) != 0)  						{  							// end of block  							mode = WASH;  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid literal/length code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case LENEXT:  // i: getting length extra (have base)  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						len += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						need = dbits;  						tree = dtree;  						tree_index = dtree_index;  						mode = DIST;  						goto case DIST;  					  					case DIST:  // i: get distance next  						j = need;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						tindex = (tree_index + (b & inflate_mask[j])) * 3;  						  						b >>= tree[tindex + 1];  						k -= tree[tindex + 1];  						  						e = tree[tindex];  						if ((e & 16) != 0)  						{  							// distance  							get_Renamed = e & 15;  							dist = tree[tindex + 2];  							mode = DISTEXT;  							break;  						}  						if ((e & 64) == 0)  						{  							// next table  							need = e;  							tree_index = tindex / 3 + tree[tindex + 2];  							break;  						}  						mode = BADCODE; // invalid code  						z.msg = "invalid distance code";  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case DISTEXT:  // i: getting distance extra  						j = get_Renamed;  						  						while (k < j)  						{  							if (n != 0)  								r = Z_OK;  							else  							{  								  								s.bitb = b; s.bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								s.write = q;  								return s.inflate_flush(z' r);  							}  							n--; b |= (z.next_in[p++] & 0xff) << k;  							k += 8;  						}  						  						dist += b & inflate_mask[j];  						  						b >>= j;  						k -= j;  						  						mode = COPY;  						goto case COPY;  					  					case COPY:  // o: copying bytes in window' waiting for space  						f = q - dist;  						while (f < 0)  						{  							// modulo window size-"while" instead  							f += s.end; // of "if" handles invalid distances  						}  						while (len != 0)  						{  							  							if (m == 0)  							{  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.write = q; r = s.inflate_flush(z' r);  									q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  									  									if (q == s.end && s.read != 0)  									{  										q = 0; m = q < s.read?s.read - q - 1:s.end - q;  									}  									  									if (m == 0)  									{  										s.bitb = b; s.bitk = k;  										z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  										s.write = q;  										return s.inflate_flush(z' r);  									}  								}  							}  							  							s.window[q++] = s.window[f++]; m--;  							  							if (f == s.end)  								f = 0;  							len--;  						}  						mode = START;  						break;  					  					case LIT:  // o: got literal' waiting for output space  						if (m == 0)  						{  							if (q == s.end && s.read != 0)  							{  								q = 0; m = q < s.read?s.read - q - 1:s.end - q;  							}  							if (m == 0)  							{  								s.write = q; r = s.inflate_flush(z' r);  								q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  								  								if (q == s.end && s.read != 0)  								{  									q = 0; m = q < s.read?s.read - q - 1:s.end - q;  								}  								if (m == 0)  								{  									s.bitb = b; s.bitk = k;  									z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  									s.write = q;  									return s.inflate_flush(z' r);  								}  							}  						}  						r = Z_OK;  						  						s.window[q++] = (byte) lit; m--;  						  						mode = START;  						break;  					  					case WASH:  // o: got eob' possibly more output  						if (k > 7)  						{  							// return unused byte' if any  							k -= 8;  							n++;  							p--; // can always return one  						}  						  						s.write = q; r = s.inflate_flush(z' r);  						q = s.write; m = q < s.read?s.read - q - 1:s.end - q;  						  						if (s.read != s.write)  						{  							s.bitb = b; s.bitk = k;  							z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  							s.write = q;  							return s.inflate_flush(z' r);  						}  						mode = END;  						goto case END;  					  					case END:   						r = Z_STREAM_END;  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					case BADCODE:  // x: got error  						  						r = Z_DATA_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  					  					default:   						r = Z_STREAM_ERROR;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						return s.inflate_flush(z' r);  					  				}  			}
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: do   			{  				// assume called with m >= 258 && n >= 10  				// get literal/length code  				while (k < 20)  				{  					// max bits for literal/length code  					n--;  					b |= (z.next_in[p++] & 0xff) << k; k += 8;  				}  				  				t = b & ml;  				tp = tl;  				tp_index = tl_index;  				if ((e = tp[(tp_index + t) * 3]) == 0)  				{  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  					m--;  					continue;  				}  				do   				{  					  					b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  					  					if ((e & 16) != 0)  					{  						e &= 15;  						c = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  						  						b >>= e; k -= e;  						  						// decode distance base of block to copy  						while (k < 15)  						{  							// max bits for distance code  							n--;  							b |= (z.next_in[p++] & 0xff) << k; k += 8;  						}  						  						t = b & md;  						tp = td;  						tp_index = td_index;  						e = tp[(tp_index + t) * 3];  						  						do   						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							if ((e & 16) != 0)  							{  								// get extra bits to add to distance base  								e &= 15;  								while (k < e)  								{  									// get extra bits (up to 13)  									n--;  									b |= (z.next_in[p++] & 0xff) << k; k += 8;  								}  								  								d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);  								  								b >>= e; k -= e;  								  								// do the copy  								m -= c;  								if (q >= d)  								{  									// offset before dest  									//  just copy  									r = q - d;  									if (q - r > 0 && 2 > q - r)  									{  										s.window[q++] = s.window[r++]; c--; // minimum count is three'  										s.window[q++] = s.window[r++]; c--; // so unroll loop a little  									}  									else  									{  										Array.Copy(s.window' r' s.window' q' 2);  										q += 2; r += 2; c -= 2;  									}  								}  								else  								{  									// else offset after destination  									r = q - d;  									do   									{  										r += s.end; // force pointer in window  									}  									while (r < 0); // covers invalid distances  									e = s.end - r;  									if (c > e)  									{  										// if source crosses'  										c -= e; // wrapped copy  										if (q - r > 0 && e > q - r)  										{  											do   											{  												s.window[q++] = s.window[r++];  											}  											while (--e != 0);  										}  										else  										{  											Array.Copy(s.window' r' s.window' q' e);  											q += e; r += e; e = 0;  										}  										r = 0; // copy rest from start of window  									}  								}  								  								// copy all or what's left  								if (q - r > 0 && c > q - r)  								{  									do   									{  										s.window[q++] = s.window[r++];  									}  									while (--c != 0);  								}  								else  								{  									Array.Copy(s.window' r' s.window' q' c);  									q += c; r += c; c = 0;  								}  								break;  							}  						    if ((e & 64) == 0)  						    {  						        t += tp[(tp_index + t) * 3 + 2];  						        t += b & inflate_mask[e];  						        e = tp[(tp_index + t) * 3];  						    }  						    else  						    {  						        z.msg = "invalid distance code";  								  						        c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  								  						        s.bitb = b; s.bitk = k;  						        z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						        s.write = q;  								  						        return Z_DATA_ERROR;  						    }  						}  						while (true);  						break;  					}  					  					if ((e & 64) == 0)  					{  						t += tp[(tp_index + t) * 3 + 2];  						t += b & inflate_mask[e];  						if ((e = tp[(tp_index + t) * 3]) == 0)  						{  							  							b >>= tp[(tp_index + t) * 3 + 1]; k -= tp[(tp_index + t) * 3 + 1];  							  							s.window[q++] = (byte) tp[(tp_index + t) * 3 + 2];  							m--;  							break;  						}  					}  					else if ((e & 32) != 0)  					{  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_STREAM_END;  					}  					else  					{  						z.msg = "invalid literal/length code";  						  						c = z.avail_in - n; c = k >> 3 < c?k >> 3:c; n += c; p -= c; k -= c << 3;  						  						s.bitb = b; s.bitk = k;  						z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  						s.write = q;  						  						return Z_DATA_ERROR;  					}  				}  				while (true);  			}  			while (m >= 258 && n >= 10);
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = k >> 3 < c?k >> 3:c;
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = k >> 3 < c?k >> 3:c;
Magic Number,VncSharp.zlib.NET,InfCodes,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= c << 3;
Magic Number,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflateInit,The following statement contains a magic number: if (w < 8 || w > 15)  			{  				inflateEnd(z);  				return Z_STREAM_ERROR;  			}
Magic Number,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflateInit,The following statement contains a magic number: if (w < 8 || w > 15)  			{  				inflateEnd(z);  				return Z_STREAM_ERROR;  			}
Magic Number,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflate,The following statement contains a magic number: while (true)  			{  				//System.out.println("mode: "+z.istate.mode);  				switch (z.istate.mode)  				{  					  					case METHOD:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)  						{  							z.istate.mode = BAD;  							z.msg = "unknown compression method";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						if ((z.istate.method >> 4) + 8 > z.istate.wbits)  						{  							z.istate.mode = BAD;  							z.msg = "invalid window size";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						z.istate.mode = FLAG;  						goto case FLAG;  					  					case FLAG:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						b = z.next_in[z.next_in_index++] & 0xff;  						  						if (((z.istate.method << 8) + b) % 31 != 0)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect header check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						if ((b & PRESET_DICT) == 0)  						{  							z.istate.mode = BLOCKS;  							break;  						}  						z.istate.mode = DICT4;  						goto case DICT4;  					  					case DICT4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = DICT3;  						goto case DICT3;  					  					case DICT3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = DICT2;  						goto case DICT2;  					  					case DICT2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = DICT1;  						goto case DICT1;  					  					case DICT1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						z.adler = z.istate.need;  						z.istate.mode = DICT0;  						return Z_NEED_DICT;  					  					case DICT0:   						z.istate.mode = BAD;  						z.msg = "need dictionary";  						z.istate.marker = 0; // can try inflateSync  						return Z_STREAM_ERROR;  					  					case BLOCKS:   						  						r = z.istate.blocks.proc(z' r);  						if (r == Z_DATA_ERROR)  						{  							z.istate.mode = BAD;  							z.istate.marker = 0; // can try inflateSync  							break;  						}  						if (r == Z_OK)  						{  							r = f;  						}  						if (r != Z_STREAM_END)  						{  							return r;  						}  						r = f;  						z.istate.blocks.reset(z' z.istate.was);  						if (z.istate.nowrap != 0)  						{  							z.istate.mode = DONE;  							break;  						}  						z.istate.mode = CHECK4;  						goto case CHECK4;  					  					case CHECK4:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int) 0xff000000L);  						z.istate.mode = CHECK3;  						goto case CHECK3;  					  					case CHECK3:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L;  						z.istate.mode = CHECK2;  						goto case CHECK2;  					  					case CHECK2:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += ((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L;  						z.istate.mode = CHECK1;  						goto case CHECK1;  					  					case CHECK1:   						  						if (z.avail_in == 0)  							return r; r = f;  						  						z.avail_in--; z.total_in++;  						z.istate.need += z.next_in[z.next_in_index++] & 0xffL;  						  						if ((int) z.istate.was[0] != (int) z.istate.need)  						{  							z.istate.mode = BAD;  							z.msg = "incorrect data check";  							z.istate.marker = 5; // can't try inflateSync  							break;  						}  						  						z.istate.mode = DONE;  						goto case DONE;  					  					case DONE:   						return Z_STREAM_END;  					  					case BAD:   						return Z_DATA_ERROR;  					  					default:   						return Z_STREAM_ERROR;  					  				}  			}
Magic Number,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflateSync,The following statement contains a magic number: while (n != 0 && m < 4)  			{  				if (z.next_in[p] == mark[m])  				{  					m++;  				}  				else if (z.next_in[p] != 0)  				{  					m = 0;  				}  				else  				{  					m = 4 - m;  				}  				p++; n--;  			}
Magic Number,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflateSync,The following statement contains a magic number: while (n != 0 && m < 4)  			{  				if (z.next_in[p] == mark[m])  				{  					m++;  				}  				else if (z.next_in[p] != 0)  				{  					m = 0;  				}  				else  				{  					m = 4 - m;  				}  				p++; n--;  			}
Magic Number,VncSharp.zlib.NET,Inflate,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Inflate.cs,inflateSync,The following statement contains a magic number: if (m != 4)  			{  				return Z_DATA_ERROR;  			}
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: var r = new int[3];
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: xp = 2;
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = z > l?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1; // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' w - l);  							r[2] = q - u[h - 1] - j; // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = z > l?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1; // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' w - l);  							r[2] = q - u[h - 1] - j; // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = z > l?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1; // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' w - l);  							r[2] = q - u[h - 1] - j; // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = z > l?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1; // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' w - l);  							r[2] = q - u[h - 1] - j; // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = z > l?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1; // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' w - l);  							r[2] = q - u[h - 1] - j; // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = z > l?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1; // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' w - l);  							r[2] = q - u[h - 1] - j; // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = z > l?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1; // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' w - l);  							r[2] = q - u[h - 1] - j; // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = z > l?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1; // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' w - l);  							r[2] = q - u[h - 1] - j; // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = z > l?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1; // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' w - l);  							r[2] = q - u[h - 1] - j; // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = z > l?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1; // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' w - l);  							r[2] = q - u[h - 1] - j; // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = z > l?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1; // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' w - l);  							r[2] = q - u[h - 1] - j; // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = z > l?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1; // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' w - l);  							r[2] = q - u[h - 1] - j; // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = z > l?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1; // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' w - l);  							r[2] = q - u[h - 1] - j; // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++)  			{  				a = c[k];  				while (a-- != 0)  				{  					// here i is the Huffman code of length k bits for value *p  					// make tables up to required level  					while (k > w + l)  					{  						h++;  						w += l; // previous table always l bits  						// compute minimum size table less than or equal to l bits  						z = g - w;  						z = z > l?l:z; // table size upper limit  						if ((f = 1 << (j = k - w)) > a + 1)  						{  							// try a k-w bit table  							// too few codes for k-w bit table  							f -= a + 1; // deduct codes from patterns left  							xp = k;  							if (j < z)  							{  								while (++j < z)  								{  									// try smaller tables up to z bits  									if ((f <<= 1) <= c[++xp])  										break; // enough codes to use up j bits  									f -= c[xp]; // else deduct codes from patterns  								}  							}  						}  						z = 1 << j; // table entries for j-bit table  						  						// allocate new table  						if (hn[0] + z > MANY)  						// (note: doesn't matter for fixed)  							return Z_DATA_ERROR; // overflow of MANY  						u[h] = q = hn[0]; // DEBUG  						hn[0] += z;  						  						// connect to last table' if there is one  						if (h != 0)  						{  							x[h] = i; // save pattern for backing up  							r[0] = (byte) j; // bits in this table  							r[1] = (byte) l; // bits to dump before this table  							j = SupportClass.URShift(i' w - l);  							r[2] = q - u[h - 1] - j; // offset to this table  							Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3); // connect to last table  						}  						else  						{  							t[0] = q; // first table is returned result  						}  					}  					  					// set up table entry in r  					r[1] = (byte) (k - w);  					if (p >= n)  					{  						r[0] = 128 + 64; // out of values--invalid code  					}  					else if (v[p] < s)  					{  						r[0] = (byte) (v[p] < 256?0:32 + 64); // 256 is end-of-block  						r[2] = v[p++]; // simple code is just the value  					}  					else  					{  						r[0] = (byte) (e[v[p] - s] + 16 + 64); // non-simple--look up in lists  						r[2] = d[v[p++] - s];  					}  					  					// fill code-like entries with r  					f = 1 << (k - w);  					for (j = SupportClass.URShift(i' w); j < z; j += f)  					{  						Array.Copy(r' 0' hp' (q + j) * 3' 3);  					}  					  					// backwards increment the k-bit code i  					for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift(j' 1))  					{  						i ^= j;  					}  					i ^= j;  					  					// backup over finished tables  					mask = (1 << w) - 1; // needed on HP' cc -O bug  					while ((i & mask) != x[h])  					{  						h--; // don't need to update q  						w -= l;  						mask = (1 << w) - 1;  					}  				}  			}
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: var v = new int[19];
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: var v = new int[288];
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: r = huft_build(c' 0' nl' 257' cplens' cplext' tl' bl' hp' hn' v);
Magic Number,VncSharp.zlib.NET,InfTree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: if (r != Z_OK || bd[0] == 0 && nl > 257)  			{  				if (r == Z_DATA_ERROR)  				{  					z.msg = "oversubscribed distance tree";  				}  				else if (r == Z_BUF_ERROR)  				{  					z.msg = "incomplete distance tree";  					r = Z_DATA_ERROR;  				}  				else if (r != Z_MEM_ERROR)  				{  					z.msg = "empty distance tree with lengths";  					r = Z_DATA_ERROR;  				}  				return r;  			}
Magic Number,VncSharp.zlib.NET,SupportClass,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\SupportClass.cs,URShift,The following statement contains a magic number: return (number >> bits) + (2 << ~bits);
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,d_code,The following statement contains a magic number: return dist < 256?_dist_code[dist]:_dist_code[256 + SupportClass.URShift(dist' 7)];
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,d_code,The following statement contains a magic number: return dist < 256?_dist_code[dist]:_dist_code[256 + SupportClass.URShift(dist' 7)];
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,d_code,The following statement contains a magic number: return dist < 256?_dist_code[dist]:_dist_code[256 + SupportClass.URShift(dist' 7)];
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[s.heap[s.heap_max] * 2 + 1] = 0;
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)  			{  				n = s.heap[h];  				bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;  				if (bits > max_length)  				{  					bits = max_length; overflow++;  				}  				tree[n * 2 + 1] = (short) bits;  				// We overwrite tree[n*2+1] which is no longer needed  				  				if (n > max_code)  					continue; // not a leaf node  				  				s.bl_count[bits]++;  				xbits = 0;  				if (n >= base_Renamed)  					xbits = extra[n - base_Renamed];  				f = tree[n * 2];  				s.opt_len += f * (bits + xbits);  				if (stree != null)  					s.static_len += f * (stree[n * 2 + 1] + xbits);  			}
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)  			{  				n = s.heap[h];  				bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;  				if (bits > max_length)  				{  					bits = max_length; overflow++;  				}  				tree[n * 2 + 1] = (short) bits;  				// We overwrite tree[n*2+1] which is no longer needed  				  				if (n > max_code)  					continue; // not a leaf node  				  				s.bl_count[bits]++;  				xbits = 0;  				if (n >= base_Renamed)  					xbits = extra[n - base_Renamed];  				f = tree[n * 2];  				s.opt_len += f * (bits + xbits);  				if (stree != null)  					s.static_len += f * (stree[n * 2 + 1] + xbits);  			}
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)  			{  				n = s.heap[h];  				bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;  				if (bits > max_length)  				{  					bits = max_length; overflow++;  				}  				tree[n * 2 + 1] = (short) bits;  				// We overwrite tree[n*2+1] which is no longer needed  				  				if (n > max_code)  					continue; // not a leaf node  				  				s.bl_count[bits]++;  				xbits = 0;  				if (n >= base_Renamed)  					xbits = extra[n - base_Renamed];  				f = tree[n * 2];  				s.opt_len += f * (bits + xbits);  				if (stree != null)  					s.static_len += f * (stree[n * 2 + 1] + xbits);  			}
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)  			{  				n = s.heap[h];  				bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;  				if (bits > max_length)  				{  					bits = max_length; overflow++;  				}  				tree[n * 2 + 1] = (short) bits;  				// We overwrite tree[n*2+1] which is no longer needed  				  				if (n > max_code)  					continue; // not a leaf node  				  				s.bl_count[bits]++;  				xbits = 0;  				if (n >= base_Renamed)  					xbits = extra[n - base_Renamed];  				f = tree[n * 2];  				s.opt_len += f * (bits + xbits);  				if (stree != null)  					s.static_len += f * (stree[n * 2 + 1] + xbits);  			}
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++)  			{  				n = s.heap[h];  				bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;  				if (bits > max_length)  				{  					bits = max_length; overflow++;  				}  				tree[n * 2 + 1] = (short) bits;  				// We overwrite tree[n*2+1] which is no longer needed  				  				if (n > max_code)  					continue; // not a leaf node  				  				s.bl_count[bits]++;  				xbits = 0;  				if (n >= base_Renamed)  					xbits = extra[n - base_Renamed];  				f = tree[n * 2];  				s.opt_len += f * (bits + xbits);  				if (stree != null)  					s.static_len += f * (stree[n * 2 + 1] + xbits);  			}
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: do   			{  				bits = max_length - 1;  				while (s.bl_count[bits] == 0)  					bits--;  				s.bl_count[bits]--; // move one leaf down the tree  				s.bl_count[bits + 1] = (short) (s.bl_count[bits + 1] + 2); // move one overflow item as its brother  				s.bl_count[max_length]--;  				// The brother of the overflow item also moves one step up'  				// but this does not affect bl_count[max_length]  				overflow -= 2;  			}  			while (overflow > 0);
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: do   			{  				bits = max_length - 1;  				while (s.bl_count[bits] == 0)  					bits--;  				s.bl_count[bits]--; // move one leaf down the tree  				s.bl_count[bits + 1] = (short) (s.bl_count[bits + 1] + 2); // move one overflow item as its brother  				s.bl_count[max_length]--;  				// The brother of the overflow item also moves one step up'  				// but this does not affect bl_count[max_length]  				overflow -= 2;  			}  			while (overflow > 0);
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)  			{  				n = s.bl_count[bits];  				while (n != 0)  				{  					m = s.heap[--h];  					if (m > max_code)  						continue;  					if (tree[m * 2 + 1] != bits)  					{  						s.opt_len = (int) (s.opt_len + (bits - (long) tree[m * 2 + 1]) * tree[m * 2]);  						tree[m * 2 + 1] = (short) bits;  					}  					n--;  				}  			}
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)  			{  				n = s.bl_count[bits];  				while (n != 0)  				{  					m = s.heap[--h];  					if (m > max_code)  						continue;  					if (tree[m * 2 + 1] != bits)  					{  						s.opt_len = (int) (s.opt_len + (bits - (long) tree[m * 2 + 1]) * tree[m * 2]);  						tree[m * 2 + 1] = (short) bits;  					}  					n--;  				}  			}
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)  			{  				n = s.bl_count[bits];  				while (n != 0)  				{  					m = s.heap[--h];  					if (m > max_code)  						continue;  					if (tree[m * 2 + 1] != bits)  					{  						s.opt_len = (int) (s.opt_len + (bits - (long) tree[m * 2 + 1]) * tree[m * 2]);  						tree[m * 2 + 1] = (short) bits;  					}  					n--;  				}  			}
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--)  			{  				n = s.bl_count[bits];  				while (n != 0)  				{  					m = s.heap[--h];  					if (m > max_code)  						continue;  					if (tree[m * 2 + 1] != bits)  					{  						s.opt_len = (int) (s.opt_len + (bits - (long) tree[m * 2 + 1]) * tree[m * 2]);  						tree[m * 2 + 1] = (short) bits;  					}  					n--;  				}  			}
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: for (n = 0; n < elems; n++)  			{  				if (tree[n * 2] != 0)  				{  					s.heap[++s.heap_len] = max_code = n;  					s.depth[n] = 0;  				}  				else  				{  					tree[n * 2 + 1] = 0;  				}  			}
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: for (n = 0; n < elems; n++)  			{  				if (tree[n * 2] != 0)  				{  					s.heap[++s.heap_len] = max_code = n;  					s.depth[n] = 0;  				}  				else  				{  					tree[n * 2 + 1] = 0;  				}  			}
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)  			{  				node = s.heap[++s.heap_len] = max_code < 2?++max_code:0;  				tree[node * 2] = 1;  				s.depth[node] = 0;  				s.opt_len--;  				if (stree != null)  					s.static_len -= stree[node * 2 + 1];  				// node is 0 or 1 so it does not have extra bits  			}
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)  			{  				node = s.heap[++s.heap_len] = max_code < 2?++max_code:0;  				tree[node * 2] = 1;  				s.depth[node] = 0;  				s.opt_len--;  				if (stree != null)  					s.static_len -= stree[node * 2 + 1];  				// node is 0 or 1 so it does not have extra bits  			}
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)  			{  				node = s.heap[++s.heap_len] = max_code < 2?++max_code:0;  				tree[node * 2] = 1;  				s.depth[node] = 0;  				s.opt_len--;  				if (stree != null)  					s.static_len -= stree[node * 2 + 1];  				// node is 0 or 1 so it does not have extra bits  			}
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2)  			{  				node = s.heap[++s.heap_len] = max_code < 2?++max_code:0;  				tree[node * 2] = 1;  				s.depth[node] = 0;  				s.opt_len--;  				if (stree != null)  					s.static_len -= stree[node * 2 + 1];  				// node is 0 or 1 so it does not have extra bits  			}
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: for (n = s.heap_len / 2; n >= 1; n--)  				s.pqdownheap(tree' n);
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: do   			{  				// n = node of least frequency  				n = s.heap[1];  				s.heap[1] = s.heap[s.heap_len--];  				s.pqdownheap(tree' 1);  				m = s.heap[1]; // m = node of next least frequency  				  				s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency  				s.heap[--s.heap_max] = m;  				  				// Create a new node father of n and m  				tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);  				s.depth[node] = (byte) (Math.Max(s.depth[n]' s.depth[m]) + 1);  				tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;  				  				// and insert the new node in the heap  				s.heap[1] = node++;  				s.pqdownheap(tree' 1);  			}  			while (s.heap_len >= 2);
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: do   			{  				// n = node of least frequency  				n = s.heap[1];  				s.heap[1] = s.heap[s.heap_len--];  				s.pqdownheap(tree' 1);  				m = s.heap[1]; // m = node of next least frequency  				  				s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency  				s.heap[--s.heap_max] = m;  				  				// Create a new node father of n and m  				tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);  				s.depth[node] = (byte) (Math.Max(s.depth[n]' s.depth[m]) + 1);  				tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;  				  				// and insert the new node in the heap  				s.heap[1] = node++;  				s.pqdownheap(tree' 1);  			}  			while (s.heap_len >= 2);
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: do   			{  				// n = node of least frequency  				n = s.heap[1];  				s.heap[1] = s.heap[s.heap_len--];  				s.pqdownheap(tree' 1);  				m = s.heap[1]; // m = node of next least frequency  				  				s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency  				s.heap[--s.heap_max] = m;  				  				// Create a new node father of n and m  				tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);  				s.depth[node] = (byte) (Math.Max(s.depth[n]' s.depth[m]) + 1);  				tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;  				  				// and insert the new node in the heap  				s.heap[1] = node++;  				s.pqdownheap(tree' 1);  			}  			while (s.heap_len >= 2);
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: do   			{  				// n = node of least frequency  				n = s.heap[1];  				s.heap[1] = s.heap[s.heap_len--];  				s.pqdownheap(tree' 1);  				m = s.heap[1]; // m = node of next least frequency  				  				s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency  				s.heap[--s.heap_max] = m;  				  				// Create a new node father of n and m  				tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);  				s.depth[node] = (byte) (Math.Max(s.depth[n]' s.depth[m]) + 1);  				tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;  				  				// and insert the new node in the heap  				s.heap[1] = node++;  				s.pqdownheap(tree' 1);  			}  			while (s.heap_len >= 2);
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: do   			{  				// n = node of least frequency  				n = s.heap[1];  				s.heap[1] = s.heap[s.heap_len--];  				s.pqdownheap(tree' 1);  				m = s.heap[1]; // m = node of next least frequency  				  				s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency  				s.heap[--s.heap_max] = m;  				  				// Create a new node father of n and m  				tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);  				s.depth[node] = (byte) (Math.Max(s.depth[n]' s.depth[m]) + 1);  				tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;  				  				// and insert the new node in the heap  				s.heap[1] = node++;  				s.pqdownheap(tree' 1);  			}  			while (s.heap_len >= 2);
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,build_tree,The following statement contains a magic number: do   			{  				// n = node of least frequency  				n = s.heap[1];  				s.heap[1] = s.heap[s.heap_len--];  				s.pqdownheap(tree' 1);  				m = s.heap[1]; // m = node of next least frequency  				  				s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency  				s.heap[--s.heap_max] = m;  				  				// Create a new node father of n and m  				tree[node * 2] = (short) (tree[n * 2] + tree[m * 2]);  				s.depth[node] = (byte) (Math.Max(s.depth[n]' s.depth[m]) + 1);  				tree[n * 2 + 1] = tree[m * 2 + 1] = (short) node;  				  				// and insert the new node in the heap  				s.heap[1] = node++;  				s.pqdownheap(tree' 1);  			}  			while (s.heap_len >= 2);
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				int len = tree[n * 2 + 1];  				if (len == 0)  					continue;  				// Now reverse the bits  				tree[n * 2] = (short) bi_reverse(next_code[len]++' len);  			}
Magic Number,VncSharp.zlib.NET,Tree,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\Tree.cs,gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++)  			{  				int len = tree[n * 2 + 1];  				if (len == 0)  					continue;  				// Now reverse the bits  				tree[n * 2] = (short) bi_reverse(next_code[len]++' len);  			}
Magic Number,VncSharp.zlib.NET,ZInputStream,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\ZInputStream.cs,skip,The following statement contains a magic number: var len = 512;
Missing Default,VncSharp,KeyboardHook,C:\repos\humphd_VncSharp\VncSharp\KeyboardHook.cs,LowLevelKeyboardProc,The following switch statement is missing a default case: switch (wParamInt)              {                  case NativeMethods.WM_KEYDOWN:                  case NativeMethods.WM_SYSKEYDOWN:                  case NativeMethods.WM_KEYUP:                  case NativeMethods.WM_SYSKEYUP:                      result = OnKey(wParamInt' lParam);                      break;              }
Missing Default,VncSharp,RemoteDesktop,C:\repos\humphd_VncSharp\VncSharp\RemoteDesktop.cs,SendSpecialKeys,The following switch statement is missing a default case: switch (keys)              {                  case SpecialKeys.Ctrl:                      PressKeys(new uint[] {0xffe3}' release); // CTRL' but don't release                      break;                  case SpecialKeys.Alt:                      PressKeys(new uint[] {0xffe9}' release); // ALT' but don't release                      break;                  case SpecialKeys.CtrlAltDel:                      PressKeys(new uint[] {0xffe3' 0xffe9' 0xffff}' release); // CTRL' ALT' DEL                      break;                  case SpecialKeys.AltF4:                      PressKeys(new uint[] {0xffe9' 0xffc1}' release); // ALT' F4                      break;                  case SpecialKeys.CtrlEsc:                      PressKeys(new uint[] {0xffe3' 0xff1b}' release); // CTRL' ESC                      break;                  // TODO: are there more I should support???              }
Missing Default,VncSharp,RfbProtocol,C:\repos\humphd_VncSharp\VncSharp\RfbProtocol.cs,ReadProtocolVersion,The following switch statement is missing a default case: switch (b[10]) {  					case 0x33:   					case 0x36:	// BUG FIX: pass 3.3 for 3.6 to allow UltraVNC to work' thanks to Steve Bostedor.  						verMinor = 3;  						break;  					case 0x37:  						verMinor = 7;  						break;  					case 0x38:  						verMinor = 8;  						break;  					case 0x39:  // BUG FIX: Apple reports 3.889  						// According to the RealVNC mailing list' Apple is really using 3.3   						// (see http://www.mail-archive.com/vnc-list@realvnc.com/msg23615.html).  I've tested with  						// both 3.3 and 3.8' and they both seem to work (I obviously haven't hit the issues others have).  						// Because 3.8 seems to work' I'm leaving that' but it might be necessary to use 3.3 in future.  						verMinor = 8;  						break;  				}
Missing Default,VncSharp,VncClient,C:\repos\humphd_VncSharp\VncSharp\VncClient.cs,GetRfbUpdates,The following switch statement is missing a default case: switch (rfb.ReadServerMessageType()) {                          case RfbProtocol.FRAMEBUFFER_UPDATE:                              var rectangles = rfb.ReadFramebufferUpdate();                                if (CheckIfThreadDone())                                  break;                                // TODO: consider gathering all update rectangles in a batch and *then* posting the event back to the main thread.                              for (var i = 0; i < rectangles; ++i) {                                  // Get the update rectangle's info                                  rfb.ReadFramebufferUpdateRectHeader(out Rectangle rectangle' out int enc);                                    // Build a derived EncodedRectangle type and pull-down all the pixel info                                  var er = factory.Build(rectangle' enc);                                  er.Decode();                                    // Let the UI know that an updated rectangle is available' but check                                  // to see if the user closed things down first.                                  if (CheckIfThreadDone() || VncUpdate == null) continue;                                  var e = new VncEventArgs(er);                                    // In order to play nicely with WinForms controls' we do a check here to                                   // see if it is necessary to synchronize this event with the UI thread.                                  var control = VncUpdate.Target as Control;                                  if (control != null) {                                      control.Invoke(VncUpdate' this' e);                                  } else {                                      // Target is not a WinForms control' so do it on this thread...                                      VncUpdate(this' new VncEventArgs(er));                                  }                              }                              break;                          case RfbProtocol.BELL:                              Beep();                              break;                          case RfbProtocol.SERVER_CUT_TEXT:                              if (CheckIfThreadDone())                                  break;                              // TODO: This is invasive' should there be a bool property allowing this message to be ignored?                              Clipboard.SetDataObject(rfb.ReadServerCutText().Replace("\n"' Environment.NewLine)' true);                              OnServerCutText();                              break;                          case RfbProtocol.SET_COLOUR_MAP_ENTRIES:  							rfb.ReadColourMapEntry();                              break;                      }
Missing Default,VncSharp.zlib.NET,InfBlocks,C:\repos\humphd_VncSharp\VncSharp\zlib.NET\InfBlocks.cs,proc,The following switch statement is missing a default case: switch (SupportClass.URShift(t' 1))  						{  							  							case 0:  // stored   								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								t = k & 7; // go to byte boundary  								  								{  									b = SupportClass.URShift(b' t); k -= t;  								}  								mode = LENS; // get length of stored block  								break;  							  							case 1:  // fixed  								{  									var bl = new int[1];  									var bd = new int[1];  									var tl = new int[1][];  									var td = new int[1][];  									  									InfTree.inflate_trees_fixed(bl' bd' tl' td' z);  									codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);  								}  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = CODES;  								break;  							  							case 2:  // dynamic  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								  								mode = TABLE;  								break;  							  							case 3:  // illegal  								  								{  									b = SupportClass.URShift(b' 3); k -= 3;  								}  								mode = BAD;  								z.msg = "invalid block type";  								r = Z_DATA_ERROR;  								  								bitb = b; bitk = k;  								z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;  								write = q;  								return inflate_flush(z' r);  							}
