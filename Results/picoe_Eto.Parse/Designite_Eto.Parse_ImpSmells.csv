Implementation smell,Namespace,Class,File,Method,Description
Long Method,Eto.Parse.Parsers,RepeatParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\RepeatParser.cs,InnerParse,The method has 109 lines of code.
Long Method,Eto.Parse.Parsers,StringParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\StringParser.cs,GetEscapedString,The method has 127 lines of code.
Complex Method,Eto.Parse,Grammar,C:\repos\picoe_Eto.Parse\Eto.Parse\Grammar.cs,OptimizeCharacterSets,Cyclomatic complexity of the method is 13
Complex Method,Eto.Parse.Parsers,RepeatParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\RepeatParser.cs,InnerParse,Cyclomatic complexity of the method is 11
Complex Method,Eto.Parse.Parsers,SequenceParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\SequenceParser.cs,InnerParse,Cyclomatic complexity of the method is 8
Complex Method,Eto.Parse.Parsers,SequenceParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\SequenceParser.cs,Initialize,Cyclomatic complexity of the method is 9
Complex Method,Eto.Parse.Parsers,GroupParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\GroupParser.cs,InnerParse,Cyclomatic complexity of the method is 13
Complex Method,Eto.Parse.Parsers,StringParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\StringParser.cs,GetEscapedString,Cyclomatic complexity of the method is 9
Complex Method,Eto.Parse.Parsers,StringParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\StringParser.cs,InnerParse,Cyclomatic complexity of the method is 9
Complex Method,Eto.Parse.Grammars,EbnfGrammar,C:\repos\picoe_Eto.Parse\Eto.Parse\Grammars\EbnfGrammar.cs,EbnfGrammar,Cyclomatic complexity of the method is 9
Long Parameter List,Eto.Parse,GrammarMatch,C:\repos\picoe_Eto.Parse\Eto.Parse\GrammarMatch.cs,GrammarMatch,The method has 8 parameters. Parameters: grammar' scanner' index' length' matches' errorIndex' childErrorIndex' errors
Long Parameter List,Eto.Parse,Match,C:\repos\picoe_Eto.Parse\Eto.Parse\Match.cs,Match,The method has 6 parameters. Parameters: name' parser' scanner' index' length' matches
Long Parameter List,Eto.Parse,Match,C:\repos\picoe_Eto.Parse\Eto.Parse\Match.cs,Match,The method has 5 parameters. Parameters: parser' scanner' index' length' matches
Long Parameter List,Eto.Parse.Parsers,UntilParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\UntilParser.cs,UntilParser,The method has 5 parameters. Parameters: inner' minimum' maximum' skip' capture
Long Statement,Eto.Parse,Parser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parser.cs,Initialize,The length of the statement  "				mode = (hasNamedChildren && AddMatch) ? ParseMode.NamedChildren : AddMatch || AddError ? ParseMode.NameOrError : ParseMode.Simple; " is 130.
Long Statement,Eto.Parse,FluentParserExtensions,C:\repos\picoe_Eto.Parse\Eto.Parse\FluentExtensions.cs,PreventRecursion,The length of the statement  "			return new TagParser { Inner = parser' AddTag = tag' ExcludeTag = tag' AllowWithDifferentPosition = allowWithDifferentPosition }; " is 129.
Long Statement,Eto.Parse.Parsers,AlternativeParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\AlternativeParser.cs,Initialize,The length of the statement  "					if (args.Grammar.Optimizations.HasFlag(GrammarOptimizations.FixRecursiveGrammars) && item != null && item.IsLeftRecursive(new ParserContainsArgs(this))) " is 152.
Long Statement,Eto.Parse.Parsers,NumberParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\NumberParser.cs,Initialize,The length of the statement  "						var parseMethod = ValueType.GetTypeInfo().DeclaredMethods.FirstOrDefault(r => r.Name == "Parse" && r.GetParameters().Select(p => p.ParameterType).SequenceEqual(parameters)); " is 173.
Long Statement,Eto.Parse.Parsers,NumberParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\NumberParser.cs,Initialize,The length of the statement  "						var parseMethod = ValueType.GetMethod("Parse"' BindingFlags.Static | BindingFlags.Public' null' new Type[] { typeof(string)' typeof(NumberStyles) }' null); " is 155.
Long Statement,Eto.Parse.Writers.Code,StringWriter,C:\repos\picoe_Eto.Parse\Eto.Parse\Writers\Code\StringWriter.cs,WriteContents,The length of the statement  "				quoteChars = string.Format("new char[] {{ {0} }}"' string.Join("' "' parser.QuoteCharacters.Select(r => string.Format("(char)0x{0:x}"' (int)r)))); " is 146.
Long Statement,Eto.Parse.Writers.Code,BooleanWriter,C:\repos\picoe_Eto.Parse\Eto.Parse\Writers\Code\BooleanWriter.cs,WriteContents,The length of the statement  "				args.Output.WriteLine("{0}.CaseSensitive = {1};"' name' parser.CaseSensitive.HasValue ? parser.CaseSensitive.ToString().ToLowerInvariant() : "null"); " is 149.
Long Statement,Eto.Parse.Writers.Code,CharWriter,C:\repos\picoe_Eto.Parse\Eto.Parse\Writers\Code\CharWriter.cs,WriteContents,The length of the statement  "				args.Output.WriteLine("{0}.CaseSensitive = {1};"' name' parser.CaseSensitive.HasValue ? parser.CaseSensitive.ToString().ToLowerInvariant() : "null"); " is 149.
Long Statement,Eto.Parse.Writers.Code,TagWriter,C:\repos\picoe_Eto.Parse\Eto.Parse\Writers\Code\TagWriter.cs,WriteContents,The length of the statement  "				args.Output.WriteLine("{0}.AllowWithDifferentPosition = {1};"' name' parser.AllowWithDifferentPosition.ToString().ToLowerInvariant()); " is 134.
Long Statement,Eto.Parse.Grammars,GoldGrammar,C:\repos\picoe_Eto.Parse\Eto.Parse\Grammars\GoldGrammar.cs,AttachEvents,The length of the statement  "				if (string.Equals("Auto Whitespace"' name' StringComparison.OrdinalIgnoreCase) && bool.TryParse(value' out val) && !val) " is 120.
Long Statement,Eto.Parse.Grammars,GoldGrammar,C:\repos\picoe_Eto.Parse\Eto.Parse\Grammars\GoldGrammar.cs,AttachEvents,The length of the statement  "					var count = name.EndsWith(" Start"' StringComparison.Ordinal) ? 6 : name.EndsWith(" Line"' StringComparison.Ordinal) ? 5 : name.EndsWith(" End"' StringComparison.Ordinal) ? 4 : 0; " is 179.
Long Statement,Eto.Parse.Grammars,GoldGrammar,C:\repos\picoe_Eto.Parse\Eto.Parse\Grammars\GoldGrammar.cs,AttachEvents,The length of the statement  "				if (name.EndsWith(" Start"' StringComparison.Ordinal) || name.EndsWith(" End"' StringComparison.Ordinal) || name.EndsWith(" Line"' StringComparison.Ordinal)) " is 157.
Long Statement,Eto.Parse.Grammars,GoldGrammar,C:\repos\picoe_Eto.Parse\Eto.Parse\Grammars\GoldGrammar.cs,AttachEvents,The length of the statement  "					var count = name.EndsWith(" Start"' StringComparison.Ordinal) ? 6 : name.EndsWith(" Line"' StringComparison.Ordinal) ? 5 : name.EndsWith(" End"' StringComparison.Ordinal) ? 4 : 0; " is 179.
Complex Conditional,Eto.Parse,Grammar,C:\repos\picoe_Eto.Parse\Eto.Parse\Grammar.cs,OptimizeCharacterSets,The conditional expression  "alt.Items.All(r => r.Name == null && (r is CharSetTerminal || r is CharRangeTerminal || r is SingleCharTerminal))"  is complex.
Complex Conditional,Eto.Parse.Parsers,NumberParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\NumberParser.cs,InnerParse,The conditional expression  "AllowExponent && !hasExponent && (ch == 'E' || ch == 'e')"  is complex.
Complex Conditional,Eto.Parse.Parsers,StringParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\StringParser.cs,GetEscapedString,The conditional expression  "!(char.IsDigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'))"  is complex.
Magic Number,Eto.Parse,ParserWriterArgs,C:\repos\picoe_Eto.Parse\Eto.Parse\ParserWriterArgs.cs,GenerateName,The following statement contains a magic number: if (name.EndsWith("Parser"' StringComparison.Ordinal))  				name = name.Substring(0' name.Length - 6);
Magic Number,Eto.Parse,Grammar,C:\repos\picoe_Eto.Parse\Eto.Parse\Grammar.cs,OptimizeCharacterSets,The following statement contains a magic number: foreach (var alt in children.OfType<AlternativeParser>().Where(r => r.Items.Count > 2))  			{  				if (alt.Items.All(r => r.Name == null && (r is CharSetTerminal || r is CharRangeTerminal || r is SingleCharTerminal)))  				{  					var chars = new List<char>();  					var inverse = new List<char>();  					foreach (var item in alt.Items)  					{  						var singleChar = item as SingleCharTerminal;  						if (singleChar != null)  						{  							if (singleChar.Inverse)  								inverse.Add(singleChar.Character);  							else  								chars.Add(singleChar.Character);  							continue;  						}  						var charSet = item as CharSetTerminal;  						if (charSet != null)  						{  							if (charSet.Inverse)  								inverse.AddRange(charSet.Characters);  							else  								chars.AddRange(charSet.Characters);  							continue;  						}  						var charRange = item as CharRangeTerminal;  						if (charRange != null)  						{  							for (char i = charRange.Start; i < charRange.End; i++)  							{  								if (charRange.Inverse)  									inverse.Add(i);  								else  									chars.Add(i);  							}  							continue;  						}  					}  					//Debug.WriteLine("Optimizing characters normal:{0} inverse:{1}"' chars.Count' inverse.Count);  					alt.Items.Clear();  					if (chars.Count > 0)  						alt.Items.Add(new CharSetTerminal(chars.ToArray()));  					if (inverse.Count > 0)  						alt.Items.Add(new CharSetTerminal(inverse.ToArray())  						{  							Inverse = true  						});  				}  			}
Magic Number,Eto.Parse.Parsers,SurrogatePairTerminal,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\SurrogatePairTerminal.cs,InnerParse,The following statement contains a magic number: if (!args.Scanner.IsEof && TryGetCodePoint(args.Scanner' out codePoint))              {                  if (Test(codePoint) != Inverse)                  {                      return 2;                  }              }
Magic Number,Eto.Parse.Parsers,SurrogatePairTerminal,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\SurrogatePairTerminal.cs,TryGetCodePoint,The following statement contains a magic number: if (highSurrogate > 0 && char.IsHighSurrogate((char) highSurrogate))              {                  var lowSurrogate = scanner.ReadChar();                  if (lowSurrogate > 0 && char.IsLowSurrogate((char) lowSurrogate))                  {                      codePoint = char.ConvertToUtf32((char) highSurrogate' (char) lowSurrogate);                      validCodePoint = true;                  }                  else                  {                      scanner.Position -= 2;                  }              }              else              {                  scanner.Position--;              }
Magic Number,Eto.Parse.Parsers,StringParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\StringParser.cs,GetValue,The following statement contains a magic number: if (text.Length > 0)  			{  				// process escapes using string format with no parameters  				if (AllowEscapeCharacters)  				{  					return GetEscapedString(text);  				}  				else if (AllowQuoted)  				{  					var quoteIndex = quoteCharString.IndexOf(text[0]);  					if (quoteIndex >= 0)  					{  						var quoteChar = endQuoteCharString[quoteIndex];  						if (text.Length >= 2 && text[text.Length - 1] == quoteChar)  						{  							text = text.Substring(1' text.Length - 2);  						}  						if (AllowDoubleQuote)  						{  							text = text.Replace(quoteChar.ToString() + quoteChar' quoteChar.ToString());  						}  					}  				}  			}
Magic Number,Eto.Parse.Parsers,StringParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\StringParser.cs,GetValue,The following statement contains a magic number: if (text.Length > 0)  			{  				// process escapes using string format with no parameters  				if (AllowEscapeCharacters)  				{  					return GetEscapedString(text);  				}  				else if (AllowQuoted)  				{  					var quoteIndex = quoteCharString.IndexOf(text[0]);  					if (quoteIndex >= 0)  					{  						var quoteChar = endQuoteCharString[quoteIndex];  						if (text.Length >= 2 && text[text.Length - 1] == quoteChar)  						{  							text = text.Substring(1' text.Length - 2);  						}  						if (AllowDoubleQuote)  						{  							text = text.Replace(quoteChar.ToString() + quoteChar' quoteChar.ToString());  						}  					}  				}  			}
Magic Number,Eto.Parse.Parsers,StringParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\StringParser.cs,GetEscapedString,The following statement contains a magic number: while (pos < length)  			{  				char c = source[pos];  				if (c != '\\')  				{  					pos++;  					sb.Append(c);  					// assume that the parse match ensured that we have a duplicate if we're not at the end of the string  					if (!parseDoubleQuote || c != quoteChar || pos >= length)  						continue;  					pos++;  					continue;  				}  				pos++;  				if (pos >= length)  					throw new ArgumentException("Missing escape sequence");  				switch (source[pos])  				{  					case 'n':  						c = '\n';  						break;  					case 'r':  						c = '\r';  						break;  					case '\'':  					case '\"':  					case '\\':  						// use the char directly  						break;  					case '0':  						c = '\0';  						break;  					case 'a':  						c = '\a';  						break;  					case 'b':  						c = '\b';  						break;  					case 'f':  						c = '\f';  						break;  					case 't':  						c = '\t';  						break;  					case 'v':  						c = '\v';  						break;  					case 'x':  						var hex = new StringBuilder(4);  						pos++;  						if (pos >= length)  							throw new ArgumentException("Missing escape sequence");  						for (int i = 0; i < 4; i++)  						{  							c = source[pos];  							if (!(char.IsDigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')))  								break;  							hex.Append(c);  							pos++;  							if (pos > length)  								break;  						}  						if (hex.Length == 0)  							throw new ArgumentException("Unrecognized escape sequence");  						c = (char)Int32.Parse(hex.ToString()' NumberStyles.HexNumber);  						pos--;  						break;  					case 'u':  						pos++;  						if (pos + 3 >= length)  							throw new ArgumentException("Unrecognized escape sequence");  						try  						{  							uint charValue = UInt32.Parse(source.Substring(pos' 4)' NumberStyles.HexNumber);  							c = (char)charValue;  							pos += 3;  						}  						catch (Exception)  						{  							throw new ArgumentException("Unrecognized escape sequence");  						}  						break;  					case 'U':  						pos++;  						if (pos + 7 >= length)  							throw new ArgumentException("Unrecognized escape sequence");  						try  						{  							uint charValue = UInt32.Parse(source.Substring(pos' 8)' NumberStyles.HexNumber);  							if (charValue > 0xffff)  								throw new ArgumentException("Unrecognized escape sequence");  							c = (char)charValue;  							pos += 7;  						}  						catch (Exception)  						{  							throw new ArgumentException("Unrecognized escape sequence");  						}  						break;  					default:  						throw new ArgumentException("Unrecognized escape sequence");  				}  				pos++;  				sb.Append(c);  			}
Magic Number,Eto.Parse.Parsers,StringParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\StringParser.cs,GetEscapedString,The following statement contains a magic number: while (pos < length)  			{  				char c = source[pos];  				if (c != '\\')  				{  					pos++;  					sb.Append(c);  					// assume that the parse match ensured that we have a duplicate if we're not at the end of the string  					if (!parseDoubleQuote || c != quoteChar || pos >= length)  						continue;  					pos++;  					continue;  				}  				pos++;  				if (pos >= length)  					throw new ArgumentException("Missing escape sequence");  				switch (source[pos])  				{  					case 'n':  						c = '\n';  						break;  					case 'r':  						c = '\r';  						break;  					case '\'':  					case '\"':  					case '\\':  						// use the char directly  						break;  					case '0':  						c = '\0';  						break;  					case 'a':  						c = '\a';  						break;  					case 'b':  						c = '\b';  						break;  					case 'f':  						c = '\f';  						break;  					case 't':  						c = '\t';  						break;  					case 'v':  						c = '\v';  						break;  					case 'x':  						var hex = new StringBuilder(4);  						pos++;  						if (pos >= length)  							throw new ArgumentException("Missing escape sequence");  						for (int i = 0; i < 4; i++)  						{  							c = source[pos];  							if (!(char.IsDigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')))  								break;  							hex.Append(c);  							pos++;  							if (pos > length)  								break;  						}  						if (hex.Length == 0)  							throw new ArgumentException("Unrecognized escape sequence");  						c = (char)Int32.Parse(hex.ToString()' NumberStyles.HexNumber);  						pos--;  						break;  					case 'u':  						pos++;  						if (pos + 3 >= length)  							throw new ArgumentException("Unrecognized escape sequence");  						try  						{  							uint charValue = UInt32.Parse(source.Substring(pos' 4)' NumberStyles.HexNumber);  							c = (char)charValue;  							pos += 3;  						}  						catch (Exception)  						{  							throw new ArgumentException("Unrecognized escape sequence");  						}  						break;  					case 'U':  						pos++;  						if (pos + 7 >= length)  							throw new ArgumentException("Unrecognized escape sequence");  						try  						{  							uint charValue = UInt32.Parse(source.Substring(pos' 8)' NumberStyles.HexNumber);  							if (charValue > 0xffff)  								throw new ArgumentException("Unrecognized escape sequence");  							c = (char)charValue;  							pos += 7;  						}  						catch (Exception)  						{  							throw new ArgumentException("Unrecognized escape sequence");  						}  						break;  					default:  						throw new ArgumentException("Unrecognized escape sequence");  				}  				pos++;  				sb.Append(c);  			}
Magic Number,Eto.Parse.Parsers,StringParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\StringParser.cs,GetEscapedString,The following statement contains a magic number: while (pos < length)  			{  				char c = source[pos];  				if (c != '\\')  				{  					pos++;  					sb.Append(c);  					// assume that the parse match ensured that we have a duplicate if we're not at the end of the string  					if (!parseDoubleQuote || c != quoteChar || pos >= length)  						continue;  					pos++;  					continue;  				}  				pos++;  				if (pos >= length)  					throw new ArgumentException("Missing escape sequence");  				switch (source[pos])  				{  					case 'n':  						c = '\n';  						break;  					case 'r':  						c = '\r';  						break;  					case '\'':  					case '\"':  					case '\\':  						// use the char directly  						break;  					case '0':  						c = '\0';  						break;  					case 'a':  						c = '\a';  						break;  					case 'b':  						c = '\b';  						break;  					case 'f':  						c = '\f';  						break;  					case 't':  						c = '\t';  						break;  					case 'v':  						c = '\v';  						break;  					case 'x':  						var hex = new StringBuilder(4);  						pos++;  						if (pos >= length)  							throw new ArgumentException("Missing escape sequence");  						for (int i = 0; i < 4; i++)  						{  							c = source[pos];  							if (!(char.IsDigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')))  								break;  							hex.Append(c);  							pos++;  							if (pos > length)  								break;  						}  						if (hex.Length == 0)  							throw new ArgumentException("Unrecognized escape sequence");  						c = (char)Int32.Parse(hex.ToString()' NumberStyles.HexNumber);  						pos--;  						break;  					case 'u':  						pos++;  						if (pos + 3 >= length)  							throw new ArgumentException("Unrecognized escape sequence");  						try  						{  							uint charValue = UInt32.Parse(source.Substring(pos' 4)' NumberStyles.HexNumber);  							c = (char)charValue;  							pos += 3;  						}  						catch (Exception)  						{  							throw new ArgumentException("Unrecognized escape sequence");  						}  						break;  					case 'U':  						pos++;  						if (pos + 7 >= length)  							throw new ArgumentException("Unrecognized escape sequence");  						try  						{  							uint charValue = UInt32.Parse(source.Substring(pos' 8)' NumberStyles.HexNumber);  							if (charValue > 0xffff)  								throw new ArgumentException("Unrecognized escape sequence");  							c = (char)charValue;  							pos += 7;  						}  						catch (Exception)  						{  							throw new ArgumentException("Unrecognized escape sequence");  						}  						break;  					default:  						throw new ArgumentException("Unrecognized escape sequence");  				}  				pos++;  				sb.Append(c);  			}
Magic Number,Eto.Parse.Parsers,StringParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\StringParser.cs,GetEscapedString,The following statement contains a magic number: while (pos < length)  			{  				char c = source[pos];  				if (c != '\\')  				{  					pos++;  					sb.Append(c);  					// assume that the parse match ensured that we have a duplicate if we're not at the end of the string  					if (!parseDoubleQuote || c != quoteChar || pos >= length)  						continue;  					pos++;  					continue;  				}  				pos++;  				if (pos >= length)  					throw new ArgumentException("Missing escape sequence");  				switch (source[pos])  				{  					case 'n':  						c = '\n';  						break;  					case 'r':  						c = '\r';  						break;  					case '\'':  					case '\"':  					case '\\':  						// use the char directly  						break;  					case '0':  						c = '\0';  						break;  					case 'a':  						c = '\a';  						break;  					case 'b':  						c = '\b';  						break;  					case 'f':  						c = '\f';  						break;  					case 't':  						c = '\t';  						break;  					case 'v':  						c = '\v';  						break;  					case 'x':  						var hex = new StringBuilder(4);  						pos++;  						if (pos >= length)  							throw new ArgumentException("Missing escape sequence");  						for (int i = 0; i < 4; i++)  						{  							c = source[pos];  							if (!(char.IsDigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')))  								break;  							hex.Append(c);  							pos++;  							if (pos > length)  								break;  						}  						if (hex.Length == 0)  							throw new ArgumentException("Unrecognized escape sequence");  						c = (char)Int32.Parse(hex.ToString()' NumberStyles.HexNumber);  						pos--;  						break;  					case 'u':  						pos++;  						if (pos + 3 >= length)  							throw new ArgumentException("Unrecognized escape sequence");  						try  						{  							uint charValue = UInt32.Parse(source.Substring(pos' 4)' NumberStyles.HexNumber);  							c = (char)charValue;  							pos += 3;  						}  						catch (Exception)  						{  							throw new ArgumentException("Unrecognized escape sequence");  						}  						break;  					case 'U':  						pos++;  						if (pos + 7 >= length)  							throw new ArgumentException("Unrecognized escape sequence");  						try  						{  							uint charValue = UInt32.Parse(source.Substring(pos' 8)' NumberStyles.HexNumber);  							if (charValue > 0xffff)  								throw new ArgumentException("Unrecognized escape sequence");  							c = (char)charValue;  							pos += 7;  						}  						catch (Exception)  						{  							throw new ArgumentException("Unrecognized escape sequence");  						}  						break;  					default:  						throw new ArgumentException("Unrecognized escape sequence");  				}  				pos++;  				sb.Append(c);  			}
Magic Number,Eto.Parse.Parsers,StringParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\StringParser.cs,GetEscapedString,The following statement contains a magic number: while (pos < length)  			{  				char c = source[pos];  				if (c != '\\')  				{  					pos++;  					sb.Append(c);  					// assume that the parse match ensured that we have a duplicate if we're not at the end of the string  					if (!parseDoubleQuote || c != quoteChar || pos >= length)  						continue;  					pos++;  					continue;  				}  				pos++;  				if (pos >= length)  					throw new ArgumentException("Missing escape sequence");  				switch (source[pos])  				{  					case 'n':  						c = '\n';  						break;  					case 'r':  						c = '\r';  						break;  					case '\'':  					case '\"':  					case '\\':  						// use the char directly  						break;  					case '0':  						c = '\0';  						break;  					case 'a':  						c = '\a';  						break;  					case 'b':  						c = '\b';  						break;  					case 'f':  						c = '\f';  						break;  					case 't':  						c = '\t';  						break;  					case 'v':  						c = '\v';  						break;  					case 'x':  						var hex = new StringBuilder(4);  						pos++;  						if (pos >= length)  							throw new ArgumentException("Missing escape sequence");  						for (int i = 0; i < 4; i++)  						{  							c = source[pos];  							if (!(char.IsDigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')))  								break;  							hex.Append(c);  							pos++;  							if (pos > length)  								break;  						}  						if (hex.Length == 0)  							throw new ArgumentException("Unrecognized escape sequence");  						c = (char)Int32.Parse(hex.ToString()' NumberStyles.HexNumber);  						pos--;  						break;  					case 'u':  						pos++;  						if (pos + 3 >= length)  							throw new ArgumentException("Unrecognized escape sequence");  						try  						{  							uint charValue = UInt32.Parse(source.Substring(pos' 4)' NumberStyles.HexNumber);  							c = (char)charValue;  							pos += 3;  						}  						catch (Exception)  						{  							throw new ArgumentException("Unrecognized escape sequence");  						}  						break;  					case 'U':  						pos++;  						if (pos + 7 >= length)  							throw new ArgumentException("Unrecognized escape sequence");  						try  						{  							uint charValue = UInt32.Parse(source.Substring(pos' 8)' NumberStyles.HexNumber);  							if (charValue > 0xffff)  								throw new ArgumentException("Unrecognized escape sequence");  							c = (char)charValue;  							pos += 7;  						}  						catch (Exception)  						{  							throw new ArgumentException("Unrecognized escape sequence");  						}  						break;  					default:  						throw new ArgumentException("Unrecognized escape sequence");  				}  				pos++;  				sb.Append(c);  			}
Magic Number,Eto.Parse.Parsers,StringParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\StringParser.cs,GetEscapedString,The following statement contains a magic number: while (pos < length)  			{  				char c = source[pos];  				if (c != '\\')  				{  					pos++;  					sb.Append(c);  					// assume that the parse match ensured that we have a duplicate if we're not at the end of the string  					if (!parseDoubleQuote || c != quoteChar || pos >= length)  						continue;  					pos++;  					continue;  				}  				pos++;  				if (pos >= length)  					throw new ArgumentException("Missing escape sequence");  				switch (source[pos])  				{  					case 'n':  						c = '\n';  						break;  					case 'r':  						c = '\r';  						break;  					case '\'':  					case '\"':  					case '\\':  						// use the char directly  						break;  					case '0':  						c = '\0';  						break;  					case 'a':  						c = '\a';  						break;  					case 'b':  						c = '\b';  						break;  					case 'f':  						c = '\f';  						break;  					case 't':  						c = '\t';  						break;  					case 'v':  						c = '\v';  						break;  					case 'x':  						var hex = new StringBuilder(4);  						pos++;  						if (pos >= length)  							throw new ArgumentException("Missing escape sequence");  						for (int i = 0; i < 4; i++)  						{  							c = source[pos];  							if (!(char.IsDigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')))  								break;  							hex.Append(c);  							pos++;  							if (pos > length)  								break;  						}  						if (hex.Length == 0)  							throw new ArgumentException("Unrecognized escape sequence");  						c = (char)Int32.Parse(hex.ToString()' NumberStyles.HexNumber);  						pos--;  						break;  					case 'u':  						pos++;  						if (pos + 3 >= length)  							throw new ArgumentException("Unrecognized escape sequence");  						try  						{  							uint charValue = UInt32.Parse(source.Substring(pos' 4)' NumberStyles.HexNumber);  							c = (char)charValue;  							pos += 3;  						}  						catch (Exception)  						{  							throw new ArgumentException("Unrecognized escape sequence");  						}  						break;  					case 'U':  						pos++;  						if (pos + 7 >= length)  							throw new ArgumentException("Unrecognized escape sequence");  						try  						{  							uint charValue = UInt32.Parse(source.Substring(pos' 8)' NumberStyles.HexNumber);  							if (charValue > 0xffff)  								throw new ArgumentException("Unrecognized escape sequence");  							c = (char)charValue;  							pos += 7;  						}  						catch (Exception)  						{  							throw new ArgumentException("Unrecognized escape sequence");  						}  						break;  					default:  						throw new ArgumentException("Unrecognized escape sequence");  				}  				pos++;  				sb.Append(c);  			}
Magic Number,Eto.Parse.Parsers,StringParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\StringParser.cs,GetEscapedString,The following statement contains a magic number: while (pos < length)  			{  				char c = source[pos];  				if (c != '\\')  				{  					pos++;  					sb.Append(c);  					// assume that the parse match ensured that we have a duplicate if we're not at the end of the string  					if (!parseDoubleQuote || c != quoteChar || pos >= length)  						continue;  					pos++;  					continue;  				}  				pos++;  				if (pos >= length)  					throw new ArgumentException("Missing escape sequence");  				switch (source[pos])  				{  					case 'n':  						c = '\n';  						break;  					case 'r':  						c = '\r';  						break;  					case '\'':  					case '\"':  					case '\\':  						// use the char directly  						break;  					case '0':  						c = '\0';  						break;  					case 'a':  						c = '\a';  						break;  					case 'b':  						c = '\b';  						break;  					case 'f':  						c = '\f';  						break;  					case 't':  						c = '\t';  						break;  					case 'v':  						c = '\v';  						break;  					case 'x':  						var hex = new StringBuilder(4);  						pos++;  						if (pos >= length)  							throw new ArgumentException("Missing escape sequence");  						for (int i = 0; i < 4; i++)  						{  							c = source[pos];  							if (!(char.IsDigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')))  								break;  							hex.Append(c);  							pos++;  							if (pos > length)  								break;  						}  						if (hex.Length == 0)  							throw new ArgumentException("Unrecognized escape sequence");  						c = (char)Int32.Parse(hex.ToString()' NumberStyles.HexNumber);  						pos--;  						break;  					case 'u':  						pos++;  						if (pos + 3 >= length)  							throw new ArgumentException("Unrecognized escape sequence");  						try  						{  							uint charValue = UInt32.Parse(source.Substring(pos' 4)' NumberStyles.HexNumber);  							c = (char)charValue;  							pos += 3;  						}  						catch (Exception)  						{  							throw new ArgumentException("Unrecognized escape sequence");  						}  						break;  					case 'U':  						pos++;  						if (pos + 7 >= length)  							throw new ArgumentException("Unrecognized escape sequence");  						try  						{  							uint charValue = UInt32.Parse(source.Substring(pos' 8)' NumberStyles.HexNumber);  							if (charValue > 0xffff)  								throw new ArgumentException("Unrecognized escape sequence");  							c = (char)charValue;  							pos += 7;  						}  						catch (Exception)  						{  							throw new ArgumentException("Unrecognized escape sequence");  						}  						break;  					default:  						throw new ArgumentException("Unrecognized escape sequence");  				}  				pos++;  				sb.Append(c);  			}
Magic Number,Eto.Parse.Parsers,StringParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\StringParser.cs,GetEscapedString,The following statement contains a magic number: while (pos < length)  			{  				char c = source[pos];  				if (c != '\\')  				{  					pos++;  					sb.Append(c);  					// assume that the parse match ensured that we have a duplicate if we're not at the end of the string  					if (!parseDoubleQuote || c != quoteChar || pos >= length)  						continue;  					pos++;  					continue;  				}  				pos++;  				if (pos >= length)  					throw new ArgumentException("Missing escape sequence");  				switch (source[pos])  				{  					case 'n':  						c = '\n';  						break;  					case 'r':  						c = '\r';  						break;  					case '\'':  					case '\"':  					case '\\':  						// use the char directly  						break;  					case '0':  						c = '\0';  						break;  					case 'a':  						c = '\a';  						break;  					case 'b':  						c = '\b';  						break;  					case 'f':  						c = '\f';  						break;  					case 't':  						c = '\t';  						break;  					case 'v':  						c = '\v';  						break;  					case 'x':  						var hex = new StringBuilder(4);  						pos++;  						if (pos >= length)  							throw new ArgumentException("Missing escape sequence");  						for (int i = 0; i < 4; i++)  						{  							c = source[pos];  							if (!(char.IsDigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')))  								break;  							hex.Append(c);  							pos++;  							if (pos > length)  								break;  						}  						if (hex.Length == 0)  							throw new ArgumentException("Unrecognized escape sequence");  						c = (char)Int32.Parse(hex.ToString()' NumberStyles.HexNumber);  						pos--;  						break;  					case 'u':  						pos++;  						if (pos + 3 >= length)  							throw new ArgumentException("Unrecognized escape sequence");  						try  						{  							uint charValue = UInt32.Parse(source.Substring(pos' 4)' NumberStyles.HexNumber);  							c = (char)charValue;  							pos += 3;  						}  						catch (Exception)  						{  							throw new ArgumentException("Unrecognized escape sequence");  						}  						break;  					case 'U':  						pos++;  						if (pos + 7 >= length)  							throw new ArgumentException("Unrecognized escape sequence");  						try  						{  							uint charValue = UInt32.Parse(source.Substring(pos' 8)' NumberStyles.HexNumber);  							if (charValue > 0xffff)  								throw new ArgumentException("Unrecognized escape sequence");  							c = (char)charValue;  							pos += 7;  						}  						catch (Exception)  						{  							throw new ArgumentException("Unrecognized escape sequence");  						}  						break;  					default:  						throw new ArgumentException("Unrecognized escape sequence");  				}  				pos++;  				sb.Append(c);  			}
Magic Number,Eto.Parse.Parsers,CharSetTerminal,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\CharSetTerminal.cs,CharSetTerminal,The following statement contains a magic number: this.MinLookupCount = 100;
Magic Number,Eto.Parse.Parsers,EolTerminal,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\EolTerminal.cs,InnerParse,The following statement contains a magic number: if (ch != -1)  			{  				if (ch == '\n')  					return 1;  				if (ch == '\r')  				{  					ch = scanner.ReadChar();  					if (ch == -1)  						return 1;  					if (ch == '\n')  						return 2;  					scanner.Position = pos + 1;  					return 1;  				}  			}
Magic Number,Eto.Parse.Writers.Code,StringWriter,C:\repos\picoe_Eto.Parse\Eto.Parse\Writers\Code\StringWriter.cs,WriteContents,The following statement contains a magic number: if (parser.QuoteCharacters == null)  				quoteChars = "null";  			else if (parser.QuoteCharacters.Length != 2 || parser.QuoteCharacters[0] != '\"' || parser.QuoteCharacters[0] != '\'')  				quoteChars = string.Format("new char[] {{ {0} }}"' string.Join("' "' parser.QuoteCharacters.Select(r => string.Format("(char)0x{0:x}"' (int)r))));
Magic Number,Eto.Parse.Grammars,GoldGrammar,C:\repos\picoe_Eto.Parse\Eto.Parse\Grammars\GoldGrammar.cs,AttachEvents,The following statement contains a magic number: terminalDecl.Matched += m => {  				var inner = Sequence(m' "regExp"' RegExp);  				var parser = m.Tag as UnaryParser;  				if (parser != null)  					parser.Inner = inner;  				var groupParser = m.Tag as GroupParser;  				var name = m["name"].Text;  				if (groupParser != null)  				{  					if (name.EndsWith(" Start"' StringComparison.Ordinal))  						groupParser.Start = inner;  					else if (name.EndsWith(" End"' StringComparison.Ordinal))  						groupParser.End = inner;  					else if (name.EndsWith(" Line"' StringComparison.Ordinal))  						groupParser.Line = inner;  					var count = name.EndsWith(" Start"' StringComparison.Ordinal) ? 6 : name.EndsWith(" Line"' StringComparison.Ordinal) ? 5 : name.EndsWith(" End"' StringComparison.Ordinal) ? 4 : 0;  					name = name.Substring(0' name.Length - count);  				}    				if (name.Equals("Comment"' StringComparison.OrdinalIgnoreCase)  				    || name.Equals("Whitespace"' StringComparison.OrdinalIgnoreCase)  				    )  				{  					definition.ClearSeparator();  				}  			};
Magic Number,Eto.Parse.Grammars,GoldGrammar,C:\repos\picoe_Eto.Parse\Eto.Parse\Grammars\GoldGrammar.cs,AttachEvents,The following statement contains a magic number: terminalDecl.Matched += m => {  				var inner = Sequence(m' "regExp"' RegExp);  				var parser = m.Tag as UnaryParser;  				if (parser != null)  					parser.Inner = inner;  				var groupParser = m.Tag as GroupParser;  				var name = m["name"].Text;  				if (groupParser != null)  				{  					if (name.EndsWith(" Start"' StringComparison.Ordinal))  						groupParser.Start = inner;  					else if (name.EndsWith(" End"' StringComparison.Ordinal))  						groupParser.End = inner;  					else if (name.EndsWith(" Line"' StringComparison.Ordinal))  						groupParser.Line = inner;  					var count = name.EndsWith(" Start"' StringComparison.Ordinal) ? 6 : name.EndsWith(" Line"' StringComparison.Ordinal) ? 5 : name.EndsWith(" End"' StringComparison.Ordinal) ? 4 : 0;  					name = name.Substring(0' name.Length - count);  				}    				if (name.Equals("Comment"' StringComparison.OrdinalIgnoreCase)  				    || name.Equals("Whitespace"' StringComparison.OrdinalIgnoreCase)  				    )  				{  					definition.ClearSeparator();  				}  			};
Magic Number,Eto.Parse.Grammars,GoldGrammar,C:\repos\picoe_Eto.Parse\Eto.Parse\Grammars\GoldGrammar.cs,AttachEvents,The following statement contains a magic number: terminalDecl.Matched += m => {  				var inner = Sequence(m' "regExp"' RegExp);  				var parser = m.Tag as UnaryParser;  				if (parser != null)  					parser.Inner = inner;  				var groupParser = m.Tag as GroupParser;  				var name = m["name"].Text;  				if (groupParser != null)  				{  					if (name.EndsWith(" Start"' StringComparison.Ordinal))  						groupParser.Start = inner;  					else if (name.EndsWith(" End"' StringComparison.Ordinal))  						groupParser.End = inner;  					else if (name.EndsWith(" Line"' StringComparison.Ordinal))  						groupParser.Line = inner;  					var count = name.EndsWith(" Start"' StringComparison.Ordinal) ? 6 : name.EndsWith(" Line"' StringComparison.Ordinal) ? 5 : name.EndsWith(" End"' StringComparison.Ordinal) ? 4 : 0;  					name = name.Substring(0' name.Length - count);  				}    				if (name.Equals("Comment"' StringComparison.OrdinalIgnoreCase)  				    || name.Equals("Whitespace"' StringComparison.OrdinalIgnoreCase)  				    )  				{  					definition.ClearSeparator();  				}  			};
Magic Number,Eto.Parse.Grammars,GoldGrammar,C:\repos\picoe_Eto.Parse\Eto.Parse\Grammars\GoldGrammar.cs,AttachEvents,The following statement contains a magic number: terminalDecl.PreMatch += m => {  				var name = m["name"].Text;  				if (name.EndsWith(" Start"' StringComparison.Ordinal) || name.EndsWith(" End"' StringComparison.Ordinal) || name.EndsWith(" Line"' StringComparison.Ordinal))  				{  					Parser parser;  					var count = name.EndsWith(" Start"' StringComparison.Ordinal) ? 6 : name.EndsWith(" Line"' StringComparison.Ordinal) ? 5 : name.EndsWith(" End"' StringComparison.Ordinal) ? 4 : 0;  					name = name.Substring(0' name.Length - count);  					if (definition.Terminals.TryGetValue(name' out parser))  					{  						parser = parser as GroupParser ?? new GroupParser();  					}  					else  						parser = new GroupParser();  					m.Tag = definition.Terminals[name] = parser;  				}  				else  					m.Tag = definition.Terminals[name] = new UnaryParser(name);  			};
Magic Number,Eto.Parse.Grammars,GoldGrammar,C:\repos\picoe_Eto.Parse\Eto.Parse\Grammars\GoldGrammar.cs,AttachEvents,The following statement contains a magic number: terminalDecl.PreMatch += m => {  				var name = m["name"].Text;  				if (name.EndsWith(" Start"' StringComparison.Ordinal) || name.EndsWith(" End"' StringComparison.Ordinal) || name.EndsWith(" Line"' StringComparison.Ordinal))  				{  					Parser parser;  					var count = name.EndsWith(" Start"' StringComparison.Ordinal) ? 6 : name.EndsWith(" Line"' StringComparison.Ordinal) ? 5 : name.EndsWith(" End"' StringComparison.Ordinal) ? 4 : 0;  					name = name.Substring(0' name.Length - count);  					if (definition.Terminals.TryGetValue(name' out parser))  					{  						parser = parser as GroupParser ?? new GroupParser();  					}  					else  						parser = new GroupParser();  					m.Tag = definition.Terminals[name] = parser;  				}  				else  					m.Tag = definition.Terminals[name] = new UnaryParser(name);  			};
Magic Number,Eto.Parse.Grammars,GoldGrammar,C:\repos\picoe_Eto.Parse\Eto.Parse\Grammars\GoldGrammar.cs,AttachEvents,The following statement contains a magic number: terminalDecl.PreMatch += m => {  				var name = m["name"].Text;  				if (name.EndsWith(" Start"' StringComparison.Ordinal) || name.EndsWith(" End"' StringComparison.Ordinal) || name.EndsWith(" Line"' StringComparison.Ordinal))  				{  					Parser parser;  					var count = name.EndsWith(" Start"' StringComparison.Ordinal) ? 6 : name.EndsWith(" Line"' StringComparison.Ordinal) ? 5 : name.EndsWith(" End"' StringComparison.Ordinal) ? 4 : 0;  					name = name.Substring(0' name.Length - count);  					if (definition.Terminals.TryGetValue(name' out parser))  					{  						parser = parser as GroupParser ?? new GroupParser();  					}  					else  						parser = new GroupParser();  					m.Tag = definition.Terminals[name] = parser;  				}  				else  					m.Tag = definition.Terminals[name] = new UnaryParser(name);  			};
Magic Number,Eto.Parse.Grammars,GoldGrammar,C:\repos\picoe_Eto.Parse\Eto.Parse\Grammars\GoldGrammar.cs,SetLiteralOrName,The following statement contains a magic number: if (name.Success)  			{  				Parser parser;  				var nameText = name.Text;  				if (definition.Sets.TryGetValue(nameText' out parser))  					return parser;  				var chars = nameText.Split(new [] { ".." }' StringSplitOptions.RemoveEmptyEntries);  				if (chars.Length == 2)  				{  					// range of characters  					return new CharRangeTerminal(Character(chars[0])' Character(chars[1]));  				}  				if (chars.Length == 1)  				{  					// single character  					return new SingleCharTerminal(Character(chars[0]));  				}  			}
Magic Number,Eto.Parse.Grammars,EbnfGrammar,C:\repos\picoe_Eto.Parse\Eto.Parse\Grammars\EbnfGrammar.cs,Primary,The following statement contains a magic number: switch (child.Name)  			{  				case "grouped sequence":  					return new UnaryParser(DefinitionList(child["definition list"]' isTerminal));  				case "optional sequence":  					return new OptionalParser(DefinitionList(child["definition list"]' isTerminal));  				case "repeated sequence":  					var repeat = new RepeatParser(DefinitionList(child["definition list"]' isTerminal)' 0);  					if (!isTerminal)  						repeat.Separator = separator;  					return repeat;  				case "meta identifier":  					if (!parserLookup.TryGetValue(child.Text' out parser))  					{  						parser = parserLookup[child.Text] = Terminals.LetterOrDigit.Repeat().Named(child.Text);  					}  					return parser;  				case "terminal string":  					return new LiteralTerminal(child.StringValue);  				case "hex character":  					return new SingleCharTerminal((char)int.Parse(child.Text.Substring(2)' NumberStyles.HexNumber));  				case "character set":  					return CharacterSet(child);  				case "special sequence":  					var name = child["name"].Text.Trim();  					if (specialLookup.TryGetValue(name' out parser))  						return parser;  					else  						return null;  				default:  					throw new FormatException(string.Format("Could not parse child with name '{0}'"' child.Name));  			}
Magic Number,Eto.Parse.Grammars,EbnfGrammar,C:\repos\picoe_Eto.Parse\Eto.Parse\Grammars\EbnfGrammar.cs,Character,The following statement contains a magic number: if (text.StartsWith("#x"' StringComparison.OrdinalIgnoreCase))  			{  				var val = int.Parse(text.Substring(2)' NumberStyles.HexNumber);  				if (val <= 0xFFFF && val >= 0)  					return (char)val;  				else  					return null;  			}
Magic Number,Eto.Parse.Grammars,EbnfGrammar,C:\repos\picoe_Eto.Parse\Eto.Parse\Grammars\EbnfGrammar.cs,Character,The following statement contains a magic number: if (text.Length == 2 && text[0] == '\\')  			{  				return text[1];  			}
Duplicate Code,Eto.Parse.Parsers,RepeatParser,C:\repos\picoe_Eto.Parse\Eto.Parse\Parsers\RepeatParser.cs,InnerParse,The method contains a code clone-set at the following line numbers (starting from the method definition): ((10' 43)' (60' 93))
