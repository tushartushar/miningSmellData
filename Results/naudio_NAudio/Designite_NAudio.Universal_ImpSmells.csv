Implementation smell,Namespace,Class,File,Method,Description
Long Method,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The method has 148 lines of code.
Long Method,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The method has 141 lines of code.
Long Method,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The method has 224 lines of code.
Complex Method,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,Cyclomatic complexity of the method is 9
Complex Method,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,Cyclomatic complexity of the method is 11
Complex Method,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,Cyclomatic complexity of the method is 9
Complex Method,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,FFT,Cyclomatic complexity of the method is 11
Complex Method,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResamplePrepare,Cyclomatic complexity of the method is 9
Complex Method,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,Cyclomatic complexity of the method is 23
Complex Method,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,Cyclomatic complexity of the method is 11
Complex Method,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,Cyclomatic complexity of the method is 8
Complex Method,NAudio.Wave,WasapiCaptureRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveInputs\WasapiCaptureRT.cs,DoRecording,Cyclomatic complexity of the method is 8
Complex Method,NAudio.Wave.SampleProviders,OffsetSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\OffsetSampleProvider.cs,Read,Cyclomatic complexity of the method is 15
Complex Method,NAudio.Win8.Wave.WaveOutputs,WasapiOutRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WasapiOutRT.cs,PlayThread,Cyclomatic complexity of the method is 12
Complex Method,NAudio.Win8.Wave.WaveOutputs,WasapiOutRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WasapiOutRT.cs,Init,Cyclomatic complexity of the method is 10
Long Parameter List,NAudio.CoreAudioApi,AudioClient,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioClient.cs,Initialize,The method has 6 parameters. Parameters: shareMode' streamFlags' bufferDuration' periodicity' waveFormat' audioSessionGuid
Long Parameter List,NAudio.CoreAudioApi,AudioVolumeNotificationData,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioVolumeNotificationData.cs,AudioVolumeNotificationData,The method has 5 parameters. Parameters: eventContext' muted' masterVolume' channelVolume' guid
Long Parameter List,NAudio.CoreAudioApi.Interfaces,IAudioCaptureClient,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\IAudioCaptureClient.cs,GetBuffer,The method has 5 parameters. Parameters: dataBuffer' numFramesToRead' bufferFlags' devicePosition' qpcPosition
Long Parameter List,NAudio.CoreAudioApi.Interfaces,IAudioClient,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\IAudioClient.cs,Initialize,The method has 6 parameters. Parameters: shareMode' streamFlags' hnsBufferDuration' hnsPeriodicity' pFormat' audioSessionGuid
Long Parameter List,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetCoefficients,The method has 6 parameters. Parameters: aa0' aa1' aa2' b0' b1' b2
Long Parameter List,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,BiQuadFilter,The method has 6 parameters. Parameters: a0' a1' a2' b0' b1' b2
Long Parameter List,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SetMode,The method has 5 parameters. Parameters: interp' filtercnt' sinc' sinc_size' sinc_interpsize
Long Parameter List,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The method has 5 parameters. Parameters: outBuffer' outBufferIndex' nsamples_in' nsamples_out' nch
Long Parameter List,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample,The method has 9 parameters. Parameters: outBuffer' outBufferIndex' inBuffer' inBufferIndex' fracpos' nch' filter' filterIndex' filtsz
Long Parameter List,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample1,The method has 8 parameters. Parameters: outBuffer' outBufferIndex' inBuffer' inBufferIndex' fracpos' filter' filterIndex' filtsz
Long Parameter List,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample2,The method has 8 parameters. Parameters: outptr' outBufferIndex' inBuffer' inBufferIndex' fracpos' filter' filterIndex' filtsz
Long Parameter List,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,Apply,The method has 7 parameters. Parameters: inBuffer' inIndex' outBuffer' outIndex' ns' span' w
Long Parameter List,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,CreateCustomFormat,The method has 6 parameters. Parameters: tag' sampleRate' channels' averageBytesPerSecond' blockAlign' bitsPerSample
Long Parameter List,NAudio.MediaFoundation,IMFReadWriteClassFactory,C:\repos\naudio_NAudio\NAudio\MediaFoundation\IMFReadWriteClassFactory.cs,CreateInstanceFromURL,The method has 5 parameters. Parameters: clsid' pwszURL' pAttributes' riid' ppvObject
Long Parameter List,NAudio.MediaFoundation,IMFReadWriteClassFactory,C:\repos\naudio_NAudio\NAudio\MediaFoundation\IMFReadWriteClassFactory.cs,CreateInstanceFromObject,The method has 5 parameters. Parameters: clsid' punkObject' pAttributes' riid' ppvObject
Long Parameter List,NAudio.MediaFoundation,IMFSourceReader,C:\repos\naudio_NAudio\NAudio\MediaFoundation\IMFSourceReader.cs,ReadSample,The method has 6 parameters. Parameters: dwStreamIndex' dwControlFlags' pdwActualStreamIndex' pdwStreamFlags' pllTimestamp' ppSample
Long Parameter List,NAudio.Utils,ByteEncoding,C:\repos\naudio_NAudio\NAudio\Utils\ByteEncoding.cs,GetBytes,The method has 5 parameters. Parameters: chars' charIndex' charCount' bytes' byteIndex
Long Parameter List,NAudio.Utils,ByteEncoding,C:\repos\naudio_NAudio\NAudio\Utils\ByteEncoding.cs,GetChars,The method has 5 parameters. Parameters: bytes' byteIndex' byteCount' chars' charIndex
Long Parameter List,NAudio.Win8.Wave.WaveOutputs,NativeMethods,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WasapiOutRT.cs,ActivateAudioInterfaceAsync,The method has 5 parameters. Parameters: deviceInterfacePath' riid' activationParams' completionHandler' activationOperation
Long Parameter List,NAudio.Win8.Wave.WaveOutputs,IAudioClient2,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WasapiOutRT.cs,Initialize,The method has 6 parameters. Parameters: shareMode' streamFlags' hnsBufferDuration' hnsPeriodicity' pFormat' audioSessionGuid
Long Identifier,NAudio.CoreAudioApi,PropertyKeys,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropertyKeys.cs,,The length of the parameter PKEY_DeviceInterface_FriendlyName is 33.
Long Identifier,NAudio.CoreAudioApi,PropertyKeys,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropertyKeys.cs,,The length of the parameter PKEY_AudioEndpoint_ControlPanelPageProvider is 43.
Long Identifier,NAudio.CoreAudioApi,PropertyKeys,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropertyKeys.cs,,The length of the parameter PKEY_AudioEndpoint_Association is 30.
Long Identifier,NAudio.CoreAudioApi,PropertyKeys,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropertyKeys.cs,,The length of the parameter PKEY_AudioEndpoint_PhysicalSpeakers is 35.
Long Identifier,NAudio.CoreAudioApi,PropertyKeys,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropertyKeys.cs,,The length of the parameter PKEY_AudioEndpoint_Disable_SysFx is 32.
Long Identifier,NAudio.CoreAudioApi,PropertyKeys,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropertyKeys.cs,,The length of the parameter PKEY_AudioEndpoint_FullRangeSpeakers is 36.
Long Identifier,NAudio.CoreAudioApi,PropertyKeys,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropertyKeys.cs,,The length of the parameter PKEY_AudioEndpoint_Supports_EventDriven_Mode is 44.
Long Identifier,NAudio.CoreAudioApi,PropertyKeys,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropertyKeys.cs,,The length of the parameter PKEY_AudioEndpoint_JackSubType is 30.
Long Identifier,NAudio.CoreAudioApi,PropertyKeys,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropertyKeys.cs,,The length of the parameter PKEY_Device_ControllerDeviceId is 30.
Long Identifier,NAudio.CoreAudioApi.Interfaces,ErrorCodes,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\ErrorCodes.cs,,The length of the parameter AUDCLNT_E_BUFFER_OPERATION_PENDING is 34.
Long Identifier,NAudio.CoreAudioApi.Interfaces,ErrorCodes,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\ErrorCodes.cs,,The length of the parameter AUDCLNT_E_THREAD_NOT_REGISTERED is 31.
Long Identifier,NAudio.CoreAudioApi.Interfaces,ErrorCodes,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\ErrorCodes.cs,,The length of the parameter AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED is 36.
Long Identifier,NAudio.CoreAudioApi.Interfaces,ErrorCodes,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\ErrorCodes.cs,,The length of the parameter AUDCLNT_E_ENDPOINT_CREATE_FAILED is 32.
Long Identifier,NAudio.CoreAudioApi.Interfaces,ErrorCodes,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\ErrorCodes.cs,,The length of the parameter AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED is 34.
Long Identifier,NAudio.CoreAudioApi.Interfaces,ErrorCodes,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\ErrorCodes.cs,,The length of the parameter AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL is 38.
Long Identifier,NAudio.CoreAudioApi.Interfaces,ErrorCodes,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\ErrorCodes.cs,,The length of the parameter AUDCLNT_E_INCORRECT_BUFFER_SIZE is 31.
Long Identifier,NAudio.CoreAudioApi.Interfaces,ErrorCodes,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\ErrorCodes.cs,,The length of the parameter AUDCLNT_E_RESOURCES_INVALIDATED is 31.
Long Identifier,NAudio.SoundFont,ModulatorType,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\ModulatorType.cs,,The length of the parameter midiContinuousControllerNumber is 30.
Long Identifier,NAudio.MediaFoundation,AudioSubtypes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\AudioSubtypes.cs,,The length of the parameter MFAudioFormat_WMAudio_Lossless is 30.
Long Identifier,NAudio.MediaFoundation,AudioSubtypes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\AudioSubtypes.cs,,The length of the parameter KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL_PLUS is 48.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MF_TRANSFORM_CATEGORY_Attribute is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MFT_ENUM_HARDWARE_URL_Attribute is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MFT_CONNECTED_STREAM_ATTRIBUTE is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MFT_PREFERRED_OUTPUTTYPE_Attribute is 34.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MFT_HW_TIMESTAMP_WITH_QPC_Attribute is 35.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MFT_FIELDOFUSE_UNLOCK_Attribute is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MFT_ENUM_TRANSCODE_ONLY_ATTRIBUTE is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MF_MT_AUDIO_AVG_BYTES_PER_SECOND is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MF_MT_AUDIO_SAMPLES_PER_SECOND is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS is 39.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MF_MT_AUDIO_PREFER_WAVEFORMATEX is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MF_MT_AAC_AUDIO_PROFILE_LEVEL_INDICATION is 40.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_UNSUPPORTED_REPRESENTATION is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_UNSUPPORTED_BYTESTREAM_TYPE is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_UNSUPPORTED_RATE_TRANSITION is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_UNSUPPORTED_STATE_TRANSITION is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_UNRECOVERABLE_ERROR_OCCURRED is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_SAMPLE_HAS_TOO_MANY_BUFFERS is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_PROPERTY_TYPE_NOT_ALLOWED is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_PROPERTY_TYPE_NOT_SUPPORTED is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_PROPERTY_VECTOR_NOT_ALLOWED is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS is 44.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_RT_THROUGHPUT_NOT_AVAILABLE is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_RT_WORKQUEUE_CLASS_NOT_SPECIFIED is 37.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_BYTESTREAM_UNKNOWN_LENGTH is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_SESSION_PAUSEWHILESTOPPED is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_FORMAT_CHANGE_NOT_SUPPORTED is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_HW_MFT_FAILED_START_STREAMING is 34.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ASF_UNSUPPORTED_STREAM_TYPE is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_MEDIA_SOURCE_NO_STREAMS_SELECTED is 37.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_CANNOT_FIND_KEYFRAME_SAMPLE is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_BWLEVEL_NOT_SUPPORTED is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_STREAMGROUPS_NOT_SUPPORTED is 35.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_MANUALSS_NOT_SUPPORTED is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_INVALID_PRESENTATION_DESCRIPTOR is 40.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_CACHESTREAM_NOT_FOUND is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_INTERNAL_SERVER_ERROR is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_INCOMPATIBLE_PUSHSERVER is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_INVALID_PUSH_TEMPLATE is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_INVALID_PUSH_PUBLISHING_POINT is 38.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_UNSUPPORTED_CONFIGURATION is 34.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ASF_FILESINK_BITRATE_UNKNOWN is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_SINK_NO_SAMPLES_PROCESSED is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_VIDEO_REN_NO_DEINTERLACE_HW is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_VIDEO_REN_COPYPROT_FAILED is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_VIDEO_REN_SURFACE_NOT_SHARED is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NO_VIDEO_SAMPLE_AVAILABLE is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_AUDIO_PLAYBACK_DEVICE_IN_USE is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_AUDIO_PLAYBACK_DEVICE_INVALIDATED is 38.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_AUDIO_SERVICE_NOT_RUNNING is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TOPO_INVALID_OPTIONAL_NODE is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TOPO_CANNOT_FIND_DECRYPTOR is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TOPO_INVALID_TIME_ATTRIBUTES is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TOPO_MISSING_PRESENTATION_DESCRIPTOR is 41.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TOPO_MISSING_STREAM_DESCRIPTOR is 35.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TOPO_STREAM_DESCRIPTOR_NOT_SELECTED is 40.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TOPO_SINK_ACTIVATES_UNSUPPORTED is 36.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_SEQUENCER_UNKNOWN_SEGMENT_ID is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_S_SEQUENCER_CONTEXT_CANCELED is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_S_SEQUENCER_SEGMENT_AT_END_OF_STREAM is 39.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_INPUT_REMAINING is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROFILE_MISSING is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROFILE_INVALID_OR_CORRUPT is 41.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROFILE_TRUNCATED is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROPERTY_PID_NOT_RECOGNIZED is 42.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROPERTY_VARIANT_TYPE_WRONG is 42.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROPERTY_NOT_WRITEABLE is 37.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROPERTY_ARRAY_VALUE_WRONG_NUM_DIM is 49.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROPERTY_VALUE_SIZE_WRONG is 40.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROPERTY_VALUE_OUT_OF_RANGE is 42.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROPERTY_VALUE_INCOMPATIBLE is 42.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_OUTPUT_MEDIATYPE is 56.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_INPUT_MEDIATYPE is 55.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_MEDIATYPE_COMBINATION is 61.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_CONFLICTS_WITH_OTHER_CURRENTLY_ENABLED_FEATURES is 62.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_NEED_MORE_INPUT is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_SPKR_CONFIG is 51.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_CANNOT_CHANGE_MEDIATYPE_WHILE_PROCESSING is 55.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_S_TRANSFORM_DO_NOT_PROPAGATE_EVENT is 37.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_CANNOT_INITIALIZE_ACM_DRIVER is 43.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_DRM_HARDWARE_INCONSISTENT is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NO_CONTENT_PROTECTION_MANAGER is 34.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_LICENSE_RESTORE_NO_RIGHTS is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_BACKUP_RESTRICTED_LICENSE is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_LICENSE_RESTORE_NEEDS_INDIVIDUALIZATION is 44.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_WMDRMOTA_ACTION_ALREADY_SET is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_WMDRMOTA_DRM_HEADER_NOT_AVAILABLE is 38.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_WMDRMOTA_DRM_ENCRYPTION_SCHEME_NOT_SUPPORTED is 49.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TOPOLOGY_VERIFICATION_FAILED is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_SIGNATURE_VERIFICATION_FAILED is 34.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_GRL_EXTENSIBLE_ENTRY_NOT_FOUND is 35.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_S_VIDEO_DISABLED_WITH_UNKNOWN_SOFTWARE_OUTPUT is 48.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ALL_PROCESS_RESTART_REQUIRED is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_PEAUTH_SESSION_NOT_STARTED is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_INCOMPATIBLE_SAMPLE_PROTECTION is 35.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_HIGH_SECURITY_LEVEL_CONTENT_NOT_ALLOWED is 44.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TEST_SIGNED_COMPONENTS_NOT_ALLOWED is 39.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ITA_ERROR_PARSING_SAP_PARAMETERS is 37.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_POLICY_MGR_ACTION_OUTOFBOUNDS is 34.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_PROTECTION_GUID is 50.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ITA_OPL_DATA_NOT_INITIALIZED is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_OUTPUT is 41.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ITA_UNRECOGNIZED_DIGITAL_VIDEO_OUTPUT is 42.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_CLOCK_INVALID_CONTINUITY_KEY is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSCODE_NO_CONTAINERTYPE is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSCODE_PROFILE_NO_MATCHING_STREAMS is 42.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSCODE_NO_MATCHING_ENCODER is 34.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ALLOCATOR_NOT_INITIALIZED is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ALLOCATOR_ALREADY_COMMITED is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationInterop,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationInterop.cs,,The length of the parameter MF_SOURCE_READER_FIRST_AUDIO_STREAM is 35.
Long Identifier,NAudio.MediaFoundation,MediaFoundationInterop,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationInterop.cs,,The length of the parameter MF_SOURCE_READER_FIRST_VIDEO_STREAM is 35.
Long Identifier,NAudio.MediaFoundation,MF_SINK_WRITER_STATISTICS,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MF_SINK_WRITER_STATISTICS.cs,,The length of the parameter dwNumOutstandingSinkSampleRequests is 34.
Long Statement,NAudio.CoreAudioApi,AudioCaptureClient,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioCaptureClient.cs,GetBuffer,The length of the statement  "            Marshal.ThrowExceptionForHR(audioCaptureClientInterface.GetBuffer(out bufferPointer' out numFramesToRead' out bufferFlags' out devicePosition' out qpcPosition)); " is 161.
Long Statement,NAudio.CoreAudioApi,AudioCaptureClient,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioCaptureClient.cs,GetBuffer,The length of the statement  "            Marshal.ThrowExceptionForHR(audioCaptureClientInterface.GetBuffer(out bufferPointer' out numFramesToRead' out bufferFlags' out devicePosition' out qpcPosition)); " is 161.
Long Statement,NAudio.CoreAudioApi,AudioClient,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioClient.cs,Initialize,The length of the statement  "            int hresult = audioClientInterface.Initialize(shareMode' streamFlags' bufferDuration' periodicity' waveFormat' ref audioSessionGuid); " is 133.
Long Statement,NAudio.CoreAudioApi,AudioClient,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioClient.cs,IsFormatSupported,The length of the statement  "            IntPtr pointerToPtr = GetPointerToPointer(); // IntPtr.Zero; // Marshal.AllocHGlobal(Marshal.SizeOf<WaveFormatExtensible>()); " is 125.
Long Statement,NAudio.CoreAudioApi,AudioEndpointVolumeCallback,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioEndpointVolumeCallback.cs,OnNotify,The length of the statement  "            var notificationData = new AudioVolumeNotificationData(data.guidEventContext' data.bMuted' data.fMasterVolume' voldata' data.guidEventContext); " is 143.
Long Statement,NAudio.CoreAudioApi,AudioSessionControl,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioSessionControl.cs,Dispose,The length of the statement  "                Marshal.ThrowExceptionForHR(audioSessionControlInterface.UnregisterAudioSessionNotification(audioSessionEventCallback)); " is 120.
Long Statement,NAudio.CoreAudioApi,AudioSessionControl,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioSessionControl.cs,UnRegisterEventClient,The length of the statement  "                Marshal.ThrowExceptionForHR(audioSessionControlInterface.UnregisterAudioSessionNotification(audioSessionEventCallback)); " is 120.
Long Statement,NAudio.CoreAudioApi,AudioStreamVolume,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioStreamVolume.cs,CheckChannelIndex,The length of the statement  "                throw new ArgumentOutOfRangeException(parameter' "You must supply a valid channel index < current count of channels: " + channelCount.ToString()); " is 146.
Long Statement,NAudio.CoreAudioApi,AudioStreamVolume,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioStreamVolume.cs,SetAllVolumes,The length of the statement  "                    String.Format(CultureInfo.InvariantCulture' "SetAllVolumes MUST be supplied with a volume level for ALL channels. The AudioStream has {0} channels and you supplied {1} channels."' " is 179.
Long Statement,NAudio.CoreAudioApi,AudioStreamVolume,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioStreamVolume.cs,SetAllVolumes,The length of the statement  "                if (level < 0.0f) throw new ArgumentOutOfRangeException("levels"' "All volumes must be between 0.0 and 1.0. Invalid volume at index: " + i.ToString()); " is 151.
Long Statement,NAudio.CoreAudioApi,AudioStreamVolume,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioStreamVolume.cs,SetAllVolumes,The length of the statement  "                if (level > 1.0f) throw new ArgumentOutOfRangeException("levels"' "All volumes must be between 0.0 and 1.0. Invalid volume at index: " + i.ToString()); " is 151.
Long Statement,NAudio.CoreAudioApi,MMDevice,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\MMDevice.cs,GetAudioMeterInformation,The length of the statement  "            Marshal.ThrowExceptionForHR(deviceInterface.Activate(ref IID_IAudioMeterInformation' ClsCtx.ALL' IntPtr.Zero' out result)); " is 123.
Long Statement,NAudio.CoreAudioApi,MMDevice,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\MMDevice.cs,GetAudioEndpointVolume,The length of the statement  "            Marshal.ThrowExceptionForHR(deviceInterface.Activate(ref IID_IAudioEndpointVolume' ClsCtx.ALL' IntPtr.Zero' out result)); " is 121.
Long Statement,NAudio.CoreAudioApi,MMDevice,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\MMDevice.cs,GetAudioSessionManager,The length of the statement  "            Marshal.ThrowExceptionForHR(deviceInterface.Activate(ref IDD_IAudioSessionManager' ClsCtx.ALL' IntPtr.Zero' out result)); " is 121.
Long Statement,NAudio.CoreAudioApi.Interfaces,PropVariant,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropVariant.cs,GetBlobAsArrayOf,The length of the statement  "                throw new InvalidDataException(String.Format("Blob size {0} not a multiple of struct size {1}"' blobByteLength' structSize)); " is 125.
Long Statement,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,BlackmannHarrisWindow,The length of the statement  "            return 0.35875 - (0.48829 * Math.Cos((2 * Math.PI * n) / (frameSize - 1))) + (0.14128 * Math.Cos((4 * Math.PI * n) / (frameSize - 1))) - (0.01168 * Math.Cos((6 * Math.PI * n) / (frameSize - 1))); " is 195.
Long Statement,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SetMode,The length of the statement  "            m_filtercnt = (m_sincsize != 0) ? 0 : (filtercnt <= 0 ? 0 : filtercnt >= WDL_RESAMPLE_MAX_FILTERS ? WDL_RESAMPLE_MAX_FILTERS : filtercnt); " is 138.
Long Statement,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SetMode,The length of the statement  "            //Debug.WriteLine(String.Format("setting interp={0}' filtercnt={1}' sinc={2}'{3}\n"' m_interp' m_filtercnt' m_sincsize' m_sincoversize)); " is 137.
Long Statement,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,BuildLowPass,The length of the statement  "                        double val = 0.35875 - 0.48829 * Math.Cos(windowpos) + 0.14128 * Math.Cos(2 * windowpos) - 0.01168 * Math.Cos(6 * windowpos); // blackman-harris " is 144.
Long Statement,NAudio.Wave,WaveExtensionMethods,C:\repos\naudio_NAudio\NAudio\Wave\WaveExtensionMethods.cs,Init,The length of the statement  "            IWaveProvider provider = convertTo16Bit ? (IWaveProvider)new SampleToWaveProvider16(sampleProvider) : new SampleToWaveProvider(sampleProvider); " is 143.
Long Statement,NAudio.Wave,WaveBuffer,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveBuffer.cs,CheckValidityCount,The length of the statement  "                throw new ArgumentOutOfRangeException(argName' String.Format("{0} cannot set a count ({1}) that is not 4 bytes aligned "' argName' newNumberOfBytes)); " is 150.
Long Statement,NAudio.Wave,WaveBuffer,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveBuffer.cs,CheckValidityCount,The length of the statement  "                throw new ArgumentOutOfRangeException(argName' String.Format("{0} cannot set a count that exceed max count {1}"' argName' byteBuffer.Length / sizeOfValue)); " is 156.
Long Statement,NAudio.Wave,MediaFoundationReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\MediaFoundationReader.cs,GetCurrentWaveFormat,The length of the statement  "            // Two ways to query it' first is to ask for properties (second is to convert into WaveFormatEx using MFCreateWaveFormatExFromMFMediaType) " is 138.
Long Statement,NAudio.Wave,MediaFoundationReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\MediaFoundationReader.cs,CreateReader,The length of the statement  "            partialMediaType.SubType = settings.RequestFloatOutput ? AudioSubtypes.MFAudioFormat_Float : AudioSubtypes.MFAudioFormat_PCM; " is 125.
Long Statement,NAudio.Wave,MediaFoundationReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\MediaFoundationReader.cs,CreateReader,The length of the statement  "                reader.SetCurrentMediaType(MediaFoundationInterop.MF_SOURCE_READER_FIRST_AUDIO_STREAM' IntPtr.Zero' partialMediaType.MediaFoundationObject); " is 140.
Long Statement,NAudio.Wave,MediaFoundationReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\MediaFoundationReader.cs,CreateReader,The length of the statement  "                    reader.SetCurrentMediaType(MediaFoundationInterop.MF_SOURCE_READER_FIRST_AUDIO_STREAM' IntPtr.Zero' partialMediaType.MediaFoundationObject); " is 140.
Long Statement,NAudio.Wave,MediaFoundationReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\MediaFoundationReader.cs,Read,The length of the statement  "                pReader.ReadSample(MediaFoundationInterop.MF_SOURCE_READER_FIRST_AUDIO_STREAM' 0' out actualStreamIndex' out dwFlags' out timestamp' out pSample); " is 146.
Long Statement,NAudio.SoundFont,InfoChunk,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\InfoChunk.cs,ToString,The length of the statement  "			return string.Format("Bank Name: {0}\r\nAuthor: {1}\r\nCopyright: {2}\r\nCreation Date: {3}\r\nTools: {4}\r\nComments: {5}\r\nSound Engine: {6}\r\nSoundFont Version: {7}\r\nTarget Product: {8}\r\nData ROM: {9}\r\nROM Version: {10}"' " is 232.
Long Statement,NAudio.SoundFont,RiffChunk,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\RiffChunk.cs,GetNextSubChunk,The length of the statement  "			//Console.WriteLine("DEBUG Failed to GetNextSubChunk because Position is {0}' dataOffset{1}' chunkSize {2}"'riffFile.BaseStream.Position'dataOffset'chunkSize); " is 159.
Long Statement,NAudio.SoundFont,RiffChunk,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\RiffChunk.cs,GetData,The length of the statement  "				throw new InvalidDataException(String.Format("Couldn't read chunk's data Chunk: {0}' read {1} bytes"'this'data.Length)); " is 120.
Long Statement,NAudio.SoundFont,RiffChunk,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\RiffChunk.cs,GetDataAsStructureArray,The length of the statement  "                throw new InvalidDataException(String.Format("Chunk size is: {0} not a multiple of structure size: {1}"' chunkSize' s.Length)); " is 127.
Long Statement,NAudio.MediaFoundation,MediaFoundationTransform,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationTransform.cs,Read,The length of the statement  "                // n.b. in theory we ought to loop here' although we'd need to be careful as the next time into ReadFromTransform there could " is 125.
Long Statement,NAudio.MediaFoundation,MediaFoundationTransform,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationTransform.cs,Read,The length of the statement  "                // still be some leftover bytes in outputBuffer' which would get overwritten. Only introduce this if we find a transform that  " is 125.
Long Statement,NAudio.Wave.SampleProviders,Mono24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono24SampleChunkConverter.cs,GetNextSample,The length of the statement  "                sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f; " is 123.
Long Statement,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The length of the statement  "                sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f; " is 123.
Long Statement,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The length of the statement  "                sampleRight = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f; " is 124.
Long Statement,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The length of the statement  "                        double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362; " is 174.
Long Statement,NAudio.Wave.SampleProviders,StereoToMonoSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\StereoToMonoSampleProvider.cs,Read,The length of the statement  "            if (sourceBuffer == null || sourceBuffer.Length < sourceSamplesRequired) sourceBuffer = new float[sourceSamplesRequired]; " is 121.
Complex Conditional,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The conditional expression  "(headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3')"  is complex.
Complex Conditional,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The conditional expression  "(frame.RawData[offset + 0] == 'X') &&                  (frame.RawData[offset + 1] == 'i') &&                  (frame.RawData[offset + 2] == 'n') &&                  (frame.RawData[offset + 3] == 'g')"  is complex.
Complex Conditional,NAudio.Utils,FieldDescriptionHelper,C:\repos\naudio_NAudio\NAudio\Utils\FieldDescriptionHelper.cs,Describe,The conditional expression  "f.IsPublic && f.IsStatic && f.FieldType == typeof (Guid) && (Guid) f.GetValue(null) == guid"  is complex.
Virtual Method Call from Constructor,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WaveFileWriterRT,The constructor "WaveFileWriterRT" calls a virtual method "Serialize".
Magic Number,NAudio.Codecs,ALawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\ALawEncoder.cs,LinearToALawSample,The following statement contains a magic number: sign = ((~sample) >> 8) & 0x80;
Magic Number,NAudio.Codecs,ALawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\ALawEncoder.cs,LinearToALawSample,The following statement contains a magic number: if (sample >= 256)              {                  exponent = (int)ALawCompressTable[(sample >> 8) & 0x7F];                  mantissa = (sample >> (exponent + 3)) & 0x0F;                  compressedByte = (byte)((exponent << 4) | mantissa);              }              else              {                  compressedByte = (byte)(sample >> 4);              }
Magic Number,NAudio.Codecs,ALawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\ALawEncoder.cs,LinearToALawSample,The following statement contains a magic number: if (sample >= 256)              {                  exponent = (int)ALawCompressTable[(sample >> 8) & 0x7F];                  mantissa = (sample >> (exponent + 3)) & 0x0F;                  compressedByte = (byte)((exponent << 4) | mantissa);              }              else              {                  compressedByte = (byte)(sample >> 4);              }
Magic Number,NAudio.Codecs,ALawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\ALawEncoder.cs,LinearToALawSample,The following statement contains a magic number: if (sample >= 256)              {                  exponent = (int)ALawCompressTable[(sample >> 8) & 0x7F];                  mantissa = (sample >> (exponent + 3)) & 0x0F;                  compressedByte = (byte)((exponent << 4) | mantissa);              }              else              {                  compressedByte = (byte)(sample >> 4);              }
Magic Number,NAudio.Codecs,ALawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\ALawEncoder.cs,LinearToALawSample,The following statement contains a magic number: if (sample >= 256)              {                  exponent = (int)ALawCompressTable[(sample >> 8) & 0x7F];                  mantissa = (sample >> (exponent + 3)) & 0x0F;                  compressedByte = (byte)((exponent << 4) | mantissa);              }              else              {                  compressedByte = (byte)(sample >> 4);              }
Magic Number,NAudio.Codecs,ALawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\ALawEncoder.cs,LinearToALawSample,The following statement contains a magic number: if (sample >= 256)              {                  exponent = (int)ALawCompressTable[(sample >> 8) & 0x7F];                  mantissa = (sample >> (exponent + 3)) & 0x0F;                  compressedByte = (byte)((exponent << 4) | mantissa);              }              else              {                  compressedByte = (byte)(sample >> 4);              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 0; i < 3; i++)                  s.Band[band].sg[i] = s.Band[band].p[i] >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 0; i < 3; i++)                  s.Band[band].sg[i] = s.Band[band].p[i] >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd1 = Saturate(s.Band[band].a[1] << 2);
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: if (wd2 > 32767)                  wd2 = 32767;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: if (wd2 > 32767)                  wd2 = 32767;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd3 = (s.Band[band].sg[0] == s.Band[band].sg[2]) ? 128 : -128;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd3 = (s.Band[band].sg[0] == s.Band[band].sg[2]) ? 128 : -128;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd3 = (s.Band[band].sg[0] == s.Band[band].sg[2]) ? 128 : -128;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd3 += (wd2 >> 7);
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd3 += (s.Band[band].a[2] * 32512) >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd3 += (s.Band[band].a[2] * 32512) >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd3 += (s.Band[band].a[2] * 32512) >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: if (wd3 > 12288)                  wd3 = 12288;              else if (wd3 < -12288)                  wd3 = -12288;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: if (wd3 > 12288)                  wd3 = 12288;              else if (wd3 < -12288)                  wd3 = -12288;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: if (wd3 > 12288)                  wd3 = 12288;              else if (wd3 < -12288)                  wd3 = -12288;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: if (wd3 > 12288)                  wd3 = 12288;              else if (wd3 < -12288)                  wd3 = -12288;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: s.Band[band].ap[2] = wd3;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: s.Band[band].sg[0] = s.Band[band].p[0] >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: s.Band[band].sg[1] = s.Band[band].p[1] >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd1 = (s.Band[band].sg[0] == s.Band[band].sg[1]) ? 192 : -192;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd1 = (s.Band[band].sg[0] == s.Band[band].sg[1]) ? 192 : -192;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd2 = (s.Band[band].a[1] * 32640) >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd2 = (s.Band[band].a[1] * 32640) >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd3 = Saturate(15360 - s.Band[band].ap[2]);
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd3 = Saturate(15360 - s.Band[band].ap[2]);
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd1 = (d == 0) ? 0 : 128;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: s.Band[band].sg[0] = d >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 1; i < 7; i++)              {                  s.Band[band].sg[i] = s.Band[band].d[i] >> 15;                  wd2 = (s.Band[band].sg[i] == s.Band[band].sg[0]) ? wd1 : -wd1;                  wd3 = (s.Band[band].b[i] * 32640) >> 15;                  s.Band[band].bp[i] = Saturate(wd2 + wd3);              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 1; i < 7; i++)              {                  s.Band[band].sg[i] = s.Band[band].d[i] >> 15;                  wd2 = (s.Band[band].sg[i] == s.Band[band].sg[0]) ? wd1 : -wd1;                  wd3 = (s.Band[band].b[i] * 32640) >> 15;                  s.Band[band].bp[i] = Saturate(wd2 + wd3);              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 1; i < 7; i++)              {                  s.Band[band].sg[i] = s.Band[band].d[i] >> 15;                  wd2 = (s.Band[band].sg[i] == s.Band[band].sg[0]) ? wd1 : -wd1;                  wd3 = (s.Band[band].b[i] * 32640) >> 15;                  s.Band[band].bp[i] = Saturate(wd2 + wd3);              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 1; i < 7; i++)              {                  s.Band[band].sg[i] = s.Band[band].d[i] >> 15;                  wd2 = (s.Band[band].sg[i] == s.Band[band].sg[0]) ? wd1 : -wd1;                  wd3 = (s.Band[band].b[i] * 32640) >> 15;                  s.Band[band].bp[i] = Saturate(wd2 + wd3);              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 6; i > 0; i--)              {                  s.Band[band].d[i] = s.Band[band].d[i - 1];                  s.Band[band].b[i] = s.Band[band].bp[i];              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 2; i > 0; i--)              {                  s.Band[band].r[i] = s.Band[band].r[i - 1];                  s.Band[band].p[i] = s.Band[band].p[i - 1];                  s.Band[band].a[i] = s.Band[band].ap[i];              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd1 = (s.Band[band].a[1] * wd1) >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd2 = Saturate(s.Band[band].r[2] + s.Band[band].r[2]);
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd2 = Saturate(s.Band[band].r[2] + s.Band[band].r[2]);
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd2 = (s.Band[band].a[2] * wd2) >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd2 = (s.Band[band].a[2] * wd2) >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 6; i > 0; i--)              {                  wd1 = Saturate(s.Band[band].d[i] + s.Band[band].d[i]);                  s.Band[band].sz += (s.Band[band].b[i] * wd1) >> 15;              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 6; i > 0; i--)              {                  wd1 = Saturate(s.Band[band].d[i] + s.Band[band].d[i]);                  s.Band[band].sz += (s.Band[band].b[i] * wd1) >> 15;              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: this.Band = new Band[2] { new Band()' new Band() };
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: this.QmfSignalHistory = new int[24];
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: if (rate == 48000)                  this.BitsPerSample = 6;              else if (rate == 56000)                  this.BitsPerSample = 7;              else if (rate == 64000)                  this.BitsPerSample = 8;              else                  throw new ArgumentException("Invalid rate' should be 48000' 56000 or 64000");
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: if (rate == 48000)                  this.BitsPerSample = 6;              else if (rate == 56000)                  this.BitsPerSample = 7;              else if (rate == 64000)                  this.BitsPerSample = 8;              else                  throw new ArgumentException("Invalid rate' should be 48000' 56000 or 64000");
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: if (rate == 48000)                  this.BitsPerSample = 6;              else if (rate == 56000)                  this.BitsPerSample = 7;              else if (rate == 64000)                  this.BitsPerSample = 8;              else                  throw new ArgumentException("Invalid rate' should be 48000' 56000 or 64000");
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: if (rate == 48000)                  this.BitsPerSample = 6;              else if (rate == 56000)                  this.BitsPerSample = 7;              else if (rate == 64000)                  this.BitsPerSample = 8;              else                  throw new ArgumentException("Invalid rate' should be 48000' 56000 or 64000");
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: if (rate == 48000)                  this.BitsPerSample = 6;              else if (rate == 56000)                  this.BitsPerSample = 7;              else if (rate == 64000)                  this.BitsPerSample = 8;              else                  throw new ArgumentException("Invalid rate' should be 48000' 56000 or 64000");
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: if (rate == 48000)                  this.BitsPerSample = 6;              else if (rate == 56000)                  this.BitsPerSample = 7;              else if (rate == 64000)                  this.BitsPerSample = 8;              else                  throw new ArgumentException("Invalid rate' should be 48000' 56000 or 64000");
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: if (((options & G722Flags.Packed) == G722Flags.Packed) && this.BitsPerSample != 8)                  this.Packed = true;              else                  this.Packed = false;
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: this.Band[0].det = 32;
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: this.Band[1].det = 8;
Magic Number,NAudio.Codecs,MuLawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\MuLawEncoder.cs,LinearToMuLawSample,The following statement contains a magic number: int sign = (sample >> 8) & 0x80;
Magic Number,NAudio.Codecs,MuLawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\MuLawEncoder.cs,LinearToMuLawSample,The following statement contains a magic number: int exponent = (int)MuLawCompressTable[(sample >> 7) & 0xFF];
Magic Number,NAudio.Codecs,MuLawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\MuLawEncoder.cs,LinearToMuLawSample,The following statement contains a magic number: int mantissa = (sample >> (exponent + 3)) & 0x0F;
Magic Number,NAudio.Codecs,MuLawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\MuLawEncoder.cs,LinearToMuLawSample,The following statement contains a magic number: int compressedByte = ~(sign | (exponent << 4) | mantissa);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetLowPassFilter,The following statement contains a magic number: var w0 = 2 * Math.PI * cutoffFrequency / sampleRate;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetLowPassFilter,The following statement contains a magic number: var alpha = Math.Sin(w0) / (2 * q);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetLowPassFilter,The following statement contains a magic number: var b0 = (1 - cosw0) / 2;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetLowPassFilter,The following statement contains a magic number: var b2 = (1 - cosw0) / 2;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetLowPassFilter,The following statement contains a magic number: var aa1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetPeakingEq,The following statement contains a magic number: var w0 = 2 * Math.PI * centreFrequency / sampleRate;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetPeakingEq,The following statement contains a magic number: var alpha = sinw0 / (2 * q);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetPeakingEq,The following statement contains a magic number: var a = Math.Pow(10' dbGain / 40);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetPeakingEq,The following statement contains a magic number: var a = Math.Pow(10' dbGain / 40);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetPeakingEq,The following statement contains a magic number: var b1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetPeakingEq,The following statement contains a magic number: var aa1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetHighPassFilter,The following statement contains a magic number: var w0 = 2 * Math.PI * cutoffFrequency / sampleRate;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetHighPassFilter,The following statement contains a magic number: var alpha = Math.Sin(w0) / (2 * q);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetHighPassFilter,The following statement contains a magic number: var b0 = (1 + cosw0) / 2;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetHighPassFilter,The following statement contains a magic number: var b2 = (1 + cosw0) / 2;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetHighPassFilter,The following statement contains a magic number: var aa1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,BandPassFilterConstantSkirtGain,The following statement contains a magic number: var w0 = 2 * Math.PI * centreFrequency / sampleRate;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,BandPassFilterConstantSkirtGain,The following statement contains a magic number: var alpha = sinw0 / (2 * q);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,BandPassFilterConstantSkirtGain,The following statement contains a magic number: var b0 = sinw0 / 2;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,BandPassFilterConstantSkirtGain,The following statement contains a magic number: var b2 = -sinw0 / 2;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,BandPassFilterConstantSkirtGain,The following statement contains a magic number: var a1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,BandPassFilterConstantPeakGain,The following statement contains a magic number: var w0 = 2 * Math.PI * centreFrequency / sampleRate;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,BandPassFilterConstantPeakGain,The following statement contains a magic number: var alpha = sinw0 / (2 * q);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,BandPassFilterConstantPeakGain,The following statement contains a magic number: var a1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,NotchFilter,The following statement contains a magic number: var w0 = 2 * Math.PI * centreFrequency / sampleRate;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,NotchFilter,The following statement contains a magic number: var alpha = sinw0 / (2 * q);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,NotchFilter,The following statement contains a magic number: var b1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,NotchFilter,The following statement contains a magic number: var a1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,AllPassFilter,The following statement contains a magic number: var w0 = 2 * Math.PI * centreFrequency / sampleRate;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,AllPassFilter,The following statement contains a magic number: var alpha = sinw0 / (2 * q);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,AllPassFilter,The following statement contains a magic number: var b1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,AllPassFilter,The following statement contains a magic number: var a1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,LowShelf,The following statement contains a magic number: var w0 = 2 * Math.PI * cutoffFrequency / sampleRate;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,LowShelf,The following statement contains a magic number: var a = Math.Pow(10' dbGain / 40);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,LowShelf,The following statement contains a magic number: var a = Math.Pow(10' dbGain / 40);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,LowShelf,The following statement contains a magic number: var alpha = sinw0 / 2 * Math.Sqrt((a + 1 / a) * (1 / shelfSlope - 1) + 2);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,LowShelf,The following statement contains a magic number: var alpha = sinw0 / 2 * Math.Sqrt((a + 1 / a) * (1 / shelfSlope - 1) + 2);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,LowShelf,The following statement contains a magic number: var temp = 2 * Math.Sqrt(a) * alpha;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,LowShelf,The following statement contains a magic number: var b1 = 2 * a * ((a - 1) - (a + 1) * cosw0);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,LowShelf,The following statement contains a magic number: var a1 = -2 * ((a - 1) + (a + 1) * cosw0);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,HighShelf,The following statement contains a magic number: var w0 = 2 * Math.PI * cutoffFrequency / sampleRate;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,HighShelf,The following statement contains a magic number: var a = Math.Pow(10' dbGain / 40);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,HighShelf,The following statement contains a magic number: var a = Math.Pow(10' dbGain / 40);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,HighShelf,The following statement contains a magic number: var alpha = sinw0 / 2 * Math.Sqrt((a + 1 / a) * (1 / shelfSlope - 1) + 2);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,HighShelf,The following statement contains a magic number: var alpha = sinw0 / 2 * Math.Sqrt((a + 1 / a) * (1 / shelfSlope - 1) + 2);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,HighShelf,The following statement contains a magic number: var temp = 2 * Math.Sqrt(a) * alpha;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,HighShelf,The following statement contains a magic number: var b1 = -2 * a * ((a - 1) + (a + 1) * cosw0);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,HighShelf,The following statement contains a magic number: var a1 = 2 * ((a - 1) - (a + 1) * cosw0);
Magic Number,NAudio.Dsp,EnvelopeDetector,C:\repos\naudio_NAudio\NAudio\Dsp\EnvelopeDetector.cs,SetCoef,The following statement contains a magic number: coeff = Math.Exp(-1.0 / (0.001 * ms * sampleRate));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,FFT,The following statement contains a magic number: for (i = 0; i < m; i++)                  n *= 2;
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,HammingWindow,The following statement contains a magic number: return 0.54 - 0.46 * Math.Cos((2 * Math.PI * n) / (frameSize - 1));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,HammingWindow,The following statement contains a magic number: return 0.54 - 0.46 * Math.Cos((2 * Math.PI * n) / (frameSize - 1));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,HammingWindow,The following statement contains a magic number: return 0.54 - 0.46 * Math.Cos((2 * Math.PI * n) / (frameSize - 1));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,HannWindow,The following statement contains a magic number: return 0.5 * (1 - Math.Cos((2 * Math.PI * n) / (frameSize - 1)));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,HannWindow,The following statement contains a magic number: return 0.5 * (1 - Math.Cos((2 * Math.PI * n) / (frameSize - 1)));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,BlackmannHarrisWindow,The following statement contains a magic number: return 0.35875 - (0.48829 * Math.Cos((2 * Math.PI * n) / (frameSize - 1))) + (0.14128 * Math.Cos((4 * Math.PI * n) / (frameSize - 1))) - (0.01168 * Math.Cos((6 * Math.PI * n) / (frameSize - 1)));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,BlackmannHarrisWindow,The following statement contains a magic number: return 0.35875 - (0.48829 * Math.Cos((2 * Math.PI * n) / (frameSize - 1))) + (0.14128 * Math.Cos((4 * Math.PI * n) / (frameSize - 1))) - (0.01168 * Math.Cos((6 * Math.PI * n) / (frameSize - 1)));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,BlackmannHarrisWindow,The following statement contains a magic number: return 0.35875 - (0.48829 * Math.Cos((2 * Math.PI * n) / (frameSize - 1))) + (0.14128 * Math.Cos((4 * Math.PI * n) / (frameSize - 1))) - (0.01168 * Math.Cos((6 * Math.PI * n) / (frameSize - 1)));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,BlackmannHarrisWindow,The following statement contains a magic number: return 0.35875 - (0.48829 * Math.Cos((2 * Math.PI * n) / (frameSize - 1))) + (0.14128 * Math.Cos((4 * Math.PI * n) / (frameSize - 1))) - (0.01168 * Math.Cos((6 * Math.PI * n) / (frameSize - 1)));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,BlackmannHarrisWindow,The following statement contains a magic number: return 0.35875 - (0.48829 * Math.Cos((2 * Math.PI * n) / (frameSize - 1))) + (0.14128 * Math.Cos((4 * Math.PI * n) / (frameSize - 1))) - (0.01168 * Math.Cos((6 * Math.PI * n) / (frameSize - 1)));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,BlackmannHarrisWindow,The following statement contains a magic number: return 0.35875 - (0.48829 * Math.Cos((2 * Math.PI * n) / (frameSize - 1))) + (0.14128 * Math.Cos((4 * Math.PI * n) / (frameSize - 1))) - (0.01168 * Math.Cos((6 * Math.PI * n) / (frameSize - 1)));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,BlackmannHarrisWindow,The following statement contains a magic number: return 0.35875 - (0.48829 * Math.Cos((2 * Math.PI * n) / (frameSize - 1))) + (0.14128 * Math.Cos((4 * Math.PI * n) / (frameSize - 1))) - (0.01168 * Math.Cos((6 * Math.PI * n) / (frameSize - 1)));
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,WdlResampler,The following statement contains a magic number: m_sratein = 44100.0;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,WdlResampler,The following statement contains a magic number: m_srateout = 44100.0;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SetMode,The following statement contains a magic number: m_sincsize = sinc && sinc_size >= 4 ? sinc_size > 8192 ? 8192 : sinc_size : 0;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SetMode,The following statement contains a magic number: m_sincsize = sinc && sinc_size >= 4 ? sinc_size > 8192 ? 8192 : sinc_size : 0;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SetMode,The following statement contains a magic number: m_sincsize = sinc && sinc_size >= 4 ? sinc_size > 8192 ? 8192 : sinc_size : 0;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SetMode,The following statement contains a magic number: m_sincoversize = (m_sincsize != 0) ? (sinc_interpsize <= 1 ? 1 : sinc_interpsize >= 4096 ? 4096 : sinc_interpsize) : 1;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SetMode,The following statement contains a magic number: m_sincoversize = (m_sincsize != 0) ? (sinc_interpsize <= 1 ? 1 : sinc_interpsize >= 4096 ? 4096 : sinc_interpsize) : 1;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResamplePrepare,The following statement contains a magic number: int hfs = fsize / 2;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResamplePrepare,The following statement contains a magic number: if (!m_feedmode) sreq = (int)(m_ratio * out_samples) + 4 + fsize - m_samples_in_rsinbuf;              else sreq = out_samples;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResamplePrepare,The following statement contains a magic number: if (sz != sreq)              {                  if (sreq > 4 && (sz == 0))                  {                      sreq /= 2;                      goto again; // try again with half the size                  }                  // todo: notify of error?                  sreq = sz;              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResamplePrepare,The following statement contains a magic number: if (sz != sreq)              {                  if (sreq > 4 && (sz == 0))                  {                      sreq /= 2;                      goto again; // try again with half the size                  }                  // todo: notify of error?                  sreq = sz;              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (nsamples_in < m_last_requested) // flush out to ensure we can deliver              {                  int fsize = (m_last_requested - nsamples_in) * 2 + m_sincsize * 2;                    int alloc_size = (m_samples_in_rsinbuf + fsize) * nch;                  Array.Resize(ref m_rsinbuf' alloc_size);                  if (m_rsinbuf.Length == alloc_size)                  {                      Array.Clear(m_rsinbuf' m_samples_in_rsinbuf * nch' fsize * nch);                      rsinbuf_availtemp = m_samples_in_rsinbuf + fsize;                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (nsamples_in < m_last_requested) // flush out to ensure we can deliver              {                  int fsize = (m_last_requested - nsamples_in) * 2 + m_sincsize * 2;                    int alloc_size = (m_samples_in_rsinbuf + fsize) * nch;                  Array.Resize(ref m_rsinbuf' alloc_size);                  if (m_rsinbuf.Length == alloc_size)                  {                      Array.Clear(m_rsinbuf' m_samples_in_rsinbuf * nch' fsize * nch);                      rsinbuf_availtemp = m_samples_in_rsinbuf + fsize;                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (ret > 0 && rsinbuf_availtemp > m_samples_in_rsinbuf) // we had to pad!!              {                  // check for the case where rsinbuf_availtemp>m_samples_in_rsinbuf' decrease ret down to actual valid samples                  double adj = (srcpos - m_samples_in_rsinbuf + outlatadj) / drspos;                  if (adj > 0)                  {                      ret -= (int)(adj + 0.5);                      if (ret < 0) ret = 0;                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,BuildLowPass,The following statement contains a magic number: if (m_filter_ratio != filtpos ||                  m_filter_coeffs_size != wantsize ||                  m_lp_oversize != wantinterp)              {                  m_lp_oversize = wantinterp;                  m_filter_ratio = filtpos;                    // build lowpass filter                  int allocsize = (wantsize + 1) * m_lp_oversize;                  Array.Resize(ref m_filter_coeffs' allocsize);                  //int cfout = 0; // this is an index into m_filter_coeffs                  if (m_filter_coeffs.Length == allocsize)                  {                      m_filter_coeffs_size = wantsize;                        int sz = wantsize * m_lp_oversize;                      int hsz = sz / 2;                      double filtpower = 0.0;                      double windowpos = 0.0;                      double dwindowpos = 2.0 * PI / (double)(sz);                      double dsincpos = PI / m_lp_oversize * filtpos; // filtpos is outrate/inrate' i.e. 0.5 is going to half rate                      double sincpos = dsincpos * (double)(-hsz);                        int x;                      for (x = -hsz; x < hsz + m_lp_oversize; x++)                      {                          double val = 0.35875 - 0.48829 * Math.Cos(windowpos) + 0.14128 * Math.Cos(2 * windowpos) - 0.01168 * Math.Cos(6 * windowpos); // blackman-harris                          if (x != 0) val *= Math.Sin(sincpos) / sincpos;                            windowpos += dwindowpos;                          sincpos += dsincpos;                            m_filter_coeffs[hsz + x] = (WDL_SincFilterSample)val;                          if (x < hsz) filtpower += val;                      }                      filtpower = m_lp_oversize / filtpower;                      for (x = 0; x < sz + m_lp_oversize; x++)                      {                          m_filter_coeffs[x] = (WDL_SincFilterSample)(m_filter_coeffs[x] * filtpower);                      }                  }                  else m_filter_coeffs_size = 0;                }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,BuildLowPass,The following statement contains a magic number: if (m_filter_ratio != filtpos ||                  m_filter_coeffs_size != wantsize ||                  m_lp_oversize != wantinterp)              {                  m_lp_oversize = wantinterp;                  m_filter_ratio = filtpos;                    // build lowpass filter                  int allocsize = (wantsize + 1) * m_lp_oversize;                  Array.Resize(ref m_filter_coeffs' allocsize);                  //int cfout = 0; // this is an index into m_filter_coeffs                  if (m_filter_coeffs.Length == allocsize)                  {                      m_filter_coeffs_size = wantsize;                        int sz = wantsize * m_lp_oversize;                      int hsz = sz / 2;                      double filtpower = 0.0;                      double windowpos = 0.0;                      double dwindowpos = 2.0 * PI / (double)(sz);                      double dsincpos = PI / m_lp_oversize * filtpos; // filtpos is outrate/inrate' i.e. 0.5 is going to half rate                      double sincpos = dsincpos * (double)(-hsz);                        int x;                      for (x = -hsz; x < hsz + m_lp_oversize; x++)                      {                          double val = 0.35875 - 0.48829 * Math.Cos(windowpos) + 0.14128 * Math.Cos(2 * windowpos) - 0.01168 * Math.Cos(6 * windowpos); // blackman-harris                          if (x != 0) val *= Math.Sin(sincpos) / sincpos;                            windowpos += dwindowpos;                          sincpos += dsincpos;                            m_filter_coeffs[hsz + x] = (WDL_SincFilterSample)val;                          if (x < hsz) filtpower += val;                      }                      filtpower = m_lp_oversize / filtpower;                      for (x = 0; x < sz + m_lp_oversize; x++)                      {                          m_filter_coeffs[x] = (WDL_SincFilterSample)(m_filter_coeffs[x] * filtpower);                      }                  }                  else m_filter_coeffs_size = 0;                }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,BuildLowPass,The following statement contains a magic number: if (m_filter_ratio != filtpos ||                  m_filter_coeffs_size != wantsize ||                  m_lp_oversize != wantinterp)              {                  m_lp_oversize = wantinterp;                  m_filter_ratio = filtpos;                    // build lowpass filter                  int allocsize = (wantsize + 1) * m_lp_oversize;                  Array.Resize(ref m_filter_coeffs' allocsize);                  //int cfout = 0; // this is an index into m_filter_coeffs                  if (m_filter_coeffs.Length == allocsize)                  {                      m_filter_coeffs_size = wantsize;                        int sz = wantsize * m_lp_oversize;                      int hsz = sz / 2;                      double filtpower = 0.0;                      double windowpos = 0.0;                      double dwindowpos = 2.0 * PI / (double)(sz);                      double dsincpos = PI / m_lp_oversize * filtpos; // filtpos is outrate/inrate' i.e. 0.5 is going to half rate                      double sincpos = dsincpos * (double)(-hsz);                        int x;                      for (x = -hsz; x < hsz + m_lp_oversize; x++)                      {                          double val = 0.35875 - 0.48829 * Math.Cos(windowpos) + 0.14128 * Math.Cos(2 * windowpos) - 0.01168 * Math.Cos(6 * windowpos); // blackman-harris                          if (x != 0) val *= Math.Sin(sincpos) / sincpos;                            windowpos += dwindowpos;                          sincpos += dsincpos;                            m_filter_coeffs[hsz + x] = (WDL_SincFilterSample)val;                          if (x < hsz) filtpower += val;                      }                      filtpower = m_lp_oversize / filtpower;                      for (x = 0; x < sz + m_lp_oversize; x++)                      {                          m_filter_coeffs[x] = (WDL_SincFilterSample)(m_filter_coeffs[x] * filtpower);                      }                  }                  else m_filter_coeffs_size = 0;                }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,BuildLowPass,The following statement contains a magic number: if (m_filter_ratio != filtpos ||                  m_filter_coeffs_size != wantsize ||                  m_lp_oversize != wantinterp)              {                  m_lp_oversize = wantinterp;                  m_filter_ratio = filtpos;                    // build lowpass filter                  int allocsize = (wantsize + 1) * m_lp_oversize;                  Array.Resize(ref m_filter_coeffs' allocsize);                  //int cfout = 0; // this is an index into m_filter_coeffs                  if (m_filter_coeffs.Length == allocsize)                  {                      m_filter_coeffs_size = wantsize;                        int sz = wantsize * m_lp_oversize;                      int hsz = sz / 2;                      double filtpower = 0.0;                      double windowpos = 0.0;                      double dwindowpos = 2.0 * PI / (double)(sz);                      double dsincpos = PI / m_lp_oversize * filtpos; // filtpos is outrate/inrate' i.e. 0.5 is going to half rate                      double sincpos = dsincpos * (double)(-hsz);                        int x;                      for (x = -hsz; x < hsz + m_lp_oversize; x++)                      {                          double val = 0.35875 - 0.48829 * Math.Cos(windowpos) + 0.14128 * Math.Cos(2 * windowpos) - 0.01168 * Math.Cos(6 * windowpos); // blackman-harris                          if (x != 0) val *= Math.Sin(sincpos) / sincpos;                            windowpos += dwindowpos;                          sincpos += dsincpos;                            m_filter_coeffs[hsz + x] = (WDL_SincFilterSample)val;                          if (x < hsz) filtpower += val;                      }                      filtpower = m_lp_oversize / filtpower;                      for (x = 0; x < sz + m_lp_oversize; x++)                      {                          m_filter_coeffs[x] = (WDL_SincFilterSample)(m_filter_coeffs[x] * filtpower);                      }                  }                  else m_filter_coeffs_size = 0;                }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,BuildLowPass,The following statement contains a magic number: if (m_filter_ratio != filtpos ||                  m_filter_coeffs_size != wantsize ||                  m_lp_oversize != wantinterp)              {                  m_lp_oversize = wantinterp;                  m_filter_ratio = filtpos;                    // build lowpass filter                  int allocsize = (wantsize + 1) * m_lp_oversize;                  Array.Resize(ref m_filter_coeffs' allocsize);                  //int cfout = 0; // this is an index into m_filter_coeffs                  if (m_filter_coeffs.Length == allocsize)                  {                      m_filter_coeffs_size = wantsize;                        int sz = wantsize * m_lp_oversize;                      int hsz = sz / 2;                      double filtpower = 0.0;                      double windowpos = 0.0;                      double dwindowpos = 2.0 * PI / (double)(sz);                      double dsincpos = PI / m_lp_oversize * filtpos; // filtpos is outrate/inrate' i.e. 0.5 is going to half rate                      double sincpos = dsincpos * (double)(-hsz);                        int x;                      for (x = -hsz; x < hsz + m_lp_oversize; x++)                      {                          double val = 0.35875 - 0.48829 * Math.Cos(windowpos) + 0.14128 * Math.Cos(2 * windowpos) - 0.01168 * Math.Cos(6 * windowpos); // blackman-harris                          if (x != 0) val *= Math.Sin(sincpos) / sincpos;                            windowpos += dwindowpos;                          sincpos += dsincpos;                            m_filter_coeffs[hsz + x] = (WDL_SincFilterSample)val;                          if (x < hsz) filtpower += val;                      }                      filtpower = m_lp_oversize / filtpower;                      for (x = 0; x < sz + m_lp_oversize; x++)                      {                          m_filter_coeffs[x] = (WDL_SincFilterSample)(m_filter_coeffs[x] * filtpower);                      }                  }                  else m_filter_coeffs_size = 0;                }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,BuildLowPass,The following statement contains a magic number: if (m_filter_ratio != filtpos ||                  m_filter_coeffs_size != wantsize ||                  m_lp_oversize != wantinterp)              {                  m_lp_oversize = wantinterp;                  m_filter_ratio = filtpos;                    // build lowpass filter                  int allocsize = (wantsize + 1) * m_lp_oversize;                  Array.Resize(ref m_filter_coeffs' allocsize);                  //int cfout = 0; // this is an index into m_filter_coeffs                  if (m_filter_coeffs.Length == allocsize)                  {                      m_filter_coeffs_size = wantsize;                        int sz = wantsize * m_lp_oversize;                      int hsz = sz / 2;                      double filtpower = 0.0;                      double windowpos = 0.0;                      double dwindowpos = 2.0 * PI / (double)(sz);                      double dsincpos = PI / m_lp_oversize * filtpos; // filtpos is outrate/inrate' i.e. 0.5 is going to half rate                      double sincpos = dsincpos * (double)(-hsz);                        int x;                      for (x = -hsz; x < hsz + m_lp_oversize; x++)                      {                          double val = 0.35875 - 0.48829 * Math.Cos(windowpos) + 0.14128 * Math.Cos(2 * windowpos) - 0.01168 * Math.Cos(6 * windowpos); // blackman-harris                          if (x != 0) val *= Math.Sin(sincpos) / sincpos;                            windowpos += dwindowpos;                          sincpos += dsincpos;                            m_filter_coeffs[hsz + x] = (WDL_SincFilterSample)val;                          if (x < hsz) filtpower += val;                      }                      filtpower = m_lp_oversize / filtpower;                      for (x = 0; x < sz + m_lp_oversize; x++)                      {                          m_filter_coeffs[x] = (WDL_SincFilterSample)(m_filter_coeffs[x] * filtpower);                      }                  }                  else m_filter_coeffs_size = 0;                }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,BuildLowPass,The following statement contains a magic number: if (m_filter_ratio != filtpos ||                  m_filter_coeffs_size != wantsize ||                  m_lp_oversize != wantinterp)              {                  m_lp_oversize = wantinterp;                  m_filter_ratio = filtpos;                    // build lowpass filter                  int allocsize = (wantsize + 1) * m_lp_oversize;                  Array.Resize(ref m_filter_coeffs' allocsize);                  //int cfout = 0; // this is an index into m_filter_coeffs                  if (m_filter_coeffs.Length == allocsize)                  {                      m_filter_coeffs_size = wantsize;                        int sz = wantsize * m_lp_oversize;                      int hsz = sz / 2;                      double filtpower = 0.0;                      double windowpos = 0.0;                      double dwindowpos = 2.0 * PI / (double)(sz);                      double dsincpos = PI / m_lp_oversize * filtpos; // filtpos is outrate/inrate' i.e. 0.5 is going to half rate                      double sincpos = dsincpos * (double)(-hsz);                        int x;                      for (x = -hsz; x < hsz + m_lp_oversize; x++)                      {                          double val = 0.35875 - 0.48829 * Math.Cos(windowpos) + 0.14128 * Math.Cos(2 * windowpos) - 0.01168 * Math.Cos(6 * windowpos); // blackman-harris                          if (x != 0) val *= Math.Sin(sincpos) / sincpos;                            windowpos += dwindowpos;                          sincpos += dsincpos;                            m_filter_coeffs[hsz + x] = (WDL_SincFilterSample)val;                          if (x < hsz) filtpower += val;                      }                      filtpower = m_lp_oversize / filtpower;                      for (x = 0; x < sz + m_lp_oversize; x++)                      {                          m_filter_coeffs[x] = (WDL_SincFilterSample)(m_filter_coeffs[x] * filtpower);                      }                  }                  else m_filter_coeffs_size = 0;                }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,BuildLowPass,The following statement contains a magic number: if (m_filter_ratio != filtpos ||                  m_filter_coeffs_size != wantsize ||                  m_lp_oversize != wantinterp)              {                  m_lp_oversize = wantinterp;                  m_filter_ratio = filtpos;                    // build lowpass filter                  int allocsize = (wantsize + 1) * m_lp_oversize;                  Array.Resize(ref m_filter_coeffs' allocsize);                  //int cfout = 0; // this is an index into m_filter_coeffs                  if (m_filter_coeffs.Length == allocsize)                  {                      m_filter_coeffs_size = wantsize;                        int sz = wantsize * m_lp_oversize;                      int hsz = sz / 2;                      double filtpower = 0.0;                      double windowpos = 0.0;                      double dwindowpos = 2.0 * PI / (double)(sz);                      double dsincpos = PI / m_lp_oversize * filtpos; // filtpos is outrate/inrate' i.e. 0.5 is going to half rate                      double sincpos = dsincpos * (double)(-hsz);                        int x;                      for (x = -hsz; x < hsz + m_lp_oversize; x++)                      {                          double val = 0.35875 - 0.48829 * Math.Cos(windowpos) + 0.14128 * Math.Cos(2 * windowpos) - 0.01168 * Math.Cos(6 * windowpos); // blackman-harris                          if (x != 0) val *= Math.Sin(sincpos) / sincpos;                            windowpos += dwindowpos;                          sincpos += dsincpos;                            m_filter_coeffs[hsz + x] = (WDL_SincFilterSample)val;                          if (x < hsz) filtpower += val;                      }                      filtpower = m_lp_oversize / filtpower;                      for (x = 0; x < sz + m_lp_oversize; x++)                      {                          m_filter_coeffs[x] = (WDL_SincFilterSample)(m_filter_coeffs[x] * filtpower);                      }                  }                  else m_filter_coeffs_size = 0;                }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample2,The following statement contains a magic number: int i = filtsz / 2;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample2,The following statement contains a magic number: while (i-- != 0)              {                  sum += filter[fptr] * inBuffer[iptr];                  sum2 += filter[fptr] * inBuffer[iptr + 1];                  sumb += filter[fptr + 1] * inBuffer[iptr];                  sum2b += filter[fptr + 1] * inBuffer[iptr + 1];                  sum += filter[fptr + oversize] * inBuffer[iptr + 2];                  sum2 += filter[fptr + oversize] * inBuffer[iptr + 3];                  sumb += filter[fptr + oversize + 1] * inBuffer[iptr + 2];                  sum2b += filter[fptr + oversize + 1] * inBuffer[iptr + 3];                  iptr += 4;                  fptr += oversize * 2;              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample2,The following statement contains a magic number: while (i-- != 0)              {                  sum += filter[fptr] * inBuffer[iptr];                  sum2 += filter[fptr] * inBuffer[iptr + 1];                  sumb += filter[fptr + 1] * inBuffer[iptr];                  sum2b += filter[fptr + 1] * inBuffer[iptr + 1];                  sum += filter[fptr + oversize] * inBuffer[iptr + 2];                  sum2 += filter[fptr + oversize] * inBuffer[iptr + 3];                  sumb += filter[fptr + oversize + 1] * inBuffer[iptr + 2];                  sum2b += filter[fptr + oversize + 1] * inBuffer[iptr + 3];                  iptr += 4;                  fptr += oversize * 2;              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample2,The following statement contains a magic number: while (i-- != 0)              {                  sum += filter[fptr] * inBuffer[iptr];                  sum2 += filter[fptr] * inBuffer[iptr + 1];                  sumb += filter[fptr + 1] * inBuffer[iptr];                  sum2b += filter[fptr + 1] * inBuffer[iptr + 1];                  sum += filter[fptr + oversize] * inBuffer[iptr + 2];                  sum2 += filter[fptr + oversize] * inBuffer[iptr + 3];                  sumb += filter[fptr + oversize + 1] * inBuffer[iptr + 2];                  sum2b += filter[fptr + oversize + 1] * inBuffer[iptr + 3];                  iptr += 4;                  fptr += oversize * 2;              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample2,The following statement contains a magic number: while (i-- != 0)              {                  sum += filter[fptr] * inBuffer[iptr];                  sum2 += filter[fptr] * inBuffer[iptr + 1];                  sumb += filter[fptr + 1] * inBuffer[iptr];                  sum2b += filter[fptr + 1] * inBuffer[iptr + 1];                  sum += filter[fptr + oversize] * inBuffer[iptr + 2];                  sum2 += filter[fptr + oversize] * inBuffer[iptr + 3];                  sumb += filter[fptr + oversize + 1] * inBuffer[iptr + 2];                  sum2b += filter[fptr + oversize + 1] * inBuffer[iptr + 3];                  iptr += 4;                  fptr += oversize * 2;              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample2,The following statement contains a magic number: while (i-- != 0)              {                  sum += filter[fptr] * inBuffer[iptr];                  sum2 += filter[fptr] * inBuffer[iptr + 1];                  sumb += filter[fptr + 1] * inBuffer[iptr];                  sum2b += filter[fptr + 1] * inBuffer[iptr + 1];                  sum += filter[fptr + oversize] * inBuffer[iptr + 2];                  sum2 += filter[fptr + oversize] * inBuffer[iptr + 3];                  sumb += filter[fptr + oversize + 1] * inBuffer[iptr + 2];                  sum2b += filter[fptr + oversize + 1] * inBuffer[iptr + 3];                  iptr += 4;                  fptr += oversize * 2;              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample2,The following statement contains a magic number: while (i-- != 0)              {                  sum += filter[fptr] * inBuffer[iptr];                  sum2 += filter[fptr] * inBuffer[iptr + 1];                  sumb += filter[fptr + 1] * inBuffer[iptr];                  sum2b += filter[fptr + 1] * inBuffer[iptr + 1];                  sum += filter[fptr + oversize] * inBuffer[iptr + 2];                  sum2 += filter[fptr + oversize] * inBuffer[iptr + 3];                  sumb += filter[fptr + oversize + 1] * inBuffer[iptr + 2];                  sum2b += filter[fptr + oversize + 1] * inBuffer[iptr + 3];                  iptr += 4;                  fptr += oversize * 2;              }
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,Reset,The following statement contains a magic number: m_hist = new double[WDL_RESAMPLE_MAX_FILTERS * WDL_RESAMPLE_MAX_NCH' 4];
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,setParms,The following statement contains a magic number: if (Math.Abs(fpos - m_fpos) < 0.000001) return;
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,setParms,The following statement contains a magic number: double alpha = spos / (2.0 * Q);
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,setParms,The following statement contains a magic number: m_b2 = m_b0 = m_b1 * 0.5;
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,setParms,The following statement contains a magic number: m_a1 = -2 * cpos * sc;
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,Apply,The following statement contains a magic number: while (ns-- != 0)                  {                      double inx = inBuffer[inIndex];                      inIndex += span;                      double outx = (double)(inx * b0 + m_hist[w' 0] * b1 + m_hist[w' 1] * b2 - m_hist[w' 2] * a1 - m_hist[w' 3] * a2);                      m_hist[w' 1] = m_hist[w' 0];                      m_hist[w' 0] = inx;                      m_hist[w' 3] = m_hist[w' 2];                      m_hist[w' 2] = denormal_filter(outx);                      outBuffer[outIndex] = (WDL_ResampleSample)m_hist[w' 2];                        outIndex += span;                  }
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,Apply,The following statement contains a magic number: while (ns-- != 0)                  {                      double inx = inBuffer[inIndex];                      inIndex += span;                      double outx = (double)(inx * b0 + m_hist[w' 0] * b1 + m_hist[w' 1] * b2 - m_hist[w' 2] * a1 - m_hist[w' 3] * a2);                      m_hist[w' 1] = m_hist[w' 0];                      m_hist[w' 0] = inx;                      m_hist[w' 3] = m_hist[w' 2];                      m_hist[w' 2] = denormal_filter(outx);                      outBuffer[outIndex] = (WDL_ResampleSample)m_hist[w' 2];                        outIndex += span;                  }
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,Apply,The following statement contains a magic number: while (ns-- != 0)                  {                      double inx = inBuffer[inIndex];                      inIndex += span;                      double outx = (double)(inx * b0 + m_hist[w' 0] * b1 + m_hist[w' 1] * b2 - m_hist[w' 2] * a1 - m_hist[w' 3] * a2);                      m_hist[w' 1] = m_hist[w' 0];                      m_hist[w' 0] = inx;                      m_hist[w' 3] = m_hist[w' 2];                      m_hist[w' 2] = denormal_filter(outx);                      outBuffer[outIndex] = (WDL_ResampleSample)m_hist[w' 2];                        outIndex += span;                  }
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,Apply,The following statement contains a magic number: while (ns-- != 0)                  {                      double inx = inBuffer[inIndex];                      inIndex += span;                      double outx = (double)(inx * b0 + m_hist[w' 0] * b1 + m_hist[w' 1] * b2 - m_hist[w' 2] * a1 - m_hist[w' 3] * a2);                      m_hist[w' 1] = m_hist[w' 0];                      m_hist[w' 0] = inx;                      m_hist[w' 3] = m_hist[w' 2];                      m_hist[w' 2] = denormal_filter(outx);                      outBuffer[outIndex] = (WDL_ResampleSample)m_hist[w' 2];                        outIndex += span;                  }
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,Apply,The following statement contains a magic number: while (ns-- != 0)                  {                      double inx = inBuffer[inIndex];                      inIndex += span;                      double outx = (double)(inx * b0 + m_hist[w' 0] * b1 + m_hist[w' 1] * b2 - m_hist[w' 2] * a1 - m_hist[w' 3] * a2);                      m_hist[w' 1] = m_hist[w' 0];                      m_hist[w' 0] = inx;                      m_hist[w' 3] = m_hist[w' 2];                      m_hist[w' 2] = denormal_filter(outx);                      outBuffer[outIndex] = (WDL_ResampleSample)m_hist[w' 2];                        outIndex += span;                  }
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,Apply,The following statement contains a magic number: while (ns-- != 0)                  {                      double inx = inBuffer[inIndex];                      inIndex += span;                      double outx = (double)(inx * b0 + m_hist[w' 0] * b1 + m_hist[w' 1] * b2 - m_hist[w' 2] * a1 - m_hist[w' 3] * a2);                      m_hist[w' 1] = m_hist[w' 0];                      m_hist[w' 0] = inx;                      m_hist[w' 3] = m_hist[w' 2];                      m_hist[w' 2] = denormal_filter(outx);                      outBuffer[outIndex] = (WDL_ResampleSample)m_hist[w' 2];                        outIndex += span;                  }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,CreateId3v2Frame,The following statement contains a magic number: if (key.Length != 4)              {                  throw new ArgumentOutOfRangeException("key"' "key " + key + " must be 4 characters long");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,GetId3TagHeaderSize,The following statement contains a magic number: byte[] result = new byte[4];
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,GetId3TagHeaderSize,The following statement contains a magic number: for (int idx = result.Length - 1; idx >= 0; idx--)              {                  result[idx] = (byte)(size % 128);                  size = size / 128;              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,GetId3TagHeaderSize,The following statement contains a magic number: for (int idx = result.Length - 1; idx >= 0; idx--)              {                  result[idx] = (byte)(size % 128);                  size = size / 128;              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,CreateId3v2TagHeader,The following statement contains a magic number: byte[] tagHeader = ByteArrayExtensions.Concat(                  Encoding.UTF8.GetBytes("ID3")'                  new byte[] { 3' 0 }' // version                  new byte[] { 0 }' // flags                  GetId3TagHeaderSize(size));
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: byte[] headerBytes = reader.ReadBytes(10);
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,LoadFromStream,The following statement contains a magic number: byte[] headerBytes = new byte[4];
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,LoadFromStream,The following statement contains a magic number: while (!IsValidHeader(headerBytes' frame))              {                  // shift down by one and try again                  headerBytes[0] = headerBytes[1];                  headerBytes[1] = headerBytes[2];                  headerBytes[2] = headerBytes[3];                  bytesRead = input.Read(headerBytes' 3' 1);                  if (bytesRead < 1)                  {                      return null;                  }                  frame.FileOffset++;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,LoadFromStream,The following statement contains a magic number: while (!IsValidHeader(headerBytes' frame))              {                  // shift down by one and try again                  headerBytes[0] = headerBytes[1];                  headerBytes[1] = headerBytes[2];                  headerBytes[2] = headerBytes[3];                  bytesRead = input.Read(headerBytes' 3' 1);                  if (bytesRead < 1)                  {                      return null;                  }                  frame.FileOffset++;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,LoadFromStream,The following statement contains a magic number: while (!IsValidHeader(headerBytes' frame))              {                  // shift down by one and try again                  headerBytes[0] = headerBytes[1];                  headerBytes[1] = headerBytes[2];                  headerBytes[2] = headerBytes[3];                  bytesRead = input.Read(headerBytes' 3' 1);                  if (bytesRead < 1)                  {                      return null;                  }                  frame.FileOffset++;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,LoadFromStream,The following statement contains a magic number: while (!IsValidHeader(headerBytes' frame))              {                  // shift down by one and try again                  headerBytes[0] = headerBytes[1];                  headerBytes[1] = headerBytes[2];                  headerBytes[2] = headerBytes[3];                  bytesRead = input.Read(headerBytes' 3' 1);                  if (bytesRead < 1)                  {                      return null;                  }                  frame.FileOffset++;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,LoadFromStream,The following statement contains a magic number: int bytesRequired = frame.FrameLength - 4;
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,LoadFromStream,The following statement contains a magic number: if (readData)              {                  frame.RawData = new byte[frame.FrameLength];                  Array.Copy(headerBytes' frame.RawData' 4);                  bytesRead = input.Read(frame.RawData' 4' bytesRequired);                  if (bytesRead < bytesRequired)                  {                      // TODO: could have an option to suppress this' although it does indicate a corrupt file                      // for now' caller should handle this exception                      throw new EndOfStreamException("Unexpected end of stream before frame complete");                  }              }              else              {                  // n.b. readData should not be false if input stream does not support seeking                  input.Position += bytesRequired;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,LoadFromStream,The following statement contains a magic number: if (readData)              {                  frame.RawData = new byte[frame.FrameLength];                  Array.Copy(headerBytes' frame.RawData' 4);                  bytesRead = input.Read(frame.RawData' 4' bytesRequired);                  if (bytesRead < bytesRequired)                  {                      // TODO: could have an option to suppress this' although it does indicate a corrupt file                      // for now' caller should handle this exception                      throw new EndOfStreamException("Unexpected end of stream before frame complete");                  }              }              else              {                  // n.b. readData should not be false if input stream does not support seeking                  input.Position += bytesRequired;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,ReadBigEndian,The following statement contains a magic number: x <<= 8;
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,ReadBigEndian,The following statement contains a magic number: x <<= 8;
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,ReadBigEndian,The following statement contains a magic number: x |= buffer[offset+2];
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,ReadBigEndian,The following statement contains a magic number: x <<= 8;
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,ReadBigEndian,The following statement contains a magic number: x |= buffer[offset+3];
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,WriteBigEndian,The following statement contains a magic number: for (int n = 0; n < 4; n++)              {                  buffer[offset + 3 - n] = littleEndian[n];              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,WriteBigEndian,The following statement contains a magic number: for (int n = 0; n < 4; n++)              {                  buffer[offset + 3 - n] = littleEndian[n];              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if (frame.MpegVersion == MpegVersion.Version1)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 32 + 4;                  else                      offset = 17 + 4;              }              else if (frame.MpegVersion == MpegVersion.Version2)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 17 + 4;                  else                      offset = 9 + 4;              }              else              {                  return null;                  // throw new FormatException("Unsupported MPEG Version");              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if (frame.MpegVersion == MpegVersion.Version1)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 32 + 4;                  else                      offset = 17 + 4;              }              else if (frame.MpegVersion == MpegVersion.Version2)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 17 + 4;                  else                      offset = 9 + 4;              }              else              {                  return null;                  // throw new FormatException("Unsupported MPEG Version");              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if (frame.MpegVersion == MpegVersion.Version1)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 32 + 4;                  else                      offset = 17 + 4;              }              else if (frame.MpegVersion == MpegVersion.Version2)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 17 + 4;                  else                      offset = 9 + 4;              }              else              {                  return null;                  // throw new FormatException("Unsupported MPEG Version");              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if (frame.MpegVersion == MpegVersion.Version1)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 32 + 4;                  else                      offset = 17 + 4;              }              else if (frame.MpegVersion == MpegVersion.Version2)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 17 + 4;                  else                      offset = 9 + 4;              }              else              {                  return null;                  // throw new FormatException("Unsupported MPEG Version");              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if (frame.MpegVersion == MpegVersion.Version1)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 32 + 4;                  else                      offset = 17 + 4;              }              else if (frame.MpegVersion == MpegVersion.Version2)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 17 + 4;                  else                      offset = 9 + 4;              }              else              {                  return null;                  // throw new FormatException("Unsupported MPEG Version");              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if (frame.MpegVersion == MpegVersion.Version1)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 32 + 4;                  else                      offset = 17 + 4;              }              else if (frame.MpegVersion == MpegVersion.Version2)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 17 + 4;                  else                      offset = 9 + 4;              }              else              {                  return null;                  // throw new FormatException("Unsupported MPEG Version");              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if (frame.MpegVersion == MpegVersion.Version1)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 32 + 4;                  else                      offset = 17 + 4;              }              else if (frame.MpegVersion == MpegVersion.Version2)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 17 + 4;                  else                      offset = 9 + 4;              }              else              {                  return null;                  // throw new FormatException("Unsupported MPEG Version");              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if (frame.MpegVersion == MpegVersion.Version1)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 32 + 4;                  else                      offset = 17 + 4;              }              else if (frame.MpegVersion == MpegVersion.Version2)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 17 + 4;                  else                      offset = 9 + 4;              }              else              {                  return null;                  // throw new FormatException("Unsupported MPEG Version");              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if ((frame.RawData[offset + 0] == 'X') &&                  (frame.RawData[offset + 1] == 'i') &&                  (frame.RawData[offset + 2] == 'n') &&                  (frame.RawData[offset + 3] == 'g'))              {                  xingHeader.startOffset = offset;                  offset += 4;              }              else              {                  return null;              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if ((frame.RawData[offset + 0] == 'X') &&                  (frame.RawData[offset + 1] == 'i') &&                  (frame.RawData[offset + 2] == 'n') &&                  (frame.RawData[offset + 3] == 'g'))              {                  xingHeader.startOffset = offset;                  offset += 4;              }              else              {                  return null;              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if ((frame.RawData[offset + 0] == 'X') &&                  (frame.RawData[offset + 1] == 'i') &&                  (frame.RawData[offset + 2] == 'n') &&                  (frame.RawData[offset + 3] == 'g'))              {                  xingHeader.startOffset = offset;                  offset += 4;              }              else              {                  return null;              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: offset += 4;
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if ((flags & XingHeaderOptions.Frames) != 0)              {                  xingHeader.framesOffset = offset;                  offset += 4;              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if ((flags & XingHeaderOptions.Bytes) != 0)              {                  xingHeader.bytesOffset = offset;                  offset += 4;              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if ((flags & XingHeaderOptions.Toc) != 0)              {                  xingHeader.tocOffset = offset;                  offset += 100;              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if ((flags & XingHeaderOptions.VbrScale) != 0)              {                  xingHeader.vbrScale = ReadBigEndian(frame.RawData' offset);                  offset += 4;              }
Magic Number,NAudio.Wave,WaveExtensionMethods,C:\repos\naudio_NAudio\NAudio\Wave\WaveExtensionMethods.cs,ToStereo,The following statement contains a magic number: if (sourceProvider.WaveFormat.Channels == 2) return sourceProvider;
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: this.extraSize = 32;
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: switch(this.sampleRate)              {                  case 8000:                   case 11025:                      blockAlign = 256;                       break;                  case 22050:                      blockAlign = 512;                      break;                  case 44100:                  default:                      blockAlign = 1024;                      break;              }
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: switch(this.sampleRate)              {                  case 8000:                   case 11025:                      blockAlign = 256;                       break;                  case 22050:                      blockAlign = 512;                      break;                  case 44100:                  default:                      blockAlign = 1024;                      break;              }
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: switch(this.sampleRate)              {                  case 8000:                   case 11025:                      blockAlign = 256;                       break;                  case 22050:                      blockAlign = 512;                      break;                  case 44100:                  default:                      blockAlign = 1024;                      break;              }
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: switch(this.sampleRate)              {                  case 8000:                   case 11025:                      blockAlign = 256;                       break;                  case 22050:                      blockAlign = 512;                      break;                  case 44100:                  default:                      blockAlign = 1024;                      break;              }
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: switch(this.sampleRate)              {                  case 8000:                   case 11025:                      blockAlign = 256;                       break;                  case 22050:                      blockAlign = 512;                      break;                  case 44100:                  default:                      blockAlign = 1024;                      break;              }
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: switch(this.sampleRate)              {                  case 8000:                   case 11025:                      blockAlign = 256;                       break;                  case 22050:                      blockAlign = 512;                      break;                  case 44100:                  default:                      blockAlign = 1024;                      break;              }
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: switch(this.sampleRate)              {                  case 8000:                   case 11025:                      blockAlign = 256;                       break;                  case 22050:                      blockAlign = 512;                      break;                  case 44100:                  default:                      blockAlign = 1024;                      break;              }
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: this.bitsPerSample = 4;
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: this.samplesPerBlock = (short) ((((blockAlign - (7 * channels)) * 8) / (bitsPerSample * channels)) + 2);
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: this.samplesPerBlock = (short) ((((blockAlign - (7 * channels)) * 8) / (bitsPerSample * channels)) + 2);
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: this.samplesPerBlock = (short) ((((blockAlign - (7 * channels)) * 8) / (bitsPerSample * channels)) + 2);
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: numCoeff = 7;
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,Gsm610WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\Gsm610WaveFormat.cs,Gsm610WaveFormat,The following statement contains a magic number: averageBytesPerSecond = 1625;
Magic Number,NAudio.Wave,Gsm610WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\Gsm610WaveFormat.cs,Gsm610WaveFormat,The following statement contains a magic number: blockAlign = 65;
Magic Number,NAudio.Wave,Gsm610WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\Gsm610WaveFormat.cs,Gsm610WaveFormat,The following statement contains a magic number: sampleRate = 8000;
Magic Number,NAudio.Wave,Gsm610WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\Gsm610WaveFormat.cs,Gsm610WaveFormat,The following statement contains a magic number: extraSize = 2;
Magic Number,NAudio.Wave,Gsm610WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\Gsm610WaveFormat.cs,Gsm610WaveFormat,The following statement contains a magic number: samplesPerBlock = 320;
Magic Number,NAudio.Wave,ImaAdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\ImaAdpcmWaveFormat.cs,ImaAdpcmWaveFormat,The following statement contains a magic number: this.extraSize = 2;
Magic Number,NAudio.Wave,Mp3WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\Mp3WaveFormat.cs,Mp3WaveFormat,The following statement contains a magic number: this.averageBytesPerSecond = bitRate / 8;
Magic Number,NAudio.Wave,TrueSpeechWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\TrueSpeechWaveFormat.cs,TrueSpeechWaveFormat,The following statement contains a magic number: this.averageBytesPerSecond = 1067;
Magic Number,NAudio.Wave,TrueSpeechWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\TrueSpeechWaveFormat.cs,TrueSpeechWaveFormat,The following statement contains a magic number: this.blockAlign = 32;
Magic Number,NAudio.Wave,TrueSpeechWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\TrueSpeechWaveFormat.cs,TrueSpeechWaveFormat,The following statement contains a magic number: this.sampleRate = 8000;
Magic Number,NAudio.Wave,TrueSpeechWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\TrueSpeechWaveFormat.cs,TrueSpeechWaveFormat,The following statement contains a magic number: this.extraSize = 32;
Magic Number,NAudio.Wave,TrueSpeechWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\TrueSpeechWaveFormat.cs,TrueSpeechWaveFormat,The following statement contains a magic number: this.unknown = new short[16];
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,ConvertLatencyToByteSize,The following statement contains a magic number: int bytes = (int) ((AverageBytesPerSecond/1000.0)*milliseconds);
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,CreateALawFormat,The following statement contains a magic number: return CreateCustomFormat(WaveFormatEncoding.ALaw' sampleRate' channels' sampleRate * channels' channels' 8);
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,CreateMuLawFormat,The following statement contains a magic number: return CreateCustomFormat(WaveFormatEncoding.MuLaw' sampleRate' channels' sampleRate * channels' channels' 8);
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,WaveFormat,The following statement contains a magic number: blockAlign = (short)(channels * (bits / 8));
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,CreateIeeeFloatWaveFormat,The following statement contains a magic number: wf.bitsPerSample = 32;
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,CreateIeeeFloatWaveFormat,The following statement contains a magic number: wf.blockAlign = (short) (4*channels);
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,ReadWaveFormat,The following statement contains a magic number: if (formatChunkLength < 16)                  throw new InvalidDataException("Invalid WaveFormat Structure");
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,ReadWaveFormat,The following statement contains a magic number: if (formatChunkLength > 16)              {                  extraSize = br.ReadInt16();                  if (extraSize != formatChunkLength - 18)                  {                      Debug.WriteLine("Format chunk mismatch");                      extraSize = (short)(formatChunkLength - 18);                  }              }
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,ReadWaveFormat,The following statement contains a magic number: if (formatChunkLength > 16)              {                  extraSize = br.ReadInt16();                  if (extraSize != formatChunkLength - 18)                  {                      Debug.WriteLine("Format chunk mismatch");                      extraSize = (short)(formatChunkLength - 18);                  }              }
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,ReadWaveFormat,The following statement contains a magic number: if (formatChunkLength > 16)              {                  extraSize = br.ReadInt16();                  if (extraSize != formatChunkLength - 18)                  {                      Debug.WriteLine("Format chunk mismatch");                      extraSize = (short)(formatChunkLength - 18);                  }              }
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,ToString,The following statement contains a magic number: switch (waveFormatTag)              {                  case WaveFormatEncoding.Pcm:                  case WaveFormatEncoding.Extensible:                      // extensible just has some extra bits after the PCM header                      return $"{bitsPerSample} bit PCM: {sampleRate/1000}kHz {channels} channels";                  default:                      return waveFormatTag.ToString();              }
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,Serialize,The following statement contains a magic number: writer.Write((int)(18 + extraSize));
Magic Number,NAudio.Wave,WaveFormatExtensible,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormatExtensible.cs,WaveFormatExtensible,The following statement contains a magic number: extraSize = 22;
Magic Number,NAudio.Wave,WaveFormatExtensible,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormatExtensible.cs,WaveFormatExtensible,The following statement contains a magic number: if (bits == 32)              {                  // KSDATAFORMAT_SUBTYPE_IEEE_FLOAT                  subFormat = AudioMediaSubtypes.MEDIASUBTYPE_IEEE_FLOAT;              }              else              {                  // KSDATAFORMAT_SUBTYPE_PCM                  subFormat = AudioMediaSubtypes.MEDIASUBTYPE_PCM;              }
Magic Number,NAudio.Wave,WaveFormatExtensible,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormatExtensible.cs,ToStandardWaveFormat,The following statement contains a magic number: if (subFormat == AudioMediaSubtypes.MEDIASUBTYPE_IEEE_FLOAT && bitsPerSample == 32)                  return CreateIeeeFloatWaveFormat(sampleRate' channels);
Magic Number,NAudio.Wave,WaveBuffer,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveBuffer.cs,WaveBuffer,The following statement contains a magic number: int aligned4Bytes = sizeToAllocateInBytes%4;
Magic Number,NAudio.Wave,WaveBuffer,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveBuffer.cs,WaveBuffer,The following statement contains a magic number: sizeToAllocateInBytes = (aligned4Bytes == 0) ? sizeToAllocateInBytes : sizeToAllocateInBytes + 4 - aligned4Bytes;
Magic Number,NAudio.Wave,WaveBuffer,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveBuffer.cs,CheckValidityCount,The following statement contains a magic number: if ( (newNumberOfBytes % 4) != 0 )              {                  throw new ArgumentOutOfRangeException(argName' String.Format("{0} cannot set a count ({1}) that is not 4 bytes aligned "' argName' newNumberOfBytes));              }
Magic Number,NAudio.Wave,BufferedWaveProvider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\BufferedWaveProvider.cs,BufferedWaveProvider,The following statement contains a magic number: BufferLength = waveFormat.AverageBytesPerSecond * 5;
Magic Number,NAudio.Wave,MonoToStereoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MonoToStereoProvider16.cs,MonoToStereoProvider16,The following statement contains a magic number: if (sourceProvider.WaveFormat.BitsPerSample != 16)              {                  throw new ArgumentException("Source must be 16 bit");              }
Magic Number,NAudio.Wave,MonoToStereoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MonoToStereoProvider16.cs,MonoToStereoProvider16,The following statement contains a magic number: WaveFormat = new WaveFormat(sourceProvider.WaveFormat.SampleRate' 2);
Magic Number,NAudio.Wave,MonoToStereoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MonoToStereoProvider16.cs,Read,The following statement contains a magic number: var sourceBytesRequired = count / 2;
Magic Number,NAudio.Wave,MonoToStereoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MonoToStereoProvider16.cs,Read,The following statement contains a magic number: var samplesRead = sourceBytesRead / 2;
Magic Number,NAudio.Wave,MonoToStereoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MonoToStereoProvider16.cs,Read,The following statement contains a magic number: var destOffset = offset / 2;
Magic Number,NAudio.Wave,MonoToStereoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MonoToStereoProvider16.cs,Read,The following statement contains a magic number: return samplesRead * 4;
Magic Number,NAudio.Wave,MultiplexingWaveProvider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MultiplexingWaveProvider.cs,MultiplexingWaveProvider,The following statement contains a magic number: bytesPerSample = WaveFormat.BitsPerSample / 8;
Magic Number,NAudio.Wave,StereoToMonoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\StereoToMonoProvider16.cs,StereoToMonoProvider16,The following statement contains a magic number: if (sourceProvider.WaveFormat.Channels != 2)              {                  throw new ArgumentException("Source must be stereo");              }
Magic Number,NAudio.Wave,StereoToMonoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\StereoToMonoProvider16.cs,StereoToMonoProvider16,The following statement contains a magic number: if (sourceProvider.WaveFormat.BitsPerSample != 16)              {                  throw new ArgumentException("Source must be 16 bit");              }
Magic Number,NAudio.Wave,StereoToMonoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\StereoToMonoProvider16.cs,Read,The following statement contains a magic number: int sourceBytesRequired = count * 2;
Magic Number,NAudio.Wave,StereoToMonoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\StereoToMonoProvider16.cs,Read,The following statement contains a magic number: int samplesRead = sourceBytesRead / 2;
Magic Number,NAudio.Wave,StereoToMonoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\StereoToMonoProvider16.cs,Read,The following statement contains a magic number: int destOffset = offset / 2;
Magic Number,NAudio.Wave,StereoToMonoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\StereoToMonoProvider16.cs,Read,The following statement contains a magic number: for (int sample = 0; sample < samplesRead; sample+=2)              {                  short left = sourceWaveBuffer.ShortBuffer[sample];                  short right = sourceWaveBuffer.ShortBuffer[sample+1];                  float outSample = (left * LeftVolume) + (right * RightVolume);                  // hard limiting                  if (outSample > Int16.MaxValue) outSample = Int16.MaxValue;                  if (outSample < Int16.MinValue) outSample = Int16.MinValue;                    destWaveBuffer.ShortBuffer[destOffset++] = (short)outSample;              }
Magic Number,NAudio.Wave,StereoToMonoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\StereoToMonoProvider16.cs,Read,The following statement contains a magic number: return sourceBytesRead / 2;
Magic Number,NAudio.Wave,VolumeWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\VolumeWaveProvider16.cs,VolumeWaveProvider16,The following statement contains a magic number: if (sourceProvider.WaveFormat.BitsPerSample != 16)                  throw new ArgumentException("Expecting 16 bit");
Magic Number,NAudio.Wave,VolumeWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\VolumeWaveProvider16.cs,Read,The following statement contains a magic number: if (this.volume == 0.0f)              {                  for (int n = 0; n < bytesRead; n++)                  {                      buffer[offset++] = 0;                  }              }              else if (this.volume != 1.0f)              {                  for (int n = 0; n < bytesRead; n += 2)                  {                      short sample = (short)((buffer[offset + 1] << 8) | buffer[offset]);                      var newSample = sample * this.volume;                      sample = (short)newSample;                      // clip if necessary                      if (this.Volume > 1.0f)                      {                          if (newSample > Int16.MaxValue) sample = Int16.MaxValue;                          else if (newSample < Int16.MinValue) sample = Int16.MinValue;                      }                        buffer[offset++] = (byte)(sample & 0xFF);                      buffer[offset++] = (byte)(sample >> 8);                  }              }
Magic Number,NAudio.Wave,VolumeWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\VolumeWaveProvider16.cs,Read,The following statement contains a magic number: if (this.volume == 0.0f)              {                  for (int n = 0; n < bytesRead; n++)                  {                      buffer[offset++] = 0;                  }              }              else if (this.volume != 1.0f)              {                  for (int n = 0; n < bytesRead; n += 2)                  {                      short sample = (short)((buffer[offset + 1] << 8) | buffer[offset]);                      var newSample = sample * this.volume;                      sample = (short)newSample;                      // clip if necessary                      if (this.Volume > 1.0f)                      {                          if (newSample > Int16.MaxValue) sample = Int16.MaxValue;                          else if (newSample < Int16.MinValue) sample = Int16.MinValue;                      }                        buffer[offset++] = (byte)(sample & 0xFF);                      buffer[offset++] = (byte)(sample >> 8);                  }              }
Magic Number,NAudio.Wave,VolumeWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\VolumeWaveProvider16.cs,Read,The following statement contains a magic number: if (this.volume == 0.0f)              {                  for (int n = 0; n < bytesRead; n++)                  {                      buffer[offset++] = 0;                  }              }              else if (this.volume != 1.0f)              {                  for (int n = 0; n < bytesRead; n += 2)                  {                      short sample = (short)((buffer[offset + 1] << 8) | buffer[offset]);                      var newSample = sample * this.volume;                      sample = (short)newSample;                      // clip if necessary                      if (this.Volume > 1.0f)                      {                          if (newSample > Int16.MaxValue) sample = Int16.MaxValue;                          else if (newSample < Int16.MinValue) sample = Int16.MinValue;                      }                        buffer[offset++] = (byte)(sample & 0xFF);                      buffer[offset++] = (byte)(sample >> 8);                  }              }
Magic Number,NAudio.Wave,Wave16ToFloatProvider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\Wave16toFloatProvider.cs,Wave16ToFloatProvider,The following statement contains a magic number: if (sourceProvider.WaveFormat.BitsPerSample != 16)                  throw new ArgumentException("Only 16 bit audio supported");
Magic Number,NAudio.Wave,Wave16ToFloatProvider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\Wave16toFloatProvider.cs,Read,The following statement contains a magic number: int sourceBytesRequired = numBytes / 2;
Magic Number,NAudio.Wave,Wave16ToFloatProvider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\Wave16toFloatProvider.cs,Read,The following statement contains a magic number: int sourceSamples = sourceBytesRead / 2;
Magic Number,NAudio.Wave,Wave16ToFloatProvider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\Wave16toFloatProvider.cs,Read,The following statement contains a magic number: int destOffset = offset / 4;
Magic Number,NAudio.Wave,Wave16ToFloatProvider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\Wave16toFloatProvider.cs,Read,The following statement contains a magic number: return sourceSamples * 4;
Magic Number,NAudio.Wave,WaveFloatTo16Provider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveFloatTo16Provider.cs,WaveFloatTo16Provider,The following statement contains a magic number: if (sourceProvider.WaveFormat.BitsPerSample != 32)                  throw new ArgumentException("Input wave provider must be 32 bit"' "sourceProvider");
Magic Number,NAudio.Wave,WaveFloatTo16Provider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveFloatTo16Provider.cs,WaveFloatTo16Provider,The following statement contains a magic number: waveFormat = new WaveFormat(sourceProvider.WaveFormat.SampleRate' 16' sourceProvider.WaveFormat.Channels);
Magic Number,NAudio.Wave,WaveFloatTo16Provider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveFloatTo16Provider.cs,Read,The following statement contains a magic number: int sourceBytesRequired = numBytes * 2;
Magic Number,NAudio.Wave,WaveFloatTo16Provider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveFloatTo16Provider.cs,Read,The following statement contains a magic number: int sourceSamples = sourceBytesRead / 4;
Magic Number,NAudio.Wave,WaveFloatTo16Provider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveFloatTo16Provider.cs,Read,The following statement contains a magic number: int destOffset = offset / 2;
Magic Number,NAudio.Wave,WaveFloatTo16Provider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveFloatTo16Provider.cs,Read,The following statement contains a magic number: for (int sample = 0; sample < sourceSamples; sample++)              {                  // adjust volume                  float sample32 = sourceWaveBuffer.FloatBuffer[sample] * volume;                  // clip                  if (sample32 > 1.0f)                      sample32 = 1.0f;                  if (sample32 < -1.0f)                      sample32 = -1.0f;                  destWaveBuffer.ShortBuffer[destOffset++] = (short)(sample32 * 32767);              }
Magic Number,NAudio.Wave,WaveFloatTo16Provider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveFloatTo16Provider.cs,Read,The following statement contains a magic number: return sourceSamples * 2;
Magic Number,NAudio.Wave,WaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveProvider16.cs,SetWaveFormat,The following statement contains a magic number: this.waveFormat = new WaveFormat(sampleRate' 16' channels);
Magic Number,NAudio.Wave,WaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveProvider16.cs,Read,The following statement contains a magic number: int samplesRequired = count / 2;
Magic Number,NAudio.Wave,WaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveProvider16.cs,Read,The following statement contains a magic number: int samplesRead = Read(waveBuffer.ShortBuffer' offset / 2' samplesRequired);
Magic Number,NAudio.Wave,WaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveProvider16.cs,Read,The following statement contains a magic number: return samplesRead * 2;
Magic Number,NAudio.Wave,WaveProvider32,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveProvider32.cs,Read,The following statement contains a magic number: int samplesRequired = count / 4;
Magic Number,NAudio.Wave,WaveProvider32,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveProvider32.cs,Read,The following statement contains a magic number: int samplesRead = Read(waveBuffer.FloatBuffer' offset / 4' samplesRequired);
Magic Number,NAudio.Wave,WaveProvider32,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveProvider32.cs,Read,The following statement contains a magic number: return samplesRead * 4;
Magic Number,NAudio.Wave,BlockAlignReductionStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\BlockAlignReductionStream.cs,BlockAlignReductionStream,The following statement contains a magic number: circularBuffer = new CircularBuffer(sourceStream.WaveFormat.AverageBytesPerSecond * 4);
Magic Number,NAudio.Wave,BlockAlignReductionStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\BlockAlignReductionStream.cs,GetSourceBuffer,The following statement contains a magic number: if (sourceBuffer == null || sourceBuffer.Length < size)              {                  // let's give ourselves some leeway                  sourceBuffer = new byte[size * 2];              }
Magic Number,NAudio.Wave,MediaFoundationReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\MediaFoundationReader.cs,CreateReader,The following statement contains a magic number: try              {                  // set the media type                  // can return MF_E_INVALIDMEDIATYPE if not supported                  reader.SetCurrentMediaType(MediaFoundationInterop.MF_SOURCE_READER_FIRST_AUDIO_STREAM' IntPtr.Zero' partialMediaType.MediaFoundationObject);              }              catch (COMException ex) when (ex.GetHResult() == MediaFoundationErrors.MF_E_INVALIDMEDIATYPE)              {                                 // HE-AAC (and v2) seems to halve the samplerate                  if (currentMediaType.SubType == AudioSubtypes.MFAudioFormat_AAC && currentMediaType.ChannelCount == 1)                  {                      partialMediaType.SampleRate = currentMediaType.SampleRate *= 2;                      partialMediaType.ChannelCount = currentMediaType.ChannelCount *= 2;                      reader.SetCurrentMediaType(MediaFoundationInterop.MF_SOURCE_READER_FIRST_AUDIO_STREAM' IntPtr.Zero' partialMediaType.MediaFoundationObject);                  }                  else { throw; }              }
Magic Number,NAudio.Wave,MediaFoundationReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\MediaFoundationReader.cs,CreateReader,The following statement contains a magic number: try              {                  // set the media type                  // can return MF_E_INVALIDMEDIATYPE if not supported                  reader.SetCurrentMediaType(MediaFoundationInterop.MF_SOURCE_READER_FIRST_AUDIO_STREAM' IntPtr.Zero' partialMediaType.MediaFoundationObject);              }              catch (COMException ex) when (ex.GetHResult() == MediaFoundationErrors.MF_E_INVALIDMEDIATYPE)              {                                 // HE-AAC (and v2) seems to halve the samplerate                  if (currentMediaType.SubType == AudioSubtypes.MFAudioFormat_AAC && currentMediaType.ChannelCount == 1)                  {                      partialMediaType.SampleRate = currentMediaType.SampleRate *= 2;                      partialMediaType.ChannelCount = currentMediaType.ChannelCount *= 2;                      reader.SetCurrentMediaType(MediaFoundationInterop.MF_SOURCE_READER_FIRST_AUDIO_STREAM' IntPtr.Zero' partialMediaType.MediaFoundationObject);                  }                  else { throw; }              }
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,SimpleCompressorStream,The following statement contains a magic number: bytesPerSample = sourceStream.WaveFormat.BitsPerSample / 8;
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,SimpleCompressorStream,The following statement contains a magic number: simpleCompressor = new SimpleCompressor(5.0' 10.0' sourceStream.WaveFormat.SampleRate);
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,SimpleCompressorStream,The following statement contains a magic number: simpleCompressor = new SimpleCompressor(5.0' 10.0' sourceStream.WaveFormat.SampleRate);
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,SimpleCompressorStream,The following statement contains a magic number: simpleCompressor.Threshold = 16;
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,SimpleCompressorStream,The following statement contains a magic number: simpleCompressor.Ratio = 6;
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,SimpleCompressorStream,The following statement contains a magic number: simpleCompressor.MakeUpGain = 16;
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,ReadSamples,The following statement contains a magic number: if (bytesPerSample == 4)              {                  left = BitConverter.ToSingle(buffer' start);                  if (channels > 1)                  {                      right = BitConverter.ToSingle(buffer' start + bytesPerSample);                  }                  else                  {                      right = left;                  }              }              else if (bytesPerSample == 2)              {                  left = BitConverter.ToInt16(buffer' start) / 32768.0;                  if (channels > 1)                  {                      right = BitConverter.ToInt16(buffer' start + bytesPerSample) / 32768.0;                  }                  else                  {                      right = left;                  }              }              else              {                  throw new InvalidOperationException(String.Format("Unsupported bytes per sample: {0}"' bytesPerSample));              }
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,ReadSamples,The following statement contains a magic number: if (bytesPerSample == 4)              {                  left = BitConverter.ToSingle(buffer' start);                  if (channels > 1)                  {                      right = BitConverter.ToSingle(buffer' start + bytesPerSample);                  }                  else                  {                      right = left;                  }              }              else if (bytesPerSample == 2)              {                  left = BitConverter.ToInt16(buffer' start) / 32768.0;                  if (channels > 1)                  {                      right = BitConverter.ToInt16(buffer' start + bytesPerSample) / 32768.0;                  }                  else                  {                      right = left;                  }              }              else              {                  throw new InvalidOperationException(String.Format("Unsupported bytes per sample: {0}"' bytesPerSample));              }
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,ReadSamples,The following statement contains a magic number: if (bytesPerSample == 4)              {                  left = BitConverter.ToSingle(buffer' start);                  if (channels > 1)                  {                      right = BitConverter.ToSingle(buffer' start + bytesPerSample);                  }                  else                  {                      right = left;                  }              }              else if (bytesPerSample == 2)              {                  left = BitConverter.ToInt16(buffer' start) / 32768.0;                  if (channels > 1)                  {                      right = BitConverter.ToInt16(buffer' start + bytesPerSample) / 32768.0;                  }                  else                  {                      right = left;                  }              }              else              {                  throw new InvalidOperationException(String.Format("Unsupported bytes per sample: {0}"' bytesPerSample));              }
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,ReadSamples,The following statement contains a magic number: if (bytesPerSample == 4)              {                  left = BitConverter.ToSingle(buffer' start);                  if (channels > 1)                  {                      right = BitConverter.ToSingle(buffer' start + bytesPerSample);                  }                  else                  {                      right = left;                  }              }              else if (bytesPerSample == 2)              {                  left = BitConverter.ToInt16(buffer' start) / 32768.0;                  if (channels > 1)                  {                      right = BitConverter.ToInt16(buffer' start + bytesPerSample) / 32768.0;                  }                  else                  {                      right = left;                  }              }              else              {                  throw new InvalidOperationException(String.Format("Unsupported bytes per sample: {0}"' bytesPerSample));              }
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,WriteSamples,The following statement contains a magic number: if (bytesPerSample == 4)              {                  Array.Copy(BitConverter.GetBytes((float)left)' 0' buffer' start' bytesPerSample);                  if (channels > 1)                  {                      Array.Copy(BitConverter.GetBytes((float)right)' 0' buffer' start + bytesPerSample' bytesPerSample);                  }              }              else if (bytesPerSample == 2)              {                  Array.Copy(BitConverter.GetBytes((short)(left * 32768.0))' 0' buffer' start' bytesPerSample);                  if (channels > 1)                  {                      Array.Copy(BitConverter.GetBytes((short)(right * 32768.0))' 0' buffer' start + bytesPerSample' bytesPerSample);                  }              }
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,WriteSamples,The following statement contains a magic number: if (bytesPerSample == 4)              {                  Array.Copy(BitConverter.GetBytes((float)left)' 0' buffer' start' bytesPerSample);                  if (channels > 1)                  {                      Array.Copy(BitConverter.GetBytes((float)right)' 0' buffer' start + bytesPerSample' bytesPerSample);                  }              }              else if (bytesPerSample == 2)              {                  Array.Copy(BitConverter.GetBytes((short)(left * 32768.0))' 0' buffer' start' bytesPerSample);                  if (channels > 1)                  {                      Array.Copy(BitConverter.GetBytes((short)(right * 32768.0))' 0' buffer' start + bytesPerSample' bytesPerSample);                  }              }
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,WriteSamples,The following statement contains a magic number: if (bytesPerSample == 4)              {                  Array.Copy(BitConverter.GetBytes((float)left)' 0' buffer' start' bytesPerSample);                  if (channels > 1)                  {                      Array.Copy(BitConverter.GetBytes((float)right)' 0' buffer' start + bytesPerSample' bytesPerSample);                  }              }              else if (bytesPerSample == 2)              {                  Array.Copy(BitConverter.GetBytes((short)(left * 32768.0))' 0' buffer' start' bytesPerSample);                  if (channels > 1)                  {                      Array.Copy(BitConverter.GetBytes((short)(right * 32768.0))' 0' buffer' start + bytesPerSample' bytesPerSample);                  }              }
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,WriteSamples,The following statement contains a magic number: if (bytesPerSample == 4)              {                  Array.Copy(BitConverter.GetBytes((float)left)' 0' buffer' start' bytesPerSample);                  if (channels > 1)                  {                      Array.Copy(BitConverter.GetBytes((float)right)' 0' buffer' start + bytesPerSample' bytesPerSample);                  }              }              else if (bytesPerSample == 2)              {                  Array.Copy(BitConverter.GetBytes((short)(left * 32768.0))' 0' buffer' start' bytesPerSample);                  if (channels > 1)                  {                      Array.Copy(BitConverter.GetBytes((short)(right * 32768.0))' 0' buffer' start + bytesPerSample' bytesPerSample);                  }              }
Magic Number,NAudio.Wave,WaveChannel32,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveChannel32.cs,WaveChannel32,The following statement contains a magic number: waveFormat = WaveFormat.CreateIeeeFloatWaveFormat(sourceStream.WaveFormat.SampleRate' 2);
Magic Number,NAudio.Wave,WaveChannel32,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveChannel32.cs,WaveChannel32,The following statement contains a magic number: destBytesPerSample = 8;
Magic Number,NAudio.Wave,WaveChannel32,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveChannel32.cs,WaveChannel32,The following statement contains a magic number: sourceBytesPerSample = sourceStream.WaveFormat.Channels * sourceStream.WaveFormat.BitsPerSample / 8;
Magic Number,NAudio.Wave,WaveChannel32,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveChannel32.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  int bytesWritten = 0;                  WaveBuffer destWaveBuffer = new WaveBuffer(destBuffer);                    // 1. fill with silence                  if (position < 0)                  {                      bytesWritten = (int) Math.Min(numBytes' 0 - position);                      for (int n = 0; n < bytesWritten; n++)                          destBuffer[n + offset] = 0;                  }                  if (bytesWritten < numBytes)                  {                      sampleProvider.LoadNextChunk(sourceStream' (numBytes - bytesWritten)/8);                      float left' right;                        int outIndex = (offset/4) + bytesWritten/4;                      while (this.sampleProvider.GetNextSample(out left' out right) && bytesWritten < numBytes)                      {                          // implement better panning laws.                           left = (pan <= 0) ? left : (left*(1 - pan)/2.0f);                          right = (pan >= 0) ? right : (right*(pan + 1)/2.0f);                          left *= volume;                          right *= volume;                          destWaveBuffer.FloatBuffer[outIndex++] = left;                          destWaveBuffer.FloatBuffer[outIndex++] = right;                          bytesWritten += 8;                          if (Sample != null) RaiseSample(left' right);                      }                  }                  // 3. Fill out with zeroes                  if (PadWithZeroes && bytesWritten < numBytes)                  {                      Array.Clear(destBuffer' offset + bytesWritten' numBytes - bytesWritten);                      bytesWritten = numBytes;                  }                  position += bytesWritten;                  return bytesWritten;              }
Magic Number,NAudio.Wave,WaveChannel32,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveChannel32.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  int bytesWritten = 0;                  WaveBuffer destWaveBuffer = new WaveBuffer(destBuffer);                    // 1. fill with silence                  if (position < 0)                  {                      bytesWritten = (int) Math.Min(numBytes' 0 - position);                      for (int n = 0; n < bytesWritten; n++)                          destBuffer[n + offset] = 0;                  }                  if (bytesWritten < numBytes)                  {                      sampleProvider.LoadNextChunk(sourceStream' (numBytes - bytesWritten)/8);                      float left' right;                        int outIndex = (offset/4) + bytesWritten/4;                      while (this.sampleProvider.GetNextSample(out left' out right) && bytesWritten < numBytes)                      {                          // implement better panning laws.                           left = (pan <= 0) ? left : (left*(1 - pan)/2.0f);                          right = (pan >= 0) ? right : (right*(pan + 1)/2.0f);                          left *= volume;                          right *= volume;                          destWaveBuffer.FloatBuffer[outIndex++] = left;                          destWaveBuffer.FloatBuffer[outIndex++] = right;                          bytesWritten += 8;                          if (Sample != null) RaiseSample(left' right);                      }                  }                  // 3. Fill out with zeroes                  if (PadWithZeroes && bytesWritten < numBytes)                  {                      Array.Clear(destBuffer' offset + bytesWritten' numBytes - bytesWritten);                      bytesWritten = numBytes;                  }                  position += bytesWritten;                  return bytesWritten;              }
Magic Number,NAudio.Wave,WaveChannel32,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveChannel32.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  int bytesWritten = 0;                  WaveBuffer destWaveBuffer = new WaveBuffer(destBuffer);                    // 1. fill with silence                  if (position < 0)                  {                      bytesWritten = (int) Math.Min(numBytes' 0 - position);                      for (int n = 0; n < bytesWritten; n++)                          destBuffer[n + offset] = 0;                  }                  if (bytesWritten < numBytes)                  {                      sampleProvider.LoadNextChunk(sourceStream' (numBytes - bytesWritten)/8);                      float left' right;                        int outIndex = (offset/4) + bytesWritten/4;                      while (this.sampleProvider.GetNextSample(out left' out right) && bytesWritten < numBytes)                      {                          // implement better panning laws.                           left = (pan <= 0) ? left : (left*(1 - pan)/2.0f);                          right = (pan >= 0) ? right : (right*(pan + 1)/2.0f);                          left *= volume;                          right *= volume;                          destWaveBuffer.FloatBuffer[outIndex++] = left;                          destWaveBuffer.FloatBuffer[outIndex++] = right;                          bytesWritten += 8;                          if (Sample != null) RaiseSample(left' right);                      }                  }                  // 3. Fill out with zeroes                  if (PadWithZeroes && bytesWritten < numBytes)                  {                      Array.Clear(destBuffer' offset + bytesWritten' numBytes - bytesWritten);                      bytesWritten = numBytes;                  }                  position += bytesWritten;                  return bytesWritten;              }
Magic Number,NAudio.Wave,WaveChannel32,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveChannel32.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  int bytesWritten = 0;                  WaveBuffer destWaveBuffer = new WaveBuffer(destBuffer);                    // 1. fill with silence                  if (position < 0)                  {                      bytesWritten = (int) Math.Min(numBytes' 0 - position);                      for (int n = 0; n < bytesWritten; n++)                          destBuffer[n + offset] = 0;                  }                  if (bytesWritten < numBytes)                  {                      sampleProvider.LoadNextChunk(sourceStream' (numBytes - bytesWritten)/8);                      float left' right;                        int outIndex = (offset/4) + bytesWritten/4;                      while (this.sampleProvider.GetNextSample(out left' out right) && bytesWritten < numBytes)                      {                          // implement better panning laws.                           left = (pan <= 0) ? left : (left*(1 - pan)/2.0f);                          right = (pan >= 0) ? right : (right*(pan + 1)/2.0f);                          left *= volume;                          right *= volume;                          destWaveBuffer.FloatBuffer[outIndex++] = left;                          destWaveBuffer.FloatBuffer[outIndex++] = right;                          bytesWritten += 8;                          if (Sample != null) RaiseSample(left' right);                      }                  }                  // 3. Fill out with zeroes                  if (PadWithZeroes && bytesWritten < numBytes)                  {                      Array.Clear(destBuffer' offset + bytesWritten' numBytes - bytesWritten);                      bytesWritten = numBytes;                  }                  position += bytesWritten;                  return bytesWritten;              }
Magic Number,NAudio.Wave,WaveOffsetStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveOffsetStream.cs,WaveOffsetStream,The following statement contains a magic number: bytesPerSample = (sourceStream.WaveFormat.BitsPerSample / 8) * sourceStream.WaveFormat.Channels;
Magic Number,NAudio.Wave,WasapiCaptureRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveInputs\WasapiCaptureRT.cs,InitializeCaptureDevice,The following statement contains a magic number: long requestedDuration = REFTIMES_PER_MILLISEC * 100;
Magic Number,NAudio.Wave,WasapiCaptureRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveInputs\WasapiCaptureRT.cs,InitializeCaptureDevice,The following statement contains a magic number: bytesPerFrame = waveFormat.Channels * waveFormat.BitsPerSample / 8;
Magic Number,NAudio.Wave,WasapiCaptureRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveInputs\WasapiCaptureRT.cs,InitializeCaptureDevice,The following statement contains a magic number: LatencyMilliseconds = (int)(audioClient.StreamLatency / 10000);
Magic Number,NAudio.Wave,WasapiCaptureRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveInputs\WasapiCaptureRT.cs,StopRecording,The following statement contains a magic number: captureTask?.Wait(5000);
Magic Number,NAudio.Wave,WasapiCaptureRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveInputs\WasapiCaptureRT.cs,DoRecording,The following statement contains a magic number: int minPacketSize = waveFormat.AverageBytesPerSecond / 100;
Magic Number,NAudio.Wave,WasapiCaptureRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveInputs\WasapiCaptureRT.cs,DoRecording,The following statement contains a magic number: try              {                  AudioCaptureClient capture = audioClient.AudioCaptureClient;                  audioClient.Start();                    int packetSize = capture.GetNextPacketSize();                    while (captureState == WasapiCaptureState.Recording)                  {                      if (packetSize == 0)                      {                          if (NativeMethods.WaitForSingleObjectEx(hEvent' 100' true) != 0)                          {                              throw new Exception("Capture event timeout");                          }                      }                        var pData = capture.GetBuffer(out var numFramesToRead' out var dwFlags);                        if ((int)(dwFlags & AudioClientBufferFlags.Silent) > 0)                      {                          pData = IntPtr.Zero;                      }                        if (numFramesToRead == 0) { continue; }                        int capturedBytes =  numFramesToRead * bytesPerFrame;                        if (pData == IntPtr.Zero)                      {                          Array.Clear(buf' bufLength' capturedBytes);                      }                      else                      {                          Marshal.Copy(pData' buf' bufLength' capturedBytes);                      }                                            bufLength += capturedBytes;                        capture.ReleaseBuffer(numFramesToRead);                        if (bufLength >= minPacketSize)                      {                          DataAvailable?.Invoke(this' new WaveInEventArgs(buf' bufLength));                          bufLength = 0;                      }                        packetSize = capture.GetNextPacketSize();                  }              }              catch (Exception ex)              {                  RaiseRecordingStopped(ex);                  Debug.WriteLine("stop wasapi");              }              finally              {                  RaiseRecordingStopped(null);                                    audioClient.Stop();              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,CreateWaveFileAsync,The following statement contains a magic number: using (var writer = new WaveFileWriterRT(fileStream' sourceProvider.WaveFormat))              {                  writer.filename = filename;                  long outputLength = 0;                  var buffer = new byte[sourceProvider.WaveFormat.AverageBytesPerSecond * 4];                  while (true)                  {                      int bytesRead = sourceProvider.Read(buffer' 0' buffer.Length);                      if (bytesRead == 0)                      {                          // end of source provider                          break;                      }                      outputLength += bytesRead;                      // Write will throw exception if WAV file becomes too large                      writer.Write(buffer' 0' bytesRead);                  }              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,CreateFactChunk,The following statement contains a magic number: if (HasFactChunk())              {                  this.writer.Write(System.Text.Encoding.UTF8.GetBytes("fact"));                  this.writer.Write((int)4);                  factSampleCountPos = this.outStream.Position;                  this.writer.Write((int)0); // number of samples              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,UpdateRiffChunk,The following statement contains a magic number: writer.Seek(4' SeekOrigin.Begin);
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,UpdateRiffChunk,The following statement contains a magic number: writer.Write((UInt32)(outStream.Length - 8));
Magic Number,NAudio.Wave,WaveFileWriterRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WaveFileWriterRT.cs,UpdateFactChunk,The following statement contains a magic number: if (HasFactChunk())              {                  int bitsPerSample = (format.BitsPerSample * format.Channels);                  if (bitsPerSample != 0)                  {                      writer.Seek((int)factSampleCountPos' SeekOrigin.Begin);                                            writer.Write((int)((dataChunkSize * 8) / bitsPerSample));                  }              }
Magic Number,NAudio.SoundFont,InstrumentBuilder,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\InstrumentBuilder.cs,Read,The following statement contains a magic number: string s = Encoding.UTF8.GetString(br.ReadBytes(20)' 0' 20);
Magic Number,NAudio.SoundFont,InstrumentBuilder,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\InstrumentBuilder.cs,Read,The following statement contains a magic number: string s = Encoding.UTF8.GetString(br.ReadBytes(20)' 0' 20);
Magic Number,NAudio.SoundFont,ModulatorType,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\ModulatorType.cs,ModulatorType,The following statement contains a magic number: sourceType = (SourceTypeEnum) ((raw & (0xFC00)) >> 10);
Magic Number,NAudio.SoundFont,PresetBuilder,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\PresetBuilder.cs,Read,The following statement contains a magic number: string s = Encoding.UTF8.GetString(br.ReadBytes(20)' 0' 20);
Magic Number,NAudio.SoundFont,PresetBuilder,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\PresetBuilder.cs,Read,The following statement contains a magic number: string s = Encoding.UTF8.GetString(br.ReadBytes(20)' 0' 20);
Magic Number,NAudio.SoundFont,RiffChunk,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\RiffChunk.cs,ReadChunkID,The following statement contains a magic number: byte []cid = riffFile.ReadBytes(4);
Magic Number,NAudio.SoundFont,RiffChunk,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\RiffChunk.cs,ReadChunkID,The following statement contains a magic number: if(cid.Length != 4)   			{  				throw new InvalidDataException("Couldn't read Chunk ID");  			}
Magic Number,NAudio.SoundFont,RiffChunk,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\RiffChunk.cs,GetNextSubChunk,The following statement contains a magic number: if(riffFile.BaseStream.Position + 8 < dataOffset + chunkSize)   			{  				RiffChunk chunk = new RiffChunk(riffFile);  				chunk.ReadChunk();  				return chunk;  			}
Magic Number,NAudio.SoundFont,SampleHeaderBuilder,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\SampleHeaderBuilder.cs,Read,The following statement contains a magic number: var s = br.ReadBytes(20);
Magic Number,NAudio.MediaFoundation,MediaFoundationApi,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationHelpers.cs,Startup,The following statement contains a magic number: if (!initialized)              {                  var sdkVersion = MediaFoundationInterop.MF_SDK_VERSION;  #if !NETFX_CORE                  var os = Environment.OSVersion;                  if (os.Version.Major == 6 && os.Version.Minor == 0)                      sdkVersion = 1;  #endif                  MediaFoundationInterop.MFStartup((sdkVersion << 16) | MediaFoundationInterop.MF_API_VERSION' 0);                  initialized = true;              }
Magic Number,NAudio.Utils,HResult,C:\repos\naudio_NAudio\NAudio\Utils\HResult.cs,MAKE_HRESULT,The following statement contains a magic number: return (int) (((uint)sev) << 31 | ((uint)fac) << 16 | ((uint)code));
Magic Number,NAudio.Utils,HResult,C:\repos\naudio_NAudio\NAudio\Utils\HResult.cs,MAKE_HRESULT,The following statement contains a magic number: return (int) (((uint)sev) << 31 | ((uint)fac) << 16 | ((uint)code));
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,UnsignedToFloat,The following statement contains a magic number: return (((double)((long)(u - 2147483647L - 1))) + 2147483648.0);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ldexp,The following statement contains a magic number: return x * Math.Pow(2' exp);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,frexp,The following statement contains a magic number: exp = (int)Math.Floor(Math.Log(x) / Math.Log(2)) + 1;
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,frexp,The following statement contains a magic number: return 1 - (Math.Pow(2' exp) - x) / Math.Pow(2' exp);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,frexp,The following statement contains a magic number: return 1 - (Math.Pow(2' exp) - x) / Math.Pow(2' exp);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,FloatToUnsigned,The following statement contains a magic number: return ((ulong)(((long)(f - 2147483648.0)) + 2147483647L) + 1);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: if (num == 0)              {                  expon = 0; hiMant = 0; loMant = 0;              }              else              {                  fMant = frexp(num' out expon);                  if ((expon > 16384) || !(fMant < 1))                  {   //  Infinity or NaN                       expon = sign | 0x7FFF; hiMant = 0; loMant = 0; // infinity                   }                  else                  {    // Finite                       expon += 16382;                      if (expon < 0)                      {    // denormalized                          fMant = ldexp(fMant' expon);                          expon = 0;                      }                      expon |= sign;                      fMant = ldexp(fMant' 32);                      fsMant = Math.Floor(fMant);                      hiMant = FloatToUnsigned(fsMant);                      fMant = ldexp(fMant - fsMant' 32);                      fsMant = Math.Floor(fMant);                      loMant = FloatToUnsigned(fsMant);                  }              }
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: if (num == 0)              {                  expon = 0; hiMant = 0; loMant = 0;              }              else              {                  fMant = frexp(num' out expon);                  if ((expon > 16384) || !(fMant < 1))                  {   //  Infinity or NaN                       expon = sign | 0x7FFF; hiMant = 0; loMant = 0; // infinity                   }                  else                  {    // Finite                       expon += 16382;                      if (expon < 0)                      {    // denormalized                          fMant = ldexp(fMant' expon);                          expon = 0;                      }                      expon |= sign;                      fMant = ldexp(fMant' 32);                      fsMant = Math.Floor(fMant);                      hiMant = FloatToUnsigned(fsMant);                      fMant = ldexp(fMant - fsMant' 32);                      fsMant = Math.Floor(fMant);                      loMant = FloatToUnsigned(fsMant);                  }              }
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: if (num == 0)              {                  expon = 0; hiMant = 0; loMant = 0;              }              else              {                  fMant = frexp(num' out expon);                  if ((expon > 16384) || !(fMant < 1))                  {   //  Infinity or NaN                       expon = sign | 0x7FFF; hiMant = 0; loMant = 0; // infinity                   }                  else                  {    // Finite                       expon += 16382;                      if (expon < 0)                      {    // denormalized                          fMant = ldexp(fMant' expon);                          expon = 0;                      }                      expon |= sign;                      fMant = ldexp(fMant' 32);                      fsMant = Math.Floor(fMant);                      hiMant = FloatToUnsigned(fsMant);                      fMant = ldexp(fMant - fsMant' 32);                      fsMant = Math.Floor(fMant);                      loMant = FloatToUnsigned(fsMant);                  }              }
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: if (num == 0)              {                  expon = 0; hiMant = 0; loMant = 0;              }              else              {                  fMant = frexp(num' out expon);                  if ((expon > 16384) || !(fMant < 1))                  {   //  Infinity or NaN                       expon = sign | 0x7FFF; hiMant = 0; loMant = 0; // infinity                   }                  else                  {    // Finite                       expon += 16382;                      if (expon < 0)                      {    // denormalized                          fMant = ldexp(fMant' expon);                          expon = 0;                      }                      expon |= sign;                      fMant = ldexp(fMant' 32);                      fsMant = Math.Floor(fMant);                      hiMant = FloatToUnsigned(fsMant);                      fMant = ldexp(fMant - fsMant' 32);                      fsMant = Math.Floor(fMant);                      loMant = FloatToUnsigned(fsMant);                  }              }
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: byte[] bytes = new byte[10];
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[0] = (byte)(expon >> 8);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[2] = (byte)(hiMant >> 24);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[2] = (byte)(hiMant >> 24);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[3] = (byte)(hiMant >> 16);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[3] = (byte)(hiMant >> 16);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[4] = (byte)(hiMant >> 8);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[4] = (byte)(hiMant >> 8);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[5] = (byte)(hiMant);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[6] = (byte)(loMant >> 24);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[6] = (byte)(loMant >> 24);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[7] = (byte)(loMant >> 16);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[7] = (byte)(loMant >> 16);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[8] = (byte)(loMant >> 8);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[8] = (byte)(loMant >> 8);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[9] = (byte)(loMant);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: if (bytes.Length != 10) throw new Exception("Incorrect length for IEEE extended.");
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: expon = ((bytes[0] & 0x7F) << 8) | bytes[1];
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: hiMant = (uint)((bytes[2] << 24) | (bytes[3] << 16) | (bytes[4] << 8) | bytes[5]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: hiMant = (uint)((bytes[2] << 24) | (bytes[3] << 16) | (bytes[4] << 8) | bytes[5]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: hiMant = (uint)((bytes[2] << 24) | (bytes[3] << 16) | (bytes[4] << 8) | bytes[5]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: hiMant = (uint)((bytes[2] << 24) | (bytes[3] << 16) | (bytes[4] << 8) | bytes[5]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: hiMant = (uint)((bytes[2] << 24) | (bytes[3] << 16) | (bytes[4] << 8) | bytes[5]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: hiMant = (uint)((bytes[2] << 24) | (bytes[3] << 16) | (bytes[4] << 8) | bytes[5]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: hiMant = (uint)((bytes[2] << 24) | (bytes[3] << 16) | (bytes[4] << 8) | bytes[5]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: loMant = (uint)((bytes[6] << 24) | (bytes[7] << 16) | (bytes[8] << 8) | bytes[9]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: loMant = (uint)((bytes[6] << 24) | (bytes[7] << 16) | (bytes[8] << 8) | bytes[9]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: loMant = (uint)((bytes[6] << 24) | (bytes[7] << 16) | (bytes[8] << 8) | bytes[9]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: loMant = (uint)((bytes[6] << 24) | (bytes[7] << 16) | (bytes[8] << 8) | bytes[9]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: loMant = (uint)((bytes[6] << 24) | (bytes[7] << 16) | (bytes[8] << 8) | bytes[9]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: loMant = (uint)((bytes[6] << 24) | (bytes[7] << 16) | (bytes[8] << 8) | bytes[9]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: loMant = (uint)((bytes[6] << 24) | (bytes[7] << 16) | (bytes[8] << 8) | bytes[9]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: if (expon == 0 && hiMant == 0 && loMant == 0)              {                  f = 0;              }              else              {                  if (expon == 0x7FFF)    /* Infinity or NaN */                  {                      f = double.NaN;                  }                  else                  {                      expon -= 16383;                      f = ldexp(UnsignedToFloat(hiMant)' expon -= 31);                      f += ldexp(UnsignedToFloat(loMant)' expon -= 32);                  }              }
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: if (expon == 0 && hiMant == 0 && loMant == 0)              {                  f = 0;              }              else              {                  if (expon == 0x7FFF)    /* Infinity or NaN */                  {                      f = double.NaN;                  }                  else                  {                      expon -= 16383;                      f = ldexp(UnsignedToFloat(hiMant)' expon -= 31);                      f += ldexp(UnsignedToFloat(loMant)' expon -= 32);                  }              }
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: if (expon == 0 && hiMant == 0 && loMant == 0)              {                  f = 0;              }              else              {                  if (expon == 0x7FFF)    /* Infinity or NaN */                  {                      f = double.NaN;                  }                  else                  {                      expon -= 16383;                      f = ldexp(UnsignedToFloat(hiMant)' expon -= 31);                      f += ldexp(UnsignedToFloat(loMant)' expon -= 32);                  }              }
Magic Number,NAudio.Utils,MergeSort,C:\repos\naudio_NAudio\NAudio\Utils\MergeSort.cs,Sort,The following statement contains a magic number: int midIndex = (lowIndex + highIndex) / 2;
Magic Number,NAudio.Wave.SampleProviders,Mono16SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono16SampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.Pcm &&                  waveFormat.BitsPerSample == 16 &&                  waveFormat.Channels == 1;
Magic Number,NAudio.Wave.SampleProviders,Mono16SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono16SampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: int sourceBytesRequired = samplePairsRequired * 2;
Magic Number,NAudio.Wave.SampleProviders,Mono16SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono16SampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: sourceSamples = source.Read(sourceBuffer' 0' sourceBytesRequired) / 2;
Magic Number,NAudio.Wave.SampleProviders,Mono24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono24SampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.Pcm &&                  waveFormat.BitsPerSample == 24 &&                  waveFormat.Channels == 1;
Magic Number,NAudio.Wave.SampleProviders,Mono24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono24SampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: int sourceBytesRequired = samplePairsRequired * 3;
Magic Number,NAudio.Wave.SampleProviders,Mono24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = sampleLeft;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Mono24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = sampleLeft;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Mono24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = sampleLeft;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Mono24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = sampleLeft;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Mono8SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono8SampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.Pcm &&                  waveFormat.BitsPerSample == 8 &&                  waveFormat.Channels == 1;
Magic Number,NAudio.Wave.SampleProviders,MonoFloatSampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\MonoFloatSampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: int sourceBytesRequired = samplePairsRequired * 4;
Magic Number,NAudio.Wave.SampleProviders,MonoFloatSampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\MonoFloatSampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: sourceSamples = source.Read(sourceBuffer' 0' sourceBytesRequired) / 4;
Magic Number,NAudio.Wave.SampleProviders,Stereo16SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo16SampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.Pcm &&                  waveFormat.BitsPerSample == 16 &&                  waveFormat.Channels == 2;
Magic Number,NAudio.Wave.SampleProviders,Stereo16SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo16SampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.Pcm &&                  waveFormat.BitsPerSample == 16 &&                  waveFormat.Channels == 2;
Magic Number,NAudio.Wave.SampleProviders,Stereo16SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo16SampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: int sourceBytesRequired = samplePairsRequired * 4;
Magic Number,NAudio.Wave.SampleProviders,Stereo16SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo16SampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: sourceSamples = source.Read(sourceBuffer' 0' sourceBytesRequired) / 2;
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.Pcm &&                  waveFormat.BitsPerSample == 24 &&                  waveFormat.Channels == 2;
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.Pcm &&                  waveFormat.BitsPerSample == 24 &&                  waveFormat.Channels == 2;
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: int sourceBytesRequired = samplePairsRequired * 6;
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Stereo8SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo8SampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.Pcm &&                  waveFormat.BitsPerSample == 8 &&                  waveFormat.Channels == 2;
Magic Number,NAudio.Wave.SampleProviders,Stereo8SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo8SampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.Pcm &&                  waveFormat.BitsPerSample == 8 &&                  waveFormat.Channels == 2;
Magic Number,NAudio.Wave.SampleProviders,Stereo8SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo8SampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: int sourceBytesRequired = samplePairsRequired * 2;
Magic Number,NAudio.Wave.SampleProviders,StereoFloatSampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\StereoFloatSampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.IeeeFloat &&                  waveFormat.Channels == 2;
Magic Number,NAudio.Wave.SampleProviders,StereoFloatSampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\StereoFloatSampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: int sourceBytesRequired = samplePairsRequired * 8;
Magic Number,NAudio.Wave.SampleProviders,StereoFloatSampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\StereoFloatSampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: sourceSamples = source.Read(sourceBuffer' 0' sourceBytesRequired) / 4;
Magic Number,NAudio.Wave.SampleProviders,FadeInOutSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\FadeInOutSampleProvider.cs,BeginFadeIn,The following statement contains a magic number: lock (lockObject)              {                  fadeSamplePosition = 0;                  fadeSampleCount = (int)((fadeDurationInMilliseconds * source.WaveFormat.SampleRate) / 1000);                  fadeState = FadeState.FadingIn;              }
Magic Number,NAudio.Wave.SampleProviders,FadeInOutSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\FadeInOutSampleProvider.cs,BeginFadeOut,The following statement contains a magic number: lock (lockObject)              {                  fadeSamplePosition = 0;                  fadeSampleCount = (int)((fadeDurationInMilliseconds * source.WaveFormat.SampleRate) / 1000);                  fadeState = FadeState.FadingOut;              }
Magic Number,NAudio.Wave.SampleProviders,MonoToStereoSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\MonoToStereoSampleProvider.cs,MonoToStereoSampleProvider,The following statement contains a magic number: WaveFormat = WaveFormat.CreateIeeeFloatWaveFormat(source.WaveFormat.SampleRate' 2);
Magic Number,NAudio.Wave.SampleProviders,MonoToStereoSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\MonoToStereoSampleProvider.cs,Read,The following statement contains a magic number: var sourceSamplesRequired = count / 2;
Magic Number,NAudio.Wave.SampleProviders,MonoToStereoSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\MonoToStereoSampleProvider.cs,Read,The following statement contains a magic number: return sourceSamplesRead * 2;
Magic Number,NAudio.Wave.SampleProviders,OffsetSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\OffsetSampleProvider.cs,Read,The following statement contains a magic number: if (phase == 2) // skip              {                  if (SkipOverSamples > 0)                  {                      var skipBuffer = new float[WaveFormat.SampleRate * WaveFormat.Channels];                      // skip everything                      int samplesSkipped = 0;                      while (samplesSkipped < SkipOverSamples)                      {                          int samplesRequired = Math.Min(SkipOverSamples - samplesSkipped' skipBuffer.Length);                          var read = sourceProvider.Read(skipBuffer' 0' samplesRequired);                          if (read == 0) // source has ended while still in skip                          {                              break;                          }                          samplesSkipped += read;                      }                  }                  phase++;                  phasePos = 0;              }
Magic Number,NAudio.Wave.SampleProviders,OffsetSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\OffsetSampleProvider.cs,Read,The following statement contains a magic number: if (phase == 3) // take              {                  int samplesRequired = count - samplesRead;                  if (takeSamples != 0)                      samplesRequired = Math.Min(samplesRequired' takeSamples - phasePos);                  int read = sourceProvider.Read(buffer' offset + samplesRead' samplesRequired);                  phasePos += read;                  samplesRead += read;                  if (read < samplesRequired || (takeSamples > 0 && phasePos >= takeSamples))                  {                      phase++;                      phasePos = 0;                  }              }
Magic Number,NAudio.Wave.SampleProviders,OffsetSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\OffsetSampleProvider.cs,Read,The following statement contains a magic number: if (phase == 4) // lead out              {                  int samplesRequired = Math.Min(count - samplesRead' LeadOutSamples - phasePos);                  for (int n = 0; n < samplesRequired; n++)                  {                      buffer[offset + samplesRead + n] = 0;                  }                  phasePos += samplesRequired;                  samplesRead += samplesRequired;                  if (phasePos >= LeadOutSamples)                  {                      phase++;                      phasePos = 0;                  }              }
Magic Number,NAudio.Wave.SampleProviders,PanningSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\PanningSampleProvider.cs,PanningSampleProvider,The following statement contains a magic number: waveFormat = WaveFormat.CreateIeeeFloatWaveFormat(source.WaveFormat.SampleRate' 2);
Magic Number,NAudio.Wave.SampleProviders,PanningSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\PanningSampleProvider.cs,Read,The following statement contains a magic number: int sourceSamplesRequired = count / 2;
Magic Number,NAudio.Wave.SampleProviders,PanningSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\PanningSampleProvider.cs,Read,The following statement contains a magic number: return sourceSamplesRead * 2;
Magic Number,NAudio.Wave.SampleProviders,SquareRootPanStrategy,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\PanningSampleProvider.cs,GetMultipliers,The following statement contains a magic number: float normPan = (-pan + 1) / 2;
Magic Number,NAudio.Wave.SampleProviders,SinPanStrategy,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\PanningSampleProvider.cs,GetMultipliers,The following statement contains a magic number: float normPan = (-pan + 1) / 2;
Magic Number,NAudio.Wave.SampleProviders,LinearPanStrategy,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\PanningSampleProvider.cs,GetMultipliers,The following statement contains a magic number: float normPan = (-pan + 1) / 2;
Magic Number,NAudio.Wave.SampleProviders,Pcm16BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm16BitToSampleProvider.cs,Read,The following statement contains a magic number: int sourceBytesRequired = count * 2;
Magic Number,NAudio.Wave.SampleProviders,Pcm16BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm16BitToSampleProvider.cs,Read,The following statement contains a magic number: for(int n = 0; n < bytesRead; n+=2)              {                  buffer[outIndex++] = BitConverter.ToInt16(sourceBuffer' n) / 32768f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm16BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm16BitToSampleProvider.cs,Read,The following statement contains a magic number: return bytesRead / 2;
Magic Number,NAudio.Wave.SampleProviders,Pcm24BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm24BitToSampleProvider.cs,Read,The following statement contains a magic number: int sourceBytesRequired = count * 3;
Magic Number,NAudio.Wave.SampleProviders,Pcm24BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm24BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 3)              {                  buffer[outIndex++] = (((sbyte)sourceBuffer[n + 2] << 16) | (sourceBuffer[n + 1] << 8) | sourceBuffer[n]) / 8388608f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm24BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm24BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 3)              {                  buffer[outIndex++] = (((sbyte)sourceBuffer[n + 2] << 16) | (sourceBuffer[n + 1] << 8) | sourceBuffer[n]) / 8388608f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm24BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm24BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 3)              {                  buffer[outIndex++] = (((sbyte)sourceBuffer[n + 2] << 16) | (sourceBuffer[n + 1] << 8) | sourceBuffer[n]) / 8388608f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm24BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm24BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 3)              {                  buffer[outIndex++] = (((sbyte)sourceBuffer[n + 2] << 16) | (sourceBuffer[n + 1] << 8) | sourceBuffer[n]) / 8388608f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm24BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm24BitToSampleProvider.cs,Read,The following statement contains a magic number: return bytesRead / 3;
Magic Number,NAudio.Wave.SampleProviders,Pcm32BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm32BitToSampleProvider.cs,Read,The following statement contains a magic number: int sourceBytesRequired = count*4;
Magic Number,NAudio.Wave.SampleProviders,Pcm32BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm32BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 4)              {                  buffer[outIndex++] = (((sbyte) sourceBuffer[n + 3] << 24 |                                         sourceBuffer[n + 2] << 16) |                                        (sourceBuffer[n + 1] << 8) |                                        sourceBuffer[n])/2147483648f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm32BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm32BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 4)              {                  buffer[outIndex++] = (((sbyte) sourceBuffer[n + 3] << 24 |                                         sourceBuffer[n + 2] << 16) |                                        (sourceBuffer[n + 1] << 8) |                                        sourceBuffer[n])/2147483648f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm32BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm32BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 4)              {                  buffer[outIndex++] = (((sbyte) sourceBuffer[n + 3] << 24 |                                         sourceBuffer[n + 2] << 16) |                                        (sourceBuffer[n + 1] << 8) |                                        sourceBuffer[n])/2147483648f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm32BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm32BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 4)              {                  buffer[outIndex++] = (((sbyte) sourceBuffer[n + 3] << 24 |                                         sourceBuffer[n + 2] << 16) |                                        (sourceBuffer[n + 1] << 8) |                                        sourceBuffer[n])/2147483648f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm32BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm32BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 4)              {                  buffer[outIndex++] = (((sbyte) sourceBuffer[n + 3] << 24 |                                         sourceBuffer[n + 2] << 16) |                                        (sourceBuffer[n + 1] << 8) |                                        sourceBuffer[n])/2147483648f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm32BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm32BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 4)              {                  buffer[outIndex++] = (((sbyte) sourceBuffer[n + 3] << 24 |                                         sourceBuffer[n + 2] << 16) |                                        (sourceBuffer[n + 1] << 8) |                                        sourceBuffer[n])/2147483648f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm32BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm32BitToSampleProvider.cs,Read,The following statement contains a magic number: return bytesRead/4;
Magic Number,NAudio.Wave.SampleProviders,SampleProviderConverters,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleProviderConverters.cs,ConvertWaveProviderIntoSampleProvider,The following statement contains a magic number: if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.Pcm)              {                  // go to float                  if (waveProvider.WaveFormat.BitsPerSample == 8)                  {                      sampleProvider = new Pcm8BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 16)                  {                      sampleProvider = new Pcm16BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 24)                  {                      sampleProvider = new Pcm24BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 32)                  {                      sampleProvider = new Pcm32BitToSampleProvider(waveProvider);                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }              else if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  if (waveProvider.WaveFormat.BitsPerSample == 64)                      sampleProvider = new WaveToSampleProvider64(waveProvider);                  else                      sampleProvider = new WaveToSampleProvider(waveProvider);              }              else              {                  throw new ArgumentException("Unsupported source encoding");              }
Magic Number,NAudio.Wave.SampleProviders,SampleProviderConverters,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleProviderConverters.cs,ConvertWaveProviderIntoSampleProvider,The following statement contains a magic number: if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.Pcm)              {                  // go to float                  if (waveProvider.WaveFormat.BitsPerSample == 8)                  {                      sampleProvider = new Pcm8BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 16)                  {                      sampleProvider = new Pcm16BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 24)                  {                      sampleProvider = new Pcm24BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 32)                  {                      sampleProvider = new Pcm32BitToSampleProvider(waveProvider);                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }              else if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  if (waveProvider.WaveFormat.BitsPerSample == 64)                      sampleProvider = new WaveToSampleProvider64(waveProvider);                  else                      sampleProvider = new WaveToSampleProvider(waveProvider);              }              else              {                  throw new ArgumentException("Unsupported source encoding");              }
Magic Number,NAudio.Wave.SampleProviders,SampleProviderConverters,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleProviderConverters.cs,ConvertWaveProviderIntoSampleProvider,The following statement contains a magic number: if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.Pcm)              {                  // go to float                  if (waveProvider.WaveFormat.BitsPerSample == 8)                  {                      sampleProvider = new Pcm8BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 16)                  {                      sampleProvider = new Pcm16BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 24)                  {                      sampleProvider = new Pcm24BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 32)                  {                      sampleProvider = new Pcm32BitToSampleProvider(waveProvider);                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }              else if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  if (waveProvider.WaveFormat.BitsPerSample == 64)                      sampleProvider = new WaveToSampleProvider64(waveProvider);                  else                      sampleProvider = new WaveToSampleProvider(waveProvider);              }              else              {                  throw new ArgumentException("Unsupported source encoding");              }
Magic Number,NAudio.Wave.SampleProviders,SampleProviderConverters,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleProviderConverters.cs,ConvertWaveProviderIntoSampleProvider,The following statement contains a magic number: if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.Pcm)              {                  // go to float                  if (waveProvider.WaveFormat.BitsPerSample == 8)                  {                      sampleProvider = new Pcm8BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 16)                  {                      sampleProvider = new Pcm16BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 24)                  {                      sampleProvider = new Pcm24BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 32)                  {                      sampleProvider = new Pcm32BitToSampleProvider(waveProvider);                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }              else if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  if (waveProvider.WaveFormat.BitsPerSample == 64)                      sampleProvider = new WaveToSampleProvider64(waveProvider);                  else                      sampleProvider = new WaveToSampleProvider(waveProvider);              }              else              {                  throw new ArgumentException("Unsupported source encoding");              }
Magic Number,NAudio.Wave.SampleProviders,SampleProviderConverters,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleProviderConverters.cs,ConvertWaveProviderIntoSampleProvider,The following statement contains a magic number: if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.Pcm)              {                  // go to float                  if (waveProvider.WaveFormat.BitsPerSample == 8)                  {                      sampleProvider = new Pcm8BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 16)                  {                      sampleProvider = new Pcm16BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 24)                  {                      sampleProvider = new Pcm24BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 32)                  {                      sampleProvider = new Pcm32BitToSampleProvider(waveProvider);                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }              else if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  if (waveProvider.WaveFormat.BitsPerSample == 64)                      sampleProvider = new WaveToSampleProvider64(waveProvider);                  else                      sampleProvider = new WaveToSampleProvider(waveProvider);              }              else              {                  throw new ArgumentException("Unsupported source encoding");              }
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider.cs,Read,The following statement contains a magic number: int samplesNeeded = count / 4;
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider.cs,Read,The following statement contains a magic number: int samplesRead = source.Read(wb.FloatBuffer' offset / 4' samplesNeeded);
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider.cs,Read,The following statement contains a magic number: return samplesRead * 4;
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider16.cs,SampleToWaveProvider16,The following statement contains a magic number: if (sourceProvider.WaveFormat.BitsPerSample != 32)                  throw new ArgumentException("Input source provider must be 32 bit"' nameof(sourceProvider));
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider16.cs,SampleToWaveProvider16,The following statement contains a magic number: waveFormat = new WaveFormat(sourceProvider.WaveFormat.SampleRate' 16' sourceProvider.WaveFormat.Channels);
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider16.cs,Read,The following statement contains a magic number: int samplesRequired = numBytes / 2;
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider16.cs,Read,The following statement contains a magic number: int destOffset = offset / 2;
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider16.cs,Read,The following statement contains a magic number: for (int sample = 0; sample < sourceSamples; sample++)              {                  // adjust volume                  float sample32 = sourceBuffer[sample] * volume;                  // clip                  if (sample32 > 1.0f)                      sample32 = 1.0f;                  if (sample32 < -1.0f)                      sample32 = -1.0f;                  destWaveBuffer.ShortBuffer[destOffset++] = (short)(sample32 * 32767);              }
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider16.cs,Read,The following statement contains a magic number: return sourceSamples * 2;
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider24,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider24.cs,SampleToWaveProvider24,The following statement contains a magic number: if (sourceProvider.WaveFormat.BitsPerSample != 32)                  throw new ArgumentException("Input source provider must be 32 bit"' "sourceProvider");
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider24,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider24.cs,SampleToWaveProvider24,The following statement contains a magic number: waveFormat = new WaveFormat(sourceProvider.WaveFormat.SampleRate' 24' sourceProvider.WaveFormat.Channels);
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider24,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider24.cs,Read,The following statement contains a magic number: var samplesRequired = numBytes / 3;
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider24,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider24.cs,Read,The following statement contains a magic number: for (var sample = 0; sample < sourceSamples; sample++)              {                  // adjust volume                  var sample32 = sourceBuffer[sample] * volume;                  // clip                  if (sample32 > 1.0f)                      sample32 = 1.0f;                  if (sample32 < -1.0f)                      sample32 = -1.0f;                    var sample24 = (int) (sample32*8388607.0);                  destBuffer[destOffset++] = (byte)(sample24);                  destBuffer[destOffset++] = (byte)(sample24 >> 8);                  destBuffer[destOffset++] = (byte)(sample24 >> 16);              }
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider24,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider24.cs,Read,The following statement contains a magic number: for (var sample = 0; sample < sourceSamples; sample++)              {                  // adjust volume                  var sample32 = sourceBuffer[sample] * volume;                  // clip                  if (sample32 > 1.0f)                      sample32 = 1.0f;                  if (sample32 < -1.0f)                      sample32 = -1.0f;                    var sample24 = (int) (sample32*8388607.0);                  destBuffer[destOffset++] = (byte)(sample24);                  destBuffer[destOffset++] = (byte)(sample24 >> 8);                  destBuffer[destOffset++] = (byte)(sample24 >> 16);              }
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider24,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider24.cs,Read,The following statement contains a magic number: for (var sample = 0; sample < sourceSamples; sample++)              {                  // adjust volume                  var sample32 = sourceBuffer[sample] * volume;                  // clip                  if (sample32 > 1.0f)                      sample32 = 1.0f;                  if (sample32 < -1.0f)                      sample32 = -1.0f;                    var sample24 = (int) (sample32*8388607.0);                  destBuffer[destOffset++] = (byte)(sample24);                  destBuffer[destOffset++] = (byte)(sample24 >> 8);                  destBuffer[destOffset++] = (byte)(sample24 >> 16);              }
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider24,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider24.cs,Read,The following statement contains a magic number: return sourceSamples * 3;
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,SignalGenerator,The following statement contains a magic number: Frequency = 440.0;
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,SignalGenerator,The following statement contains a magic number: SweepLengthSecs = 2;
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,NextRandomTwo,The following statement contains a magic number: return 2*random.NextDouble() - 1;
Magic Number,NAudio.Wave.SampleProviders,StereoToMonoSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\StereoToMonoSampleProvider.cs,StereoToMonoSampleProvider,The following statement contains a magic number: if (sourceProvider.WaveFormat.Channels != 2)              {                  throw new ArgumentException("Source must be stereo");              }
Magic Number,NAudio.Wave.SampleProviders,StereoToMonoSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\StereoToMonoSampleProvider.cs,Read,The following statement contains a magic number: var sourceSamplesRequired = count * 2;
Magic Number,NAudio.Wave.SampleProviders,StereoToMonoSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\StereoToMonoSampleProvider.cs,Read,The following statement contains a magic number: var destOffset = offset / 2;
Magic Number,NAudio.Wave.SampleProviders,StereoToMonoSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\StereoToMonoSampleProvider.cs,Read,The following statement contains a magic number: for (var sourceSample = 0; sourceSample < sourceSamplesRead; sourceSample += 2)              {                  var left = sourceBuffer[sourceSample];                  var right = sourceBuffer[sourceSample + 1];                  var outSample = (left * LeftVolume) + (right * RightVolume);                    buffer[destOffset++] = outSample;              }
Magic Number,NAudio.Wave.SampleProviders,StereoToMonoSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\StereoToMonoSampleProvider.cs,Read,The following statement contains a magic number: return sourceSamplesRead / 2;
Magic Number,NAudio.Wave.SampleProviders,WaveToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\WaveToSampleProvider.cs,Read,The following statement contains a magic number: int bytesNeeded = count * 4;
Magic Number,NAudio.Wave.SampleProviders,WaveToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\WaveToSampleProvider.cs,Read,The following statement contains a magic number: int samplesRead = bytesRead / 4;
Magic Number,NAudio.Wave.SampleProviders,WaveToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\WaveToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n+=4)              {                  buffer[outputIndex++] = BitConverter.ToSingle(sourceBuffer' n);              }
Magic Number,NAudio.Wave.SampleProviders,WaveToSampleProvider64,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\WaveToSampleProvider64.cs,Read,The following statement contains a magic number: int bytesNeeded = count * 8;
Magic Number,NAudio.Wave.SampleProviders,WaveToSampleProvider64,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\WaveToSampleProvider64.cs,Read,The following statement contains a magic number: int samplesRead = bytesRead / 8;
Magic Number,NAudio.Wave.SampleProviders,WaveToSampleProvider64,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\WaveToSampleProvider64.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 8)              {                  long sample64 = BitConverter.ToInt64(sourceBuffer' n);                  buffer[outputIndex++] = (float)BitConverter.Int64BitsToDouble(sample64);              }
Magic Number,NAudio.Wave.SampleProviders,WdlResamplingSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\WdlResamplingSampleProvider.cs,WdlResamplingSampleProvider,The following statement contains a magic number: resampler.SetMode(true' 2' false);
Magic Number,NAudio.Wave.WaveFormats,WmaWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WmaWaveFormat.cs,WmaWaveFormat,The following statement contains a magic number: if (channels == 1)                  dwChannelMask = 1;              else if (channels == 2)                  dwChannelMask = 3;
Magic Number,NAudio.Wave.WaveFormats,WmaWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WmaWaveFormat.cs,WmaWaveFormat,The following statement contains a magic number: if (channels == 1)                  dwChannelMask = 1;              else if (channels == 2)                  dwChannelMask = 3;
Magic Number,NAudio.Win8.Wave.WaveOutputs,WasapiOutRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WasapiOutRT.cs,PlayThread,The following statement contains a magic number: try              {                  if (this.resamplerNeeded)                  {                      var resampler = new WdlResamplingSampleProvider(playbackProvider.ToSampleProvider()' outputFormat.SampleRate);                      playbackProvider = new SampleToWaveProvider(resampler);                  }                    // fill a whole buffer                  bufferFrameCount = audioClient.BufferSize;                  bytesPerFrame = outputFormat.Channels*outputFormat.BitsPerSample/8;                  readBuffer = new byte[bufferFrameCount*bytesPerFrame];                  FillBuffer(playbackProvider' bufferFrameCount);                  int timeout = 3 * latencyMilliseconds;                                    while (playbackState != WasapiOutState.Disposed)                  {                      if (playbackState != WasapiOutState.Playing)                      {                          playThreadEvent.WaitOne(500);                      }                                            // If still playing and notification is ok                      if (playbackState == WasapiOutState.Playing)                      {                          if (!isClientRunning)                          {                              audioClient.Start();                              isClientRunning = true;                          }                          // If using Event Sync' Wait for notification from AudioClient or Sleep half latency                          var r = NativeMethods.WaitForSingleObjectEx(frameEventWaitHandle' timeout' true);                          if (r != 0) throw new InvalidOperationException("Timed out waiting for event");                          // See how much buffer space is available.                          int numFramesPadding = 0;                          // In exclusive mode' always ask the max = bufferFrameCount = audioClient.BufferSize                          numFramesPadding = (shareMode == AudioClientShareMode.Shared) ? audioClient.CurrentPadding : 0;                            int numFramesAvailable = bufferFrameCount - numFramesPadding;                          if (numFramesAvailable > 0)                          {                              FillBuffer(playbackProvider' numFramesAvailable);                          }                      }                        if (playbackState == WasapiOutState.Stopping)                      {                          // play the buffer out                          while (audioClient.CurrentPadding > 0)                          {                              await Task.Delay(latencyMilliseconds / 2);                          }                          audioClient.Stop();                          isClientRunning = false;                          audioClient.Reset();                          playbackState = WasapiOutState.Stopped;                          RaisePlaybackStopped(null);                      }                      if (playbackState == WasapiOutState.Disposing)                      {                          audioClient.Stop();                          isClientRunning = false;                          audioClient.Reset();                          playbackState = WasapiOutState.Disposed;                          var disposablePlaybackProvider = playbackProvider as IDisposable;                          if (disposablePlaybackProvider!=null)                              disposablePlaybackProvider.Dispose(); // do everything on this thread' even dispose in case it is Media Foundation                          RaisePlaybackStopped(null);                        }                    }              }              catch (Exception e)              {                  RaisePlaybackStopped(e);              }              finally              {                  audioClient.Dispose();                  audioClient = null;                  renderClient = null;                  NativeMethods.CloseHandle(frameEventWaitHandle);                }
Magic Number,NAudio.Win8.Wave.WaveOutputs,WasapiOutRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WasapiOutRT.cs,PlayThread,The following statement contains a magic number: try              {                  if (this.resamplerNeeded)                  {                      var resampler = new WdlResamplingSampleProvider(playbackProvider.ToSampleProvider()' outputFormat.SampleRate);                      playbackProvider = new SampleToWaveProvider(resampler);                  }                    // fill a whole buffer                  bufferFrameCount = audioClient.BufferSize;                  bytesPerFrame = outputFormat.Channels*outputFormat.BitsPerSample/8;                  readBuffer = new byte[bufferFrameCount*bytesPerFrame];                  FillBuffer(playbackProvider' bufferFrameCount);                  int timeout = 3 * latencyMilliseconds;                                    while (playbackState != WasapiOutState.Disposed)                  {                      if (playbackState != WasapiOutState.Playing)                      {                          playThreadEvent.WaitOne(500);                      }                                            // If still playing and notification is ok                      if (playbackState == WasapiOutState.Playing)                      {                          if (!isClientRunning)                          {                              audioClient.Start();                              isClientRunning = true;                          }                          // If using Event Sync' Wait for notification from AudioClient or Sleep half latency                          var r = NativeMethods.WaitForSingleObjectEx(frameEventWaitHandle' timeout' true);                          if (r != 0) throw new InvalidOperationException("Timed out waiting for event");                          // See how much buffer space is available.                          int numFramesPadding = 0;                          // In exclusive mode' always ask the max = bufferFrameCount = audioClient.BufferSize                          numFramesPadding = (shareMode == AudioClientShareMode.Shared) ? audioClient.CurrentPadding : 0;                            int numFramesAvailable = bufferFrameCount - numFramesPadding;                          if (numFramesAvailable > 0)                          {                              FillBuffer(playbackProvider' numFramesAvailable);                          }                      }                        if (playbackState == WasapiOutState.Stopping)                      {                          // play the buffer out                          while (audioClient.CurrentPadding > 0)                          {                              await Task.Delay(latencyMilliseconds / 2);                          }                          audioClient.Stop();                          isClientRunning = false;                          audioClient.Reset();                          playbackState = WasapiOutState.Stopped;                          RaisePlaybackStopped(null);                      }                      if (playbackState == WasapiOutState.Disposing)                      {                          audioClient.Stop();                          isClientRunning = false;                          audioClient.Reset();                          playbackState = WasapiOutState.Disposed;                          var disposablePlaybackProvider = playbackProvider as IDisposable;                          if (disposablePlaybackProvider!=null)                              disposablePlaybackProvider.Dispose(); // do everything on this thread' even dispose in case it is Media Foundation                          RaisePlaybackStopped(null);                        }                    }              }              catch (Exception e)              {                  RaisePlaybackStopped(e);              }              finally              {                  audioClient.Dispose();                  audioClient = null;                  renderClient = null;                  NativeMethods.CloseHandle(frameEventWaitHandle);                }
Magic Number,NAudio.Win8.Wave.WaveOutputs,WasapiOutRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WasapiOutRT.cs,PlayThread,The following statement contains a magic number: try              {                  if (this.resamplerNeeded)                  {                      var resampler = new WdlResamplingSampleProvider(playbackProvider.ToSampleProvider()' outputFormat.SampleRate);                      playbackProvider = new SampleToWaveProvider(resampler);                  }                    // fill a whole buffer                  bufferFrameCount = audioClient.BufferSize;                  bytesPerFrame = outputFormat.Channels*outputFormat.BitsPerSample/8;                  readBuffer = new byte[bufferFrameCount*bytesPerFrame];                  FillBuffer(playbackProvider' bufferFrameCount);                  int timeout = 3 * latencyMilliseconds;                                    while (playbackState != WasapiOutState.Disposed)                  {                      if (playbackState != WasapiOutState.Playing)                      {                          playThreadEvent.WaitOne(500);                      }                                            // If still playing and notification is ok                      if (playbackState == WasapiOutState.Playing)                      {                          if (!isClientRunning)                          {                              audioClient.Start();                              isClientRunning = true;                          }                          // If using Event Sync' Wait for notification from AudioClient or Sleep half latency                          var r = NativeMethods.WaitForSingleObjectEx(frameEventWaitHandle' timeout' true);                          if (r != 0) throw new InvalidOperationException("Timed out waiting for event");                          // See how much buffer space is available.                          int numFramesPadding = 0;                          // In exclusive mode' always ask the max = bufferFrameCount = audioClient.BufferSize                          numFramesPadding = (shareMode == AudioClientShareMode.Shared) ? audioClient.CurrentPadding : 0;                            int numFramesAvailable = bufferFrameCount - numFramesPadding;                          if (numFramesAvailable > 0)                          {                              FillBuffer(playbackProvider' numFramesAvailable);                          }                      }                        if (playbackState == WasapiOutState.Stopping)                      {                          // play the buffer out                          while (audioClient.CurrentPadding > 0)                          {                              await Task.Delay(latencyMilliseconds / 2);                          }                          audioClient.Stop();                          isClientRunning = false;                          audioClient.Reset();                          playbackState = WasapiOutState.Stopped;                          RaisePlaybackStopped(null);                      }                      if (playbackState == WasapiOutState.Disposing)                      {                          audioClient.Stop();                          isClientRunning = false;                          audioClient.Reset();                          playbackState = WasapiOutState.Disposed;                          var disposablePlaybackProvider = playbackProvider as IDisposable;                          if (disposablePlaybackProvider!=null)                              disposablePlaybackProvider.Dispose(); // do everything on this thread' even dispose in case it is Media Foundation                          RaisePlaybackStopped(null);                        }                    }              }              catch (Exception e)              {                  RaisePlaybackStopped(e);              }              finally              {                  audioClient.Dispose();                  audioClient = null;                  renderClient = null;                  NativeMethods.CloseHandle(frameEventWaitHandle);                }
Magic Number,NAudio.Win8.Wave.WaveOutputs,WasapiOutRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WasapiOutRT.cs,PlayThread,The following statement contains a magic number: try              {                  if (this.resamplerNeeded)                  {                      var resampler = new WdlResamplingSampleProvider(playbackProvider.ToSampleProvider()' outputFormat.SampleRate);                      playbackProvider = new SampleToWaveProvider(resampler);                  }                    // fill a whole buffer                  bufferFrameCount = audioClient.BufferSize;                  bytesPerFrame = outputFormat.Channels*outputFormat.BitsPerSample/8;                  readBuffer = new byte[bufferFrameCount*bytesPerFrame];                  FillBuffer(playbackProvider' bufferFrameCount);                  int timeout = 3 * latencyMilliseconds;                                    while (playbackState != WasapiOutState.Disposed)                  {                      if (playbackState != WasapiOutState.Playing)                      {                          playThreadEvent.WaitOne(500);                      }                                            // If still playing and notification is ok                      if (playbackState == WasapiOutState.Playing)                      {                          if (!isClientRunning)                          {                              audioClient.Start();                              isClientRunning = true;                          }                          // If using Event Sync' Wait for notification from AudioClient or Sleep half latency                          var r = NativeMethods.WaitForSingleObjectEx(frameEventWaitHandle' timeout' true);                          if (r != 0) throw new InvalidOperationException("Timed out waiting for event");                          // See how much buffer space is available.                          int numFramesPadding = 0;                          // In exclusive mode' always ask the max = bufferFrameCount = audioClient.BufferSize                          numFramesPadding = (shareMode == AudioClientShareMode.Shared) ? audioClient.CurrentPadding : 0;                            int numFramesAvailable = bufferFrameCount - numFramesPadding;                          if (numFramesAvailable > 0)                          {                              FillBuffer(playbackProvider' numFramesAvailable);                          }                      }                        if (playbackState == WasapiOutState.Stopping)                      {                          // play the buffer out                          while (audioClient.CurrentPadding > 0)                          {                              await Task.Delay(latencyMilliseconds / 2);                          }                          audioClient.Stop();                          isClientRunning = false;                          audioClient.Reset();                          playbackState = WasapiOutState.Stopped;                          RaisePlaybackStopped(null);                      }                      if (playbackState == WasapiOutState.Disposing)                      {                          audioClient.Stop();                          isClientRunning = false;                          audioClient.Reset();                          playbackState = WasapiOutState.Disposed;                          var disposablePlaybackProvider = playbackProvider as IDisposable;                          if (disposablePlaybackProvider!=null)                              disposablePlaybackProvider.Dispose(); // do everything on this thread' even dispose in case it is Media Foundation                          RaisePlaybackStopped(null);                        }                    }              }              catch (Exception e)              {                  RaisePlaybackStopped(e);              }              finally              {                  audioClient.Dispose();                  audioClient = null;                  renderClient = null;                  NativeMethods.CloseHandle(frameEventWaitHandle);                }
Magic Number,NAudio.Win8.Wave.WaveOutputs,WasapiOutRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WasapiOutRT.cs,Init,The following statement contains a magic number: long latencyRefTimes = latencyMilliseconds*10000;
Magic Number,NAudio.Win8.Wave.WaveOutputs,WasapiOutRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WasapiOutRT.cs,Init,The following statement contains a magic number: if (!audioClient.IsFormatSupported(shareMode' outputFormat' out closestSampleRateFormat))              {                  // Use closesSampleRateFormat (in sharedMode' it equals usualy to the audioClient.MixFormat)                  // See documentation : http://msdn.microsoft.com/en-us/library/ms678737(VS.85).aspx                   // They say : "In shared mode' the audio engine always supports the mix format"                  // The MixFormat is more likely to be a WaveFormatExtensible.                  if (closestSampleRateFormat == null)                  {                      WaveFormat correctSampleRateFormat = audioClient.MixFormat;                      /*WaveFormat.CreateIeeeFloatWaveFormat(                      audioClient.MixFormat.SampleRate'                      audioClient.MixFormat.Channels);*/                        if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                      {                          // Iterate from Worst to Best Format                          WaveFormatExtensible[] bestToWorstFormats =                              {                                  new WaveFormatExtensible(                                      outputFormat.SampleRate' 32'                                      outputFormat.Channels)'                                  new WaveFormatExtensible(                                      outputFormat.SampleRate' 24'                                      outputFormat.Channels)'                                  new WaveFormatExtensible(                                      outputFormat.SampleRate' 16'                                      outputFormat.Channels)'                              };                            // Check from best Format to worst format ( Float32' Int24' Int16 )                          for (int i = 0; i < bestToWorstFormats.Length; i++)                          {                              correctSampleRateFormat = bestToWorstFormats[i];                              if (audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                              {                                  break;                              }                              correctSampleRateFormat = null;                          }                            // If still null' then test on the PCM16' 2 channels                          if (correctSampleRateFormat == null)                          {                              // Last Last Last Chance (Thanks WASAPI)                              correctSampleRateFormat = new WaveFormatExtensible(outputFormat.SampleRate' 16' 2);                              if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                              {                                  throw new NotSupportedException("Can't find a supported format to use");                              }                          }                      }                      outputFormat = correctSampleRateFormat;                  }                  else                  {                      outputFormat = closestSampleRateFormat;                  }                    // just check that we can make it.                  //using (new MediaFoundationResampler(waveProvider' outputFormat))                  {                  }                  this.resamplerNeeded = true;              }              else              {                  resamplerNeeded = false;              }
Magic Number,NAudio.Win8.Wave.WaveOutputs,WasapiOutRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WasapiOutRT.cs,Init,The following statement contains a magic number: if (!audioClient.IsFormatSupported(shareMode' outputFormat' out closestSampleRateFormat))              {                  // Use closesSampleRateFormat (in sharedMode' it equals usualy to the audioClient.MixFormat)                  // See documentation : http://msdn.microsoft.com/en-us/library/ms678737(VS.85).aspx                   // They say : "In shared mode' the audio engine always supports the mix format"                  // The MixFormat is more likely to be a WaveFormatExtensible.                  if (closestSampleRateFormat == null)                  {                      WaveFormat correctSampleRateFormat = audioClient.MixFormat;                      /*WaveFormat.CreateIeeeFloatWaveFormat(                      audioClient.MixFormat.SampleRate'                      audioClient.MixFormat.Channels);*/                        if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                      {                          // Iterate from Worst to Best Format                          WaveFormatExtensible[] bestToWorstFormats =                              {                                  new WaveFormatExtensible(                                      outputFormat.SampleRate' 32'                                      outputFormat.Channels)'                                  new WaveFormatExtensible(                                      outputFormat.SampleRate' 24'                                      outputFormat.Channels)'                                  new WaveFormatExtensible(                                      outputFormat.SampleRate' 16'                                      outputFormat.Channels)'                              };                            // Check from best Format to worst format ( Float32' Int24' Int16 )                          for (int i = 0; i < bestToWorstFormats.Length; i++)                          {                              correctSampleRateFormat = bestToWorstFormats[i];                              if (audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                              {                                  break;                              }                              correctSampleRateFormat = null;                          }                            // If still null' then test on the PCM16' 2 channels                          if (correctSampleRateFormat == null)                          {                              // Last Last Last Chance (Thanks WASAPI)                              correctSampleRateFormat = new WaveFormatExtensible(outputFormat.SampleRate' 16' 2);                              if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                              {                                  throw new NotSupportedException("Can't find a supported format to use");                              }                          }                      }                      outputFormat = correctSampleRateFormat;                  }                  else                  {                      outputFormat = closestSampleRateFormat;                  }                    // just check that we can make it.                  //using (new MediaFoundationResampler(waveProvider' outputFormat))                  {                  }                  this.resamplerNeeded = true;              }              else              {                  resamplerNeeded = false;              }
Magic Number,NAudio.Win8.Wave.WaveOutputs,WasapiOutRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WasapiOutRT.cs,Init,The following statement contains a magic number: if (!audioClient.IsFormatSupported(shareMode' outputFormat' out closestSampleRateFormat))              {                  // Use closesSampleRateFormat (in sharedMode' it equals usualy to the audioClient.MixFormat)                  // See documentation : http://msdn.microsoft.com/en-us/library/ms678737(VS.85).aspx                   // They say : "In shared mode' the audio engine always supports the mix format"                  // The MixFormat is more likely to be a WaveFormatExtensible.                  if (closestSampleRateFormat == null)                  {                      WaveFormat correctSampleRateFormat = audioClient.MixFormat;                      /*WaveFormat.CreateIeeeFloatWaveFormat(                      audioClient.MixFormat.SampleRate'                      audioClient.MixFormat.Channels);*/                        if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                      {                          // Iterate from Worst to Best Format                          WaveFormatExtensible[] bestToWorstFormats =                              {                                  new WaveFormatExtensible(                                      outputFormat.SampleRate' 32'                                      outputFormat.Channels)'                                  new WaveFormatExtensible(                                      outputFormat.SampleRate' 24'                                      outputFormat.Channels)'                                  new WaveFormatExtensible(                                      outputFormat.SampleRate' 16'                                      outputFormat.Channels)'                              };                            // Check from best Format to worst format ( Float32' Int24' Int16 )                          for (int i = 0; i < bestToWorstFormats.Length; i++)                          {                              correctSampleRateFormat = bestToWorstFormats[i];                              if (audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                              {                                  break;                              }                              correctSampleRateFormat = null;                          }                            // If still null' then test on the PCM16' 2 channels                          if (correctSampleRateFormat == null)                          {                              // Last Last Last Chance (Thanks WASAPI)                              correctSampleRateFormat = new WaveFormatExtensible(outputFormat.SampleRate' 16' 2);                              if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                              {                                  throw new NotSupportedException("Can't find a supported format to use");                              }                          }                      }                      outputFormat = correctSampleRateFormat;                  }                  else                  {                      outputFormat = closestSampleRateFormat;                  }                    // just check that we can make it.                  //using (new MediaFoundationResampler(waveProvider' outputFormat))                  {                  }                  this.resamplerNeeded = true;              }              else              {                  resamplerNeeded = false;              }
Magic Number,NAudio.Win8.Wave.WaveOutputs,WasapiOutRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WasapiOutRT.cs,Init,The following statement contains a magic number: if (!audioClient.IsFormatSupported(shareMode' outputFormat' out closestSampleRateFormat))              {                  // Use closesSampleRateFormat (in sharedMode' it equals usualy to the audioClient.MixFormat)                  // See documentation : http://msdn.microsoft.com/en-us/library/ms678737(VS.85).aspx                   // They say : "In shared mode' the audio engine always supports the mix format"                  // The MixFormat is more likely to be a WaveFormatExtensible.                  if (closestSampleRateFormat == null)                  {                      WaveFormat correctSampleRateFormat = audioClient.MixFormat;                      /*WaveFormat.CreateIeeeFloatWaveFormat(                      audioClient.MixFormat.SampleRate'                      audioClient.MixFormat.Channels);*/                        if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                      {                          // Iterate from Worst to Best Format                          WaveFormatExtensible[] bestToWorstFormats =                              {                                  new WaveFormatExtensible(                                      outputFormat.SampleRate' 32'                                      outputFormat.Channels)'                                  new WaveFormatExtensible(                                      outputFormat.SampleRate' 24'                                      outputFormat.Channels)'                                  new WaveFormatExtensible(                                      outputFormat.SampleRate' 16'                                      outputFormat.Channels)'                              };                            // Check from best Format to worst format ( Float32' Int24' Int16 )                          for (int i = 0; i < bestToWorstFormats.Length; i++)                          {                              correctSampleRateFormat = bestToWorstFormats[i];                              if (audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                              {                                  break;                              }                              correctSampleRateFormat = null;                          }                            // If still null' then test on the PCM16' 2 channels                          if (correctSampleRateFormat == null)                          {                              // Last Last Last Chance (Thanks WASAPI)                              correctSampleRateFormat = new WaveFormatExtensible(outputFormat.SampleRate' 16' 2);                              if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                              {                                  throw new NotSupportedException("Can't find a supported format to use");                              }                          }                      }                      outputFormat = correctSampleRateFormat;                  }                  else                  {                      outputFormat = closestSampleRateFormat;                  }                    // just check that we can make it.                  //using (new MediaFoundationResampler(waveProvider' outputFormat))                  {                  }                  this.resamplerNeeded = true;              }              else              {                  resamplerNeeded = false;              }
Magic Number,NAudio.Win8.Wave.WaveOutputs,WasapiOutRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WasapiOutRT.cs,Init,The following statement contains a magic number: if (!audioClient.IsFormatSupported(shareMode' outputFormat' out closestSampleRateFormat))              {                  // Use closesSampleRateFormat (in sharedMode' it equals usualy to the audioClient.MixFormat)                  // See documentation : http://msdn.microsoft.com/en-us/library/ms678737(VS.85).aspx                   // They say : "In shared mode' the audio engine always supports the mix format"                  // The MixFormat is more likely to be a WaveFormatExtensible.                  if (closestSampleRateFormat == null)                  {                      WaveFormat correctSampleRateFormat = audioClient.MixFormat;                      /*WaveFormat.CreateIeeeFloatWaveFormat(                      audioClient.MixFormat.SampleRate'                      audioClient.MixFormat.Channels);*/                        if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                      {                          // Iterate from Worst to Best Format                          WaveFormatExtensible[] bestToWorstFormats =                              {                                  new WaveFormatExtensible(                                      outputFormat.SampleRate' 32'                                      outputFormat.Channels)'                                  new WaveFormatExtensible(                                      outputFormat.SampleRate' 24'                                      outputFormat.Channels)'                                  new WaveFormatExtensible(                                      outputFormat.SampleRate' 16'                                      outputFormat.Channels)'                              };                            // Check from best Format to worst format ( Float32' Int24' Int16 )                          for (int i = 0; i < bestToWorstFormats.Length; i++)                          {                              correctSampleRateFormat = bestToWorstFormats[i];                              if (audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                              {                                  break;                              }                              correctSampleRateFormat = null;                          }                            // If still null' then test on the PCM16' 2 channels                          if (correctSampleRateFormat == null)                          {                              // Last Last Last Chance (Thanks WASAPI)                              correctSampleRateFormat = new WaveFormatExtensible(outputFormat.SampleRate' 16' 2);                              if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                              {                                  throw new NotSupportedException("Can't find a supported format to use");                              }                          }                      }                      outputFormat = correctSampleRateFormat;                  }                  else                  {                      outputFormat = closestSampleRateFormat;                  }                    // just check that we can make it.                  //using (new MediaFoundationResampler(waveProvider' outputFormat))                  {                  }                  this.resamplerNeeded = true;              }              else              {                  resamplerNeeded = false;              }
Magic Number,NAudio.Win8.Wave.WaveOutputs,WasapiOutRT,C:\repos\naudio_NAudio\NAudio.Universal\Wave\WaveOutputs\WasapiOutRT.cs,Init,The following statement contains a magic number: if (shareMode == AudioClientShareMode.Shared)              {                  // With EventCallBack and Shared'                   audioClient.Initialize(shareMode' AudioClientStreamFlags.EventCallback' latencyRefTimes' 0'                                         outputFormat' Guid.Empty);                    // Get back the effective latency from AudioClient. On Windows 10 it can be 0                  if (audioClient.StreamLatency > 0)                      latencyMilliseconds = (int) (audioClient.StreamLatency/10000);              }              else              {                  // With EventCallBack and Exclusive' both latencies must equals                  audioClient.Initialize(shareMode' AudioClientStreamFlags.EventCallback' latencyRefTimes' latencyRefTimes'                                         outputFormat' Guid.Empty);              }
Missing Default,NAudio.Dsp,EnvelopeGenerator,C:\repos\naudio_NAudio\NAudio\Dsp\EnvelopeGenerator.cs,Process,The following switch statement is missing a default case: switch (state)              {                  case EnvelopeState.Idle:                      break;                  case EnvelopeState.Attack:                      output = attackBase + output * attackCoef;                      if (output >= 1.0f)                      {                          output = 1.0f;                          state = EnvelopeState.Decay;                      }                      break;                  case EnvelopeState.Decay:                      output = decayBase + output * decayCoef;                      if (output <= sustainLevel)                      {                          output = sustainLevel;                          state = EnvelopeState.Sustain;                      }                      break;                  case EnvelopeState.Sustain:                      break;                  case EnvelopeState.Release:                      output = releaseBase + output * releaseCoef;                      if (output <= 0.0)                      {                          output = 0.0f;                          state = EnvelopeState.Idle;                      }                      break;              }
