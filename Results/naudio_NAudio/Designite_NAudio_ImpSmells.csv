Implementation smell,Namespace,Class,File,Method,Description
Long Method,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The method has 148 lines of code.
Long Method,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The method has 141 lines of code.
Long Method,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The method has 224 lines of code.
Long Method,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The method has 123 lines of code.
Long Method,NAudio.Midi,MidiFile,C:\repos\naudio_NAudio\NAudio\Midi\MidiFile.cs,MidiFile,The method has 120 lines of code.
Long Method,NAudio.Wave,DirectSoundOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\DirectSoundOut.cs,PlaybackThreadFunc,The method has 111 lines of code.
Long Method,NAudio.Wave,WasapiOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WasapiOut.cs,Init,The method has 106 lines of code.
Complex Method,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,Cyclomatic complexity of the method is 9
Complex Method,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,Cyclomatic complexity of the method is 11
Complex Method,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,Cyclomatic complexity of the method is 9
Complex Method,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResamplePrepare,Cyclomatic complexity of the method is 9
Complex Method,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,Cyclomatic complexity of the method is 23
Complex Method,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,Cyclomatic complexity of the method is 16
Complex Method,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,ShortTimeFourierTransform,Cyclomatic complexity of the method is 8
Complex Method,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,FFT,Cyclomatic complexity of the method is 11
Complex Method,NAudio.FileFormats.Wav,WaveFileChunkReader,C:\repos\naudio_NAudio\NAudio\FileFormats\Wav\WaveFileChunkReader.cs,ReadWaveHeader,Cyclomatic complexity of the method is 8
Complex Method,NAudio.Midi,MidiFile,C:\repos\naudio_NAudio\NAudio\Midi\MidiFile.cs,MidiFile,Cyclomatic complexity of the method is 13
Complex Method,NAudio.Wave.SampleProviders,OffsetSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\OffsetSampleProvider.cs,Read,Cyclomatic complexity of the method is 15
Complex Method,NAudio.Wave.SampleProviders,SmbPitchShiftingSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SmbPitchShiftingSampleProvider.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,NAudio.Wave,WaveInEvent,C:\repos\naudio_NAudio\NAudio\Wave\WaveInputs\WaveInEvent.cs,DoRecording,Cyclomatic complexity of the method is 8
Complex Method,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,Cyclomatic complexity of the method is 11
Complex Method,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,Cyclomatic complexity of the method is 8
Complex Method,NAudio.Wave,WasapiOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WasapiOut.cs,PlayThread,Cyclomatic complexity of the method is 8
Complex Method,NAudio.Wave,WasapiOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WasapiOut.cs,Init,Cyclomatic complexity of the method is 11
Complex Method,NAudio.Wave,WaveOutEvent,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveOutEvent.cs,DoPlayback,Cyclomatic complexity of the method is 8
Complex Method,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ReadAiffHeader,Cyclomatic complexity of the method is 11
Complex Method,NAudio.Wave,WaveFormatConversionProvider,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveFormatConversionProvider.cs,Read,Cyclomatic complexity of the method is 10
Long Parameter List,NAudio.CoreAudioApi,AudioClient,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioClient.cs,Initialize,The method has 6 parameters. Parameters: shareMode' streamFlags' bufferDuration' periodicity' waveFormat' audioSessionGuid
Long Parameter List,NAudio.CoreAudioApi,AudioVolumeNotificationData,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioVolumeNotificationData.cs,AudioVolumeNotificationData,The method has 5 parameters. Parameters: eventContext' muted' masterVolume' channelVolume' guid
Long Parameter List,NAudio.CoreAudioApi.Interfaces,IAudioCaptureClient,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\IAudioCaptureClient.cs,GetBuffer,The method has 5 parameters. Parameters: dataBuffer' numFramesToRead' bufferFlags' devicePosition' qpcPosition
Long Parameter List,NAudio.CoreAudioApi.Interfaces,IAudioClient,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\IAudioClient.cs,Initialize,The method has 6 parameters. Parameters: shareMode' streamFlags' hnsBufferDuration' hnsPeriodicity' pFormat' audioSessionGuid
Long Parameter List,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SetMode,The method has 5 parameters. Parameters: interp' filtercnt' sinc' sinc_size' sinc_interpsize
Long Parameter List,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The method has 5 parameters. Parameters: outBuffer' outBufferIndex' nsamples_in' nsamples_out' nch
Long Parameter List,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample,The method has 9 parameters. Parameters: outBuffer' outBufferIndex' inBuffer' inBufferIndex' fracpos' nch' filter' filterIndex' filtsz
Long Parameter List,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample1,The method has 8 parameters. Parameters: outBuffer' outBufferIndex' inBuffer' inBufferIndex' fracpos' filter' filterIndex' filtsz
Long Parameter List,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample2,The method has 8 parameters. Parameters: outptr' outBufferIndex' inBuffer' inBufferIndex' fracpos' filter' filterIndex' filtsz
Long Parameter List,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,Apply,The method has 7 parameters. Parameters: inBuffer' inIndex' outBuffer' outIndex' ns' span' w
Long Parameter List,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The method has 6 parameters. Parameters: pitchShift' numSampsToProcess' fftFrameSize' osamp' sampleRate' indata
Long Parameter List,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetCoefficients,The method has 6 parameters. Parameters: aa0' aa1' aa2' b0' b1' b2
Long Parameter List,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,BiQuadFilter,The method has 6 parameters. Parameters: a0' a1' a2' b0' b1' b2
Long Parameter List,NAudio.MediaFoundation,IMFReadWriteClassFactory,C:\repos\naudio_NAudio\NAudio\MediaFoundation\IMFReadWriteClassFactory.cs,CreateInstanceFromURL,The method has 5 parameters. Parameters: clsid' pwszURL' pAttributes' riid' ppvObject
Long Parameter List,NAudio.MediaFoundation,IMFReadWriteClassFactory,C:\repos\naudio_NAudio\NAudio\MediaFoundation\IMFReadWriteClassFactory.cs,CreateInstanceFromObject,The method has 5 parameters. Parameters: clsid' punkObject' pAttributes' riid' ppvObject
Long Parameter List,NAudio.MediaFoundation,MediaFoundationInterop,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationInterop.cs,MFTEnumEx,The method has 6 parameters. Parameters: guidCategory' flags' pInputType' pOutputType' pppMFTActivate' pcMFTActivate
Long Parameter List,NAudio.MediaFoundation,IMFSourceReader,C:\repos\naudio_NAudio\NAudio\MediaFoundation\IMFSourceReader.cs,ReadSample,The method has 6 parameters. Parameters: dwStreamIndex' dwControlFlags' pdwActualStreamIndex' pdwStreamFlags' pllTimestamp' ppSample
Long Parameter List,NAudio.Midi,MidiIn,C:\repos\naudio_NAudio\NAudio\Midi\MidiIn.cs,Callback,The method has 5 parameters. Parameters: midiInHandle' message' userData' messageParameter1' messageParameter2
Long Parameter List,NAudio.Midi,MidiInterop,C:\repos\naudio_NAudio\NAudio\Midi\MidiInterop.cs,midiInOpen,The method has 5 parameters. Parameters: hMidiIn' uDeviceID' callback' dwInstance' dwFlags
Long Parameter List,NAudio.Midi,MidiInterop,C:\repos\naudio_NAudio\NAudio\Midi\MidiInterop.cs,midiInOpenWindow,The method has 5 parameters. Parameters: hMidiIn' uDeviceID' callbackWindowHandle' dwInstance' dwFlags
Long Parameter List,NAudio.Midi,MidiInterop,C:\repos\naudio_NAudio\NAudio\Midi\MidiInterop.cs,midiOutOpen,The method has 5 parameters. Parameters: lphMidiOut' uDeviceID' dwCallback' dwInstance' dwFlags
Long Parameter List,NAudio.Midi,MidiInterop,C:\repos\naudio_NAudio\NAudio\Midi\MidiInterop.cs,midiStreamOpen,The method has 6 parameters. Parameters: hMidiStream' puDeviceID' cMidi' dwCallback' dwInstance' fdwOpen
Long Parameter List,NAudio.Midi,MidiOut,C:\repos\naudio_NAudio\NAudio\Midi\MidiOut.cs,Callback,The method has 5 parameters. Parameters: midiInHandle' message' userData' messageParameter1' messageParameter2
Long Parameter List,NAudio.Midi,NoteEvent,C:\repos\naudio_NAudio\NAudio\Midi\NoteEvent.cs,NoteEvent,The method has 5 parameters. Parameters: absoluteTime' channel' commandCode' noteNumber' velocity
Long Parameter List,NAudio.Midi,NoteOnEvent,C:\repos\naudio_NAudio\NAudio\Midi\NoteOnEvent.cs,NoteOnEvent,The method has 5 parameters. Parameters: absoluteTime' channel' noteNumber' velocity' duration
Long Parameter List,NAudio.Midi,SmpteOffsetEvent,C:\repos\naudio_NAudio\NAudio\Midi\SmpteOffsetEvent.cs,SmpteOffsetEvent,The method has 5 parameters. Parameters: hours' minutes' seconds' frames' subFrames
Long Parameter List,NAudio.Midi,TimeSignatureEvent,C:\repos\naudio_NAudio\NAudio\Midi\TimeSignatureEvent.cs,TimeSignatureEvent,The method has 5 parameters. Parameters: absoluteTime' numerator' denominator' ticksInMetronomeClick' no32ndNotesInQuarterNote
Long Parameter List,NAudio.Utils,ByteEncoding,C:\repos\naudio_NAudio\NAudio\Utils\ByteEncoding.cs,GetBytes,The method has 5 parameters. Parameters: chars' charIndex' charCount' bytes' byteIndex
Long Parameter List,NAudio.Utils,ByteEncoding,C:\repos\naudio_NAudio\NAudio\Utils\ByteEncoding.cs,GetChars,The method has 5 parameters. Parameters: bytes' byteIndex' byteCount' chars' charIndex
Long Parameter List,NAudio.Wave.Asio,AsioDriver,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioDriver.cs,CoCreateInstance,The method has 5 parameters. Parameters: clsid' inner' context' uuid' rReturnedComObject
Long Parameter List,NAudio.Wave.Compression,AcmDriver,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmDriver.cs,ShowFormatChooseDialog,The method has 7 parameters. Parameters: ownerWindowHandle' windowTitle' enumFlags' enumFormat' selectedFormat' selectedFormatDescription' selectedFormatTagDescription
Long Parameter List,NAudio.Wave.Compression,AcmInterop,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmInterop.cs,acmDriverAdd,The method has 5 parameters. Parameters: driverHandle' driverModule' driverFunctionAddress' priority' flags
Long Parameter List,NAudio.Wave.Compression,AcmInterop,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmInterop.cs,acmFormatEnum,The method has 5 parameters. Parameters: hAcmDriver' formatDetails' callback' instance' flags
Long Parameter List,NAudio.Wave.Compression,AcmInterop,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmInterop.cs,acmFormatSuggest,The method has 5 parameters. Parameters: hAcmDriver' sourceFormat' destFormat' sizeDestFormat' suggestFlags
Long Parameter List,NAudio.Wave.Compression,AcmInterop,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmInterop.cs,acmFormatSuggest2,The method has 5 parameters. Parameters: hAcmDriver' sourceFormatPointer' destFormatPointer' sizeDestFormat' suggestFlags
Long Parameter List,NAudio.Wave.Compression,AcmInterop,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmInterop.cs,acmFormatTagEnum,The method has 5 parameters. Parameters: hAcmDriver' formatTagDetails' callback' instance' reserved
Long Parameter List,NAudio.Wave.Compression,AcmInterop,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmInterop.cs,acmStreamOpen,The method has 8 parameters. Parameters: hAcmStream' hAcmDriver' sourceFormat' destFormat' waveFilter' callback' instance' openFlags
Long Parameter List,NAudio.Wave.Compression,AcmInterop,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmInterop.cs,acmStreamOpen2,The method has 8 parameters. Parameters: hAcmStream' hAcmDriver' sourceFormatPointer' destFormatPointer' waveFilter' callback' instance' openFlags
Long Parameter List,NAudio.Wave,WaveIn,C:\repos\naudio_NAudio\NAudio\Wave\WaveInputs\WaveIn.cs,Callback,The method has 5 parameters. Parameters: waveInHandle' message' userData' waveHeader' reserved
Long Parameter List,NAudio.Wave,WaveInterop,C:\repos\naudio_NAudio\NAudio\Wave\MmeInterop\WaveInterop.cs,waveOutOpen,The method has 6 parameters. Parameters: hWaveOut' uDeviceID' lpFormat' dwCallback' dwInstance' dwFlags
Long Parameter List,NAudio.Wave,WaveInterop,C:\repos\naudio_NAudio\NAudio\Wave\MmeInterop\WaveInterop.cs,waveOutOpenWindow,The method has 6 parameters. Parameters: hWaveOut' uDeviceID' lpFormat' callbackWindowHandle' dwInstance' dwFlags
Long Parameter List,NAudio.Wave,WaveInterop,C:\repos\naudio_NAudio\NAudio\Wave\MmeInterop\WaveInterop.cs,waveInOpen,The method has 6 parameters. Parameters: hWaveIn' uDeviceID' lpFormat' dwCallback' dwInstance' dwFlags
Long Parameter List,NAudio.Wave,WaveInterop,C:\repos\naudio_NAudio\NAudio\Wave\MmeInterop\WaveInterop.cs,waveInOpenWindow,The method has 6 parameters. Parameters: hWaveIn' uDeviceID' lpFormat' callbackWindowHandle' dwInstance' dwFlags
Long Parameter List,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,CreateCustomFormat,The method has 6 parameters. Parameters: tag' sampleRate' channels' averageBytesPerSecond' blockAlign' bitsPerSample
Long Parameter List,NAudio.Wave,MediaFoundationEncoder,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\MediaFoundationEncoder.cs,ConvertOneBuffer,The method has 5 parameters. Parameters: writer' streamIndex' inputProvider' position' managedBuffer
Long Parameter List,NAudio.Wave,IDirectSoundBuffer,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\DirectSoundOut.cs,Lock,The method has 7 parameters. Parameters: dwOffset' dwBytes' audioPtr1' audioBytes1' audioPtr2' audioBytes2' dwFlags
Long Parameter List,NAudio.Wave,WaveOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveOut.cs,Callback,The method has 5 parameters. Parameters: hWaveOut' uMsg' dwInstance' wavhdr' dwReserved
Long Parameter List,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ReadAiffHeader,The method has 5 parameters. Parameters: stream' format' dataChunkPosition' dataChunkLength' chunks
Long Parameter List,NAudio.Dmo,DmoInterop,C:\repos\naudio_NAudio\NAudio\Dmo\DmoInterop.cs,DMOEnum,The method has 7 parameters. Parameters: guidCategory' flags' inTypes' inTypesArray' outTypes' outTypesArray' enumDmo
Long Parameter List,NAudio.Dmo,MediaObject,C:\repos\naudio_NAudio\NAudio\Dmo\MediaObject.cs,ProcessInput,The method has 5 parameters. Parameters: inputStreamIndex' mediaBuffer' flags' timestamp' duration
Long Parameter List,NAudio.Dmo,IMediaObject,C:\repos\naudio_NAudio\NAudio\Dmo\IMediaObject.cs,ProcessInput,The method has 5 parameters. Parameters: inputStreamIndex' mediaBuffer' flags' referenceTimeTimestamp' referenceTimeDuration
Long Parameter List,NAudio.Mixer,MixerControl,C:\repos\naudio_NAudio\NAudio\Mixer\MixerControl.cs,GetMixerControl,The method has 5 parameters. Parameters: mixerHandle' nLineID' controlId' nChannels' mixerFlags
Long Parameter List,NAudio.Mixer,MixerInterop,C:\repos\naudio_NAudio\NAudio\Mixer\MixerInterop.cs,mixerOpen,The method has 5 parameters. Parameters: hMixer' uMxId' dwCallback' dwInstance' dwOpenFlags
Long Identifier,NAudio.CoreAudioApi,PropertyKeys,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropertyKeys.cs,,The length of the parameter PKEY_DeviceInterface_FriendlyName is 33.
Long Identifier,NAudio.CoreAudioApi,PropertyKeys,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropertyKeys.cs,,The length of the parameter PKEY_AudioEndpoint_ControlPanelPageProvider is 43.
Long Identifier,NAudio.CoreAudioApi,PropertyKeys,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropertyKeys.cs,,The length of the parameter PKEY_AudioEndpoint_Association is 30.
Long Identifier,NAudio.CoreAudioApi,PropertyKeys,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropertyKeys.cs,,The length of the parameter PKEY_AudioEndpoint_PhysicalSpeakers is 35.
Long Identifier,NAudio.CoreAudioApi,PropertyKeys,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropertyKeys.cs,,The length of the parameter PKEY_AudioEndpoint_Disable_SysFx is 32.
Long Identifier,NAudio.CoreAudioApi,PropertyKeys,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropertyKeys.cs,,The length of the parameter PKEY_AudioEndpoint_FullRangeSpeakers is 36.
Long Identifier,NAudio.CoreAudioApi,PropertyKeys,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropertyKeys.cs,,The length of the parameter PKEY_AudioEndpoint_Supports_EventDriven_Mode is 44.
Long Identifier,NAudio.CoreAudioApi,PropertyKeys,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropertyKeys.cs,,The length of the parameter PKEY_AudioEndpoint_JackSubType is 30.
Long Identifier,NAudio.CoreAudioApi,PropertyKeys,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropertyKeys.cs,,The length of the parameter PKEY_Device_ControllerDeviceId is 30.
Long Identifier,NAudio.CoreAudioApi.Interfaces,ErrorCodes,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\ErrorCodes.cs,,The length of the parameter AUDCLNT_E_BUFFER_OPERATION_PENDING is 34.
Long Identifier,NAudio.CoreAudioApi.Interfaces,ErrorCodes,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\ErrorCodes.cs,,The length of the parameter AUDCLNT_E_THREAD_NOT_REGISTERED is 31.
Long Identifier,NAudio.CoreAudioApi.Interfaces,ErrorCodes,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\ErrorCodes.cs,,The length of the parameter AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED is 36.
Long Identifier,NAudio.CoreAudioApi.Interfaces,ErrorCodes,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\ErrorCodes.cs,,The length of the parameter AUDCLNT_E_ENDPOINT_CREATE_FAILED is 32.
Long Identifier,NAudio.CoreAudioApi.Interfaces,ErrorCodes,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\ErrorCodes.cs,,The length of the parameter AUDCLNT_E_EVENTHANDLE_NOT_EXPECTED is 34.
Long Identifier,NAudio.CoreAudioApi.Interfaces,ErrorCodes,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\ErrorCodes.cs,,The length of the parameter AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL is 38.
Long Identifier,NAudio.CoreAudioApi.Interfaces,ErrorCodes,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\ErrorCodes.cs,,The length of the parameter AUDCLNT_E_INCORRECT_BUFFER_SIZE is 31.
Long Identifier,NAudio.CoreAudioApi.Interfaces,ErrorCodes,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\Interfaces\ErrorCodes.cs,,The length of the parameter AUDCLNT_E_RESOURCES_INVALIDATED is 31.
Long Identifier,NAudio.MediaFoundation,AudioSubtypes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\AudioSubtypes.cs,,The length of the parameter MFAudioFormat_WMAudio_Lossless is 30.
Long Identifier,NAudio.MediaFoundation,AudioSubtypes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\AudioSubtypes.cs,,The length of the parameter KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL_PLUS is 48.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_UNSUPPORTED_REPRESENTATION is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_UNSUPPORTED_BYTESTREAM_TYPE is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_UNSUPPORTED_RATE_TRANSITION is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_UNSUPPORTED_STATE_TRANSITION is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_UNRECOVERABLE_ERROR_OCCURRED is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_SAMPLE_HAS_TOO_MANY_BUFFERS is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_PROPERTY_TYPE_NOT_ALLOWED is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_PROPERTY_TYPE_NOT_SUPPORTED is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_PROPERTY_VECTOR_NOT_ALLOWED is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS is 44.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_RT_THROUGHPUT_NOT_AVAILABLE is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_RT_WORKQUEUE_CLASS_NOT_SPECIFIED is 37.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_BYTESTREAM_UNKNOWN_LENGTH is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_SESSION_PAUSEWHILESTOPPED is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_FORMAT_CHANGE_NOT_SUPPORTED is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_HW_MFT_FAILED_START_STREAMING is 34.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ASF_UNSUPPORTED_STREAM_TYPE is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_MEDIA_SOURCE_NO_STREAMS_SELECTED is 37.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_CANNOT_FIND_KEYFRAME_SAMPLE is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_BWLEVEL_NOT_SUPPORTED is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_STREAMGROUPS_NOT_SUPPORTED is 35.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_MANUALSS_NOT_SUPPORTED is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_INVALID_PRESENTATION_DESCRIPTOR is 40.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_CACHESTREAM_NOT_FOUND is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_INTERNAL_SERVER_ERROR is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_INCOMPATIBLE_PUSHSERVER is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_INVALID_PUSH_TEMPLATE is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_INVALID_PUSH_PUBLISHING_POINT is 38.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NET_UNSUPPORTED_CONFIGURATION is 34.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ASF_FILESINK_BITRATE_UNKNOWN is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_SINK_NO_SAMPLES_PROCESSED is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_VIDEO_REN_NO_DEINTERLACE_HW is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_VIDEO_REN_COPYPROT_FAILED is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_VIDEO_REN_SURFACE_NOT_SHARED is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NO_VIDEO_SAMPLE_AVAILABLE is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_AUDIO_PLAYBACK_DEVICE_IN_USE is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_AUDIO_PLAYBACK_DEVICE_INVALIDATED is 38.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_AUDIO_SERVICE_NOT_RUNNING is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TOPO_INVALID_OPTIONAL_NODE is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TOPO_CANNOT_FIND_DECRYPTOR is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TOPO_INVALID_TIME_ATTRIBUTES is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TOPO_MISSING_PRESENTATION_DESCRIPTOR is 41.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TOPO_MISSING_STREAM_DESCRIPTOR is 35.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TOPO_STREAM_DESCRIPTOR_NOT_SELECTED is 40.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TOPO_SINK_ACTIVATES_UNSUPPORTED is 36.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_SEQUENCER_UNKNOWN_SEGMENT_ID is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_S_SEQUENCER_CONTEXT_CANCELED is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_S_SEQUENCER_SEGMENT_AT_END_OF_STREAM is 39.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_INPUT_REMAINING is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROFILE_MISSING is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROFILE_INVALID_OR_CORRUPT is 41.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROFILE_TRUNCATED is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROPERTY_PID_NOT_RECOGNIZED is 42.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROPERTY_VARIANT_TYPE_WRONG is 42.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROPERTY_NOT_WRITEABLE is 37.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROPERTY_ARRAY_VALUE_WRONG_NUM_DIM is 49.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROPERTY_VALUE_SIZE_WRONG is 40.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROPERTY_VALUE_OUT_OF_RANGE is 42.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_PROPERTY_VALUE_INCOMPATIBLE is 42.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_OUTPUT_MEDIATYPE is 56.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_INPUT_MEDIATYPE is 55.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_MEDIATYPE_COMBINATION is 61.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_CONFLICTS_WITH_OTHER_CURRENTLY_ENABLED_FEATURES is 62.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_NEED_MORE_INPUT is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_SPKR_CONFIG is 51.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_CANNOT_CHANGE_MEDIATYPE_WHILE_PROCESSING is 55.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_S_TRANSFORM_DO_NOT_PROPAGATE_EVENT is 37.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSFORM_CANNOT_INITIALIZE_ACM_DRIVER is 43.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_DRM_HARDWARE_INCONSISTENT is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_NO_CONTENT_PROTECTION_MANAGER is 34.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_LICENSE_RESTORE_NO_RIGHTS is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_BACKUP_RESTRICTED_LICENSE is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_LICENSE_RESTORE_NEEDS_INDIVIDUALIZATION is 44.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_WMDRMOTA_ACTION_ALREADY_SET is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_WMDRMOTA_DRM_HEADER_NOT_AVAILABLE is 38.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_WMDRMOTA_DRM_ENCRYPTION_SCHEME_NOT_SUPPORTED is 49.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TOPOLOGY_VERIFICATION_FAILED is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_SIGNATURE_VERIFICATION_FAILED is 34.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_GRL_EXTENSIBLE_ENTRY_NOT_FOUND is 35.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_S_VIDEO_DISABLED_WITH_UNKNOWN_SOFTWARE_OUTPUT is 48.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ALL_PROCESS_RESTART_REQUIRED is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_PEAUTH_SESSION_NOT_STARTED is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_INCOMPATIBLE_SAMPLE_PROTECTION is 35.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_HIGH_SECURITY_LEVEL_CONTENT_NOT_ALLOWED is 44.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TEST_SIGNED_COMPONENTS_NOT_ALLOWED is 39.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ITA_ERROR_PARSING_SAP_PARAMETERS is 37.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_POLICY_MGR_ACTION_OUTOFBOUNDS is 34.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_PROTECTION_GUID is 50.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ITA_OPL_DATA_NOT_INITIALIZED is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_OUTPUT is 41.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ITA_UNRECOGNIZED_DIGITAL_VIDEO_OUTPUT is 42.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_CLOCK_INVALID_CONTINUITY_KEY is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSCODE_NO_CONTAINERTYPE is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSCODE_PROFILE_NO_MATCHING_STREAMS is 42.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_TRANSCODE_NO_MATCHING_ENCODER is 34.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ALLOCATOR_NOT_INITIALIZED is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationErrors,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationErrors.cs,,The length of the parameter MF_E_ALLOCATOR_ALREADY_COMMITED is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MF_TRANSFORM_CATEGORY_Attribute is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MFT_ENUM_HARDWARE_URL_Attribute is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MFT_CONNECTED_STREAM_ATTRIBUTE is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MFT_PREFERRED_OUTPUTTYPE_Attribute is 34.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MFT_HW_TIMESTAMP_WITH_QPC_Attribute is 35.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MFT_FIELDOFUSE_UNLOCK_Attribute is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MFT_ENUM_TRANSCODE_ONLY_ATTRIBUTE is 33.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MF_MT_AUDIO_AVG_BYTES_PER_SECOND is 32.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MF_MT_AUDIO_SAMPLES_PER_SECOND is 30.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MF_READWRITE_ENABLE_HARDWARE_TRANSFORMS is 39.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MF_MT_AUDIO_PREFER_WAVEFORMATEX is 31.
Long Identifier,NAudio.MediaFoundation,MediaFoundationAttributes,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationAttributes.cs,,The length of the parameter MF_MT_AAC_AUDIO_PROFILE_LEVEL_INDICATION is 40.
Long Identifier,NAudio.MediaFoundation,MediaFoundationInterop,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationInterop.cs,,The length of the parameter MF_SOURCE_READER_FIRST_AUDIO_STREAM is 35.
Long Identifier,NAudio.MediaFoundation,MediaFoundationInterop,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationInterop.cs,,The length of the parameter MF_SOURCE_READER_FIRST_VIDEO_STREAM is 35.
Long Identifier,NAudio.MediaFoundation,MF_SINK_WRITER_STATISTICS,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MF_SINK_WRITER_STATISTICS.cs,,The length of the parameter dwNumOutstandingSinkSampleRequests is 34.
Long Identifier,NAudio.Wave,WaveCapabilitiesHelpers,C:\repos\naudio_NAudio\NAudio\Wave\MmeInterop\WaveInCapabilities.cs,,The length of the parameter MicrosoftDefaultManufacturerId is 30.
Long Identifier,NAudio.Dmo,DmoGuids,C:\repos\naudio_NAudio\NAudio\Dmo\DmoGuids.cs,,The length of the parameter DMOCATEGORY_AUDIO_CAPTURE_EFFECT is 32.
Long Identifier,NAudio.SoundFont,ModulatorType,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\ModulatorType.cs,,The length of the parameter midiContinuousControllerNumber is 30.
Long Identifier,NAudio.Mixer,MixerInterop,C:\repos\naudio_NAudio\NAudio\Mixer\MixerInterop.cs,,The length of the parameter MIXERCONTROL_CONTROLF_MULTIPLE is 30.
Long Identifier,NAudio.Mixer,MixerInterop,C:\repos\naudio_NAudio\NAudio\Mixer\MixerInterop.cs,,The length of the parameter MIXERCONTROL_CONTROLF_DISABLED is 30.
Long Statement,NAudio.CoreAudioApi,AudioCaptureClient,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioCaptureClient.cs,GetBuffer,The length of the statement  "            Marshal.ThrowExceptionForHR(audioCaptureClientInterface.GetBuffer(out bufferPointer' out numFramesToRead' out bufferFlags' out devicePosition' out qpcPosition)); " is 161.
Long Statement,NAudio.CoreAudioApi,AudioCaptureClient,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioCaptureClient.cs,GetBuffer,The length of the statement  "            Marshal.ThrowExceptionForHR(audioCaptureClientInterface.GetBuffer(out bufferPointer' out numFramesToRead' out bufferFlags' out devicePosition' out qpcPosition)); " is 161.
Long Statement,NAudio.CoreAudioApi,AudioClient,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioClient.cs,Initialize,The length of the statement  "            int hresult = audioClientInterface.Initialize(shareMode' streamFlags' bufferDuration' periodicity' waveFormat' ref audioSessionGuid); " is 133.
Long Statement,NAudio.CoreAudioApi,AudioClient,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioClient.cs,IsFormatSupported,The length of the statement  "            IntPtr pointerToPtr = GetPointerToPointer(); // IntPtr.Zero; // Marshal.AllocHGlobal(Marshal.SizeOf<WaveFormatExtensible>()); " is 125.
Long Statement,NAudio.CoreAudioApi,AudioEndpointVolumeCallback,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioEndpointVolumeCallback.cs,OnNotify,The length of the statement  "            var notificationData = new AudioVolumeNotificationData(data.guidEventContext' data.bMuted' data.fMasterVolume' voldata' data.guidEventContext); " is 143.
Long Statement,NAudio.CoreAudioApi,AudioSessionControl,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioSessionControl.cs,Dispose,The length of the statement  "                Marshal.ThrowExceptionForHR(audioSessionControlInterface.UnregisterAudioSessionNotification(audioSessionEventCallback)); " is 120.
Long Statement,NAudio.CoreAudioApi,AudioSessionControl,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioSessionControl.cs,UnRegisterEventClient,The length of the statement  "                Marshal.ThrowExceptionForHR(audioSessionControlInterface.UnregisterAudioSessionNotification(audioSessionEventCallback)); " is 120.
Long Statement,NAudio.CoreAudioApi,AudioStreamVolume,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioStreamVolume.cs,CheckChannelIndex,The length of the statement  "                throw new ArgumentOutOfRangeException(parameter' "You must supply a valid channel index < current count of channels: " + channelCount.ToString()); " is 146.
Long Statement,NAudio.CoreAudioApi,AudioStreamVolume,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioStreamVolume.cs,SetAllVolumes,The length of the statement  "                    String.Format(CultureInfo.InvariantCulture' "SetAllVolumes MUST be supplied with a volume level for ALL channels. The AudioStream has {0} channels and you supplied {1} channels."' " is 179.
Long Statement,NAudio.CoreAudioApi,AudioStreamVolume,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioStreamVolume.cs,SetAllVolumes,The length of the statement  "                if (level < 0.0f) throw new ArgumentOutOfRangeException("levels"' "All volumes must be between 0.0 and 1.0. Invalid volume at index: " + i.ToString()); " is 151.
Long Statement,NAudio.CoreAudioApi,AudioStreamVolume,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\AudioStreamVolume.cs,SetAllVolumes,The length of the statement  "                if (level > 1.0f) throw new ArgumentOutOfRangeException("levels"' "All volumes must be between 0.0 and 1.0. Invalid volume at index: " + i.ToString()); " is 151.
Long Statement,NAudio.CoreAudioApi,WasapiCapture,C:\repos\naudio_NAudio\NAudio\Wave\WaveInputs\WasapiCapture.cs,InitializeCaptureDevice,The length of the statement  "                    audioClient.Initialize(ShareMode' AudioClientStreamFlags.EventCallback | streamFlags' requestedDuration' requestedDuration' " is 123.
Long Statement,NAudio.CoreAudioApi,MMDevice,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\MMDevice.cs,GetAudioMeterInformation,The length of the statement  "            Marshal.ThrowExceptionForHR(deviceInterface.Activate(ref IID_IAudioMeterInformation' ClsCtx.ALL' IntPtr.Zero' out result)); " is 123.
Long Statement,NAudio.CoreAudioApi,MMDevice,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\MMDevice.cs,GetAudioEndpointVolume,The length of the statement  "            Marshal.ThrowExceptionForHR(deviceInterface.Activate(ref IID_IAudioEndpointVolume' ClsCtx.ALL' IntPtr.Zero' out result)); " is 121.
Long Statement,NAudio.CoreAudioApi,MMDevice,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\MMDevice.cs,GetAudioSessionManager,The length of the statement  "            Marshal.ThrowExceptionForHR(deviceInterface.Activate(ref IDD_IAudioSessionManager' ClsCtx.ALL' IntPtr.Zero' out result)); " is 121.
Long Statement,NAudio.CoreAudioApi.Interfaces,PropVariant,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\PropVariant.cs,GetBlobAsArrayOf,The length of the statement  "                throw new InvalidDataException(String.Format("Blob size {0} not a multiple of struct size {1}"' blobByteLength' structSize)); " is 125.
Long Statement,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SetMode,The length of the statement  "            m_filtercnt = (m_sincsize != 0) ? 0 : (filtercnt <= 0 ? 0 : filtercnt >= WDL_RESAMPLE_MAX_FILTERS ? WDL_RESAMPLE_MAX_FILTERS : filtercnt); " is 138.
Long Statement,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SetMode,The length of the statement  "            //Debug.WriteLine(String.Format("setting interp={0}' filtercnt={1}' sinc={2}'{3}\n"' m_interp' m_filtercnt' m_sincsize' m_sincoversize)); " is 137.
Long Statement,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,BuildLowPass,The length of the statement  "                        double val = 0.35875 - 0.48829 * Math.Cos(windowpos) + 0.14128 * Math.Cos(2 * windowpos) - 0.01168 * Math.Cos(6 * windowpos); // blackman-harris " is 144.
Long Statement,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,BlackmannHarrisWindow,The length of the statement  "            return 0.35875 - (0.48829 * Math.Cos((2 * Math.PI * n) / (frameSize - 1))) + (0.14128 * Math.Cos((4 * Math.PI * n) / (frameSize - 1))) - (0.01168 * Math.Cos((6 * Math.PI * n) / (frameSize - 1))); " is 195.
Long Statement,NAudio.MediaFoundation,MediaFoundationTransform,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationTransform.cs,Read,The length of the statement  "                // n.b. in theory we ought to loop here' although we'd need to be careful as the next time into ReadFromTransform there could " is 125.
Long Statement,NAudio.MediaFoundation,MediaFoundationTransform,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationTransform.cs,Read,The length of the statement  "                // still be some leftover bytes in outputBuffer' which would get overwritten. Only introduce this if we find a transform that  " is 125.
Long Statement,NAudio.Midi,MetaEvent,C:\repos\naudio_NAudio\NAudio\Midi\MetaEvent.cs,ReadMetaEvent,The length of the statement  "//System.Windows.Forms.MessageBox.Show(String.Format("Unsupported MetaEvent {0} length {1} pos {2}"'metaEvent'length'br.BaseStream.Position)); " is 142.
Long Statement,NAudio.Midi,MidiFile,C:\repos\naudio_NAudio\NAudio\Midi\MidiFile.cs,Export,The length of the statement  "                        System.Diagnostics.Debug.Assert(MidiEvent.IsEndTrack(eventList[eventList.Count - 1])' "Exporting a track with a missing end track"); " is 132.
Long Statement,NAudio.Wave.Asio,AsioDriver,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioDriver.cs,GetChannels,The length of the statement  "            HandleException(asioDriverVTable.getChannels(pAsioComObject' out numInputChannels' out numOutputChannels)' "getChannels"); " is 122.
Long Statement,NAudio.Wave.Asio,AsioDriver,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioDriver.cs,GetBufferSize,The length of the statement  "            HandleException(asioDriverVTable.getBufferSize(pAsioComObject' out minSize' out maxSize' out preferredSize' out granularity)' "getBufferSize"); " is 143.
Long Statement,NAudio.Wave.Asio,AsioDriver,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioDriver.cs,CreateBuffers,The length of the statement  "            HandleException(asioDriverVTable.createBuffers(pAsioComObject' bufferInfos' numChannels' bufferSize' pinnedcallbacks)' "createBuffers"); " is 136.
Long Statement,NAudio.Wave.Asio,AsioDriver,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioDriver.cs,HandleException,The length of the statement  "                    $"Error code [{AsioException.getErrorName(error)}] while calling ASIO method <{methodName}>' {this.GetErrorMessage()}"); " is 120.
Long Statement,NAudio.Wave.Asio,AsioDriverExt,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioDriverExt.cs,BuildCapabilities,The length of the statement  "            driver.GetBufferSize(out capability.BufferMinSize' out capability.BufferMaxSize' out capability.BufferPreferredSize' out capability.BufferGranularity); " is 151.
Long Statement,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,SelectSampleConvertor,The length of the statement  "                            convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToInt2Channels : (SampleConvertor)ConvertorShortToIntGeneric; " is 120.
Long Statement,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,SelectSampleConvertor,The length of the statement  "                            convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToInt2Channels : (SampleConvertor)ConvertorFloatToIntGeneric; " is 120.
Long Statement,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,SelectSampleConvertor,The length of the statement  "                            convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToShort2Channels : (SampleConvertor)ConvertorShortToShortGeneric; " is 124.
Long Statement,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,SelectSampleConvertor,The length of the statement  "                            convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToShort2Channels : (SampleConvertor)ConvertorFloatToShortGeneric; " is 124.
Long Statement,NAudio.Wave.Compression,AcmDriver,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmDriver.cs,EnumerateAcmDrivers,The length of the statement  "            MmException.Try(AcmInterop.acmDriverEnum(new AcmInterop.AcmDriverEnumCallback(DriverEnumCallback)' IntPtr.Zero' 0)' "acmDriverEnum"); " is 133.
Long Statement,NAudio.Wave.Compression,AcmStream,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmStream.cs,DestToSource,The length of the statement  "            MmException.Try(AcmInterop.acmStreamSize(streamHandle' dest' out convertedBytes' AcmStreamSizeFlags.Destination)' "acmStreamSize"); " is 131.
Long Statement,NAudio.Wave.Compression,AcmStream,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmStream.cs,SuggestPcmFormat,The length of the statement  "            MmException.Try(AcmInterop.acmFormatSuggest(IntPtr.Zero' compressedFormat' suggestedFormat' Marshal.SizeOf(suggestedFormat)' AcmFormatSuggestFlags.FormatTag)' "acmFormatSuggest"); " is 179.
Long Statement,NAudio.Wave.Compression,AcmStream,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmStream.cs,SuggestPcmFormat,The length of the statement  "            MmResult result = AcmInterop.acmFormatSuggest2(IntPtr.Zero' compressedFormatPointer' suggestedFormatPointer' Marshal.SizeOf(suggestedFormat)' AcmFormatSuggestFlags.FormatTag); " is 175.
Long Statement,NAudio.Wave.Compression,AcmStream,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmStream.cs,Convert,The length of the statement  "                System.Diagnostics.Debug.WriteLine(String.Format("Not a whole number of blocks: {0} ({1})"' bytesToConvert' sourceFormat.BlockAlign)); " is 134.
Long Statement,NAudio.Wave.Compression,AcmStreamHeader,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmStreamHeader.cs,Convert,The length of the statement  "                AcmStreamConvertFlags flags = firstTime ? (AcmStreamConvertFlags.Start | AcmStreamConvertFlags.BlockAlign) : AcmStreamConvertFlags.BlockAlign; " is 142.
Long Statement,NAudio.Wave.Compression,AcmStreamHeader,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmStreamHeader.cs,Convert,The length of the statement  "                System.Diagnostics.Debug.Assert(streamHeader.destBufferLength == destBuffer.Length' "Codecs should not change dest buffer length"); " is 131.
Long Statement,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The length of the statement  "                        double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362; " is 174.
Long Statement,NAudio.Wave.SampleProviders,StereoToMonoSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\StereoToMonoSampleProvider.cs,Read,The length of the statement  "            if (sourceBuffer == null || sourceBuffer.Length < sourceSamplesRequired) sourceBuffer = new float[sourceSamplesRequired]; " is 121.
Long Statement,NAudio.Wave.SampleProviders,Mono24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono24SampleChunkConverter.cs,GetNextSample,The length of the statement  "                sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f; " is 123.
Long Statement,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The length of the statement  "                sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f; " is 123.
Long Statement,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The length of the statement  "                sampleRight = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f; " is 124.
Long Statement,NAudio.Wave,WaveExtensionMethods,C:\repos\naudio_NAudio\NAudio\Wave\WaveExtensionMethods.cs,Init,The length of the statement  "            IWaveProvider provider = convertTo16Bit ? (IWaveProvider)new SampleToWaveProvider16(sampleProvider) : new SampleToWaveProvider(sampleProvider); " is 143.
Long Statement,NAudio.Wave,AsioOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AsioOut.cs,InitRecordAndPlayback,The length of the statement  "                convertor = AsioSampleConvertor.SelectSampleConvertor(waveProvider.WaveFormat' driver.Capabilities.OutputChannelInfos[0].type); " is 127.
Long Statement,NAudio.Wave,MediaFoundationEncoder,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\MediaFoundationEncoder.cs,Encode,The length of the statement  "            if (inputProvider.WaveFormat.Encoding != WaveFormatEncoding.Pcm && inputProvider.WaveFormat.Encoding != WaveFormatEncoding.IeeeFloat) " is 133.
Long Statement,NAudio.Wave,DirectSoundOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\DirectSoundOut.cs,InitializeDirectSound,The length of the statement  "                    System.Diagnostics.Debug.Assert(samplesTotalSize == (2 * samplesFrameSize)' "Invalid SamplesTotalSize vs SamplesFrameSize"); " is 124.
Long Statement,NAudio.Wave,WaveBuffer,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveBuffer.cs,CheckValidityCount,The length of the statement  "                throw new ArgumentOutOfRangeException(argName' String.Format("{0} cannot set a count ({1}) that is not 4 bytes aligned "' argName' newNumberOfBytes)); " is 150.
Long Statement,NAudio.Wave,WaveBuffer,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveBuffer.cs,CheckValidityCount,The length of the statement  "                throw new ArgumentOutOfRangeException(argName' String.Format("{0} cannot set a count that exceed max count {1}"' argName' byteBuffer.Length / sizeOfValue)); " is 156.
Long Statement,NAudio.Wave,WaveCallbackInfo,C:\repos\naudio_NAudio\NAudio\Wave\MmeInterop\WaveCallbackInfo.cs,WaveOutOpen,The length of the statement  "                result = WaveInterop.waveOutOpen(out waveOutHandle' (IntPtr)deviceNumber' waveFormat' callback' IntPtr.Zero' WaveInterop.WaveInOutOpenFlags.CallbackFunction); " is 158.
Long Statement,NAudio.Wave,WaveCallbackInfo,C:\repos\naudio_NAudio\NAudio\Wave\MmeInterop\WaveCallbackInfo.cs,WaveOutOpen,The length of the statement  "                result = WaveInterop.waveOutOpenWindow(out waveOutHandle' (IntPtr)deviceNumber' waveFormat' this.Handle' IntPtr.Zero' WaveInterop.WaveInOutOpenFlags.CallbackWindow); " is 165.
Long Statement,NAudio.Wave,WaveCallbackInfo,C:\repos\naudio_NAudio\NAudio\Wave\MmeInterop\WaveCallbackInfo.cs,WaveInOpen,The length of the statement  "                result = WaveInterop.waveInOpen(out waveInHandle' (IntPtr)deviceNumber' waveFormat' callback' IntPtr.Zero' WaveInterop.WaveInOutOpenFlags.CallbackFunction); " is 156.
Long Statement,NAudio.Wave,WaveCallbackInfo,C:\repos\naudio_NAudio\NAudio\Wave\MmeInterop\WaveCallbackInfo.cs,WaveInOpen,The length of the statement  "                result = WaveInterop.waveInOpenWindow(out waveInHandle' (IntPtr)deviceNumber' waveFormat' this.Handle' IntPtr.Zero' WaveInterop.WaveInOutOpenFlags.CallbackWindow); " is 163.
Long Statement,NAudio.Wave,WaveOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveOut.cs,Init,The length of the statement  "            int bufferSize = waveProvider.WaveFormat.ConvertLatencyToByteSize((DesiredLatency + NumberOfBuffers - 1) / NumberOfBuffers);             " is 124.
Long Statement,NAudio.Wave,WaveOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveOut.cs,GetPosition,The length of the statement  "                mmTime.wType = MmTime.TIME_BYTES; // request results in bytes' TODO: perhaps make this a little more flexible and support the other types? " is 138.
Long Statement,NAudio.Wave,WaveOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveOut.cs,GetPosition,The length of the statement  "                    throw new Exception(string.Format("waveOutGetPosition: wType -> Expected {0}' Received {1}"' MmTime.TIME_BYTES' mmTime.wType)); " is 127.
Long Statement,NAudio.Wave,WaveOutEvent,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveOutEvent.cs,Init,The length of the statement  "            int bufferSize = waveProvider.WaveFormat.ConvertLatencyToByteSize((DesiredLatency + NumberOfBuffers - 1) / NumberOfBuffers);             " is 124.
Long Statement,NAudio.Wave,WaveOutEvent,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveOutEvent.cs,Init,The length of the statement  "                result = WaveInterop.waveOutOpenWindow(out hWaveOut' (IntPtr)DeviceNumber' waveStream.WaveFormat' callbackEvent.SafeWaitHandle.DangerousGetHandle()' IntPtr.Zero' WaveInterop.WaveInOutOpenFlags.CallbackEvent); " is 208.
Long Statement,NAudio.Wave,WaveOutEvent,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveOutEvent.cs,GetPosition,The length of the statement  "                mmTime.wType = MmTime.TIME_BYTES; // request results in bytes' TODO: perhaps make this a little more flexible and support the other types? " is 138.
Long Statement,NAudio.Wave,WaveOutEvent,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveOutEvent.cs,GetPosition,The length of the statement  "                    throw new Exception(string.Format("waveOutGetPosition: wType -> Expected {0}' Received {1}"' MmTime.TIME_BYTES' mmTime.wType)); " is 127.
Long Statement,NAudio.Wave,AudioFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AudioFileReader.cs,CreateReaderStream,The length of the statement  "                if (readerStream.WaveFormat.Encoding != WaveFormatEncoding.Pcm && readerStream.WaveFormat.Encoding != WaveFormatEncoding.IeeeFloat) " is 131.
Long Statement,NAudio.Wave,AudioFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AudioFileReader.cs,CreateReaderStream,The length of the statement  "            else if (fileName.EndsWith(".aiff"' StringComparison.OrdinalIgnoreCase) || fileName.EndsWith(".aif"' StringComparison.OrdinalIgnoreCase)) " is 137.
Long Statement,NAudio.Wave,MediaFoundationReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\MediaFoundationReader.cs,GetCurrentWaveFormat,The length of the statement  "            // Two ways to query it' first is to ask for properties (second is to convert into WaveFormatEx using MFCreateWaveFormatExFromMFMediaType) " is 138.
Long Statement,NAudio.Wave,MediaFoundationReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\MediaFoundationReader.cs,CreateReader,The length of the statement  "            partialMediaType.SubType = settings.RequestFloatOutput ? AudioSubtypes.MFAudioFormat_Float : AudioSubtypes.MFAudioFormat_PCM; " is 125.
Long Statement,NAudio.Wave,MediaFoundationReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\MediaFoundationReader.cs,CreateReader,The length of the statement  "                reader.SetCurrentMediaType(MediaFoundationInterop.MF_SOURCE_READER_FIRST_AUDIO_STREAM' IntPtr.Zero' partialMediaType.MediaFoundationObject); " is 140.
Long Statement,NAudio.Wave,MediaFoundationReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\MediaFoundationReader.cs,CreateReader,The length of the statement  "                    reader.SetCurrentMediaType(MediaFoundationInterop.MF_SOURCE_READER_FIRST_AUDIO_STREAM' IntPtr.Zero' partialMediaType.MediaFoundationObject); " is 140.
Long Statement,NAudio.Wave,MediaFoundationReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\MediaFoundationReader.cs,Read,The length of the statement  "                pReader.ReadSample(MediaFoundationInterop.MF_SOURCE_READER_FIRST_AUDIO_STREAM' 0' out actualStreamIndex' out dwFlags' out timestamp' out pSample); " is 146.
Long Statement,NAudio.Wave,Mp3FileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Mp3FileReader.cs,ValidateFrameFormat,The length of the statement  "                        "Got a frame with channel mode {0}' in an MP3 with {1} channels. Mp3FileReader does not support changes to channel count."' " is 123.
Long Statement,NAudio.Wave,StreamMediaFoundationReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\StreamMediaFoundationReader.cs,CreateReader,The length of the statement  "            var ppSourceReader = MediaFoundationApi.CreateSourceReaderFromByteStream(MediaFoundationApi.CreateByteStream(new ComStream(stream))); " is 133.
Long Statement,NAudio.Wave,WaveFormatConversionProvider,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveFormatConversionProvider.cs,Read,The length of the statement  "                        $"sourceBytesRead: {sourceBytesRead}' sourceBytesConverted {sourceBytesConverted}' destBytesConverted {destBytesConverted}"); " is 125.
Long Statement,NAudio.Wave,WaveInBuffer,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveInBuffer.cs,Reuse,The length of the statement  "            MmException.Try(WaveInterop.waveInUnprepareHeader(waveInHandle' header' Marshal.SizeOf(header))' "waveUnprepareHeader"); " is 120.
Long Statement,NAudio.Dmo,MediaObject,C:\repos\naudio_NAudio\NAudio\Dmo\MediaObject.cs,IsAcceptingData,The length of the statement  "            return (flags & DmoInputStatusFlags.DMO_INPUT_STATUSF_ACCEPT_DATA) == DmoInputStatusFlags.DMO_INPUT_STATUSF_ACCEPT_DATA; " is 120.
Long Statement,NAudio.Dmo,DmoMediaType,C:\repos\naudio_NAudio\NAudio\Dmo\DmoMediaType.cs,SetWaveFormat,The length of the statement  "            bFixedSizeSamples = SubType == AudioMediaSubtypes.MEDIASUBTYPE_PCM || SubType == AudioMediaSubtypes.MEDIASUBTYPE_IEEE_FLOAT; " is 124.
Long Statement,NAudio.SoundFont,InfoChunk,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\InfoChunk.cs,ToString,The length of the statement  "			return string.Format("Bank Name: {0}\r\nAuthor: {1}\r\nCopyright: {2}\r\nCreation Date: {3}\r\nTools: {4}\r\nComments: {5}\r\nSound Engine: {6}\r\nSoundFont Version: {7}\r\nTarget Product: {8}\r\nData ROM: {9}\r\nROM Version: {10}"' " is 232.
Long Statement,NAudio.SoundFont,RiffChunk,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\RiffChunk.cs,GetNextSubChunk,The length of the statement  "			//Console.WriteLine("DEBUG Failed to GetNextSubChunk because Position is {0}' dataOffset{1}' chunkSize {2}"'riffFile.BaseStream.Position'dataOffset'chunkSize); " is 159.
Long Statement,NAudio.SoundFont,RiffChunk,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\RiffChunk.cs,GetData,The length of the statement  "				throw new InvalidDataException(String.Format("Couldn't read chunk's data Chunk: {0}' read {1} bytes"'this'data.Length)); " is 120.
Long Statement,NAudio.SoundFont,RiffChunk,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\RiffChunk.cs,GetDataAsStructureArray,The length of the statement  "                throw new InvalidDataException(String.Format("Chunk size is: {0} not a multiple of structure size: {1}"' chunkSize' s.Length)); " is 127.
Long Statement,NAudio.Gui,Fader,C:\repos\naudio_NAudio\NAudio\Gui\Fader.cs,DrawSlider,The length of the statement  "            g.DrawLine(centreLine'sliderRectangle.Left'sliderRectangle.Top + sliderRectangle.Height/2'sliderRectangle.Right'sliderRectangle.Top + sliderRectangle.Height/2); " is 160.
Long Statement,NAudio.Gui,PanSlider,C:\repos\naudio_NAudio\NAudio\Gui\PanSlider.cs,OnPaint,The length of the statement  "				pe.Graphics.FillRectangle(Brushes.Orange'(int)((this.Width/2) * (pan+1))'1'(int) ((this.Width/2) * (0-pan))'this.Height-2); " is 123.
Long Statement,NAudio.Mixer,BooleanMixerControl,C:\repos\naudio_NAudio\NAudio\Mixer\BooleanMixerControl.cs,GetDetails,The length of the statement  "			boolDetails = (MixerInterop.MIXERCONTROLDETAILS_BOOLEAN) Marshal.PtrToStructure(pDetails'typeof(MixerInterop.MIXERCONTROLDETAILS_BOOLEAN)); " is 139.
Long Statement,NAudio.Mixer,SignedMixerControl,C:\repos\naudio_NAudio\NAudio\Mixer\SignedMixerControl.cs,GetDetails,The length of the statement  "			signedDetails = (MixerInterop.MIXERCONTROLDETAILS_SIGNED) Marshal.PtrToStructure(mixerControlDetails.paDetails'typeof(MixerInterop.MIXERCONTROLDETAILS_SIGNED)); " is 160.
Long Statement,NAudio.Mixer,UnsignedMixerControl,C:\repos\naudio_NAudio\NAudio\Mixer\UnsignedMixerControl.cs,GetDetails,The length of the statement  "                unsignedDetails[channel] = (MixerInterop.MIXERCONTROLDETAILS_UNSIGNED)Marshal.PtrToStructure(mixerControlDetails.paDetails' typeof(MixerInterop.MIXERCONTROLDETAILS_UNSIGNED)); " is 175.
Complex Conditional,NAudio.Utils,FieldDescriptionHelper,C:\repos\naudio_NAudio\NAudio\Utils\FieldDescriptionHelper.cs,Describe,The conditional expression  "f.IsPublic && f.IsStatic && f.FieldType == typeof (Guid) && (Guid) f.GetValue(null) == guid"  is complex.
Complex Conditional,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The conditional expression  "(headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3')"  is complex.
Complex Conditional,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The conditional expression  "(frame.RawData[offset + 0] == 'X') &&                  (frame.RawData[offset + 1] == 'i') &&                  (frame.RawData[offset + 2] == 'n') &&                  (frame.RawData[offset + 3] == 'g')"  is complex.
Virtual Method Call from Constructor,NAudio.Wave,BwfWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\BwfWriter.cs,BwfWriter,The constructor "BwfWriter" calls a virtual method "Serialize".
Virtual Method Call from Constructor,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WaveFileWriter,The constructor "WaveFileWriter" calls a virtual method "Serialize".
Empty Catch Block,NAudio.Midi,MidiInMessageEventArgs,C:\repos\naudio_NAudio\NAudio\Midi\MidiInMessageEventArgs.cs,MidiInMessageEventArgs,The method has an empty catch block.
Empty Catch Block,NAudio.Wave,Mp3FileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Mp3FileReader.cs,CreateTableOfContents,The method has an empty catch block.
Empty Catch Block,NAudio.Wave,Mp3FileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Mp3FileReader.cs,ReadNextFrame,The method has an empty catch block.
Magic Number,NAudio.Codecs,ALawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\ALawEncoder.cs,LinearToALawSample,The following statement contains a magic number: sign = ((~sample) >> 8) & 0x80;
Magic Number,NAudio.Codecs,ALawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\ALawEncoder.cs,LinearToALawSample,The following statement contains a magic number: if (sample >= 256)              {                  exponent = (int)ALawCompressTable[(sample >> 8) & 0x7F];                  mantissa = (sample >> (exponent + 3)) & 0x0F;                  compressedByte = (byte)((exponent << 4) | mantissa);              }              else              {                  compressedByte = (byte)(sample >> 4);              }
Magic Number,NAudio.Codecs,ALawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\ALawEncoder.cs,LinearToALawSample,The following statement contains a magic number: if (sample >= 256)              {                  exponent = (int)ALawCompressTable[(sample >> 8) & 0x7F];                  mantissa = (sample >> (exponent + 3)) & 0x0F;                  compressedByte = (byte)((exponent << 4) | mantissa);              }              else              {                  compressedByte = (byte)(sample >> 4);              }
Magic Number,NAudio.Codecs,ALawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\ALawEncoder.cs,LinearToALawSample,The following statement contains a magic number: if (sample >= 256)              {                  exponent = (int)ALawCompressTable[(sample >> 8) & 0x7F];                  mantissa = (sample >> (exponent + 3)) & 0x0F;                  compressedByte = (byte)((exponent << 4) | mantissa);              }              else              {                  compressedByte = (byte)(sample >> 4);              }
Magic Number,NAudio.Codecs,ALawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\ALawEncoder.cs,LinearToALawSample,The following statement contains a magic number: if (sample >= 256)              {                  exponent = (int)ALawCompressTable[(sample >> 8) & 0x7F];                  mantissa = (sample >> (exponent + 3)) & 0x0F;                  compressedByte = (byte)((exponent << 4) | mantissa);              }              else              {                  compressedByte = (byte)(sample >> 4);              }
Magic Number,NAudio.Codecs,ALawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\ALawEncoder.cs,LinearToALawSample,The following statement contains a magic number: if (sample >= 256)              {                  exponent = (int)ALawCompressTable[(sample >> 8) & 0x7F];                  mantissa = (sample >> (exponent + 3)) & 0x0F;                  compressedByte = (byte)((exponent << 4) | mantissa);              }              else              {                  compressedByte = (byte)(sample >> 4);              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 0; i < 3; i++)                  s.Band[band].sg[i] = s.Band[band].p[i] >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 0; i < 3; i++)                  s.Band[band].sg[i] = s.Band[band].p[i] >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd1 = Saturate(s.Band[band].a[1] << 2);
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: if (wd2 > 32767)                  wd2 = 32767;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: if (wd2 > 32767)                  wd2 = 32767;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd3 = (s.Band[band].sg[0] == s.Band[band].sg[2]) ? 128 : -128;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd3 = (s.Band[band].sg[0] == s.Band[band].sg[2]) ? 128 : -128;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd3 = (s.Band[band].sg[0] == s.Band[band].sg[2]) ? 128 : -128;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd3 += (wd2 >> 7);
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd3 += (s.Band[band].a[2] * 32512) >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd3 += (s.Band[band].a[2] * 32512) >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd3 += (s.Band[band].a[2] * 32512) >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: if (wd3 > 12288)                  wd3 = 12288;              else if (wd3 < -12288)                  wd3 = -12288;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: if (wd3 > 12288)                  wd3 = 12288;              else if (wd3 < -12288)                  wd3 = -12288;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: if (wd3 > 12288)                  wd3 = 12288;              else if (wd3 < -12288)                  wd3 = -12288;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: if (wd3 > 12288)                  wd3 = 12288;              else if (wd3 < -12288)                  wd3 = -12288;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: s.Band[band].ap[2] = wd3;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: s.Band[band].sg[0] = s.Band[band].p[0] >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: s.Band[band].sg[1] = s.Band[band].p[1] >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd1 = (s.Band[band].sg[0] == s.Band[band].sg[1]) ? 192 : -192;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd1 = (s.Band[band].sg[0] == s.Band[band].sg[1]) ? 192 : -192;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd2 = (s.Band[band].a[1] * 32640) >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd2 = (s.Band[band].a[1] * 32640) >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd3 = Saturate(15360 - s.Band[band].ap[2]);
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd3 = Saturate(15360 - s.Band[band].ap[2]);
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd1 = (d == 0) ? 0 : 128;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: s.Band[band].sg[0] = d >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 1; i < 7; i++)              {                  s.Band[band].sg[i] = s.Band[band].d[i] >> 15;                  wd2 = (s.Band[band].sg[i] == s.Band[band].sg[0]) ? wd1 : -wd1;                  wd3 = (s.Band[band].b[i] * 32640) >> 15;                  s.Band[band].bp[i] = Saturate(wd2 + wd3);              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 1; i < 7; i++)              {                  s.Band[band].sg[i] = s.Band[band].d[i] >> 15;                  wd2 = (s.Band[band].sg[i] == s.Band[band].sg[0]) ? wd1 : -wd1;                  wd3 = (s.Band[band].b[i] * 32640) >> 15;                  s.Band[band].bp[i] = Saturate(wd2 + wd3);              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 1; i < 7; i++)              {                  s.Band[band].sg[i] = s.Band[band].d[i] >> 15;                  wd2 = (s.Band[band].sg[i] == s.Band[band].sg[0]) ? wd1 : -wd1;                  wd3 = (s.Band[band].b[i] * 32640) >> 15;                  s.Band[band].bp[i] = Saturate(wd2 + wd3);              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 1; i < 7; i++)              {                  s.Band[band].sg[i] = s.Band[band].d[i] >> 15;                  wd2 = (s.Band[band].sg[i] == s.Band[band].sg[0]) ? wd1 : -wd1;                  wd3 = (s.Band[band].b[i] * 32640) >> 15;                  s.Band[band].bp[i] = Saturate(wd2 + wd3);              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 6; i > 0; i--)              {                  s.Band[band].d[i] = s.Band[band].d[i - 1];                  s.Band[band].b[i] = s.Band[band].bp[i];              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 2; i > 0; i--)              {                  s.Band[band].r[i] = s.Band[band].r[i - 1];                  s.Band[band].p[i] = s.Band[band].p[i - 1];                  s.Band[band].a[i] = s.Band[band].ap[i];              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd1 = (s.Band[band].a[1] * wd1) >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd2 = Saturate(s.Band[band].r[2] + s.Band[band].r[2]);
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd2 = Saturate(s.Band[band].r[2] + s.Band[band].r[2]);
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd2 = (s.Band[band].a[2] * wd2) >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: wd2 = (s.Band[band].a[2] * wd2) >> 15;
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 6; i > 0; i--)              {                  wd1 = Saturate(s.Band[band].d[i] + s.Band[band].d[i]);                  s.Band[band].sz += (s.Band[band].b[i] * wd1) >> 15;              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Block4,The following statement contains a magic number: for (i = 6; i > 0; i--)              {                  wd1 = Saturate(s.Band[band].d[i] + s.Band[band].d[i]);                  s.Band[band].sz += (s.Band[band].b[i] * wd1) >> 15;              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Decode,The following statement contains a magic number: for (j = 0; j < inputLength; )              {                  if (state.Packed)                  {                      // Unpack the code bits                      if (state.InBits < state.BitsPerSample)                      {                          state.InBuffer |= (uint)(inputG722Data[j++] << state.InBits);                          state.InBits += 8;                      }                      code = (int)state.InBuffer & ((1 << state.BitsPerSample) - 1);                      state.InBuffer >>= state.BitsPerSample;                      state.InBits -= state.BitsPerSample;                  }                  else                  {                      code = inputG722Data[j++];                  }                    switch (state.BitsPerSample)                  {                      default:                      case 8:                          wd1 = code & 0x3F;                          ihigh = (code >> 6) & 0x03;                          wd2 = qm6[wd1];                          wd1 >>= 2;                          break;                      case 7:                          wd1 = code & 0x1F;                          ihigh = (code >> 5) & 0x03;                          wd2 = qm5[wd1];                          wd1 >>= 1;                          break;                      case 6:                          wd1 = code & 0x0F;                          ihigh = (code >> 4) & 0x03;                          wd2 = qm4[wd1];                          break;                  }                                    // Block 5L' LOW BAND INVQBL                  wd2 = (state.Band[0].det * wd2) >> 15;                                    // Block 5L' RECONS                  rlow = state.Band[0].s + wd2;                                    // Block 6L' LIMIT                  if (rlow > 16383)                      rlow = 16383;                  else if (rlow < -16384)                      rlow = -16384;                    // Block 2L' INVQAL                  wd2 = qm4[wd1];                  dlowt = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  wd2 = rl42[wd1];                  wd1 = (state.Band[0].nb * 127) >> 7;                  wd1 += wl[wd2];                  if (wd1 < 0)                      wd1 = 0;                  else if (wd1 > 18432)                      wd1 = 18432;                  state.Band[0].nb = wd1;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlowt);                    if (!state.EncodeFrom8000Hz)                  {                      // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                                            // Block 5H' RECONS                      rhigh = dhigh + state.Band[1].s;                                            // Block 6H' LIMIT                      if (rhigh > 16383)                          rhigh = 16383;                      else if (rhigh < -16384)                          rhigh = -16384;                        // Block 2H' INVQAH                      wd2 = rh2[ihigh];                      wd1 = (state.Band[1].nb * 127) >> 7;                      wd1 += wh[wd2];                      if (wd1 < 0)                          wd1 = 0;                      else if (wd1 > 22528)                          wd1 = 22528;                      state.Band[1].nb = wd1;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                  }                    if (state.ItuTestMode)                  {                      outputBuffer[outlen++] = (short)(rlow << 1);                      outputBuffer[outlen++] = (short)(rhigh << 1);                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          outputBuffer[outlen++] = (short)(rlow << 1);                      }                      else                      {                          // Apply the receive QMF                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = rlow + rhigh;                          state.QmfSignalHistory[23] = rlow - rhigh;                            xout1 = 0;                          xout2 = 0;                          for (i = 0; i < 12; i++)                          {                              xout2 += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              xout1 += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          outputBuffer[outlen++] = (short)(xout1 >> 11);                          outputBuffer[outlen++] = (short)(xout2 >> 11);                      }                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722Codec,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,Encode,The following statement contains a magic number: for (j = 0; j < inputBufferCount; )              {                  if (state.ItuTestMode)                  {                      xlow =                      xhigh = inputBuffer[j++] >> 1;                  }                  else                  {                      if (state.EncodeFrom8000Hz)                      {                          xlow = inputBuffer[j++] >> 1;                      }                      else                      {                          // Apply the transmit QMF                          // Shuffle the buffer down                          for (i = 0; i < 22; i++)                              state.QmfSignalHistory[i] = state.QmfSignalHistory[i + 2];                          state.QmfSignalHistory[22] = inputBuffer[j++];                          state.QmfSignalHistory[23] = inputBuffer[j++];                            // Discard every other QMF output                          sumeven = 0;                          sumodd = 0;                          for (i = 0; i < 12; i++)                          {                              sumodd += state.QmfSignalHistory[2 * i] * qmf_coeffs[i];                              sumeven += state.QmfSignalHistory[2 * i + 1] * qmf_coeffs[11 - i];                          }                          xlow = (sumeven + sumodd) >> 14;                          xhigh = (sumeven - sumodd) >> 14;                      }                  }                  // Block 1L' SUBTRA                  el = Saturate(xlow - state.Band[0].s);                    // Block 1L' QUANTL                  wd = (el >= 0) ? el : -(el + 1);                    for (i = 1; i < 30; i++)                  {                      wd1 = (q6[i] * state.Band[0].det) >> 12;                      if (wd < wd1)                          break;                  }                  ilow = (el < 0) ? iln[i] : ilp[i];                    // Block 2L' INVQAL                  ril = ilow >> 2;                  wd2 = qm4[ril];                  dlow = (state.Band[0].det * wd2) >> 15;                    // Block 3L' LOGSCL                  il4 = rl42[ril];                  wd = (state.Band[0].nb * 127) >> 7;                  state.Band[0].nb = wd + wl[il4];                  if (state.Band[0].nb < 0)                      state.Band[0].nb = 0;                  else if (state.Band[0].nb > 18432)                      state.Band[0].nb = 18432;                    // Block 3L' SCALEL                  wd1 = (state.Band[0].nb >> 6) & 31;                  wd2 = 8 - (state.Band[0].nb >> 11);                  wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                  state.Band[0].det = wd3 << 2;                    Block4(state' 0' dlow);                    if (state.EncodeFrom8000Hz)                  {                      // Just leave the high bits as zero                      code = (0xC0 | ilow) >> (8 - state.BitsPerSample);                  }                  else                  {                      // Block 1H' SUBTRA                      eh = Saturate(xhigh - state.Band[1].s);                        // Block 1H' QUANTH                      wd = (eh >= 0) ? eh : -(eh + 1);                      wd1 = (564 * state.Band[1].det) >> 12;                      mih = (wd >= wd1) ? 2 : 1;                      ihigh = (eh < 0) ? ihn[mih] : ihp[mih];                        // Block 2H' INVQAH                      wd2 = qm2[ihigh];                      dhigh = (state.Band[1].det * wd2) >> 15;                        // Block 3H' LOGSCH                      ih2 = rh2[ihigh];                      wd = (state.Band[1].nb * 127) >> 7;                      state.Band[1].nb = wd + wh[ih2];                      if (state.Band[1].nb < 0)                          state.Band[1].nb = 0;                      else if (state.Band[1].nb > 22528)                          state.Band[1].nb = 22528;                        // Block 3H' SCALEH                      wd1 = (state.Band[1].nb >> 6) & 31;                      wd2 = 10 - (state.Band[1].nb >> 11);                      wd3 = (wd2 < 0) ? (ilb[wd1] << -wd2) : (ilb[wd1] >> wd2);                      state.Band[1].det = wd3 << 2;                        Block4(state' 1' dhigh);                      code = ((ihigh << 6) | ilow) >> (8 - state.BitsPerSample);                  }                    if (state.Packed)                  {                      // Pack the code bits                      state.OutBuffer |= (uint)(code << state.OutBits);                      state.OutBits += state.BitsPerSample;                      if (state.OutBits >= 8)                      {                          outputBuffer[g722_bytes++] = (byte)(state.OutBuffer & 0xFF);                          state.OutBits -= 8;                          state.OutBuffer >>= 8;                      }                  }                  else                  {                      outputBuffer[g722_bytes++] = (byte)code;                  }              }
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: this.Band = new Band[2] { new Band()' new Band() };
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: this.QmfSignalHistory = new int[24];
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: if (rate == 48000)                  this.BitsPerSample = 6;              else if (rate == 56000)                  this.BitsPerSample = 7;              else if (rate == 64000)                  this.BitsPerSample = 8;              else                  throw new ArgumentException("Invalid rate' should be 48000' 56000 or 64000");
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: if (rate == 48000)                  this.BitsPerSample = 6;              else if (rate == 56000)                  this.BitsPerSample = 7;              else if (rate == 64000)                  this.BitsPerSample = 8;              else                  throw new ArgumentException("Invalid rate' should be 48000' 56000 or 64000");
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: if (rate == 48000)                  this.BitsPerSample = 6;              else if (rate == 56000)                  this.BitsPerSample = 7;              else if (rate == 64000)                  this.BitsPerSample = 8;              else                  throw new ArgumentException("Invalid rate' should be 48000' 56000 or 64000");
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: if (rate == 48000)                  this.BitsPerSample = 6;              else if (rate == 56000)                  this.BitsPerSample = 7;              else if (rate == 64000)                  this.BitsPerSample = 8;              else                  throw new ArgumentException("Invalid rate' should be 48000' 56000 or 64000");
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: if (rate == 48000)                  this.BitsPerSample = 6;              else if (rate == 56000)                  this.BitsPerSample = 7;              else if (rate == 64000)                  this.BitsPerSample = 8;              else                  throw new ArgumentException("Invalid rate' should be 48000' 56000 or 64000");
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: if (rate == 48000)                  this.BitsPerSample = 6;              else if (rate == 56000)                  this.BitsPerSample = 7;              else if (rate == 64000)                  this.BitsPerSample = 8;              else                  throw new ArgumentException("Invalid rate' should be 48000' 56000 or 64000");
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: if (((options & G722Flags.Packed) == G722Flags.Packed) && this.BitsPerSample != 8)                  this.Packed = true;              else                  this.Packed = false;
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: this.Band[0].det = 32;
Magic Number,NAudio.Codecs,G722CodecState,C:\repos\naudio_NAudio\NAudio\Codecs\G722Codec.cs,G722CodecState,The following statement contains a magic number: this.Band[1].det = 8;
Magic Number,NAudio.Codecs,MuLawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\MuLawEncoder.cs,LinearToMuLawSample,The following statement contains a magic number: int sign = (sample >> 8) & 0x80;
Magic Number,NAudio.Codecs,MuLawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\MuLawEncoder.cs,LinearToMuLawSample,The following statement contains a magic number: int exponent = (int)MuLawCompressTable[(sample >> 7) & 0xFF];
Magic Number,NAudio.Codecs,MuLawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\MuLawEncoder.cs,LinearToMuLawSample,The following statement contains a magic number: int mantissa = (sample >> (exponent + 3)) & 0x0F;
Magic Number,NAudio.Codecs,MuLawEncoder,C:\repos\naudio_NAudio\NAudio\Codecs\MuLawEncoder.cs,LinearToMuLawSample,The following statement contains a magic number: int compressedByte = ~(sign | (exponent << 4) | mantissa);
Magic Number,NAudio.CoreAudioApi,WasapiCapture,C:\repos\naudio_NAudio\NAudio\Wave\WaveInputs\WasapiCapture.cs,InitializeCaptureDevice,The following statement contains a magic number: bytesPerFrame = waveFormat.Channels * waveFormat.BitsPerSample / 8;
Magic Number,NAudio.CoreAudioApi,WasapiCapture,C:\repos\naudio_NAudio\NAudio\Wave\WaveInputs\WasapiCapture.cs,DoRecording,The following statement contains a magic number: int sleepMilliseconds = (int)(actualDuration / ReftimesPerMillisec / 2);
Magic Number,NAudio.CoreAudioApi,WasapiCapture,C:\repos\naudio_NAudio\NAudio\Wave\WaveInputs\WasapiCapture.cs,DoRecording,The following statement contains a magic number: int waitMilliseconds = (int)(3 * actualDuration / ReftimesPerMillisec);
Magic Number,NAudio.CoreAudioApi,MMDeviceEnumerator,C:\repos\naudio_NAudio\NAudio\CoreAudioApi\MMDeviceEnumerator.cs,MMDeviceEnumerator,The following statement contains a magic number: if (System.Environment.OSVersion.Version.Major < 6)              {                  throw new NotSupportedException("This functionality is only supported on Windows Vista or newer.");              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,WdlResampler,The following statement contains a magic number: m_sratein = 44100.0;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,WdlResampler,The following statement contains a magic number: m_srateout = 44100.0;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SetMode,The following statement contains a magic number: m_sincsize = sinc && sinc_size >= 4 ? sinc_size > 8192 ? 8192 : sinc_size : 0;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SetMode,The following statement contains a magic number: m_sincsize = sinc && sinc_size >= 4 ? sinc_size > 8192 ? 8192 : sinc_size : 0;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SetMode,The following statement contains a magic number: m_sincsize = sinc && sinc_size >= 4 ? sinc_size > 8192 ? 8192 : sinc_size : 0;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SetMode,The following statement contains a magic number: m_sincoversize = (m_sincsize != 0) ? (sinc_interpsize <= 1 ? 1 : sinc_interpsize >= 4096 ? 4096 : sinc_interpsize) : 1;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SetMode,The following statement contains a magic number: m_sincoversize = (m_sincsize != 0) ? (sinc_interpsize <= 1 ? 1 : sinc_interpsize >= 4096 ? 4096 : sinc_interpsize) : 1;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResamplePrepare,The following statement contains a magic number: int hfs = fsize / 2;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResamplePrepare,The following statement contains a magic number: if (!m_feedmode) sreq = (int)(m_ratio * out_samples) + 4 + fsize - m_samples_in_rsinbuf;              else sreq = out_samples;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResamplePrepare,The following statement contains a magic number: if (sz != sreq)              {                  if (sreq > 4 && (sz == 0))                  {                      sreq /= 2;                      goto again; // try again with half the size                  }                  // todo: notify of error?                  sreq = sz;              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResamplePrepare,The following statement contains a magic number: if (sz != sreq)              {                  if (sreq > 4 && (sz == 0))                  {                      sreq /= 2;                      goto again; // try again with half the size                  }                  // todo: notify of error?                  sreq = sz;              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (nsamples_in < m_last_requested) // flush out to ensure we can deliver              {                  int fsize = (m_last_requested - nsamples_in) * 2 + m_sincsize * 2;                    int alloc_size = (m_samples_in_rsinbuf + fsize) * nch;                  Array.Resize(ref m_rsinbuf' alloc_size);                  if (m_rsinbuf.Length == alloc_size)                  {                      Array.Clear(m_rsinbuf' m_samples_in_rsinbuf * nch' fsize * nch);                      rsinbuf_availtemp = m_samples_in_rsinbuf + fsize;                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (nsamples_in < m_last_requested) // flush out to ensure we can deliver              {                  int fsize = (m_last_requested - nsamples_in) * 2 + m_sincsize * 2;                    int alloc_size = (m_samples_in_rsinbuf + fsize) * nch;                  Array.Resize(ref m_rsinbuf' alloc_size);                  if (m_rsinbuf.Length == alloc_size)                  {                      Array.Clear(m_rsinbuf' m_samples_in_rsinbuf * nch' fsize * nch);                      rsinbuf_availtemp = m_samples_in_rsinbuf + fsize;                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (m_sincsize != 0) // sinc interpolating              {                  if (m_ratio > 1.0) BuildLowPass(1.0 / (m_ratio * 1.03));                  else BuildLowPass(1.0);                    int filtsz = m_filter_coeffs_size;                  int filtlen = rsinbuf_availtemp - filtsz;                  outlatadj = filtsz / 2 - 1;                  int filter = 0; // filter is an index into m_filter_coeffs m_filter_coeffs.Get();                    if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample1(outBuffer' outptr' m_rsinbuf' localin + ipos' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr++;                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample2(outBuffer' outptr' m_rsinbuf' localin + ipos * 2' srcpos - ipos' m_filter_coeffs' filter' filtsz);                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                            if (ipos >= filtlen - 1) break; // quit decoding' not enough input samples                            SincSample(outBuffer' outptr' m_rsinbuf' localin + ipos * nch' srcpos - ipos' nch' m_filter_coeffs' filter' filtsz);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }                  }              }              else if (!m_interp) // point sampling              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            outBuffer[outptr++] = m_rsinbuf[localin + ipos];                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            ipos += ipos;                            outBuffer[outptr + 0] = m_rsinbuf[localin + ipos];                          outBuffer[outptr + 1] = m_rsinbuf[localin + ipos + 1];                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          if (ipos >= rsinbuf_availtemp) break; // quit decoding' not enough input samples                            Array.Copy(m_rsinbuf' localin + ipos * nch' outBuffer' outptr' nch);                          outptr += nch;                          srcpos += drspos;                          ret++;                      }              }              else // linear interpolation              {                  if (nch == 1)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos;                          outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 1] * (fracpos));                          srcpos += drspos;                          ret++;                      }                  }                  else if (nch == 2)                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int inptr = localin + ipos * 2;                          outBuffer[outptr + 0] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + 2] * (fracpos));                          outBuffer[outptr + 1] = (WDL_ResampleSample)(m_rsinbuf[inptr + 1] * (ifracpos) + m_rsinbuf[inptr + 3] * (fracpos));                          outptr += 2;                          srcpos += drspos;                          ret++;                      }                  }                  else                  {                      while (ns-- != 0)                      {                          int ipos = (int)srcpos;                          double fracpos = srcpos - ipos;                            if (ipos >= rsinbuf_availtemp - 1)                          {                              break; // quit decoding' not enough input samples                          }                            double ifracpos = 1.0 - fracpos;                          int ch = nch;                          int inptr = localin + ipos * nch;                          while (ch-- != 0)                          {                              outBuffer[outptr++] = (WDL_ResampleSample)(m_rsinbuf[inptr] * (ifracpos) + m_rsinbuf[inptr + nch] * (fracpos));                              inptr++;                          }                          srcpos += drspos;                          ret++;                      }                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,ResampleOut,The following statement contains a magic number: if (ret > 0 && rsinbuf_availtemp > m_samples_in_rsinbuf) // we had to pad!!              {                  // check for the case where rsinbuf_availtemp>m_samples_in_rsinbuf' decrease ret down to actual valid samples                  double adj = (srcpos - m_samples_in_rsinbuf + outlatadj) / drspos;                  if (adj > 0)                  {                      ret -= (int)(adj + 0.5);                      if (ret < 0) ret = 0;                  }              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,BuildLowPass,The following statement contains a magic number: if (m_filter_ratio != filtpos ||                  m_filter_coeffs_size != wantsize ||                  m_lp_oversize != wantinterp)              {                  m_lp_oversize = wantinterp;                  m_filter_ratio = filtpos;                    // build lowpass filter                  int allocsize = (wantsize + 1) * m_lp_oversize;                  Array.Resize(ref m_filter_coeffs' allocsize);                  //int cfout = 0; // this is an index into m_filter_coeffs                  if (m_filter_coeffs.Length == allocsize)                  {                      m_filter_coeffs_size = wantsize;                        int sz = wantsize * m_lp_oversize;                      int hsz = sz / 2;                      double filtpower = 0.0;                      double windowpos = 0.0;                      double dwindowpos = 2.0 * PI / (double)(sz);                      double dsincpos = PI / m_lp_oversize * filtpos; // filtpos is outrate/inrate' i.e. 0.5 is going to half rate                      double sincpos = dsincpos * (double)(-hsz);                        int x;                      for (x = -hsz; x < hsz + m_lp_oversize; x++)                      {                          double val = 0.35875 - 0.48829 * Math.Cos(windowpos) + 0.14128 * Math.Cos(2 * windowpos) - 0.01168 * Math.Cos(6 * windowpos); // blackman-harris                          if (x != 0) val *= Math.Sin(sincpos) / sincpos;                            windowpos += dwindowpos;                          sincpos += dsincpos;                            m_filter_coeffs[hsz + x] = (WDL_SincFilterSample)val;                          if (x < hsz) filtpower += val;                      }                      filtpower = m_lp_oversize / filtpower;                      for (x = 0; x < sz + m_lp_oversize; x++)                      {                          m_filter_coeffs[x] = (WDL_SincFilterSample)(m_filter_coeffs[x] * filtpower);                      }                  }                  else m_filter_coeffs_size = 0;                }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,BuildLowPass,The following statement contains a magic number: if (m_filter_ratio != filtpos ||                  m_filter_coeffs_size != wantsize ||                  m_lp_oversize != wantinterp)              {                  m_lp_oversize = wantinterp;                  m_filter_ratio = filtpos;                    // build lowpass filter                  int allocsize = (wantsize + 1) * m_lp_oversize;                  Array.Resize(ref m_filter_coeffs' allocsize);                  //int cfout = 0; // this is an index into m_filter_coeffs                  if (m_filter_coeffs.Length == allocsize)                  {                      m_filter_coeffs_size = wantsize;                        int sz = wantsize * m_lp_oversize;                      int hsz = sz / 2;                      double filtpower = 0.0;                      double windowpos = 0.0;                      double dwindowpos = 2.0 * PI / (double)(sz);                      double dsincpos = PI / m_lp_oversize * filtpos; // filtpos is outrate/inrate' i.e. 0.5 is going to half rate                      double sincpos = dsincpos * (double)(-hsz);                        int x;                      for (x = -hsz; x < hsz + m_lp_oversize; x++)                      {                          double val = 0.35875 - 0.48829 * Math.Cos(windowpos) + 0.14128 * Math.Cos(2 * windowpos) - 0.01168 * Math.Cos(6 * windowpos); // blackman-harris                          if (x != 0) val *= Math.Sin(sincpos) / sincpos;                            windowpos += dwindowpos;                          sincpos += dsincpos;                            m_filter_coeffs[hsz + x] = (WDL_SincFilterSample)val;                          if (x < hsz) filtpower += val;                      }                      filtpower = m_lp_oversize / filtpower;                      for (x = 0; x < sz + m_lp_oversize; x++)                      {                          m_filter_coeffs[x] = (WDL_SincFilterSample)(m_filter_coeffs[x] * filtpower);                      }                  }                  else m_filter_coeffs_size = 0;                }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,BuildLowPass,The following statement contains a magic number: if (m_filter_ratio != filtpos ||                  m_filter_coeffs_size != wantsize ||                  m_lp_oversize != wantinterp)              {                  m_lp_oversize = wantinterp;                  m_filter_ratio = filtpos;                    // build lowpass filter                  int allocsize = (wantsize + 1) * m_lp_oversize;                  Array.Resize(ref m_filter_coeffs' allocsize);                  //int cfout = 0; // this is an index into m_filter_coeffs                  if (m_filter_coeffs.Length == allocsize)                  {                      m_filter_coeffs_size = wantsize;                        int sz = wantsize * m_lp_oversize;                      int hsz = sz / 2;                      double filtpower = 0.0;                      double windowpos = 0.0;                      double dwindowpos = 2.0 * PI / (double)(sz);                      double dsincpos = PI / m_lp_oversize * filtpos; // filtpos is outrate/inrate' i.e. 0.5 is going to half rate                      double sincpos = dsincpos * (double)(-hsz);                        int x;                      for (x = -hsz; x < hsz + m_lp_oversize; x++)                      {                          double val = 0.35875 - 0.48829 * Math.Cos(windowpos) + 0.14128 * Math.Cos(2 * windowpos) - 0.01168 * Math.Cos(6 * windowpos); // blackman-harris                          if (x != 0) val *= Math.Sin(sincpos) / sincpos;                            windowpos += dwindowpos;                          sincpos += dsincpos;                            m_filter_coeffs[hsz + x] = (WDL_SincFilterSample)val;                          if (x < hsz) filtpower += val;                      }                      filtpower = m_lp_oversize / filtpower;                      for (x = 0; x < sz + m_lp_oversize; x++)                      {                          m_filter_coeffs[x] = (WDL_SincFilterSample)(m_filter_coeffs[x] * filtpower);                      }                  }                  else m_filter_coeffs_size = 0;                }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,BuildLowPass,The following statement contains a magic number: if (m_filter_ratio != filtpos ||                  m_filter_coeffs_size != wantsize ||                  m_lp_oversize != wantinterp)              {                  m_lp_oversize = wantinterp;                  m_filter_ratio = filtpos;                    // build lowpass filter                  int allocsize = (wantsize + 1) * m_lp_oversize;                  Array.Resize(ref m_filter_coeffs' allocsize);                  //int cfout = 0; // this is an index into m_filter_coeffs                  if (m_filter_coeffs.Length == allocsize)                  {                      m_filter_coeffs_size = wantsize;                        int sz = wantsize * m_lp_oversize;                      int hsz = sz / 2;                      double filtpower = 0.0;                      double windowpos = 0.0;                      double dwindowpos = 2.0 * PI / (double)(sz);                      double dsincpos = PI / m_lp_oversize * filtpos; // filtpos is outrate/inrate' i.e. 0.5 is going to half rate                      double sincpos = dsincpos * (double)(-hsz);                        int x;                      for (x = -hsz; x < hsz + m_lp_oversize; x++)                      {                          double val = 0.35875 - 0.48829 * Math.Cos(windowpos) + 0.14128 * Math.Cos(2 * windowpos) - 0.01168 * Math.Cos(6 * windowpos); // blackman-harris                          if (x != 0) val *= Math.Sin(sincpos) / sincpos;                            windowpos += dwindowpos;                          sincpos += dsincpos;                            m_filter_coeffs[hsz + x] = (WDL_SincFilterSample)val;                          if (x < hsz) filtpower += val;                      }                      filtpower = m_lp_oversize / filtpower;                      for (x = 0; x < sz + m_lp_oversize; x++)                      {                          m_filter_coeffs[x] = (WDL_SincFilterSample)(m_filter_coeffs[x] * filtpower);                      }                  }                  else m_filter_coeffs_size = 0;                }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,BuildLowPass,The following statement contains a magic number: if (m_filter_ratio != filtpos ||                  m_filter_coeffs_size != wantsize ||                  m_lp_oversize != wantinterp)              {                  m_lp_oversize = wantinterp;                  m_filter_ratio = filtpos;                    // build lowpass filter                  int allocsize = (wantsize + 1) * m_lp_oversize;                  Array.Resize(ref m_filter_coeffs' allocsize);                  //int cfout = 0; // this is an index into m_filter_coeffs                  if (m_filter_coeffs.Length == allocsize)                  {                      m_filter_coeffs_size = wantsize;                        int sz = wantsize * m_lp_oversize;                      int hsz = sz / 2;                      double filtpower = 0.0;                      double windowpos = 0.0;                      double dwindowpos = 2.0 * PI / (double)(sz);                      double dsincpos = PI / m_lp_oversize * filtpos; // filtpos is outrate/inrate' i.e. 0.5 is going to half rate                      double sincpos = dsincpos * (double)(-hsz);                        int x;                      for (x = -hsz; x < hsz + m_lp_oversize; x++)                      {                          double val = 0.35875 - 0.48829 * Math.Cos(windowpos) + 0.14128 * Math.Cos(2 * windowpos) - 0.01168 * Math.Cos(6 * windowpos); // blackman-harris                          if (x != 0) val *= Math.Sin(sincpos) / sincpos;                            windowpos += dwindowpos;                          sincpos += dsincpos;                            m_filter_coeffs[hsz + x] = (WDL_SincFilterSample)val;                          if (x < hsz) filtpower += val;                      }                      filtpower = m_lp_oversize / filtpower;                      for (x = 0; x < sz + m_lp_oversize; x++)                      {                          m_filter_coeffs[x] = (WDL_SincFilterSample)(m_filter_coeffs[x] * filtpower);                      }                  }                  else m_filter_coeffs_size = 0;                }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,BuildLowPass,The following statement contains a magic number: if (m_filter_ratio != filtpos ||                  m_filter_coeffs_size != wantsize ||                  m_lp_oversize != wantinterp)              {                  m_lp_oversize = wantinterp;                  m_filter_ratio = filtpos;                    // build lowpass filter                  int allocsize = (wantsize + 1) * m_lp_oversize;                  Array.Resize(ref m_filter_coeffs' allocsize);                  //int cfout = 0; // this is an index into m_filter_coeffs                  if (m_filter_coeffs.Length == allocsize)                  {                      m_filter_coeffs_size = wantsize;                        int sz = wantsize * m_lp_oversize;                      int hsz = sz / 2;                      double filtpower = 0.0;                      double windowpos = 0.0;                      double dwindowpos = 2.0 * PI / (double)(sz);                      double dsincpos = PI / m_lp_oversize * filtpos; // filtpos is outrate/inrate' i.e. 0.5 is going to half rate                      double sincpos = dsincpos * (double)(-hsz);                        int x;                      for (x = -hsz; x < hsz + m_lp_oversize; x++)                      {                          double val = 0.35875 - 0.48829 * Math.Cos(windowpos) + 0.14128 * Math.Cos(2 * windowpos) - 0.01168 * Math.Cos(6 * windowpos); // blackman-harris                          if (x != 0) val *= Math.Sin(sincpos) / sincpos;                            windowpos += dwindowpos;                          sincpos += dsincpos;                            m_filter_coeffs[hsz + x] = (WDL_SincFilterSample)val;                          if (x < hsz) filtpower += val;                      }                      filtpower = m_lp_oversize / filtpower;                      for (x = 0; x < sz + m_lp_oversize; x++)                      {                          m_filter_coeffs[x] = (WDL_SincFilterSample)(m_filter_coeffs[x] * filtpower);                      }                  }                  else m_filter_coeffs_size = 0;                }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,BuildLowPass,The following statement contains a magic number: if (m_filter_ratio != filtpos ||                  m_filter_coeffs_size != wantsize ||                  m_lp_oversize != wantinterp)              {                  m_lp_oversize = wantinterp;                  m_filter_ratio = filtpos;                    // build lowpass filter                  int allocsize = (wantsize + 1) * m_lp_oversize;                  Array.Resize(ref m_filter_coeffs' allocsize);                  //int cfout = 0; // this is an index into m_filter_coeffs                  if (m_filter_coeffs.Length == allocsize)                  {                      m_filter_coeffs_size = wantsize;                        int sz = wantsize * m_lp_oversize;                      int hsz = sz / 2;                      double filtpower = 0.0;                      double windowpos = 0.0;                      double dwindowpos = 2.0 * PI / (double)(sz);                      double dsincpos = PI / m_lp_oversize * filtpos; // filtpos is outrate/inrate' i.e. 0.5 is going to half rate                      double sincpos = dsincpos * (double)(-hsz);                        int x;                      for (x = -hsz; x < hsz + m_lp_oversize; x++)                      {                          double val = 0.35875 - 0.48829 * Math.Cos(windowpos) + 0.14128 * Math.Cos(2 * windowpos) - 0.01168 * Math.Cos(6 * windowpos); // blackman-harris                          if (x != 0) val *= Math.Sin(sincpos) / sincpos;                            windowpos += dwindowpos;                          sincpos += dsincpos;                            m_filter_coeffs[hsz + x] = (WDL_SincFilterSample)val;                          if (x < hsz) filtpower += val;                      }                      filtpower = m_lp_oversize / filtpower;                      for (x = 0; x < sz + m_lp_oversize; x++)                      {                          m_filter_coeffs[x] = (WDL_SincFilterSample)(m_filter_coeffs[x] * filtpower);                      }                  }                  else m_filter_coeffs_size = 0;                }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,BuildLowPass,The following statement contains a magic number: if (m_filter_ratio != filtpos ||                  m_filter_coeffs_size != wantsize ||                  m_lp_oversize != wantinterp)              {                  m_lp_oversize = wantinterp;                  m_filter_ratio = filtpos;                    // build lowpass filter                  int allocsize = (wantsize + 1) * m_lp_oversize;                  Array.Resize(ref m_filter_coeffs' allocsize);                  //int cfout = 0; // this is an index into m_filter_coeffs                  if (m_filter_coeffs.Length == allocsize)                  {                      m_filter_coeffs_size = wantsize;                        int sz = wantsize * m_lp_oversize;                      int hsz = sz / 2;                      double filtpower = 0.0;                      double windowpos = 0.0;                      double dwindowpos = 2.0 * PI / (double)(sz);                      double dsincpos = PI / m_lp_oversize * filtpos; // filtpos is outrate/inrate' i.e. 0.5 is going to half rate                      double sincpos = dsincpos * (double)(-hsz);                        int x;                      for (x = -hsz; x < hsz + m_lp_oversize; x++)                      {                          double val = 0.35875 - 0.48829 * Math.Cos(windowpos) + 0.14128 * Math.Cos(2 * windowpos) - 0.01168 * Math.Cos(6 * windowpos); // blackman-harris                          if (x != 0) val *= Math.Sin(sincpos) / sincpos;                            windowpos += dwindowpos;                          sincpos += dsincpos;                            m_filter_coeffs[hsz + x] = (WDL_SincFilterSample)val;                          if (x < hsz) filtpower += val;                      }                      filtpower = m_lp_oversize / filtpower;                      for (x = 0; x < sz + m_lp_oversize; x++)                      {                          m_filter_coeffs[x] = (WDL_SincFilterSample)(m_filter_coeffs[x] * filtpower);                      }                  }                  else m_filter_coeffs_size = 0;                }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample2,The following statement contains a magic number: int i = filtsz / 2;
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample2,The following statement contains a magic number: while (i-- != 0)              {                  sum += filter[fptr] * inBuffer[iptr];                  sum2 += filter[fptr] * inBuffer[iptr + 1];                  sumb += filter[fptr + 1] * inBuffer[iptr];                  sum2b += filter[fptr + 1] * inBuffer[iptr + 1];                  sum += filter[fptr + oversize] * inBuffer[iptr + 2];                  sum2 += filter[fptr + oversize] * inBuffer[iptr + 3];                  sumb += filter[fptr + oversize + 1] * inBuffer[iptr + 2];                  sum2b += filter[fptr + oversize + 1] * inBuffer[iptr + 3];                  iptr += 4;                  fptr += oversize * 2;              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample2,The following statement contains a magic number: while (i-- != 0)              {                  sum += filter[fptr] * inBuffer[iptr];                  sum2 += filter[fptr] * inBuffer[iptr + 1];                  sumb += filter[fptr + 1] * inBuffer[iptr];                  sum2b += filter[fptr + 1] * inBuffer[iptr + 1];                  sum += filter[fptr + oversize] * inBuffer[iptr + 2];                  sum2 += filter[fptr + oversize] * inBuffer[iptr + 3];                  sumb += filter[fptr + oversize + 1] * inBuffer[iptr + 2];                  sum2b += filter[fptr + oversize + 1] * inBuffer[iptr + 3];                  iptr += 4;                  fptr += oversize * 2;              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample2,The following statement contains a magic number: while (i-- != 0)              {                  sum += filter[fptr] * inBuffer[iptr];                  sum2 += filter[fptr] * inBuffer[iptr + 1];                  sumb += filter[fptr + 1] * inBuffer[iptr];                  sum2b += filter[fptr + 1] * inBuffer[iptr + 1];                  sum += filter[fptr + oversize] * inBuffer[iptr + 2];                  sum2 += filter[fptr + oversize] * inBuffer[iptr + 3];                  sumb += filter[fptr + oversize + 1] * inBuffer[iptr + 2];                  sum2b += filter[fptr + oversize + 1] * inBuffer[iptr + 3];                  iptr += 4;                  fptr += oversize * 2;              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample2,The following statement contains a magic number: while (i-- != 0)              {                  sum += filter[fptr] * inBuffer[iptr];                  sum2 += filter[fptr] * inBuffer[iptr + 1];                  sumb += filter[fptr + 1] * inBuffer[iptr];                  sum2b += filter[fptr + 1] * inBuffer[iptr + 1];                  sum += filter[fptr + oversize] * inBuffer[iptr + 2];                  sum2 += filter[fptr + oversize] * inBuffer[iptr + 3];                  sumb += filter[fptr + oversize + 1] * inBuffer[iptr + 2];                  sum2b += filter[fptr + oversize + 1] * inBuffer[iptr + 3];                  iptr += 4;                  fptr += oversize * 2;              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample2,The following statement contains a magic number: while (i-- != 0)              {                  sum += filter[fptr] * inBuffer[iptr];                  sum2 += filter[fptr] * inBuffer[iptr + 1];                  sumb += filter[fptr + 1] * inBuffer[iptr];                  sum2b += filter[fptr + 1] * inBuffer[iptr + 1];                  sum += filter[fptr + oversize] * inBuffer[iptr + 2];                  sum2 += filter[fptr + oversize] * inBuffer[iptr + 3];                  sumb += filter[fptr + oversize + 1] * inBuffer[iptr + 2];                  sum2b += filter[fptr + oversize + 1] * inBuffer[iptr + 3];                  iptr += 4;                  fptr += oversize * 2;              }
Magic Number,NAudio.Dsp,WdlResampler,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,SincSample2,The following statement contains a magic number: while (i-- != 0)              {                  sum += filter[fptr] * inBuffer[iptr];                  sum2 += filter[fptr] * inBuffer[iptr + 1];                  sumb += filter[fptr + 1] * inBuffer[iptr];                  sum2b += filter[fptr + 1] * inBuffer[iptr + 1];                  sum += filter[fptr + oversize] * inBuffer[iptr + 2];                  sum2 += filter[fptr + oversize] * inBuffer[iptr + 3];                  sumb += filter[fptr + oversize + 1] * inBuffer[iptr + 2];                  sum2b += filter[fptr + oversize + 1] * inBuffer[iptr + 3];                  iptr += 4;                  fptr += oversize * 2;              }
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,Reset,The following statement contains a magic number: m_hist = new double[WDL_RESAMPLE_MAX_FILTERS * WDL_RESAMPLE_MAX_NCH' 4];
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,setParms,The following statement contains a magic number: if (Math.Abs(fpos - m_fpos) < 0.000001) return;
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,setParms,The following statement contains a magic number: double alpha = spos / (2.0 * Q);
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,setParms,The following statement contains a magic number: m_b2 = m_b0 = m_b1 * 0.5;
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,setParms,The following statement contains a magic number: m_a1 = -2 * cpos * sc;
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,Apply,The following statement contains a magic number: while (ns-- != 0)                  {                      double inx = inBuffer[inIndex];                      inIndex += span;                      double outx = (double)(inx * b0 + m_hist[w' 0] * b1 + m_hist[w' 1] * b2 - m_hist[w' 2] * a1 - m_hist[w' 3] * a2);                      m_hist[w' 1] = m_hist[w' 0];                      m_hist[w' 0] = inx;                      m_hist[w' 3] = m_hist[w' 2];                      m_hist[w' 2] = denormal_filter(outx);                      outBuffer[outIndex] = (WDL_ResampleSample)m_hist[w' 2];                        outIndex += span;                  }
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,Apply,The following statement contains a magic number: while (ns-- != 0)                  {                      double inx = inBuffer[inIndex];                      inIndex += span;                      double outx = (double)(inx * b0 + m_hist[w' 0] * b1 + m_hist[w' 1] * b2 - m_hist[w' 2] * a1 - m_hist[w' 3] * a2);                      m_hist[w' 1] = m_hist[w' 0];                      m_hist[w' 0] = inx;                      m_hist[w' 3] = m_hist[w' 2];                      m_hist[w' 2] = denormal_filter(outx);                      outBuffer[outIndex] = (WDL_ResampleSample)m_hist[w' 2];                        outIndex += span;                  }
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,Apply,The following statement contains a magic number: while (ns-- != 0)                  {                      double inx = inBuffer[inIndex];                      inIndex += span;                      double outx = (double)(inx * b0 + m_hist[w' 0] * b1 + m_hist[w' 1] * b2 - m_hist[w' 2] * a1 - m_hist[w' 3] * a2);                      m_hist[w' 1] = m_hist[w' 0];                      m_hist[w' 0] = inx;                      m_hist[w' 3] = m_hist[w' 2];                      m_hist[w' 2] = denormal_filter(outx);                      outBuffer[outIndex] = (WDL_ResampleSample)m_hist[w' 2];                        outIndex += span;                  }
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,Apply,The following statement contains a magic number: while (ns-- != 0)                  {                      double inx = inBuffer[inIndex];                      inIndex += span;                      double outx = (double)(inx * b0 + m_hist[w' 0] * b1 + m_hist[w' 1] * b2 - m_hist[w' 2] * a1 - m_hist[w' 3] * a2);                      m_hist[w' 1] = m_hist[w' 0];                      m_hist[w' 0] = inx;                      m_hist[w' 3] = m_hist[w' 2];                      m_hist[w' 2] = denormal_filter(outx);                      outBuffer[outIndex] = (WDL_ResampleSample)m_hist[w' 2];                        outIndex += span;                  }
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,Apply,The following statement contains a magic number: while (ns-- != 0)                  {                      double inx = inBuffer[inIndex];                      inIndex += span;                      double outx = (double)(inx * b0 + m_hist[w' 0] * b1 + m_hist[w' 1] * b2 - m_hist[w' 2] * a1 - m_hist[w' 3] * a2);                      m_hist[w' 1] = m_hist[w' 0];                      m_hist[w' 0] = inx;                      m_hist[w' 3] = m_hist[w' 2];                      m_hist[w' 2] = denormal_filter(outx);                      outBuffer[outIndex] = (WDL_ResampleSample)m_hist[w' 2];                        outIndex += span;                  }
Magic Number,NAudio.Dsp,WDL_Resampler_IIRFilter,C:\repos\naudio_NAudio\NAudio\Dsp\WdlResampler.cs,Apply,The following statement contains a magic number: while (ns-- != 0)                  {                      double inx = inBuffer[inIndex];                      inIndex += span;                      double outx = (double)(inx * b0 + m_hist[w' 0] * b1 + m_hist[w' 1] * b2 - m_hist[w' 2] * a1 - m_hist[w' 3] * a2);                      m_hist[w' 1] = m_hist[w' 0];                      m_hist[w' 0] = inx;                      m_hist[w' 3] = m_hist[w' 2];                      m_hist[w' 2] = denormal_filter(outx);                      outBuffer[outIndex] = (WDL_ResampleSample)m_hist[w' 2];                        outIndex += span;                  }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: fftFrameSize2 = fftFrameSize/2;
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: expct = 2.0*Math.PI*(double) stepSize/(double) fftFrameSize;
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: for (i = 0; i < numSampsToProcess; i++)              {                    /* As long as we have not yet collected enough data just read in */                  gInFIFO[gRover] = indata[i];                  outdata[i] = gOutFIFO[gRover - inFifoLatency];                  gRover++;                    /* now we have enough data for processing */                  if (gRover >= fftFrameSize)                  {                      gRover = inFifoLatency;                        /* do windowing and re'im interleave */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gFFTworksp[2*k] = (float) (gInFIFO[k]*window);                          gFFTworksp[2*k + 1] = 0.0F;                      }                          /* ***************** ANALYSIS ******************* */                      /* do transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' -1);                        /* this is the analysis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* de-interlace FFT buffer */                          real = gFFTworksp[2*k];                          imag = gFFTworksp[2*k + 1];                            /* compute magnitude and phase */                          magn = 2.0*Math.Sqrt(real*real + imag*imag);                          phase = Math.Atan2(imag' real);                            /* compute phase difference */                          tmp = phase - gLastPhase[k];                          gLastPhase[k] = (float) phase;                            /* subtract expected phase difference */                          tmp -= (double) k*expct;                            /* map delta phase into +/- Pi interval */                          qpd = (long) (tmp/Math.PI);                          if (qpd >= 0) qpd += qpd & 1;                          else qpd -= qpd & 1;                          tmp -= Math.PI*(double) qpd;                            /* get deviation from bin frequency from the +/- Pi interval */                          tmp = osamp*tmp/(2.0*Math.PI);                            /* compute the k-th partials' true frequency */                          tmp = (double) k*freqPerBin + tmp*freqPerBin;                            /* store magnitude and true frequency in analysis arrays */                          gAnaMagn[k] = (float) magn;                          gAnaFreq[k] = (float) tmp;                        }                        /* ***************** PROCESSING ******************* */                      /* this does the actual pitch shifting */                      for (int zero = 0; zero < fftFrameSize; zero++)                      {                          gSynMagn[zero] = 0;                          gSynFreq[zero] = 0;                      }                        for (k = 0; k <= fftFrameSize2; k++)                      {                          index = (long) (k*pitchShift);                          if (index <= fftFrameSize2)                          {                              gSynMagn[index] += gAnaMagn[k];                              gSynFreq[index] = gAnaFreq[k]*pitchShift;                          }                      }                        /* ***************** SYNTHESIS ******************* */                      /* this is the synthesis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* get magnitude and true frequency from synthesis arrays */                          magn = gSynMagn[k];                          tmp = gSynFreq[k];                            /* subtract bin mid frequency */                          tmp -= (double) k*freqPerBin;                            /* get bin deviation from freq deviation */                          tmp /= freqPerBin;                            /* take osamp into account */                          tmp = 2.0*Math.PI*tmp/osamp;                            /* add the overlap phase advance back in */                          tmp += (double) k*expct;                            /* accumulate delta phase to get bin phase */                          gSumPhase[k] += (float) tmp;                          phase = gSumPhase[k];                            /* get real and imag part and re-interleave */                          gFFTworksp[2*k] = (float) (magn*Math.Cos(phase));                          gFFTworksp[2*k + 1] = (float) (magn*Math.Sin(phase));                      }                        /* zero negative frequencies */                      for (k = fftFrameSize + 2; k < 2*fftFrameSize; k++) gFFTworksp[k] = 0.0F;                        /* do inverse transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' 1);                        /* do windowing and add to output accumulator */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gOutputAccum[k] += (float) (2.0*window*gFFTworksp[2*k]/(fftFrameSize2*osamp));                      }                      for (k = 0; k < stepSize; k++) gOutFIFO[k] = gOutputAccum[k];                        /* shift accumulator */                      //memmove(gOutputAccum' gOutputAccum + stepSize' fftFrameSize * sizeof(float));                      for (k = 0; k < fftFrameSize; k++)                      {                          gOutputAccum[k] = gOutputAccum[k + stepSize];                      }                        /* move input FIFO */                      for (k = 0; k < inFifoLatency; k++) gInFIFO[k] = gInFIFO[k + stepSize];                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: for (i = 0; i < numSampsToProcess; i++)              {                    /* As long as we have not yet collected enough data just read in */                  gInFIFO[gRover] = indata[i];                  outdata[i] = gOutFIFO[gRover - inFifoLatency];                  gRover++;                    /* now we have enough data for processing */                  if (gRover >= fftFrameSize)                  {                      gRover = inFifoLatency;                        /* do windowing and re'im interleave */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gFFTworksp[2*k] = (float) (gInFIFO[k]*window);                          gFFTworksp[2*k + 1] = 0.0F;                      }                          /* ***************** ANALYSIS ******************* */                      /* do transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' -1);                        /* this is the analysis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* de-interlace FFT buffer */                          real = gFFTworksp[2*k];                          imag = gFFTworksp[2*k + 1];                            /* compute magnitude and phase */                          magn = 2.0*Math.Sqrt(real*real + imag*imag);                          phase = Math.Atan2(imag' real);                            /* compute phase difference */                          tmp = phase - gLastPhase[k];                          gLastPhase[k] = (float) phase;                            /* subtract expected phase difference */                          tmp -= (double) k*expct;                            /* map delta phase into +/- Pi interval */                          qpd = (long) (tmp/Math.PI);                          if (qpd >= 0) qpd += qpd & 1;                          else qpd -= qpd & 1;                          tmp -= Math.PI*(double) qpd;                            /* get deviation from bin frequency from the +/- Pi interval */                          tmp = osamp*tmp/(2.0*Math.PI);                            /* compute the k-th partials' true frequency */                          tmp = (double) k*freqPerBin + tmp*freqPerBin;                            /* store magnitude and true frequency in analysis arrays */                          gAnaMagn[k] = (float) magn;                          gAnaFreq[k] = (float) tmp;                        }                        /* ***************** PROCESSING ******************* */                      /* this does the actual pitch shifting */                      for (int zero = 0; zero < fftFrameSize; zero++)                      {                          gSynMagn[zero] = 0;                          gSynFreq[zero] = 0;                      }                        for (k = 0; k <= fftFrameSize2; k++)                      {                          index = (long) (k*pitchShift);                          if (index <= fftFrameSize2)                          {                              gSynMagn[index] += gAnaMagn[k];                              gSynFreq[index] = gAnaFreq[k]*pitchShift;                          }                      }                        /* ***************** SYNTHESIS ******************* */                      /* this is the synthesis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* get magnitude and true frequency from synthesis arrays */                          magn = gSynMagn[k];                          tmp = gSynFreq[k];                            /* subtract bin mid frequency */                          tmp -= (double) k*freqPerBin;                            /* get bin deviation from freq deviation */                          tmp /= freqPerBin;                            /* take osamp into account */                          tmp = 2.0*Math.PI*tmp/osamp;                            /* add the overlap phase advance back in */                          tmp += (double) k*expct;                            /* accumulate delta phase to get bin phase */                          gSumPhase[k] += (float) tmp;                          phase = gSumPhase[k];                            /* get real and imag part and re-interleave */                          gFFTworksp[2*k] = (float) (magn*Math.Cos(phase));                          gFFTworksp[2*k + 1] = (float) (magn*Math.Sin(phase));                      }                        /* zero negative frequencies */                      for (k = fftFrameSize + 2; k < 2*fftFrameSize; k++) gFFTworksp[k] = 0.0F;                        /* do inverse transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' 1);                        /* do windowing and add to output accumulator */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gOutputAccum[k] += (float) (2.0*window*gFFTworksp[2*k]/(fftFrameSize2*osamp));                      }                      for (k = 0; k < stepSize; k++) gOutFIFO[k] = gOutputAccum[k];                        /* shift accumulator */                      //memmove(gOutputAccum' gOutputAccum + stepSize' fftFrameSize * sizeof(float));                      for (k = 0; k < fftFrameSize; k++)                      {                          gOutputAccum[k] = gOutputAccum[k + stepSize];                      }                        /* move input FIFO */                      for (k = 0; k < inFifoLatency; k++) gInFIFO[k] = gInFIFO[k + stepSize];                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: for (i = 0; i < numSampsToProcess; i++)              {                    /* As long as we have not yet collected enough data just read in */                  gInFIFO[gRover] = indata[i];                  outdata[i] = gOutFIFO[gRover - inFifoLatency];                  gRover++;                    /* now we have enough data for processing */                  if (gRover >= fftFrameSize)                  {                      gRover = inFifoLatency;                        /* do windowing and re'im interleave */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gFFTworksp[2*k] = (float) (gInFIFO[k]*window);                          gFFTworksp[2*k + 1] = 0.0F;                      }                          /* ***************** ANALYSIS ******************* */                      /* do transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' -1);                        /* this is the analysis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* de-interlace FFT buffer */                          real = gFFTworksp[2*k];                          imag = gFFTworksp[2*k + 1];                            /* compute magnitude and phase */                          magn = 2.0*Math.Sqrt(real*real + imag*imag);                          phase = Math.Atan2(imag' real);                            /* compute phase difference */                          tmp = phase - gLastPhase[k];                          gLastPhase[k] = (float) phase;                            /* subtract expected phase difference */                          tmp -= (double) k*expct;                            /* map delta phase into +/- Pi interval */                          qpd = (long) (tmp/Math.PI);                          if (qpd >= 0) qpd += qpd & 1;                          else qpd -= qpd & 1;                          tmp -= Math.PI*(double) qpd;                            /* get deviation from bin frequency from the +/- Pi interval */                          tmp = osamp*tmp/(2.0*Math.PI);                            /* compute the k-th partials' true frequency */                          tmp = (double) k*freqPerBin + tmp*freqPerBin;                            /* store magnitude and true frequency in analysis arrays */                          gAnaMagn[k] = (float) magn;                          gAnaFreq[k] = (float) tmp;                        }                        /* ***************** PROCESSING ******************* */                      /* this does the actual pitch shifting */                      for (int zero = 0; zero < fftFrameSize; zero++)                      {                          gSynMagn[zero] = 0;                          gSynFreq[zero] = 0;                      }                        for (k = 0; k <= fftFrameSize2; k++)                      {                          index = (long) (k*pitchShift);                          if (index <= fftFrameSize2)                          {                              gSynMagn[index] += gAnaMagn[k];                              gSynFreq[index] = gAnaFreq[k]*pitchShift;                          }                      }                        /* ***************** SYNTHESIS ******************* */                      /* this is the synthesis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* get magnitude and true frequency from synthesis arrays */                          magn = gSynMagn[k];                          tmp = gSynFreq[k];                            /* subtract bin mid frequency */                          tmp -= (double) k*freqPerBin;                            /* get bin deviation from freq deviation */                          tmp /= freqPerBin;                            /* take osamp into account */                          tmp = 2.0*Math.PI*tmp/osamp;                            /* add the overlap phase advance back in */                          tmp += (double) k*expct;                            /* accumulate delta phase to get bin phase */                          gSumPhase[k] += (float) tmp;                          phase = gSumPhase[k];                            /* get real and imag part and re-interleave */                          gFFTworksp[2*k] = (float) (magn*Math.Cos(phase));                          gFFTworksp[2*k + 1] = (float) (magn*Math.Sin(phase));                      }                        /* zero negative frequencies */                      for (k = fftFrameSize + 2; k < 2*fftFrameSize; k++) gFFTworksp[k] = 0.0F;                        /* do inverse transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' 1);                        /* do windowing and add to output accumulator */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gOutputAccum[k] += (float) (2.0*window*gFFTworksp[2*k]/(fftFrameSize2*osamp));                      }                      for (k = 0; k < stepSize; k++) gOutFIFO[k] = gOutputAccum[k];                        /* shift accumulator */                      //memmove(gOutputAccum' gOutputAccum + stepSize' fftFrameSize * sizeof(float));                      for (k = 0; k < fftFrameSize; k++)                      {                          gOutputAccum[k] = gOutputAccum[k + stepSize];                      }                        /* move input FIFO */                      for (k = 0; k < inFifoLatency; k++) gInFIFO[k] = gInFIFO[k + stepSize];                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: for (i = 0; i < numSampsToProcess; i++)              {                    /* As long as we have not yet collected enough data just read in */                  gInFIFO[gRover] = indata[i];                  outdata[i] = gOutFIFO[gRover - inFifoLatency];                  gRover++;                    /* now we have enough data for processing */                  if (gRover >= fftFrameSize)                  {                      gRover = inFifoLatency;                        /* do windowing and re'im interleave */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gFFTworksp[2*k] = (float) (gInFIFO[k]*window);                          gFFTworksp[2*k + 1] = 0.0F;                      }                          /* ***************** ANALYSIS ******************* */                      /* do transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' -1);                        /* this is the analysis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* de-interlace FFT buffer */                          real = gFFTworksp[2*k];                          imag = gFFTworksp[2*k + 1];                            /* compute magnitude and phase */                          magn = 2.0*Math.Sqrt(real*real + imag*imag);                          phase = Math.Atan2(imag' real);                            /* compute phase difference */                          tmp = phase - gLastPhase[k];                          gLastPhase[k] = (float) phase;                            /* subtract expected phase difference */                          tmp -= (double) k*expct;                            /* map delta phase into +/- Pi interval */                          qpd = (long) (tmp/Math.PI);                          if (qpd >= 0) qpd += qpd & 1;                          else qpd -= qpd & 1;                          tmp -= Math.PI*(double) qpd;                            /* get deviation from bin frequency from the +/- Pi interval */                          tmp = osamp*tmp/(2.0*Math.PI);                            /* compute the k-th partials' true frequency */                          tmp = (double) k*freqPerBin + tmp*freqPerBin;                            /* store magnitude and true frequency in analysis arrays */                          gAnaMagn[k] = (float) magn;                          gAnaFreq[k] = (float) tmp;                        }                        /* ***************** PROCESSING ******************* */                      /* this does the actual pitch shifting */                      for (int zero = 0; zero < fftFrameSize; zero++)                      {                          gSynMagn[zero] = 0;                          gSynFreq[zero] = 0;                      }                        for (k = 0; k <= fftFrameSize2; k++)                      {                          index = (long) (k*pitchShift);                          if (index <= fftFrameSize2)                          {                              gSynMagn[index] += gAnaMagn[k];                              gSynFreq[index] = gAnaFreq[k]*pitchShift;                          }                      }                        /* ***************** SYNTHESIS ******************* */                      /* this is the synthesis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* get magnitude and true frequency from synthesis arrays */                          magn = gSynMagn[k];                          tmp = gSynFreq[k];                            /* subtract bin mid frequency */                          tmp -= (double) k*freqPerBin;                            /* get bin deviation from freq deviation */                          tmp /= freqPerBin;                            /* take osamp into account */                          tmp = 2.0*Math.PI*tmp/osamp;                            /* add the overlap phase advance back in */                          tmp += (double) k*expct;                            /* accumulate delta phase to get bin phase */                          gSumPhase[k] += (float) tmp;                          phase = gSumPhase[k];                            /* get real and imag part and re-interleave */                          gFFTworksp[2*k] = (float) (magn*Math.Cos(phase));                          gFFTworksp[2*k + 1] = (float) (magn*Math.Sin(phase));                      }                        /* zero negative frequencies */                      for (k = fftFrameSize + 2; k < 2*fftFrameSize; k++) gFFTworksp[k] = 0.0F;                        /* do inverse transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' 1);                        /* do windowing and add to output accumulator */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gOutputAccum[k] += (float) (2.0*window*gFFTworksp[2*k]/(fftFrameSize2*osamp));                      }                      for (k = 0; k < stepSize; k++) gOutFIFO[k] = gOutputAccum[k];                        /* shift accumulator */                      //memmove(gOutputAccum' gOutputAccum + stepSize' fftFrameSize * sizeof(float));                      for (k = 0; k < fftFrameSize; k++)                      {                          gOutputAccum[k] = gOutputAccum[k + stepSize];                      }                        /* move input FIFO */                      for (k = 0; k < inFifoLatency; k++) gInFIFO[k] = gInFIFO[k + stepSize];                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: for (i = 0; i < numSampsToProcess; i++)              {                    /* As long as we have not yet collected enough data just read in */                  gInFIFO[gRover] = indata[i];                  outdata[i] = gOutFIFO[gRover - inFifoLatency];                  gRover++;                    /* now we have enough data for processing */                  if (gRover >= fftFrameSize)                  {                      gRover = inFifoLatency;                        /* do windowing and re'im interleave */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gFFTworksp[2*k] = (float) (gInFIFO[k]*window);                          gFFTworksp[2*k + 1] = 0.0F;                      }                          /* ***************** ANALYSIS ******************* */                      /* do transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' -1);                        /* this is the analysis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* de-interlace FFT buffer */                          real = gFFTworksp[2*k];                          imag = gFFTworksp[2*k + 1];                            /* compute magnitude and phase */                          magn = 2.0*Math.Sqrt(real*real + imag*imag);                          phase = Math.Atan2(imag' real);                            /* compute phase difference */                          tmp = phase - gLastPhase[k];                          gLastPhase[k] = (float) phase;                            /* subtract expected phase difference */                          tmp -= (double) k*expct;                            /* map delta phase into +/- Pi interval */                          qpd = (long) (tmp/Math.PI);                          if (qpd >= 0) qpd += qpd & 1;                          else qpd -= qpd & 1;                          tmp -= Math.PI*(double) qpd;                            /* get deviation from bin frequency from the +/- Pi interval */                          tmp = osamp*tmp/(2.0*Math.PI);                            /* compute the k-th partials' true frequency */                          tmp = (double) k*freqPerBin + tmp*freqPerBin;                            /* store magnitude and true frequency in analysis arrays */                          gAnaMagn[k] = (float) magn;                          gAnaFreq[k] = (float) tmp;                        }                        /* ***************** PROCESSING ******************* */                      /* this does the actual pitch shifting */                      for (int zero = 0; zero < fftFrameSize; zero++)                      {                          gSynMagn[zero] = 0;                          gSynFreq[zero] = 0;                      }                        for (k = 0; k <= fftFrameSize2; k++)                      {                          index = (long) (k*pitchShift);                          if (index <= fftFrameSize2)                          {                              gSynMagn[index] += gAnaMagn[k];                              gSynFreq[index] = gAnaFreq[k]*pitchShift;                          }                      }                        /* ***************** SYNTHESIS ******************* */                      /* this is the synthesis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* get magnitude and true frequency from synthesis arrays */                          magn = gSynMagn[k];                          tmp = gSynFreq[k];                            /* subtract bin mid frequency */                          tmp -= (double) k*freqPerBin;                            /* get bin deviation from freq deviation */                          tmp /= freqPerBin;                            /* take osamp into account */                          tmp = 2.0*Math.PI*tmp/osamp;                            /* add the overlap phase advance back in */                          tmp += (double) k*expct;                            /* accumulate delta phase to get bin phase */                          gSumPhase[k] += (float) tmp;                          phase = gSumPhase[k];                            /* get real and imag part and re-interleave */                          gFFTworksp[2*k] = (float) (magn*Math.Cos(phase));                          gFFTworksp[2*k + 1] = (float) (magn*Math.Sin(phase));                      }                        /* zero negative frequencies */                      for (k = fftFrameSize + 2; k < 2*fftFrameSize; k++) gFFTworksp[k] = 0.0F;                        /* do inverse transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' 1);                        /* do windowing and add to output accumulator */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gOutputAccum[k] += (float) (2.0*window*gFFTworksp[2*k]/(fftFrameSize2*osamp));                      }                      for (k = 0; k < stepSize; k++) gOutFIFO[k] = gOutputAccum[k];                        /* shift accumulator */                      //memmove(gOutputAccum' gOutputAccum + stepSize' fftFrameSize * sizeof(float));                      for (k = 0; k < fftFrameSize; k++)                      {                          gOutputAccum[k] = gOutputAccum[k + stepSize];                      }                        /* move input FIFO */                      for (k = 0; k < inFifoLatency; k++) gInFIFO[k] = gInFIFO[k + stepSize];                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: for (i = 0; i < numSampsToProcess; i++)              {                    /* As long as we have not yet collected enough data just read in */                  gInFIFO[gRover] = indata[i];                  outdata[i] = gOutFIFO[gRover - inFifoLatency];                  gRover++;                    /* now we have enough data for processing */                  if (gRover >= fftFrameSize)                  {                      gRover = inFifoLatency;                        /* do windowing and re'im interleave */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gFFTworksp[2*k] = (float) (gInFIFO[k]*window);                          gFFTworksp[2*k + 1] = 0.0F;                      }                          /* ***************** ANALYSIS ******************* */                      /* do transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' -1);                        /* this is the analysis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* de-interlace FFT buffer */                          real = gFFTworksp[2*k];                          imag = gFFTworksp[2*k + 1];                            /* compute magnitude and phase */                          magn = 2.0*Math.Sqrt(real*real + imag*imag);                          phase = Math.Atan2(imag' real);                            /* compute phase difference */                          tmp = phase - gLastPhase[k];                          gLastPhase[k] = (float) phase;                            /* subtract expected phase difference */                          tmp -= (double) k*expct;                            /* map delta phase into +/- Pi interval */                          qpd = (long) (tmp/Math.PI);                          if (qpd >= 0) qpd += qpd & 1;                          else qpd -= qpd & 1;                          tmp -= Math.PI*(double) qpd;                            /* get deviation from bin frequency from the +/- Pi interval */                          tmp = osamp*tmp/(2.0*Math.PI);                            /* compute the k-th partials' true frequency */                          tmp = (double) k*freqPerBin + tmp*freqPerBin;                            /* store magnitude and true frequency in analysis arrays */                          gAnaMagn[k] = (float) magn;                          gAnaFreq[k] = (float) tmp;                        }                        /* ***************** PROCESSING ******************* */                      /* this does the actual pitch shifting */                      for (int zero = 0; zero < fftFrameSize; zero++)                      {                          gSynMagn[zero] = 0;                          gSynFreq[zero] = 0;                      }                        for (k = 0; k <= fftFrameSize2; k++)                      {                          index = (long) (k*pitchShift);                          if (index <= fftFrameSize2)                          {                              gSynMagn[index] += gAnaMagn[k];                              gSynFreq[index] = gAnaFreq[k]*pitchShift;                          }                      }                        /* ***************** SYNTHESIS ******************* */                      /* this is the synthesis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* get magnitude and true frequency from synthesis arrays */                          magn = gSynMagn[k];                          tmp = gSynFreq[k];                            /* subtract bin mid frequency */                          tmp -= (double) k*freqPerBin;                            /* get bin deviation from freq deviation */                          tmp /= freqPerBin;                            /* take osamp into account */                          tmp = 2.0*Math.PI*tmp/osamp;                            /* add the overlap phase advance back in */                          tmp += (double) k*expct;                            /* accumulate delta phase to get bin phase */                          gSumPhase[k] += (float) tmp;                          phase = gSumPhase[k];                            /* get real and imag part and re-interleave */                          gFFTworksp[2*k] = (float) (magn*Math.Cos(phase));                          gFFTworksp[2*k + 1] = (float) (magn*Math.Sin(phase));                      }                        /* zero negative frequencies */                      for (k = fftFrameSize + 2; k < 2*fftFrameSize; k++) gFFTworksp[k] = 0.0F;                        /* do inverse transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' 1);                        /* do windowing and add to output accumulator */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gOutputAccum[k] += (float) (2.0*window*gFFTworksp[2*k]/(fftFrameSize2*osamp));                      }                      for (k = 0; k < stepSize; k++) gOutFIFO[k] = gOutputAccum[k];                        /* shift accumulator */                      //memmove(gOutputAccum' gOutputAccum + stepSize' fftFrameSize * sizeof(float));                      for (k = 0; k < fftFrameSize; k++)                      {                          gOutputAccum[k] = gOutputAccum[k + stepSize];                      }                        /* move input FIFO */                      for (k = 0; k < inFifoLatency; k++) gInFIFO[k] = gInFIFO[k + stepSize];                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: for (i = 0; i < numSampsToProcess; i++)              {                    /* As long as we have not yet collected enough data just read in */                  gInFIFO[gRover] = indata[i];                  outdata[i] = gOutFIFO[gRover - inFifoLatency];                  gRover++;                    /* now we have enough data for processing */                  if (gRover >= fftFrameSize)                  {                      gRover = inFifoLatency;                        /* do windowing and re'im interleave */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gFFTworksp[2*k] = (float) (gInFIFO[k]*window);                          gFFTworksp[2*k + 1] = 0.0F;                      }                          /* ***************** ANALYSIS ******************* */                      /* do transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' -1);                        /* this is the analysis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* de-interlace FFT buffer */                          real = gFFTworksp[2*k];                          imag = gFFTworksp[2*k + 1];                            /* compute magnitude and phase */                          magn = 2.0*Math.Sqrt(real*real + imag*imag);                          phase = Math.Atan2(imag' real);                            /* compute phase difference */                          tmp = phase - gLastPhase[k];                          gLastPhase[k] = (float) phase;                            /* subtract expected phase difference */                          tmp -= (double) k*expct;                            /* map delta phase into +/- Pi interval */                          qpd = (long) (tmp/Math.PI);                          if (qpd >= 0) qpd += qpd & 1;                          else qpd -= qpd & 1;                          tmp -= Math.PI*(double) qpd;                            /* get deviation from bin frequency from the +/- Pi interval */                          tmp = osamp*tmp/(2.0*Math.PI);                            /* compute the k-th partials' true frequency */                          tmp = (double) k*freqPerBin + tmp*freqPerBin;                            /* store magnitude and true frequency in analysis arrays */                          gAnaMagn[k] = (float) magn;                          gAnaFreq[k] = (float) tmp;                        }                        /* ***************** PROCESSING ******************* */                      /* this does the actual pitch shifting */                      for (int zero = 0; zero < fftFrameSize; zero++)                      {                          gSynMagn[zero] = 0;                          gSynFreq[zero] = 0;                      }                        for (k = 0; k <= fftFrameSize2; k++)                      {                          index = (long) (k*pitchShift);                          if (index <= fftFrameSize2)                          {                              gSynMagn[index] += gAnaMagn[k];                              gSynFreq[index] = gAnaFreq[k]*pitchShift;                          }                      }                        /* ***************** SYNTHESIS ******************* */                      /* this is the synthesis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* get magnitude and true frequency from synthesis arrays */                          magn = gSynMagn[k];                          tmp = gSynFreq[k];                            /* subtract bin mid frequency */                          tmp -= (double) k*freqPerBin;                            /* get bin deviation from freq deviation */                          tmp /= freqPerBin;                            /* take osamp into account */                          tmp = 2.0*Math.PI*tmp/osamp;                            /* add the overlap phase advance back in */                          tmp += (double) k*expct;                            /* accumulate delta phase to get bin phase */                          gSumPhase[k] += (float) tmp;                          phase = gSumPhase[k];                            /* get real and imag part and re-interleave */                          gFFTworksp[2*k] = (float) (magn*Math.Cos(phase));                          gFFTworksp[2*k + 1] = (float) (magn*Math.Sin(phase));                      }                        /* zero negative frequencies */                      for (k = fftFrameSize + 2; k < 2*fftFrameSize; k++) gFFTworksp[k] = 0.0F;                        /* do inverse transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' 1);                        /* do windowing and add to output accumulator */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gOutputAccum[k] += (float) (2.0*window*gFFTworksp[2*k]/(fftFrameSize2*osamp));                      }                      for (k = 0; k < stepSize; k++) gOutFIFO[k] = gOutputAccum[k];                        /* shift accumulator */                      //memmove(gOutputAccum' gOutputAccum + stepSize' fftFrameSize * sizeof(float));                      for (k = 0; k < fftFrameSize; k++)                      {                          gOutputAccum[k] = gOutputAccum[k + stepSize];                      }                        /* move input FIFO */                      for (k = 0; k < inFifoLatency; k++) gInFIFO[k] = gInFIFO[k + stepSize];                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: for (i = 0; i < numSampsToProcess; i++)              {                    /* As long as we have not yet collected enough data just read in */                  gInFIFO[gRover] = indata[i];                  outdata[i] = gOutFIFO[gRover - inFifoLatency];                  gRover++;                    /* now we have enough data for processing */                  if (gRover >= fftFrameSize)                  {                      gRover = inFifoLatency;                        /* do windowing and re'im interleave */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gFFTworksp[2*k] = (float) (gInFIFO[k]*window);                          gFFTworksp[2*k + 1] = 0.0F;                      }                          /* ***************** ANALYSIS ******************* */                      /* do transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' -1);                        /* this is the analysis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* de-interlace FFT buffer */                          real = gFFTworksp[2*k];                          imag = gFFTworksp[2*k + 1];                            /* compute magnitude and phase */                          magn = 2.0*Math.Sqrt(real*real + imag*imag);                          phase = Math.Atan2(imag' real);                            /* compute phase difference */                          tmp = phase - gLastPhase[k];                          gLastPhase[k] = (float) phase;                            /* subtract expected phase difference */                          tmp -= (double) k*expct;                            /* map delta phase into +/- Pi interval */                          qpd = (long) (tmp/Math.PI);                          if (qpd >= 0) qpd += qpd & 1;                          else qpd -= qpd & 1;                          tmp -= Math.PI*(double) qpd;                            /* get deviation from bin frequency from the +/- Pi interval */                          tmp = osamp*tmp/(2.0*Math.PI);                            /* compute the k-th partials' true frequency */                          tmp = (double) k*freqPerBin + tmp*freqPerBin;                            /* store magnitude and true frequency in analysis arrays */                          gAnaMagn[k] = (float) magn;                          gAnaFreq[k] = (float) tmp;                        }                        /* ***************** PROCESSING ******************* */                      /* this does the actual pitch shifting */                      for (int zero = 0; zero < fftFrameSize; zero++)                      {                          gSynMagn[zero] = 0;                          gSynFreq[zero] = 0;                      }                        for (k = 0; k <= fftFrameSize2; k++)                      {                          index = (long) (k*pitchShift);                          if (index <= fftFrameSize2)                          {                              gSynMagn[index] += gAnaMagn[k];                              gSynFreq[index] = gAnaFreq[k]*pitchShift;                          }                      }                        /* ***************** SYNTHESIS ******************* */                      /* this is the synthesis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* get magnitude and true frequency from synthesis arrays */                          magn = gSynMagn[k];                          tmp = gSynFreq[k];                            /* subtract bin mid frequency */                          tmp -= (double) k*freqPerBin;                            /* get bin deviation from freq deviation */                          tmp /= freqPerBin;                            /* take osamp into account */                          tmp = 2.0*Math.PI*tmp/osamp;                            /* add the overlap phase advance back in */                          tmp += (double) k*expct;                            /* accumulate delta phase to get bin phase */                          gSumPhase[k] += (float) tmp;                          phase = gSumPhase[k];                            /* get real and imag part and re-interleave */                          gFFTworksp[2*k] = (float) (magn*Math.Cos(phase));                          gFFTworksp[2*k + 1] = (float) (magn*Math.Sin(phase));                      }                        /* zero negative frequencies */                      for (k = fftFrameSize + 2; k < 2*fftFrameSize; k++) gFFTworksp[k] = 0.0F;                        /* do inverse transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' 1);                        /* do windowing and add to output accumulator */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gOutputAccum[k] += (float) (2.0*window*gFFTworksp[2*k]/(fftFrameSize2*osamp));                      }                      for (k = 0; k < stepSize; k++) gOutFIFO[k] = gOutputAccum[k];                        /* shift accumulator */                      //memmove(gOutputAccum' gOutputAccum + stepSize' fftFrameSize * sizeof(float));                      for (k = 0; k < fftFrameSize; k++)                      {                          gOutputAccum[k] = gOutputAccum[k + stepSize];                      }                        /* move input FIFO */                      for (k = 0; k < inFifoLatency; k++) gInFIFO[k] = gInFIFO[k + stepSize];                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: for (i = 0; i < numSampsToProcess; i++)              {                    /* As long as we have not yet collected enough data just read in */                  gInFIFO[gRover] = indata[i];                  outdata[i] = gOutFIFO[gRover - inFifoLatency];                  gRover++;                    /* now we have enough data for processing */                  if (gRover >= fftFrameSize)                  {                      gRover = inFifoLatency;                        /* do windowing and re'im interleave */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gFFTworksp[2*k] = (float) (gInFIFO[k]*window);                          gFFTworksp[2*k + 1] = 0.0F;                      }                          /* ***************** ANALYSIS ******************* */                      /* do transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' -1);                        /* this is the analysis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* de-interlace FFT buffer */                          real = gFFTworksp[2*k];                          imag = gFFTworksp[2*k + 1];                            /* compute magnitude and phase */                          magn = 2.0*Math.Sqrt(real*real + imag*imag);                          phase = Math.Atan2(imag' real);                            /* compute phase difference */                          tmp = phase - gLastPhase[k];                          gLastPhase[k] = (float) phase;                            /* subtract expected phase difference */                          tmp -= (double) k*expct;                            /* map delta phase into +/- Pi interval */                          qpd = (long) (tmp/Math.PI);                          if (qpd >= 0) qpd += qpd & 1;                          else qpd -= qpd & 1;                          tmp -= Math.PI*(double) qpd;                            /* get deviation from bin frequency from the +/- Pi interval */                          tmp = osamp*tmp/(2.0*Math.PI);                            /* compute the k-th partials' true frequency */                          tmp = (double) k*freqPerBin + tmp*freqPerBin;                            /* store magnitude and true frequency in analysis arrays */                          gAnaMagn[k] = (float) magn;                          gAnaFreq[k] = (float) tmp;                        }                        /* ***************** PROCESSING ******************* */                      /* this does the actual pitch shifting */                      for (int zero = 0; zero < fftFrameSize; zero++)                      {                          gSynMagn[zero] = 0;                          gSynFreq[zero] = 0;                      }                        for (k = 0; k <= fftFrameSize2; k++)                      {                          index = (long) (k*pitchShift);                          if (index <= fftFrameSize2)                          {                              gSynMagn[index] += gAnaMagn[k];                              gSynFreq[index] = gAnaFreq[k]*pitchShift;                          }                      }                        /* ***************** SYNTHESIS ******************* */                      /* this is the synthesis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* get magnitude and true frequency from synthesis arrays */                          magn = gSynMagn[k];                          tmp = gSynFreq[k];                            /* subtract bin mid frequency */                          tmp -= (double) k*freqPerBin;                            /* get bin deviation from freq deviation */                          tmp /= freqPerBin;                            /* take osamp into account */                          tmp = 2.0*Math.PI*tmp/osamp;                            /* add the overlap phase advance back in */                          tmp += (double) k*expct;                            /* accumulate delta phase to get bin phase */                          gSumPhase[k] += (float) tmp;                          phase = gSumPhase[k];                            /* get real and imag part and re-interleave */                          gFFTworksp[2*k] = (float) (magn*Math.Cos(phase));                          gFFTworksp[2*k + 1] = (float) (magn*Math.Sin(phase));                      }                        /* zero negative frequencies */                      for (k = fftFrameSize + 2; k < 2*fftFrameSize; k++) gFFTworksp[k] = 0.0F;                        /* do inverse transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' 1);                        /* do windowing and add to output accumulator */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gOutputAccum[k] += (float) (2.0*window*gFFTworksp[2*k]/(fftFrameSize2*osamp));                      }                      for (k = 0; k < stepSize; k++) gOutFIFO[k] = gOutputAccum[k];                        /* shift accumulator */                      //memmove(gOutputAccum' gOutputAccum + stepSize' fftFrameSize * sizeof(float));                      for (k = 0; k < fftFrameSize; k++)                      {                          gOutputAccum[k] = gOutputAccum[k + stepSize];                      }                        /* move input FIFO */                      for (k = 0; k < inFifoLatency; k++) gInFIFO[k] = gInFIFO[k + stepSize];                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: for (i = 0; i < numSampsToProcess; i++)              {                    /* As long as we have not yet collected enough data just read in */                  gInFIFO[gRover] = indata[i];                  outdata[i] = gOutFIFO[gRover - inFifoLatency];                  gRover++;                    /* now we have enough data for processing */                  if (gRover >= fftFrameSize)                  {                      gRover = inFifoLatency;                        /* do windowing and re'im interleave */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gFFTworksp[2*k] = (float) (gInFIFO[k]*window);                          gFFTworksp[2*k + 1] = 0.0F;                      }                          /* ***************** ANALYSIS ******************* */                      /* do transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' -1);                        /* this is the analysis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* de-interlace FFT buffer */                          real = gFFTworksp[2*k];                          imag = gFFTworksp[2*k + 1];                            /* compute magnitude and phase */                          magn = 2.0*Math.Sqrt(real*real + imag*imag);                          phase = Math.Atan2(imag' real);                            /* compute phase difference */                          tmp = phase - gLastPhase[k];                          gLastPhase[k] = (float) phase;                            /* subtract expected phase difference */                          tmp -= (double) k*expct;                            /* map delta phase into +/- Pi interval */                          qpd = (long) (tmp/Math.PI);                          if (qpd >= 0) qpd += qpd & 1;                          else qpd -= qpd & 1;                          tmp -= Math.PI*(double) qpd;                            /* get deviation from bin frequency from the +/- Pi interval */                          tmp = osamp*tmp/(2.0*Math.PI);                            /* compute the k-th partials' true frequency */                          tmp = (double) k*freqPerBin + tmp*freqPerBin;                            /* store magnitude and true frequency in analysis arrays */                          gAnaMagn[k] = (float) magn;                          gAnaFreq[k] = (float) tmp;                        }                        /* ***************** PROCESSING ******************* */                      /* this does the actual pitch shifting */                      for (int zero = 0; zero < fftFrameSize; zero++)                      {                          gSynMagn[zero] = 0;                          gSynFreq[zero] = 0;                      }                        for (k = 0; k <= fftFrameSize2; k++)                      {                          index = (long) (k*pitchShift);                          if (index <= fftFrameSize2)                          {                              gSynMagn[index] += gAnaMagn[k];                              gSynFreq[index] = gAnaFreq[k]*pitchShift;                          }                      }                        /* ***************** SYNTHESIS ******************* */                      /* this is the synthesis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* get magnitude and true frequency from synthesis arrays */                          magn = gSynMagn[k];                          tmp = gSynFreq[k];                            /* subtract bin mid frequency */                          tmp -= (double) k*freqPerBin;                            /* get bin deviation from freq deviation */                          tmp /= freqPerBin;                            /* take osamp into account */                          tmp = 2.0*Math.PI*tmp/osamp;                            /* add the overlap phase advance back in */                          tmp += (double) k*expct;                            /* accumulate delta phase to get bin phase */                          gSumPhase[k] += (float) tmp;                          phase = gSumPhase[k];                            /* get real and imag part and re-interleave */                          gFFTworksp[2*k] = (float) (magn*Math.Cos(phase));                          gFFTworksp[2*k + 1] = (float) (magn*Math.Sin(phase));                      }                        /* zero negative frequencies */                      for (k = fftFrameSize + 2; k < 2*fftFrameSize; k++) gFFTworksp[k] = 0.0F;                        /* do inverse transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' 1);                        /* do windowing and add to output accumulator */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gOutputAccum[k] += (float) (2.0*window*gFFTworksp[2*k]/(fftFrameSize2*osamp));                      }                      for (k = 0; k < stepSize; k++) gOutFIFO[k] = gOutputAccum[k];                        /* shift accumulator */                      //memmove(gOutputAccum' gOutputAccum + stepSize' fftFrameSize * sizeof(float));                      for (k = 0; k < fftFrameSize; k++)                      {                          gOutputAccum[k] = gOutputAccum[k + stepSize];                      }                        /* move input FIFO */                      for (k = 0; k < inFifoLatency; k++) gInFIFO[k] = gInFIFO[k + stepSize];                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: for (i = 0; i < numSampsToProcess; i++)              {                    /* As long as we have not yet collected enough data just read in */                  gInFIFO[gRover] = indata[i];                  outdata[i] = gOutFIFO[gRover - inFifoLatency];                  gRover++;                    /* now we have enough data for processing */                  if (gRover >= fftFrameSize)                  {                      gRover = inFifoLatency;                        /* do windowing and re'im interleave */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gFFTworksp[2*k] = (float) (gInFIFO[k]*window);                          gFFTworksp[2*k + 1] = 0.0F;                      }                          /* ***************** ANALYSIS ******************* */                      /* do transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' -1);                        /* this is the analysis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* de-interlace FFT buffer */                          real = gFFTworksp[2*k];                          imag = gFFTworksp[2*k + 1];                            /* compute magnitude and phase */                          magn = 2.0*Math.Sqrt(real*real + imag*imag);                          phase = Math.Atan2(imag' real);                            /* compute phase difference */                          tmp = phase - gLastPhase[k];                          gLastPhase[k] = (float) phase;                            /* subtract expected phase difference */                          tmp -= (double) k*expct;                            /* map delta phase into +/- Pi interval */                          qpd = (long) (tmp/Math.PI);                          if (qpd >= 0) qpd += qpd & 1;                          else qpd -= qpd & 1;                          tmp -= Math.PI*(double) qpd;                            /* get deviation from bin frequency from the +/- Pi interval */                          tmp = osamp*tmp/(2.0*Math.PI);                            /* compute the k-th partials' true frequency */                          tmp = (double) k*freqPerBin + tmp*freqPerBin;                            /* store magnitude and true frequency in analysis arrays */                          gAnaMagn[k] = (float) magn;                          gAnaFreq[k] = (float) tmp;                        }                        /* ***************** PROCESSING ******************* */                      /* this does the actual pitch shifting */                      for (int zero = 0; zero < fftFrameSize; zero++)                      {                          gSynMagn[zero] = 0;                          gSynFreq[zero] = 0;                      }                        for (k = 0; k <= fftFrameSize2; k++)                      {                          index = (long) (k*pitchShift);                          if (index <= fftFrameSize2)                          {                              gSynMagn[index] += gAnaMagn[k];                              gSynFreq[index] = gAnaFreq[k]*pitchShift;                          }                      }                        /* ***************** SYNTHESIS ******************* */                      /* this is the synthesis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* get magnitude and true frequency from synthesis arrays */                          magn = gSynMagn[k];                          tmp = gSynFreq[k];                            /* subtract bin mid frequency */                          tmp -= (double) k*freqPerBin;                            /* get bin deviation from freq deviation */                          tmp /= freqPerBin;                            /* take osamp into account */                          tmp = 2.0*Math.PI*tmp/osamp;                            /* add the overlap phase advance back in */                          tmp += (double) k*expct;                            /* accumulate delta phase to get bin phase */                          gSumPhase[k] += (float) tmp;                          phase = gSumPhase[k];                            /* get real and imag part and re-interleave */                          gFFTworksp[2*k] = (float) (magn*Math.Cos(phase));                          gFFTworksp[2*k + 1] = (float) (magn*Math.Sin(phase));                      }                        /* zero negative frequencies */                      for (k = fftFrameSize + 2; k < 2*fftFrameSize; k++) gFFTworksp[k] = 0.0F;                        /* do inverse transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' 1);                        /* do windowing and add to output accumulator */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gOutputAccum[k] += (float) (2.0*window*gFFTworksp[2*k]/(fftFrameSize2*osamp));                      }                      for (k = 0; k < stepSize; k++) gOutFIFO[k] = gOutputAccum[k];                        /* shift accumulator */                      //memmove(gOutputAccum' gOutputAccum + stepSize' fftFrameSize * sizeof(float));                      for (k = 0; k < fftFrameSize; k++)                      {                          gOutputAccum[k] = gOutputAccum[k + stepSize];                      }                        /* move input FIFO */                      for (k = 0; k < inFifoLatency; k++) gInFIFO[k] = gInFIFO[k + stepSize];                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: for (i = 0; i < numSampsToProcess; i++)              {                    /* As long as we have not yet collected enough data just read in */                  gInFIFO[gRover] = indata[i];                  outdata[i] = gOutFIFO[gRover - inFifoLatency];                  gRover++;                    /* now we have enough data for processing */                  if (gRover >= fftFrameSize)                  {                      gRover = inFifoLatency;                        /* do windowing and re'im interleave */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gFFTworksp[2*k] = (float) (gInFIFO[k]*window);                          gFFTworksp[2*k + 1] = 0.0F;                      }                          /* ***************** ANALYSIS ******************* */                      /* do transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' -1);                        /* this is the analysis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* de-interlace FFT buffer */                          real = gFFTworksp[2*k];                          imag = gFFTworksp[2*k + 1];                            /* compute magnitude and phase */                          magn = 2.0*Math.Sqrt(real*real + imag*imag);                          phase = Math.Atan2(imag' real);                            /* compute phase difference */                          tmp = phase - gLastPhase[k];                          gLastPhase[k] = (float) phase;                            /* subtract expected phase difference */                          tmp -= (double) k*expct;                            /* map delta phase into +/- Pi interval */                          qpd = (long) (tmp/Math.PI);                          if (qpd >= 0) qpd += qpd & 1;                          else qpd -= qpd & 1;                          tmp -= Math.PI*(double) qpd;                            /* get deviation from bin frequency from the +/- Pi interval */                          tmp = osamp*tmp/(2.0*Math.PI);                            /* compute the k-th partials' true frequency */                          tmp = (double) k*freqPerBin + tmp*freqPerBin;                            /* store magnitude and true frequency in analysis arrays */                          gAnaMagn[k] = (float) magn;                          gAnaFreq[k] = (float) tmp;                        }                        /* ***************** PROCESSING ******************* */                      /* this does the actual pitch shifting */                      for (int zero = 0; zero < fftFrameSize; zero++)                      {                          gSynMagn[zero] = 0;                          gSynFreq[zero] = 0;                      }                        for (k = 0; k <= fftFrameSize2; k++)                      {                          index = (long) (k*pitchShift);                          if (index <= fftFrameSize2)                          {                              gSynMagn[index] += gAnaMagn[k];                              gSynFreq[index] = gAnaFreq[k]*pitchShift;                          }                      }                        /* ***************** SYNTHESIS ******************* */                      /* this is the synthesis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* get magnitude and true frequency from synthesis arrays */                          magn = gSynMagn[k];                          tmp = gSynFreq[k];                            /* subtract bin mid frequency */                          tmp -= (double) k*freqPerBin;                            /* get bin deviation from freq deviation */                          tmp /= freqPerBin;                            /* take osamp into account */                          tmp = 2.0*Math.PI*tmp/osamp;                            /* add the overlap phase advance back in */                          tmp += (double) k*expct;                            /* accumulate delta phase to get bin phase */                          gSumPhase[k] += (float) tmp;                          phase = gSumPhase[k];                            /* get real and imag part and re-interleave */                          gFFTworksp[2*k] = (float) (magn*Math.Cos(phase));                          gFFTworksp[2*k + 1] = (float) (magn*Math.Sin(phase));                      }                        /* zero negative frequencies */                      for (k = fftFrameSize + 2; k < 2*fftFrameSize; k++) gFFTworksp[k] = 0.0F;                        /* do inverse transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' 1);                        /* do windowing and add to output accumulator */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gOutputAccum[k] += (float) (2.0*window*gFFTworksp[2*k]/(fftFrameSize2*osamp));                      }                      for (k = 0; k < stepSize; k++) gOutFIFO[k] = gOutputAccum[k];                        /* shift accumulator */                      //memmove(gOutputAccum' gOutputAccum + stepSize' fftFrameSize * sizeof(float));                      for (k = 0; k < fftFrameSize; k++)                      {                          gOutputAccum[k] = gOutputAccum[k + stepSize];                      }                        /* move input FIFO */                      for (k = 0; k < inFifoLatency; k++) gInFIFO[k] = gInFIFO[k + stepSize];                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: for (i = 0; i < numSampsToProcess; i++)              {                    /* As long as we have not yet collected enough data just read in */                  gInFIFO[gRover] = indata[i];                  outdata[i] = gOutFIFO[gRover - inFifoLatency];                  gRover++;                    /* now we have enough data for processing */                  if (gRover >= fftFrameSize)                  {                      gRover = inFifoLatency;                        /* do windowing and re'im interleave */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gFFTworksp[2*k] = (float) (gInFIFO[k]*window);                          gFFTworksp[2*k + 1] = 0.0F;                      }                          /* ***************** ANALYSIS ******************* */                      /* do transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' -1);                        /* this is the analysis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* de-interlace FFT buffer */                          real = gFFTworksp[2*k];                          imag = gFFTworksp[2*k + 1];                            /* compute magnitude and phase */                          magn = 2.0*Math.Sqrt(real*real + imag*imag);                          phase = Math.Atan2(imag' real);                            /* compute phase difference */                          tmp = phase - gLastPhase[k];                          gLastPhase[k] = (float) phase;                            /* subtract expected phase difference */                          tmp -= (double) k*expct;                            /* map delta phase into +/- Pi interval */                          qpd = (long) (tmp/Math.PI);                          if (qpd >= 0) qpd += qpd & 1;                          else qpd -= qpd & 1;                          tmp -= Math.PI*(double) qpd;                            /* get deviation from bin frequency from the +/- Pi interval */                          tmp = osamp*tmp/(2.0*Math.PI);                            /* compute the k-th partials' true frequency */                          tmp = (double) k*freqPerBin + tmp*freqPerBin;                            /* store magnitude and true frequency in analysis arrays */                          gAnaMagn[k] = (float) magn;                          gAnaFreq[k] = (float) tmp;                        }                        /* ***************** PROCESSING ******************* */                      /* this does the actual pitch shifting */                      for (int zero = 0; zero < fftFrameSize; zero++)                      {                          gSynMagn[zero] = 0;                          gSynFreq[zero] = 0;                      }                        for (k = 0; k <= fftFrameSize2; k++)                      {                          index = (long) (k*pitchShift);                          if (index <= fftFrameSize2)                          {                              gSynMagn[index] += gAnaMagn[k];                              gSynFreq[index] = gAnaFreq[k]*pitchShift;                          }                      }                        /* ***************** SYNTHESIS ******************* */                      /* this is the synthesis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* get magnitude and true frequency from synthesis arrays */                          magn = gSynMagn[k];                          tmp = gSynFreq[k];                            /* subtract bin mid frequency */                          tmp -= (double) k*freqPerBin;                            /* get bin deviation from freq deviation */                          tmp /= freqPerBin;                            /* take osamp into account */                          tmp = 2.0*Math.PI*tmp/osamp;                            /* add the overlap phase advance back in */                          tmp += (double) k*expct;                            /* accumulate delta phase to get bin phase */                          gSumPhase[k] += (float) tmp;                          phase = gSumPhase[k];                            /* get real and imag part and re-interleave */                          gFFTworksp[2*k] = (float) (magn*Math.Cos(phase));                          gFFTworksp[2*k + 1] = (float) (magn*Math.Sin(phase));                      }                        /* zero negative frequencies */                      for (k = fftFrameSize + 2; k < 2*fftFrameSize; k++) gFFTworksp[k] = 0.0F;                        /* do inverse transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' 1);                        /* do windowing and add to output accumulator */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gOutputAccum[k] += (float) (2.0*window*gFFTworksp[2*k]/(fftFrameSize2*osamp));                      }                      for (k = 0; k < stepSize; k++) gOutFIFO[k] = gOutputAccum[k];                        /* shift accumulator */                      //memmove(gOutputAccum' gOutputAccum + stepSize' fftFrameSize * sizeof(float));                      for (k = 0; k < fftFrameSize; k++)                      {                          gOutputAccum[k] = gOutputAccum[k + stepSize];                      }                        /* move input FIFO */                      for (k = 0; k < inFifoLatency; k++) gInFIFO[k] = gInFIFO[k + stepSize];                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: for (i = 0; i < numSampsToProcess; i++)              {                    /* As long as we have not yet collected enough data just read in */                  gInFIFO[gRover] = indata[i];                  outdata[i] = gOutFIFO[gRover - inFifoLatency];                  gRover++;                    /* now we have enough data for processing */                  if (gRover >= fftFrameSize)                  {                      gRover = inFifoLatency;                        /* do windowing and re'im interleave */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gFFTworksp[2*k] = (float) (gInFIFO[k]*window);                          gFFTworksp[2*k + 1] = 0.0F;                      }                          /* ***************** ANALYSIS ******************* */                      /* do transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' -1);                        /* this is the analysis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* de-interlace FFT buffer */                          real = gFFTworksp[2*k];                          imag = gFFTworksp[2*k + 1];                            /* compute magnitude and phase */                          magn = 2.0*Math.Sqrt(real*real + imag*imag);                          phase = Math.Atan2(imag' real);                            /* compute phase difference */                          tmp = phase - gLastPhase[k];                          gLastPhase[k] = (float) phase;                            /* subtract expected phase difference */                          tmp -= (double) k*expct;                            /* map delta phase into +/- Pi interval */                          qpd = (long) (tmp/Math.PI);                          if (qpd >= 0) qpd += qpd & 1;                          else qpd -= qpd & 1;                          tmp -= Math.PI*(double) qpd;                            /* get deviation from bin frequency from the +/- Pi interval */                          tmp = osamp*tmp/(2.0*Math.PI);                            /* compute the k-th partials' true frequency */                          tmp = (double) k*freqPerBin + tmp*freqPerBin;                            /* store magnitude and true frequency in analysis arrays */                          gAnaMagn[k] = (float) magn;                          gAnaFreq[k] = (float) tmp;                        }                        /* ***************** PROCESSING ******************* */                      /* this does the actual pitch shifting */                      for (int zero = 0; zero < fftFrameSize; zero++)                      {                          gSynMagn[zero] = 0;                          gSynFreq[zero] = 0;                      }                        for (k = 0; k <= fftFrameSize2; k++)                      {                          index = (long) (k*pitchShift);                          if (index <= fftFrameSize2)                          {                              gSynMagn[index] += gAnaMagn[k];                              gSynFreq[index] = gAnaFreq[k]*pitchShift;                          }                      }                        /* ***************** SYNTHESIS ******************* */                      /* this is the synthesis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* get magnitude and true frequency from synthesis arrays */                          magn = gSynMagn[k];                          tmp = gSynFreq[k];                            /* subtract bin mid frequency */                          tmp -= (double) k*freqPerBin;                            /* get bin deviation from freq deviation */                          tmp /= freqPerBin;                            /* take osamp into account */                          tmp = 2.0*Math.PI*tmp/osamp;                            /* add the overlap phase advance back in */                          tmp += (double) k*expct;                            /* accumulate delta phase to get bin phase */                          gSumPhase[k] += (float) tmp;                          phase = gSumPhase[k];                            /* get real and imag part and re-interleave */                          gFFTworksp[2*k] = (float) (magn*Math.Cos(phase));                          gFFTworksp[2*k + 1] = (float) (magn*Math.Sin(phase));                      }                        /* zero negative frequencies */                      for (k = fftFrameSize + 2; k < 2*fftFrameSize; k++) gFFTworksp[k] = 0.0F;                        /* do inverse transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' 1);                        /* do windowing and add to output accumulator */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gOutputAccum[k] += (float) (2.0*window*gFFTworksp[2*k]/(fftFrameSize2*osamp));                      }                      for (k = 0; k < stepSize; k++) gOutFIFO[k] = gOutputAccum[k];                        /* shift accumulator */                      //memmove(gOutputAccum' gOutputAccum + stepSize' fftFrameSize * sizeof(float));                      for (k = 0; k < fftFrameSize; k++)                      {                          gOutputAccum[k] = gOutputAccum[k + stepSize];                      }                        /* move input FIFO */                      for (k = 0; k < inFifoLatency; k++) gInFIFO[k] = gInFIFO[k + stepSize];                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: for (i = 0; i < numSampsToProcess; i++)              {                    /* As long as we have not yet collected enough data just read in */                  gInFIFO[gRover] = indata[i];                  outdata[i] = gOutFIFO[gRover - inFifoLatency];                  gRover++;                    /* now we have enough data for processing */                  if (gRover >= fftFrameSize)                  {                      gRover = inFifoLatency;                        /* do windowing and re'im interleave */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gFFTworksp[2*k] = (float) (gInFIFO[k]*window);                          gFFTworksp[2*k + 1] = 0.0F;                      }                          /* ***************** ANALYSIS ******************* */                      /* do transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' -1);                        /* this is the analysis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* de-interlace FFT buffer */                          real = gFFTworksp[2*k];                          imag = gFFTworksp[2*k + 1];                            /* compute magnitude and phase */                          magn = 2.0*Math.Sqrt(real*real + imag*imag);                          phase = Math.Atan2(imag' real);                            /* compute phase difference */                          tmp = phase - gLastPhase[k];                          gLastPhase[k] = (float) phase;                            /* subtract expected phase difference */                          tmp -= (double) k*expct;                            /* map delta phase into +/- Pi interval */                          qpd = (long) (tmp/Math.PI);                          if (qpd >= 0) qpd += qpd & 1;                          else qpd -= qpd & 1;                          tmp -= Math.PI*(double) qpd;                            /* get deviation from bin frequency from the +/- Pi interval */                          tmp = osamp*tmp/(2.0*Math.PI);                            /* compute the k-th partials' true frequency */                          tmp = (double) k*freqPerBin + tmp*freqPerBin;                            /* store magnitude and true frequency in analysis arrays */                          gAnaMagn[k] = (float) magn;                          gAnaFreq[k] = (float) tmp;                        }                        /* ***************** PROCESSING ******************* */                      /* this does the actual pitch shifting */                      for (int zero = 0; zero < fftFrameSize; zero++)                      {                          gSynMagn[zero] = 0;                          gSynFreq[zero] = 0;                      }                        for (k = 0; k <= fftFrameSize2; k++)                      {                          index = (long) (k*pitchShift);                          if (index <= fftFrameSize2)                          {                              gSynMagn[index] += gAnaMagn[k];                              gSynFreq[index] = gAnaFreq[k]*pitchShift;                          }                      }                        /* ***************** SYNTHESIS ******************* */                      /* this is the synthesis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* get magnitude and true frequency from synthesis arrays */                          magn = gSynMagn[k];                          tmp = gSynFreq[k];                            /* subtract bin mid frequency */                          tmp -= (double) k*freqPerBin;                            /* get bin deviation from freq deviation */                          tmp /= freqPerBin;                            /* take osamp into account */                          tmp = 2.0*Math.PI*tmp/osamp;                            /* add the overlap phase advance back in */                          tmp += (double) k*expct;                            /* accumulate delta phase to get bin phase */                          gSumPhase[k] += (float) tmp;                          phase = gSumPhase[k];                            /* get real and imag part and re-interleave */                          gFFTworksp[2*k] = (float) (magn*Math.Cos(phase));                          gFFTworksp[2*k + 1] = (float) (magn*Math.Sin(phase));                      }                        /* zero negative frequencies */                      for (k = fftFrameSize + 2; k < 2*fftFrameSize; k++) gFFTworksp[k] = 0.0F;                        /* do inverse transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' 1);                        /* do windowing and add to output accumulator */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gOutputAccum[k] += (float) (2.0*window*gFFTworksp[2*k]/(fftFrameSize2*osamp));                      }                      for (k = 0; k < stepSize; k++) gOutFIFO[k] = gOutputAccum[k];                        /* shift accumulator */                      //memmove(gOutputAccum' gOutputAccum + stepSize' fftFrameSize * sizeof(float));                      for (k = 0; k < fftFrameSize; k++)                      {                          gOutputAccum[k] = gOutputAccum[k + stepSize];                      }                        /* move input FIFO */                      for (k = 0; k < inFifoLatency; k++) gInFIFO[k] = gInFIFO[k + stepSize];                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: for (i = 0; i < numSampsToProcess; i++)              {                    /* As long as we have not yet collected enough data just read in */                  gInFIFO[gRover] = indata[i];                  outdata[i] = gOutFIFO[gRover - inFifoLatency];                  gRover++;                    /* now we have enough data for processing */                  if (gRover >= fftFrameSize)                  {                      gRover = inFifoLatency;                        /* do windowing and re'im interleave */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gFFTworksp[2*k] = (float) (gInFIFO[k]*window);                          gFFTworksp[2*k + 1] = 0.0F;                      }                          /* ***************** ANALYSIS ******************* */                      /* do transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' -1);                        /* this is the analysis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* de-interlace FFT buffer */                          real = gFFTworksp[2*k];                          imag = gFFTworksp[2*k + 1];                            /* compute magnitude and phase */                          magn = 2.0*Math.Sqrt(real*real + imag*imag);                          phase = Math.Atan2(imag' real);                            /* compute phase difference */                          tmp = phase - gLastPhase[k];                          gLastPhase[k] = (float) phase;                            /* subtract expected phase difference */                          tmp -= (double) k*expct;                            /* map delta phase into +/- Pi interval */                          qpd = (long) (tmp/Math.PI);                          if (qpd >= 0) qpd += qpd & 1;                          else qpd -= qpd & 1;                          tmp -= Math.PI*(double) qpd;                            /* get deviation from bin frequency from the +/- Pi interval */                          tmp = osamp*tmp/(2.0*Math.PI);                            /* compute the k-th partials' true frequency */                          tmp = (double) k*freqPerBin + tmp*freqPerBin;                            /* store magnitude and true frequency in analysis arrays */                          gAnaMagn[k] = (float) magn;                          gAnaFreq[k] = (float) tmp;                        }                        /* ***************** PROCESSING ******************* */                      /* this does the actual pitch shifting */                      for (int zero = 0; zero < fftFrameSize; zero++)                      {                          gSynMagn[zero] = 0;                          gSynFreq[zero] = 0;                      }                        for (k = 0; k <= fftFrameSize2; k++)                      {                          index = (long) (k*pitchShift);                          if (index <= fftFrameSize2)                          {                              gSynMagn[index] += gAnaMagn[k];                              gSynFreq[index] = gAnaFreq[k]*pitchShift;                          }                      }                        /* ***************** SYNTHESIS ******************* */                      /* this is the synthesis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* get magnitude and true frequency from synthesis arrays */                          magn = gSynMagn[k];                          tmp = gSynFreq[k];                            /* subtract bin mid frequency */                          tmp -= (double) k*freqPerBin;                            /* get bin deviation from freq deviation */                          tmp /= freqPerBin;                            /* take osamp into account */                          tmp = 2.0*Math.PI*tmp/osamp;                            /* add the overlap phase advance back in */                          tmp += (double) k*expct;                            /* accumulate delta phase to get bin phase */                          gSumPhase[k] += (float) tmp;                          phase = gSumPhase[k];                            /* get real and imag part and re-interleave */                          gFFTworksp[2*k] = (float) (magn*Math.Cos(phase));                          gFFTworksp[2*k + 1] = (float) (magn*Math.Sin(phase));                      }                        /* zero negative frequencies */                      for (k = fftFrameSize + 2; k < 2*fftFrameSize; k++) gFFTworksp[k] = 0.0F;                        /* do inverse transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' 1);                        /* do windowing and add to output accumulator */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gOutputAccum[k] += (float) (2.0*window*gFFTworksp[2*k]/(fftFrameSize2*osamp));                      }                      for (k = 0; k < stepSize; k++) gOutFIFO[k] = gOutputAccum[k];                        /* shift accumulator */                      //memmove(gOutputAccum' gOutputAccum + stepSize' fftFrameSize * sizeof(float));                      for (k = 0; k < fftFrameSize; k++)                      {                          gOutputAccum[k] = gOutputAccum[k + stepSize];                      }                        /* move input FIFO */                      for (k = 0; k < inFifoLatency; k++) gInFIFO[k] = gInFIFO[k + stepSize];                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: for (i = 0; i < numSampsToProcess; i++)              {                    /* As long as we have not yet collected enough data just read in */                  gInFIFO[gRover] = indata[i];                  outdata[i] = gOutFIFO[gRover - inFifoLatency];                  gRover++;                    /* now we have enough data for processing */                  if (gRover >= fftFrameSize)                  {                      gRover = inFifoLatency;                        /* do windowing and re'im interleave */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gFFTworksp[2*k] = (float) (gInFIFO[k]*window);                          gFFTworksp[2*k + 1] = 0.0F;                      }                          /* ***************** ANALYSIS ******************* */                      /* do transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' -1);                        /* this is the analysis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* de-interlace FFT buffer */                          real = gFFTworksp[2*k];                          imag = gFFTworksp[2*k + 1];                            /* compute magnitude and phase */                          magn = 2.0*Math.Sqrt(real*real + imag*imag);                          phase = Math.Atan2(imag' real);                            /* compute phase difference */                          tmp = phase - gLastPhase[k];                          gLastPhase[k] = (float) phase;                            /* subtract expected phase difference */                          tmp -= (double) k*expct;                            /* map delta phase into +/- Pi interval */                          qpd = (long) (tmp/Math.PI);                          if (qpd >= 0) qpd += qpd & 1;                          else qpd -= qpd & 1;                          tmp -= Math.PI*(double) qpd;                            /* get deviation from bin frequency from the +/- Pi interval */                          tmp = osamp*tmp/(2.0*Math.PI);                            /* compute the k-th partials' true frequency */                          tmp = (double) k*freqPerBin + tmp*freqPerBin;                            /* store magnitude and true frequency in analysis arrays */                          gAnaMagn[k] = (float) magn;                          gAnaFreq[k] = (float) tmp;                        }                        /* ***************** PROCESSING ******************* */                      /* this does the actual pitch shifting */                      for (int zero = 0; zero < fftFrameSize; zero++)                      {                          gSynMagn[zero] = 0;                          gSynFreq[zero] = 0;                      }                        for (k = 0; k <= fftFrameSize2; k++)                      {                          index = (long) (k*pitchShift);                          if (index <= fftFrameSize2)                          {                              gSynMagn[index] += gAnaMagn[k];                              gSynFreq[index] = gAnaFreq[k]*pitchShift;                          }                      }                        /* ***************** SYNTHESIS ******************* */                      /* this is the synthesis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* get magnitude and true frequency from synthesis arrays */                          magn = gSynMagn[k];                          tmp = gSynFreq[k];                            /* subtract bin mid frequency */                          tmp -= (double) k*freqPerBin;                            /* get bin deviation from freq deviation */                          tmp /= freqPerBin;                            /* take osamp into account */                          tmp = 2.0*Math.PI*tmp/osamp;                            /* add the overlap phase advance back in */                          tmp += (double) k*expct;                            /* accumulate delta phase to get bin phase */                          gSumPhase[k] += (float) tmp;                          phase = gSumPhase[k];                            /* get real and imag part and re-interleave */                          gFFTworksp[2*k] = (float) (magn*Math.Cos(phase));                          gFFTworksp[2*k + 1] = (float) (magn*Math.Sin(phase));                      }                        /* zero negative frequencies */                      for (k = fftFrameSize + 2; k < 2*fftFrameSize; k++) gFFTworksp[k] = 0.0F;                        /* do inverse transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' 1);                        /* do windowing and add to output accumulator */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gOutputAccum[k] += (float) (2.0*window*gFFTworksp[2*k]/(fftFrameSize2*osamp));                      }                      for (k = 0; k < stepSize; k++) gOutFIFO[k] = gOutputAccum[k];                        /* shift accumulator */                      //memmove(gOutputAccum' gOutputAccum + stepSize' fftFrameSize * sizeof(float));                      for (k = 0; k < fftFrameSize; k++)                      {                          gOutputAccum[k] = gOutputAccum[k + stepSize];                      }                        /* move input FIFO */                      for (k = 0; k < inFifoLatency; k++) gInFIFO[k] = gInFIFO[k + stepSize];                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: for (i = 0; i < numSampsToProcess; i++)              {                    /* As long as we have not yet collected enough data just read in */                  gInFIFO[gRover] = indata[i];                  outdata[i] = gOutFIFO[gRover - inFifoLatency];                  gRover++;                    /* now we have enough data for processing */                  if (gRover >= fftFrameSize)                  {                      gRover = inFifoLatency;                        /* do windowing and re'im interleave */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gFFTworksp[2*k] = (float) (gInFIFO[k]*window);                          gFFTworksp[2*k + 1] = 0.0F;                      }                          /* ***************** ANALYSIS ******************* */                      /* do transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' -1);                        /* this is the analysis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* de-interlace FFT buffer */                          real = gFFTworksp[2*k];                          imag = gFFTworksp[2*k + 1];                            /* compute magnitude and phase */                          magn = 2.0*Math.Sqrt(real*real + imag*imag);                          phase = Math.Atan2(imag' real);                            /* compute phase difference */                          tmp = phase - gLastPhase[k];                          gLastPhase[k] = (float) phase;                            /* subtract expected phase difference */                          tmp -= (double) k*expct;                            /* map delta phase into +/- Pi interval */                          qpd = (long) (tmp/Math.PI);                          if (qpd >= 0) qpd += qpd & 1;                          else qpd -= qpd & 1;                          tmp -= Math.PI*(double) qpd;                            /* get deviation from bin frequency from the +/- Pi interval */                          tmp = osamp*tmp/(2.0*Math.PI);                            /* compute the k-th partials' true frequency */                          tmp = (double) k*freqPerBin + tmp*freqPerBin;                            /* store magnitude and true frequency in analysis arrays */                          gAnaMagn[k] = (float) magn;                          gAnaFreq[k] = (float) tmp;                        }                        /* ***************** PROCESSING ******************* */                      /* this does the actual pitch shifting */                      for (int zero = 0; zero < fftFrameSize; zero++)                      {                          gSynMagn[zero] = 0;                          gSynFreq[zero] = 0;                      }                        for (k = 0; k <= fftFrameSize2; k++)                      {                          index = (long) (k*pitchShift);                          if (index <= fftFrameSize2)                          {                              gSynMagn[index] += gAnaMagn[k];                              gSynFreq[index] = gAnaFreq[k]*pitchShift;                          }                      }                        /* ***************** SYNTHESIS ******************* */                      /* this is the synthesis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* get magnitude and true frequency from synthesis arrays */                          magn = gSynMagn[k];                          tmp = gSynFreq[k];                            /* subtract bin mid frequency */                          tmp -= (double) k*freqPerBin;                            /* get bin deviation from freq deviation */                          tmp /= freqPerBin;                            /* take osamp into account */                          tmp = 2.0*Math.PI*tmp/osamp;                            /* add the overlap phase advance back in */                          tmp += (double) k*expct;                            /* accumulate delta phase to get bin phase */                          gSumPhase[k] += (float) tmp;                          phase = gSumPhase[k];                            /* get real and imag part and re-interleave */                          gFFTworksp[2*k] = (float) (magn*Math.Cos(phase));                          gFFTworksp[2*k + 1] = (float) (magn*Math.Sin(phase));                      }                        /* zero negative frequencies */                      for (k = fftFrameSize + 2; k < 2*fftFrameSize; k++) gFFTworksp[k] = 0.0F;                        /* do inverse transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' 1);                        /* do windowing and add to output accumulator */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gOutputAccum[k] += (float) (2.0*window*gFFTworksp[2*k]/(fftFrameSize2*osamp));                      }                      for (k = 0; k < stepSize; k++) gOutFIFO[k] = gOutputAccum[k];                        /* shift accumulator */                      //memmove(gOutputAccum' gOutputAccum + stepSize' fftFrameSize * sizeof(float));                      for (k = 0; k < fftFrameSize; k++)                      {                          gOutputAccum[k] = gOutputAccum[k + stepSize];                      }                        /* move input FIFO */                      for (k = 0; k < inFifoLatency; k++) gInFIFO[k] = gInFIFO[k + stepSize];                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,PitchShift,The following statement contains a magic number: for (i = 0; i < numSampsToProcess; i++)              {                    /* As long as we have not yet collected enough data just read in */                  gInFIFO[gRover] = indata[i];                  outdata[i] = gOutFIFO[gRover - inFifoLatency];                  gRover++;                    /* now we have enough data for processing */                  if (gRover >= fftFrameSize)                  {                      gRover = inFifoLatency;                        /* do windowing and re'im interleave */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gFFTworksp[2*k] = (float) (gInFIFO[k]*window);                          gFFTworksp[2*k + 1] = 0.0F;                      }                          /* ***************** ANALYSIS ******************* */                      /* do transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' -1);                        /* this is the analysis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* de-interlace FFT buffer */                          real = gFFTworksp[2*k];                          imag = gFFTworksp[2*k + 1];                            /* compute magnitude and phase */                          magn = 2.0*Math.Sqrt(real*real + imag*imag);                          phase = Math.Atan2(imag' real);                            /* compute phase difference */                          tmp = phase - gLastPhase[k];                          gLastPhase[k] = (float) phase;                            /* subtract expected phase difference */                          tmp -= (double) k*expct;                            /* map delta phase into +/- Pi interval */                          qpd = (long) (tmp/Math.PI);                          if (qpd >= 0) qpd += qpd & 1;                          else qpd -= qpd & 1;                          tmp -= Math.PI*(double) qpd;                            /* get deviation from bin frequency from the +/- Pi interval */                          tmp = osamp*tmp/(2.0*Math.PI);                            /* compute the k-th partials' true frequency */                          tmp = (double) k*freqPerBin + tmp*freqPerBin;                            /* store magnitude and true frequency in analysis arrays */                          gAnaMagn[k] = (float) magn;                          gAnaFreq[k] = (float) tmp;                        }                        /* ***************** PROCESSING ******************* */                      /* this does the actual pitch shifting */                      for (int zero = 0; zero < fftFrameSize; zero++)                      {                          gSynMagn[zero] = 0;                          gSynFreq[zero] = 0;                      }                        for (k = 0; k <= fftFrameSize2; k++)                      {                          index = (long) (k*pitchShift);                          if (index <= fftFrameSize2)                          {                              gSynMagn[index] += gAnaMagn[k];                              gSynFreq[index] = gAnaFreq[k]*pitchShift;                          }                      }                        /* ***************** SYNTHESIS ******************* */                      /* this is the synthesis step */                      for (k = 0; k <= fftFrameSize2; k++)                      {                            /* get magnitude and true frequency from synthesis arrays */                          magn = gSynMagn[k];                          tmp = gSynFreq[k];                            /* subtract bin mid frequency */                          tmp -= (double) k*freqPerBin;                            /* get bin deviation from freq deviation */                          tmp /= freqPerBin;                            /* take osamp into account */                          tmp = 2.0*Math.PI*tmp/osamp;                            /* add the overlap phase advance back in */                          tmp += (double) k*expct;                            /* accumulate delta phase to get bin phase */                          gSumPhase[k] += (float) tmp;                          phase = gSumPhase[k];                            /* get real and imag part and re-interleave */                          gFFTworksp[2*k] = (float) (magn*Math.Cos(phase));                          gFFTworksp[2*k + 1] = (float) (magn*Math.Sin(phase));                      }                        /* zero negative frequencies */                      for (k = fftFrameSize + 2; k < 2*fftFrameSize; k++) gFFTworksp[k] = 0.0F;                        /* do inverse transform */                      ShortTimeFourierTransform(gFFTworksp' fftFrameSize' 1);                        /* do windowing and add to output accumulator */                      for (k = 0; k < fftFrameSize; k++)                      {                          window = -.5*Math.Cos(2.0*Math.PI*(double) k/(double) fftFrameSize) + .5;                          gOutputAccum[k] += (float) (2.0*window*gFFTworksp[2*k]/(fftFrameSize2*osamp));                      }                      for (k = 0; k < stepSize; k++) gOutFIFO[k] = gOutputAccum[k];                        /* shift accumulator */                      //memmove(gOutputAccum' gOutputAccum + stepSize' fftFrameSize * sizeof(float));                      for (k = 0; k < fftFrameSize; k++)                      {                          gOutputAccum[k] = gOutputAccum[k + stepSize];                      }                        /* move input FIFO */                      for (k = 0; k < inFifoLatency; k++) gInFIFO[k] = gInFIFO[k + stepSize];                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,ShortTimeFourierTransform,The following statement contains a magic number: for (i = 2; i < 2*fftFrameSize - 2; i += 2)              {                  for (bitm = 2' j = 0; bitm < 2*fftFrameSize; bitm <<= 1)                  {                      if ((i & bitm) != 0) j++;                      j <<= 1;                  }                  if (i < j)                  {                      temp = fftBuffer[i];                      fftBuffer[i] = fftBuffer[j];                      fftBuffer[j] = temp;                      temp = fftBuffer[i + 1];                      fftBuffer[i + 1] = fftBuffer[j + 1];                      fftBuffer[j + 1] = temp;                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,ShortTimeFourierTransform,The following statement contains a magic number: for (i = 2; i < 2*fftFrameSize - 2; i += 2)              {                  for (bitm = 2' j = 0; bitm < 2*fftFrameSize; bitm <<= 1)                  {                      if ((i & bitm) != 0) j++;                      j <<= 1;                  }                  if (i < j)                  {                      temp = fftBuffer[i];                      fftBuffer[i] = fftBuffer[j];                      fftBuffer[j] = temp;                      temp = fftBuffer[i + 1];                      fftBuffer[i + 1] = fftBuffer[j + 1];                      fftBuffer[j + 1] = temp;                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,ShortTimeFourierTransform,The following statement contains a magic number: for (i = 2; i < 2*fftFrameSize - 2; i += 2)              {                  for (bitm = 2' j = 0; bitm < 2*fftFrameSize; bitm <<= 1)                  {                      if ((i & bitm) != 0) j++;                      j <<= 1;                  }                  if (i < j)                  {                      temp = fftBuffer[i];                      fftBuffer[i] = fftBuffer[j];                      fftBuffer[j] = temp;                      temp = fftBuffer[i + 1];                      fftBuffer[i + 1] = fftBuffer[j + 1];                      fftBuffer[j + 1] = temp;                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,ShortTimeFourierTransform,The following statement contains a magic number: for (i = 2; i < 2*fftFrameSize - 2; i += 2)              {                  for (bitm = 2' j = 0; bitm < 2*fftFrameSize; bitm <<= 1)                  {                      if ((i & bitm) != 0) j++;                      j <<= 1;                  }                  if (i < j)                  {                      temp = fftBuffer[i];                      fftBuffer[i] = fftBuffer[j];                      fftBuffer[j] = temp;                      temp = fftBuffer[i + 1];                      fftBuffer[i + 1] = fftBuffer[j + 1];                      fftBuffer[j + 1] = temp;                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,ShortTimeFourierTransform,The following statement contains a magic number: for (i = 2; i < 2*fftFrameSize - 2; i += 2)              {                  for (bitm = 2' j = 0; bitm < 2*fftFrameSize; bitm <<= 1)                  {                      if ((i & bitm) != 0) j++;                      j <<= 1;                  }                  if (i < j)                  {                      temp = fftBuffer[i];                      fftBuffer[i] = fftBuffer[j];                      fftBuffer[j] = temp;                      temp = fftBuffer[i + 1];                      fftBuffer[i + 1] = fftBuffer[j + 1];                      fftBuffer[j + 1] = temp;                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,ShortTimeFourierTransform,The following statement contains a magic number: for (i = 2; i < 2*fftFrameSize - 2; i += 2)              {                  for (bitm = 2' j = 0; bitm < 2*fftFrameSize; bitm <<= 1)                  {                      if ((i & bitm) != 0) j++;                      j <<= 1;                  }                  if (i < j)                  {                      temp = fftBuffer[i];                      fftBuffer[i] = fftBuffer[j];                      fftBuffer[j] = temp;                      temp = fftBuffer[i + 1];                      fftBuffer[i + 1] = fftBuffer[j + 1];                      fftBuffer[j + 1] = temp;                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,ShortTimeFourierTransform,The following statement contains a magic number: long max = (long) (Math.Log(fftFrameSize)/Math.Log(2.0) + .5);
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,ShortTimeFourierTransform,The following statement contains a magic number: long max = (long) (Math.Log(fftFrameSize)/Math.Log(2.0) + .5);
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,ShortTimeFourierTransform,The following statement contains a magic number: for (k = 0' le = 2; k < max; k++)              {                  le <<= 1;                  le2 = le >> 1;                  ur = 1.0F;                  ui = 0.0F;                  arg = (float) Math.PI/(le2 >> 1);                  wr = (float) Math.Cos(arg);                  wi = (float) (sign*Math.Sin(arg));                  for (j = 0; j < le2; j += 2)                  {                        for (i = j; i < 2*fftFrameSize; i += le)                      {                          tr = fftBuffer[i + le2]*ur - fftBuffer[i + le2 + 1]*ui;                          ti = fftBuffer[i + le2]*ui + fftBuffer[i + le2 + 1]*ur;                          fftBuffer[i + le2] = fftBuffer[i] - tr;                          fftBuffer[i + le2 + 1] = fftBuffer[i + 1] - ti;                          fftBuffer[i] += tr;                          fftBuffer[i + 1] += ti;                        }                      tr = ur*wr - ui*wi;                      ui = ur*wi + ui*wr;                      ur = tr;                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,ShortTimeFourierTransform,The following statement contains a magic number: for (k = 0' le = 2; k < max; k++)              {                  le <<= 1;                  le2 = le >> 1;                  ur = 1.0F;                  ui = 0.0F;                  arg = (float) Math.PI/(le2 >> 1);                  wr = (float) Math.Cos(arg);                  wi = (float) (sign*Math.Sin(arg));                  for (j = 0; j < le2; j += 2)                  {                        for (i = j; i < 2*fftFrameSize; i += le)                      {                          tr = fftBuffer[i + le2]*ur - fftBuffer[i + le2 + 1]*ui;                          ti = fftBuffer[i + le2]*ui + fftBuffer[i + le2 + 1]*ur;                          fftBuffer[i + le2] = fftBuffer[i] - tr;                          fftBuffer[i + le2 + 1] = fftBuffer[i + 1] - ti;                          fftBuffer[i] += tr;                          fftBuffer[i + 1] += ti;                        }                      tr = ur*wr - ui*wi;                      ui = ur*wi + ui*wr;                      ur = tr;                  }              }
Magic Number,NAudio.Dsp,SmbPitchShifter,C:\repos\naudio_NAudio\NAudio\Dsp\SmbPitchShifter.cs,ShortTimeFourierTransform,The following statement contains a magic number: for (k = 0' le = 2; k < max; k++)              {                  le <<= 1;                  le2 = le >> 1;                  ur = 1.0F;                  ui = 0.0F;                  arg = (float) Math.PI/(le2 >> 1);                  wr = (float) Math.Cos(arg);                  wi = (float) (sign*Math.Sin(arg));                  for (j = 0; j < le2; j += 2)                  {                        for (i = j; i < 2*fftFrameSize; i += le)                      {                          tr = fftBuffer[i + le2]*ur - fftBuffer[i + le2 + 1]*ui;                          ti = fftBuffer[i + le2]*ui + fftBuffer[i + le2 + 1]*ur;                          fftBuffer[i + le2] = fftBuffer[i] - tr;                          fftBuffer[i + le2 + 1] = fftBuffer[i + 1] - ti;                          fftBuffer[i] += tr;                          fftBuffer[i + 1] += ti;                        }                      tr = ur*wr - ui*wi;                      ui = ur*wi + ui*wr;                      ur = tr;                  }              }
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetLowPassFilter,The following statement contains a magic number: var w0 = 2 * Math.PI * cutoffFrequency / sampleRate;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetLowPassFilter,The following statement contains a magic number: var alpha = Math.Sin(w0) / (2 * q);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetLowPassFilter,The following statement contains a magic number: var b0 = (1 - cosw0) / 2;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetLowPassFilter,The following statement contains a magic number: var b2 = (1 - cosw0) / 2;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetLowPassFilter,The following statement contains a magic number: var aa1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetPeakingEq,The following statement contains a magic number: var w0 = 2 * Math.PI * centreFrequency / sampleRate;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetPeakingEq,The following statement contains a magic number: var alpha = sinw0 / (2 * q);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetPeakingEq,The following statement contains a magic number: var a = Math.Pow(10' dbGain / 40);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetPeakingEq,The following statement contains a magic number: var a = Math.Pow(10' dbGain / 40);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetPeakingEq,The following statement contains a magic number: var b1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetPeakingEq,The following statement contains a magic number: var aa1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetHighPassFilter,The following statement contains a magic number: var w0 = 2 * Math.PI * cutoffFrequency / sampleRate;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetHighPassFilter,The following statement contains a magic number: var alpha = Math.Sin(w0) / (2 * q);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetHighPassFilter,The following statement contains a magic number: var b0 = (1 + cosw0) / 2;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetHighPassFilter,The following statement contains a magic number: var b2 = (1 + cosw0) / 2;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,SetHighPassFilter,The following statement contains a magic number: var aa1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,BandPassFilterConstantSkirtGain,The following statement contains a magic number: var w0 = 2 * Math.PI * centreFrequency / sampleRate;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,BandPassFilterConstantSkirtGain,The following statement contains a magic number: var alpha = sinw0 / (2 * q);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,BandPassFilterConstantSkirtGain,The following statement contains a magic number: var b0 = sinw0 / 2;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,BandPassFilterConstantSkirtGain,The following statement contains a magic number: var b2 = -sinw0 / 2;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,BandPassFilterConstantSkirtGain,The following statement contains a magic number: var a1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,BandPassFilterConstantPeakGain,The following statement contains a magic number: var w0 = 2 * Math.PI * centreFrequency / sampleRate;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,BandPassFilterConstantPeakGain,The following statement contains a magic number: var alpha = sinw0 / (2 * q);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,BandPassFilterConstantPeakGain,The following statement contains a magic number: var a1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,NotchFilter,The following statement contains a magic number: var w0 = 2 * Math.PI * centreFrequency / sampleRate;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,NotchFilter,The following statement contains a magic number: var alpha = sinw0 / (2 * q);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,NotchFilter,The following statement contains a magic number: var b1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,NotchFilter,The following statement contains a magic number: var a1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,AllPassFilter,The following statement contains a magic number: var w0 = 2 * Math.PI * centreFrequency / sampleRate;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,AllPassFilter,The following statement contains a magic number: var alpha = sinw0 / (2 * q);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,AllPassFilter,The following statement contains a magic number: var b1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,AllPassFilter,The following statement contains a magic number: var a1 = -2 * cosw0;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,LowShelf,The following statement contains a magic number: var w0 = 2 * Math.PI * cutoffFrequency / sampleRate;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,LowShelf,The following statement contains a magic number: var a = Math.Pow(10' dbGain / 40);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,LowShelf,The following statement contains a magic number: var a = Math.Pow(10' dbGain / 40);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,LowShelf,The following statement contains a magic number: var alpha = sinw0 / 2 * Math.Sqrt((a + 1 / a) * (1 / shelfSlope - 1) + 2);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,LowShelf,The following statement contains a magic number: var alpha = sinw0 / 2 * Math.Sqrt((a + 1 / a) * (1 / shelfSlope - 1) + 2);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,LowShelf,The following statement contains a magic number: var temp = 2 * Math.Sqrt(a) * alpha;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,LowShelf,The following statement contains a magic number: var b1 = 2 * a * ((a - 1) - (a + 1) * cosw0);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,LowShelf,The following statement contains a magic number: var a1 = -2 * ((a - 1) + (a + 1) * cosw0);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,HighShelf,The following statement contains a magic number: var w0 = 2 * Math.PI * cutoffFrequency / sampleRate;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,HighShelf,The following statement contains a magic number: var a = Math.Pow(10' dbGain / 40);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,HighShelf,The following statement contains a magic number: var a = Math.Pow(10' dbGain / 40);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,HighShelf,The following statement contains a magic number: var alpha = sinw0 / 2 * Math.Sqrt((a + 1 / a) * (1 / shelfSlope - 1) + 2);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,HighShelf,The following statement contains a magic number: var alpha = sinw0 / 2 * Math.Sqrt((a + 1 / a) * (1 / shelfSlope - 1) + 2);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,HighShelf,The following statement contains a magic number: var temp = 2 * Math.Sqrt(a) * alpha;
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,HighShelf,The following statement contains a magic number: var b1 = -2 * a * ((a - 1) + (a + 1) * cosw0);
Magic Number,NAudio.Dsp,BiQuadFilter,C:\repos\naudio_NAudio\NAudio\Dsp\BiQuadFilter.cs,HighShelf,The following statement contains a magic number: var a1 = 2 * ((a - 1) - (a + 1) * cosw0);
Magic Number,NAudio.Dsp,EnvelopeDetector,C:\repos\naudio_NAudio\NAudio\Dsp\EnvelopeDetector.cs,SetCoef,The following statement contains a magic number: coeff = Math.Exp(-1.0 / (0.001 * ms * sampleRate));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,FFT,The following statement contains a magic number: for (i = 0; i < m; i++)                  n *= 2;
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,HammingWindow,The following statement contains a magic number: return 0.54 - 0.46 * Math.Cos((2 * Math.PI * n) / (frameSize - 1));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,HammingWindow,The following statement contains a magic number: return 0.54 - 0.46 * Math.Cos((2 * Math.PI * n) / (frameSize - 1));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,HammingWindow,The following statement contains a magic number: return 0.54 - 0.46 * Math.Cos((2 * Math.PI * n) / (frameSize - 1));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,HannWindow,The following statement contains a magic number: return 0.5 * (1 - Math.Cos((2 * Math.PI * n) / (frameSize - 1)));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,HannWindow,The following statement contains a magic number: return 0.5 * (1 - Math.Cos((2 * Math.PI * n) / (frameSize - 1)));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,BlackmannHarrisWindow,The following statement contains a magic number: return 0.35875 - (0.48829 * Math.Cos((2 * Math.PI * n) / (frameSize - 1))) + (0.14128 * Math.Cos((4 * Math.PI * n) / (frameSize - 1))) - (0.01168 * Math.Cos((6 * Math.PI * n) / (frameSize - 1)));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,BlackmannHarrisWindow,The following statement contains a magic number: return 0.35875 - (0.48829 * Math.Cos((2 * Math.PI * n) / (frameSize - 1))) + (0.14128 * Math.Cos((4 * Math.PI * n) / (frameSize - 1))) - (0.01168 * Math.Cos((6 * Math.PI * n) / (frameSize - 1)));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,BlackmannHarrisWindow,The following statement contains a magic number: return 0.35875 - (0.48829 * Math.Cos((2 * Math.PI * n) / (frameSize - 1))) + (0.14128 * Math.Cos((4 * Math.PI * n) / (frameSize - 1))) - (0.01168 * Math.Cos((6 * Math.PI * n) / (frameSize - 1)));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,BlackmannHarrisWindow,The following statement contains a magic number: return 0.35875 - (0.48829 * Math.Cos((2 * Math.PI * n) / (frameSize - 1))) + (0.14128 * Math.Cos((4 * Math.PI * n) / (frameSize - 1))) - (0.01168 * Math.Cos((6 * Math.PI * n) / (frameSize - 1)));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,BlackmannHarrisWindow,The following statement contains a magic number: return 0.35875 - (0.48829 * Math.Cos((2 * Math.PI * n) / (frameSize - 1))) + (0.14128 * Math.Cos((4 * Math.PI * n) / (frameSize - 1))) - (0.01168 * Math.Cos((6 * Math.PI * n) / (frameSize - 1)));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,BlackmannHarrisWindow,The following statement contains a magic number: return 0.35875 - (0.48829 * Math.Cos((2 * Math.PI * n) / (frameSize - 1))) + (0.14128 * Math.Cos((4 * Math.PI * n) / (frameSize - 1))) - (0.01168 * Math.Cos((6 * Math.PI * n) / (frameSize - 1)));
Magic Number,NAudio.Dsp,FastFourierTransform,C:\repos\naudio_NAudio\NAudio\Dsp\FastFourierTransform.cs,BlackmannHarrisWindow,The following statement contains a magic number: return 0.35875 - (0.48829 * Math.Cos((2 * Math.PI * n) / (frameSize - 1))) + (0.14128 * Math.Cos((4 * Math.PI * n) / (frameSize - 1))) - (0.01168 * Math.Cos((6 * Math.PI * n) / (frameSize - 1)));
Magic Number,NAudio.FileFormats.Wav,WaveFileChunkReader,C:\repos\naudio_NAudio\NAudio\FileFormats\Wav\WaveFileChunkReader.cs,ReadWaveHeader,The following statement contains a magic number: long stopPosition = Math.Min(riffSize + 8' stream.Length);
Magic Number,NAudio.FileFormats.Wav,WaveFileChunkReader,C:\repos\naudio_NAudio\NAudio\FileFormats\Wav\WaveFileChunkReader.cs,ReadWaveHeader,The following statement contains a magic number: while (stream.Position <= stopPosition - 8)              {                  Int32 chunkIdentifier = br.ReadInt32();                  var chunkLength = br.ReadUInt32();                  if (chunkIdentifier == dataChunkId)                  {                      dataChunkPosition = stream.Position;                      if (!isRf64) // we already know the dataChunkLength if this is an RF64 file                      {                          dataChunkLength = chunkLength;                      }                      stream.Position += chunkLength;                  }                  else if (chunkIdentifier == formatChunkId)                  {                      if (chunkLength > Int32.MaxValue)                           throw new InvalidDataException(string.Format("Format chunk length must be between 0 and {0}."' Int32.MaxValue));                      waveFormat = WaveFormat.FromFormatChunk(br' (int)chunkLength);                  }                  else                  {                      // check for invalid chunk length                      if (chunkLength > stream.Length - stream.Position)                      {                          if (strictMode)                          {                              Debug.Assert(false' String.Format("Invalid chunk length {0}' pos: {1}. length: {2}"'                                  chunkLength' stream.Position' stream.Length));                          }                          // an exception will be thrown further down if we haven't got a format and data chunk yet'                          // otherwise we will tolerate this file despite it having corrupt data at the end                          break;                      }                      if (storeAllChunks)                      {                          if (chunkLength > Int32.MaxValue)                              throw new InvalidDataException(string.Format("RiffChunk chunk length must be between 0 and {0}."' Int32.MaxValue));                          riffChunks.Add(GetRiffChunk(stream' chunkIdentifier' (int)chunkLength));                      }                      stream.Position += chunkLength;                  }              }
Magic Number,NAudio.FileFormats.Wav,WaveFileChunkReader,C:\repos\naudio_NAudio\NAudio\FileFormats\Wav\WaveFileChunkReader.cs,ReadDs64Chunk,The following statement contains a magic number: reader.ReadBytes(chunkSize - 24);
Magic Number,NAudio.MediaFoundation,MediaFoundationApi,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationHelpers.cs,Startup,The following statement contains a magic number: if (!initialized)              {                  var sdkVersion = MediaFoundationInterop.MF_SDK_VERSION;  #if !NETFX_CORE                  var os = Environment.OSVersion;                  if (os.Version.Major == 6 && os.Version.Minor == 0)                      sdkVersion = 1;  #endif                  MediaFoundationInterop.MFStartup((sdkVersion << 16) | MediaFoundationInterop.MF_API_VERSION' 0);                  initialized = true;              }
Magic Number,NAudio.MediaFoundation,MediaFoundationApi,C:\repos\naudio_NAudio\NAudio\MediaFoundation\MediaFoundationHelpers.cs,Startup,The following statement contains a magic number: if (!initialized)              {                  var sdkVersion = MediaFoundationInterop.MF_SDK_VERSION;  #if !NETFX_CORE                  var os = Environment.OSVersion;                  if (os.Version.Major == 6 && os.Version.Minor == 0)                      sdkVersion = 1;  #endif                  MediaFoundationInterop.MFStartup((sdkVersion << 16) | MediaFoundationInterop.MF_API_VERSION' 0);                  initialized = true;              }
Magic Number,NAudio.Midi,ControlChangeEvent,C:\repos\naudio_NAudio\NAudio\Midi\ControlChangeEvent.cs,GetAsShortMessage,The following statement contains a magic number: return base.GetAsShortMessage() + (c << 8) + (controllerValue << 16);
Magic Number,NAudio.Midi,ControlChangeEvent,C:\repos\naudio_NAudio\NAudio\Midi\ControlChangeEvent.cs,GetAsShortMessage,The following statement contains a magic number: return base.GetAsShortMessage() + (c << 8) + (controllerValue << 16);
Magic Number,NAudio.Midi,KeySignatureEvent,C:\repos\naudio_NAudio\NAudio\Midi\KeySignatureEvent.cs,KeySignatureEvent,The following statement contains a magic number: if (length != 2)              {                  throw new FormatException("Invalid key signature length");              }
Magic Number,NAudio.Midi,MidiEvent,C:\repos\naudio_NAudio\NAudio\Midi\MidiEvent.cs,FromRawMessage,The following statement contains a magic number: int data1 = (rawMessage >> 8) & 0xFF;
Magic Number,NAudio.Midi,MidiEvent,C:\repos\naudio_NAudio\NAudio\Midi\MidiEvent.cs,FromRawMessage,The following statement contains a magic number: int data2 = (rawMessage >> 16) & 0xFF;
Magic Number,NAudio.Midi,MidiEvent,C:\repos\naudio_NAudio\NAudio\Midi\MidiEvent.cs,FromRawMessage,The following statement contains a magic number: switch (commandCode)              {                  case MidiCommandCode.NoteOn:                  case MidiCommandCode.NoteOff:                  case MidiCommandCode.KeyAfterTouch:                      if (data2 > 0 && commandCode == MidiCommandCode.NoteOn)                      {                          me = new NoteOnEvent(absoluteTime' channel' data1' data2' 0);                      }                      else                      {                          me = new NoteEvent(absoluteTime' channel' commandCode' data1' data2);                      }                      break;                  case MidiCommandCode.ControlChange:                      me = new ControlChangeEvent(absoluteTime'channel'(MidiController)data1'data2);                      break;                  case MidiCommandCode.PatchChange:                      me = new PatchChangeEvent(absoluteTime'channel'data1);                      break;                  case MidiCommandCode.ChannelAfterTouch:                      me = new ChannelAfterTouchEvent(absoluteTime'channel'data1);                      break;                  case MidiCommandCode.PitchWheelChange:                      me = new PitchWheelChangeEvent(absoluteTime' channel' data1 + (data2 << 7));                      break;                  case MidiCommandCode.TimingClock:                  case MidiCommandCode.StartSequence:                  case MidiCommandCode.ContinueSequence:                  case MidiCommandCode.StopSequence:                  case MidiCommandCode.AutoSensing:                      me = new MidiEvent(absoluteTime'channel'commandCode);                      break;                  case MidiCommandCode.MetaEvent:                  case MidiCommandCode.Sysex:                  default:                      throw new FormatException(String.Format("Unsupported MIDI Command Code for Raw Message {0}"' commandCode));              }
Magic Number,NAudio.Midi,MidiEvent,C:\repos\naudio_NAudio\NAudio\Midi\MidiEvent.cs,ReadVarInt,The following statement contains a magic number: for(int n = 0; n < 4; n++)               {                  b = br.ReadByte();                  value <<= 7;                  value += (b & 0x7F);                  if((b & 0x80) == 0)                   {                      return value;                  }              }
Magic Number,NAudio.Midi,MidiEvent,C:\repos\naudio_NAudio\NAudio\Midi\MidiEvent.cs,ReadVarInt,The following statement contains a magic number: for(int n = 0; n < 4; n++)               {                  b = br.ReadByte();                  value <<= 7;                  value += (b & 0x7F);                  if((b & 0x80) == 0)                   {                      return value;                  }              }
Magic Number,NAudio.Midi,MidiEvent,C:\repos\naudio_NAudio\NAudio\Midi\MidiEvent.cs,WriteVarInt,The following statement contains a magic number: byte[] buffer = new byte[4];
Magic Number,NAudio.Midi,MidiEvent,C:\repos\naudio_NAudio\NAudio\Midi\MidiEvent.cs,WriteVarInt,The following statement contains a magic number: do              {                  buffer[n++] = (byte)(value & 0x7F);                  value >>= 7;              } while (value > 0);
Magic Number,NAudio.Midi,MidiFile,C:\repos\naudio_NAudio\NAudio\Midi\MidiFile.cs,MidiFile,The following statement contains a magic number: try               {                  string chunkHeader = Encoding.UTF8.GetString(br.ReadBytes(4));                  if(chunkHeader != "MThd")                   {                      throw new FormatException("Not a MIDI file - header chunk missing");                  }                  uint chunkSize = SwapUInt32(br.ReadUInt32());                                    if(chunkSize != 6)                   {                      throw new FormatException("Unexpected header chunk length");                  }                  // 0 = single track' 1 = multi-track synchronous' 2 = multi-track asynchronous                  fileFormat = SwapUInt16(br.ReadUInt16());                  int tracks = SwapUInt16(br.ReadUInt16());                  deltaTicksPerQuarterNote = SwapUInt16(br.ReadUInt16());                    events = new MidiEventCollection((fileFormat == 0) ? 0 : 1' deltaTicksPerQuarterNote);                  for (int n = 0; n < tracks; n++)                  {                      events.AddTrack();                  }                                    long absoluteTime = 0;                                    for(int track = 0; track < tracks; track++)                   {                      if(fileFormat == 1)                       {                          absoluteTime = 0;                      }                      chunkHeader = Encoding.UTF8.GetString(br.ReadBytes(4));                      if(chunkHeader != "MTrk")                       {                          throw new FormatException("Invalid chunk header");                      }                      chunkSize = SwapUInt32(br.ReadUInt32());                        long startPos = br.BaseStream.Position;                      MidiEvent me = null;                      var outstandingNoteOns = new List<NoteOnEvent>();                      while(br.BaseStream.Position < startPos + chunkSize)                       {                          try                          {                              me = MidiEvent.ReadNextEvent(br' me);                          }                          catch (InvalidDataException)                          {                              if (strictChecking) throw;                              continue;                          }                          catch (FormatException)                          {                              if (strictChecking) throw;                              continue;                          }                            absoluteTime += me.DeltaTime;                          me.AbsoluteTime = absoluteTime;                          events[track].Add(me);                          if (me.CommandCode == MidiCommandCode.NoteOn)                           {                              var ne = (NoteEvent) me;                              if(ne.Velocity > 0)                               {                                  outstandingNoteOns.Add((NoteOnEvent) ne);                              }                              else                               {                                  // don't remove the note offs' even though                                  // they are annoying                                  // events[track].Remove(me);                                  FindNoteOn(ne'outstandingNoteOns);                              }                          }                          else if(me.CommandCode == MidiCommandCode.NoteOff)                           {                              FindNoteOn((NoteEvent) me'outstandingNoteOns);                          }                          else if(me.CommandCode == MidiCommandCode.MetaEvent)                           {                              MetaEvent metaEvent = (MetaEvent) me;                              if(metaEvent.MetaEventType == MetaEventType.EndTrack)                               {                                  //break;                                  // some dodgy MIDI files have an event after end track                                  if (strictChecking)                                  {                                      if (br.BaseStream.Position < startPos + chunkSize)                                      {                                          throw new FormatException(                                              $"End Track event was not the last MIDI event on track {track}");                                      }                                  }                              }                          }                      }                      if(outstandingNoteOns.Count > 0)                       {                          if (strictChecking)                          {                              throw new FormatException(                                  $"Note ons without note offs {outstandingNoteOns.Count} (file format {fileFormat})");                          }                      }                      if(br.BaseStream.Position != startPos + chunkSize)                       {                          throw new FormatException($"Read too far {chunkSize}+{startPos}!={br.BaseStream.Position}");                      }                  }              }              finally              {                  if (ownInputStream)                      br.Close();              }
Magic Number,NAudio.Midi,MidiFile,C:\repos\naudio_NAudio\NAudio\Midi\MidiFile.cs,MidiFile,The following statement contains a magic number: try               {                  string chunkHeader = Encoding.UTF8.GetString(br.ReadBytes(4));                  if(chunkHeader != "MThd")                   {                      throw new FormatException("Not a MIDI file - header chunk missing");                  }                  uint chunkSize = SwapUInt32(br.ReadUInt32());                                    if(chunkSize != 6)                   {                      throw new FormatException("Unexpected header chunk length");                  }                  // 0 = single track' 1 = multi-track synchronous' 2 = multi-track asynchronous                  fileFormat = SwapUInt16(br.ReadUInt16());                  int tracks = SwapUInt16(br.ReadUInt16());                  deltaTicksPerQuarterNote = SwapUInt16(br.ReadUInt16());                    events = new MidiEventCollection((fileFormat == 0) ? 0 : 1' deltaTicksPerQuarterNote);                  for (int n = 0; n < tracks; n++)                  {                      events.AddTrack();                  }                                    long absoluteTime = 0;                                    for(int track = 0; track < tracks; track++)                   {                      if(fileFormat == 1)                       {                          absoluteTime = 0;                      }                      chunkHeader = Encoding.UTF8.GetString(br.ReadBytes(4));                      if(chunkHeader != "MTrk")                       {                          throw new FormatException("Invalid chunk header");                      }                      chunkSize = SwapUInt32(br.ReadUInt32());                        long startPos = br.BaseStream.Position;                      MidiEvent me = null;                      var outstandingNoteOns = new List<NoteOnEvent>();                      while(br.BaseStream.Position < startPos + chunkSize)                       {                          try                          {                              me = MidiEvent.ReadNextEvent(br' me);                          }                          catch (InvalidDataException)                          {                              if (strictChecking) throw;                              continue;                          }                          catch (FormatException)                          {                              if (strictChecking) throw;                              continue;                          }                            absoluteTime += me.DeltaTime;                          me.AbsoluteTime = absoluteTime;                          events[track].Add(me);                          if (me.CommandCode == MidiCommandCode.NoteOn)                           {                              var ne = (NoteEvent) me;                              if(ne.Velocity > 0)                               {                                  outstandingNoteOns.Add((NoteOnEvent) ne);                              }                              else                               {                                  // don't remove the note offs' even though                                  // they are annoying                                  // events[track].Remove(me);                                  FindNoteOn(ne'outstandingNoteOns);                              }                          }                          else if(me.CommandCode == MidiCommandCode.NoteOff)                           {                              FindNoteOn((NoteEvent) me'outstandingNoteOns);                          }                          else if(me.CommandCode == MidiCommandCode.MetaEvent)                           {                              MetaEvent metaEvent = (MetaEvent) me;                              if(metaEvent.MetaEventType == MetaEventType.EndTrack)                               {                                  //break;                                  // some dodgy MIDI files have an event after end track                                  if (strictChecking)                                  {                                      if (br.BaseStream.Position < startPos + chunkSize)                                      {                                          throw new FormatException(                                              $"End Track event was not the last MIDI event on track {track}");                                      }                                  }                              }                          }                      }                      if(outstandingNoteOns.Count > 0)                       {                          if (strictChecking)                          {                              throw new FormatException(                                  $"Note ons without note offs {outstandingNoteOns.Count} (file format {fileFormat})");                          }                      }                      if(br.BaseStream.Position != startPos + chunkSize)                       {                          throw new FormatException($"Read too far {chunkSize}+{startPos}!={br.BaseStream.Position}");                      }                  }              }              finally              {                  if (ownInputStream)                      br.Close();              }
Magic Number,NAudio.Midi,MidiFile,C:\repos\naudio_NAudio\NAudio\Midi\MidiFile.cs,MidiFile,The following statement contains a magic number: try               {                  string chunkHeader = Encoding.UTF8.GetString(br.ReadBytes(4));                  if(chunkHeader != "MThd")                   {                      throw new FormatException("Not a MIDI file - header chunk missing");                  }                  uint chunkSize = SwapUInt32(br.ReadUInt32());                                    if(chunkSize != 6)                   {                      throw new FormatException("Unexpected header chunk length");                  }                  // 0 = single track' 1 = multi-track synchronous' 2 = multi-track asynchronous                  fileFormat = SwapUInt16(br.ReadUInt16());                  int tracks = SwapUInt16(br.ReadUInt16());                  deltaTicksPerQuarterNote = SwapUInt16(br.ReadUInt16());                    events = new MidiEventCollection((fileFormat == 0) ? 0 : 1' deltaTicksPerQuarterNote);                  for (int n = 0; n < tracks; n++)                  {                      events.AddTrack();                  }                                    long absoluteTime = 0;                                    for(int track = 0; track < tracks; track++)                   {                      if(fileFormat == 1)                       {                          absoluteTime = 0;                      }                      chunkHeader = Encoding.UTF8.GetString(br.ReadBytes(4));                      if(chunkHeader != "MTrk")                       {                          throw new FormatException("Invalid chunk header");                      }                      chunkSize = SwapUInt32(br.ReadUInt32());                        long startPos = br.BaseStream.Position;                      MidiEvent me = null;                      var outstandingNoteOns = new List<NoteOnEvent>();                      while(br.BaseStream.Position < startPos + chunkSize)                       {                          try                          {                              me = MidiEvent.ReadNextEvent(br' me);                          }                          catch (InvalidDataException)                          {                              if (strictChecking) throw;                              continue;                          }                          catch (FormatException)                          {                              if (strictChecking) throw;                              continue;                          }                            absoluteTime += me.DeltaTime;                          me.AbsoluteTime = absoluteTime;                          events[track].Add(me);                          if (me.CommandCode == MidiCommandCode.NoteOn)                           {                              var ne = (NoteEvent) me;                              if(ne.Velocity > 0)                               {                                  outstandingNoteOns.Add((NoteOnEvent) ne);                              }                              else                               {                                  // don't remove the note offs' even though                                  // they are annoying                                  // events[track].Remove(me);                                  FindNoteOn(ne'outstandingNoteOns);                              }                          }                          else if(me.CommandCode == MidiCommandCode.NoteOff)                           {                              FindNoteOn((NoteEvent) me'outstandingNoteOns);                          }                          else if(me.CommandCode == MidiCommandCode.MetaEvent)                           {                              MetaEvent metaEvent = (MetaEvent) me;                              if(metaEvent.MetaEventType == MetaEventType.EndTrack)                               {                                  //break;                                  // some dodgy MIDI files have an event after end track                                  if (strictChecking)                                  {                                      if (br.BaseStream.Position < startPos + chunkSize)                                      {                                          throw new FormatException(                                              $"End Track event was not the last MIDI event on track {track}");                                      }                                  }                              }                          }                      }                      if(outstandingNoteOns.Count > 0)                       {                          if (strictChecking)                          {                              throw new FormatException(                                  $"Note ons without note offs {outstandingNoteOns.Count} (file format {fileFormat})");                          }                      }                      if(br.BaseStream.Position != startPos + chunkSize)                       {                          throw new FormatException($"Read too far {chunkSize}+{startPos}!={br.BaseStream.Position}");                      }                  }              }              finally              {                  if (ownInputStream)                      br.Close();              }
Magic Number,NAudio.Midi,MidiFile,C:\repos\naudio_NAudio\NAudio\Midi\MidiFile.cs,SwapUInt32,The following statement contains a magic number: return ((i & 0xFF000000) >> 24) | ((i & 0x00FF0000) >> 8) | ((i & 0x0000FF00) << 8) | ((i & 0x000000FF) << 24);
Magic Number,NAudio.Midi,MidiFile,C:\repos\naudio_NAudio\NAudio\Midi\MidiFile.cs,SwapUInt32,The following statement contains a magic number: return ((i & 0xFF000000) >> 24) | ((i & 0x00FF0000) >> 8) | ((i & 0x0000FF00) << 8) | ((i & 0x000000FF) << 24);
Magic Number,NAudio.Midi,MidiFile,C:\repos\naudio_NAudio\NAudio\Midi\MidiFile.cs,SwapUInt32,The following statement contains a magic number: return ((i & 0xFF000000) >> 24) | ((i & 0x00FF0000) >> 8) | ((i & 0x0000FF00) << 8) | ((i & 0x000000FF) << 24);
Magic Number,NAudio.Midi,MidiFile,C:\repos\naudio_NAudio\NAudio\Midi\MidiFile.cs,SwapUInt32,The following statement contains a magic number: return ((i & 0xFF000000) >> 24) | ((i & 0x00FF0000) >> 8) | ((i & 0x0000FF00) << 8) | ((i & 0x000000FF) << 24);
Magic Number,NAudio.Midi,MidiFile,C:\repos\naudio_NAudio\NAudio\Midi\MidiFile.cs,SwapUInt16,The following statement contains a magic number: return (ushort) (((i & 0xFF00) >> 8) | ((i & 0x00FF) << 8));
Magic Number,NAudio.Midi,MidiFile,C:\repos\naudio_NAudio\NAudio\Midi\MidiFile.cs,SwapUInt16,The following statement contains a magic number: return (ushort) (((i & 0xFF00) >> 8) | ((i & 0x00FF) << 8));
Magic Number,NAudio.Midi,MidiFile,C:\repos\naudio_NAudio\NAudio\Midi\MidiFile.cs,Export,The following statement contains a magic number: using (var writer = new BinaryWriter(File.Create(filename)))              {                  writer.Write(Encoding.UTF8.GetBytes("MThd"));                  writer.Write(SwapUInt32(6)); // chunk size                  writer.Write(SwapUInt16((ushort)events.MidiFileType));                  writer.Write(SwapUInt16((ushort)events.Tracks));                  writer.Write(SwapUInt16((ushort)events.DeltaTicksPerQuarterNote));                    for (int track = 0; track < events.Tracks; track++ )                  {                      IList<MidiEvent> eventList = events[track];                        writer.Write(Encoding.UTF8.GetBytes("MTrk"));                      long trackSizePosition = writer.BaseStream.Position;                      writer.Write(SwapUInt32(0));                        long absoluteTime = events.StartAbsoluteTime;                        // use a stable sort to preserve ordering of MIDI events whose                       // absolute times are the same                      MergeSort.Sort(eventList' new MidiEventComparer());                      if (eventList.Count > 0)                      {                          System.Diagnostics.Debug.Assert(MidiEvent.IsEndTrack(eventList[eventList.Count - 1])' "Exporting a track with a missing end track");                      }                      foreach (var midiEvent in eventList)                      {                          midiEvent.Export(ref absoluteTime' writer);                      }                        uint trackChunkLength = (uint)(writer.BaseStream.Position - trackSizePosition) - 4;                      writer.BaseStream.Position = trackSizePosition;                      writer.Write(SwapUInt32(trackChunkLength));                      writer.BaseStream.Position += trackChunkLength;                  }              }
Magic Number,NAudio.Midi,MidiFile,C:\repos\naudio_NAudio\NAudio\Midi\MidiFile.cs,Export,The following statement contains a magic number: using (var writer = new BinaryWriter(File.Create(filename)))              {                  writer.Write(Encoding.UTF8.GetBytes("MThd"));                  writer.Write(SwapUInt32(6)); // chunk size                  writer.Write(SwapUInt16((ushort)events.MidiFileType));                  writer.Write(SwapUInt16((ushort)events.Tracks));                  writer.Write(SwapUInt16((ushort)events.DeltaTicksPerQuarterNote));                    for (int track = 0; track < events.Tracks; track++ )                  {                      IList<MidiEvent> eventList = events[track];                        writer.Write(Encoding.UTF8.GetBytes("MTrk"));                      long trackSizePosition = writer.BaseStream.Position;                      writer.Write(SwapUInt32(0));                        long absoluteTime = events.StartAbsoluteTime;                        // use a stable sort to preserve ordering of MIDI events whose                       // absolute times are the same                      MergeSort.Sort(eventList' new MidiEventComparer());                      if (eventList.Count > 0)                      {                          System.Diagnostics.Debug.Assert(MidiEvent.IsEndTrack(eventList[eventList.Count - 1])' "Exporting a track with a missing end track");                      }                      foreach (var midiEvent in eventList)                      {                          midiEvent.Export(ref absoluteTime' writer);                      }                        uint trackChunkLength = (uint)(writer.BaseStream.Position - trackSizePosition) - 4;                      writer.BaseStream.Position = trackSizePosition;                      writer.Write(SwapUInt32(trackChunkLength));                      writer.BaseStream.Position += trackChunkLength;                  }              }
Magic Number,NAudio.Midi,MidiMessage,C:\repos\naudio_NAudio\NAudio\Midi\MidiMessage.cs,MidiMessage,The following statement contains a magic number: rawData = status + (data1 << 8) + (data2 << 16);
Magic Number,NAudio.Midi,MidiMessage,C:\repos\naudio_NAudio\NAudio\Midi\MidiMessage.cs,MidiMessage,The following statement contains a magic number: rawData = status + (data1 << 8) + (data2 << 16);
Magic Number,NAudio.Midi,MidiMessage,C:\repos\naudio_NAudio\NAudio\Midi\MidiMessage.cs,ValidateNoteParameters,The following statement contains a magic number: if (note < 0 || note > 127)              {                  throw new ArgumentOutOfRangeException("note"' "Note number must be in the range 0-127");              }
Magic Number,NAudio.Midi,MidiMessage,C:\repos\naudio_NAudio\NAudio\Midi\MidiMessage.cs,ValidateNoteParameters,The following statement contains a magic number: if (volume < 0 || volume > 127)              {                  throw new ArgumentOutOfRangeException("volume"' "Velocity must be in the range 0-127");              }
Magic Number,NAudio.Midi,MidiMessage,C:\repos\naudio_NAudio\NAudio\Midi\MidiMessage.cs,ValidateChannel,The following statement contains a magic number: if ((channel < 1) || (channel > 16))              {                  throw new ArgumentOutOfRangeException("channel"' channel'                      String.Format("Channel must be 1-16 (Got {0})"' channel));              }
Magic Number,NAudio.Midi,NoteEvent,C:\repos\naudio_NAudio\NAudio\Midi\NoteEvent.cs,NoteEvent,The following statement contains a magic number: if (velocity > 127)              {                  velocity = 127;              }
Magic Number,NAudio.Midi,NoteEvent,C:\repos\naudio_NAudio\NAudio\Midi\NoteEvent.cs,NoteEvent,The following statement contains a magic number: if (velocity > 127)              {                  velocity = 127;              }
Magic Number,NAudio.Midi,NoteEvent,C:\repos\naudio_NAudio\NAudio\Midi\NoteEvent.cs,GetAsShortMessage,The following statement contains a magic number: return base.GetAsShortMessage() + (noteNumber << 8) + (velocity << 16);
Magic Number,NAudio.Midi,NoteEvent,C:\repos\naudio_NAudio\NAudio\Midi\NoteEvent.cs,GetAsShortMessage,The following statement contains a magic number: return base.GetAsShortMessage() + (noteNumber << 8) + (velocity << 16);
Magic Number,NAudio.Midi,PatchChangeEvent,C:\repos\naudio_NAudio\NAudio\Midi\PatchChangeEvent.cs,GetAsShortMessage,The following statement contains a magic number: return base.GetAsShortMessage() + (this.patch << 8);
Magic Number,NAudio.Midi,PitchWheelChangeEvent,C:\repos\naudio_NAudio\NAudio\Midi\PitchWheelChangeEvent.cs,PitchWheelChangeEvent,The following statement contains a magic number: pitch = b1 + (b2 << 7);
Magic Number,NAudio.Midi,PitchWheelChangeEvent,C:\repos\naudio_NAudio\NAudio\Midi\PitchWheelChangeEvent.cs,GetAsShortMessage,The following statement contains a magic number: return base.GetAsShortMessage() + ((pitch & 0x7f) << 8) + (((pitch >> 7) & 0x7f) << 16);
Magic Number,NAudio.Midi,PitchWheelChangeEvent,C:\repos\naudio_NAudio\NAudio\Midi\PitchWheelChangeEvent.cs,GetAsShortMessage,The following statement contains a magic number: return base.GetAsShortMessage() + ((pitch & 0x7f) << 8) + (((pitch >> 7) & 0x7f) << 16);
Magic Number,NAudio.Midi,PitchWheelChangeEvent,C:\repos\naudio_NAudio\NAudio\Midi\PitchWheelChangeEvent.cs,GetAsShortMessage,The following statement contains a magic number: return base.GetAsShortMessage() + ((pitch & 0x7f) << 8) + (((pitch >> 7) & 0x7f) << 16);
Magic Number,NAudio.Midi,PitchWheelChangeEvent,C:\repos\naudio_NAudio\NAudio\Midi\PitchWheelChangeEvent.cs,Export,The following statement contains a magic number: writer.Write((byte)((pitch >> 7) & 0x7f));
Magic Number,NAudio.Midi,SmpteOffsetEvent,C:\repos\naudio_NAudio\NAudio\Midi\SmpteOffsetEvent.cs,SmpteOffsetEvent,The following statement contains a magic number: if(length != 5)               {                  throw new FormatException(String.Format("Invalid SMPTE Offset length: Got {0}' expected 5"'length));              }
Magic Number,NAudio.Midi,TempoEvent,C:\repos\naudio_NAudio\NAudio\Midi\TempoEvent.cs,TempoEvent,The following statement contains a magic number: if(length != 3)               {                  throw new FormatException("Invalid tempo length");              }
Magic Number,NAudio.Midi,TempoEvent,C:\repos\naudio_NAudio\NAudio\Midi\TempoEvent.cs,TempoEvent,The following statement contains a magic number: microsecondsPerQuarterNote = (br.ReadByte() << 16) + (br.ReadByte() << 8) + br.ReadByte();
Magic Number,NAudio.Midi,TempoEvent,C:\repos\naudio_NAudio\NAudio\Midi\TempoEvent.cs,TempoEvent,The following statement contains a magic number: microsecondsPerQuarterNote = (br.ReadByte() << 16) + (br.ReadByte() << 8) + br.ReadByte();
Magic Number,NAudio.Midi,TempoEvent,C:\repos\naudio_NAudio\NAudio\Midi\TempoEvent.cs,ToString,The following statement contains a magic number: return String.Format("{0} {2}bpm ({1})"'                  base.ToString()'                  microsecondsPerQuarterNote'                  (60000000 / microsecondsPerQuarterNote));
Magic Number,NAudio.Midi,TempoEvent,C:\repos\naudio_NAudio\NAudio\Midi\TempoEvent.cs,Export,The following statement contains a magic number: writer.Write((byte) ((microsecondsPerQuarterNote >> 16) & 0xFF));
Magic Number,NAudio.Midi,TempoEvent,C:\repos\naudio_NAudio\NAudio\Midi\TempoEvent.cs,Export,The following statement contains a magic number: writer.Write((byte) ((microsecondsPerQuarterNote >> 8) & 0xFF));
Magic Number,NAudio.Midi,TimeSignatureEvent,C:\repos\naudio_NAudio\NAudio\Midi\TimeSignatureEvent.cs,TimeSignatureEvent,The following statement contains a magic number: if(length != 4)               {                  throw new FormatException(String.Format("Invalid time signature length: Got {0}' expected 4"' length));              }
Magic Number,NAudio.Midi,TrackSequenceNumberEvent,C:\repos\naudio_NAudio\NAudio\Midi\TrackSequenceNumberEvent.cs,TrackSequenceNumberEvent,The following statement contains a magic number: if(length != 2)               {                  throw new FormatException("Invalid sequence number length");              }
Magic Number,NAudio.Midi,TrackSequenceNumberEvent,C:\repos\naudio_NAudio\NAudio\Midi\TrackSequenceNumberEvent.cs,TrackSequenceNumberEvent,The following statement contains a magic number: sequenceNumber = (ushort) ((br.ReadByte() << 8) + br.ReadByte());
Magic Number,NAudio.Midi,TrackSequenceNumberEvent,C:\repos\naudio_NAudio\NAudio\Midi\TrackSequenceNumberEvent.cs,Export,The following statement contains a magic number: writer.Write((byte)((sequenceNumber >> 8) & 0xFF));
Magic Number,NAudio.Utils,ChunkIdentifier,C:\repos\naudio_NAudio\NAudio\Utils\ChunkIdentifier.cs,ChunkIdentifierToInt32,The following statement contains a magic number: if (s.Length != 4) throw new ArgumentException("Must be a four character string");
Magic Number,NAudio.Utils,ChunkIdentifier,C:\repos\naudio_NAudio\NAudio\Utils\ChunkIdentifier.cs,ChunkIdentifierToInt32,The following statement contains a magic number: if (bytes.Length != 4) throw new ArgumentException("Must encode to exactly four bytes");
Magic Number,NAudio.Utils,WavePositionExtensions,C:\repos\naudio_NAudio\NAudio\Utils\WavePositionExtensions.cs,GetPositionTimeSpan,The following statement contains a magic number: var pos = @this.GetPosition() / (@this.OutputWaveFormat.Channels * @this.OutputWaveFormat.BitsPerSample / 8);
Magic Number,NAudio.Utils,WavePositionExtensions,C:\repos\naudio_NAudio\NAudio\Utils\WavePositionExtensions.cs,GetPositionTimeSpan,The following statement contains a magic number: return TimeSpan.FromMilliseconds(pos * 1000.0 / @this.OutputWaveFormat.SampleRate);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,UnsignedToFloat,The following statement contains a magic number: return (((double)((long)(u - 2147483647L - 1))) + 2147483648.0);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ldexp,The following statement contains a magic number: return x * Math.Pow(2' exp);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,frexp,The following statement contains a magic number: exp = (int)Math.Floor(Math.Log(x) / Math.Log(2)) + 1;
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,frexp,The following statement contains a magic number: return 1 - (Math.Pow(2' exp) - x) / Math.Pow(2' exp);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,frexp,The following statement contains a magic number: return 1 - (Math.Pow(2' exp) - x) / Math.Pow(2' exp);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,FloatToUnsigned,The following statement contains a magic number: return ((ulong)(((long)(f - 2147483648.0)) + 2147483647L) + 1);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: if (num == 0)              {                  expon = 0; hiMant = 0; loMant = 0;              }              else              {                  fMant = frexp(num' out expon);                  if ((expon > 16384) || !(fMant < 1))                  {   //  Infinity or NaN                       expon = sign | 0x7FFF; hiMant = 0; loMant = 0; // infinity                   }                  else                  {    // Finite                       expon += 16382;                      if (expon < 0)                      {    // denormalized                          fMant = ldexp(fMant' expon);                          expon = 0;                      }                      expon |= sign;                      fMant = ldexp(fMant' 32);                      fsMant = Math.Floor(fMant);                      hiMant = FloatToUnsigned(fsMant);                      fMant = ldexp(fMant - fsMant' 32);                      fsMant = Math.Floor(fMant);                      loMant = FloatToUnsigned(fsMant);                  }              }
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: if (num == 0)              {                  expon = 0; hiMant = 0; loMant = 0;              }              else              {                  fMant = frexp(num' out expon);                  if ((expon > 16384) || !(fMant < 1))                  {   //  Infinity or NaN                       expon = sign | 0x7FFF; hiMant = 0; loMant = 0; // infinity                   }                  else                  {    // Finite                       expon += 16382;                      if (expon < 0)                      {    // denormalized                          fMant = ldexp(fMant' expon);                          expon = 0;                      }                      expon |= sign;                      fMant = ldexp(fMant' 32);                      fsMant = Math.Floor(fMant);                      hiMant = FloatToUnsigned(fsMant);                      fMant = ldexp(fMant - fsMant' 32);                      fsMant = Math.Floor(fMant);                      loMant = FloatToUnsigned(fsMant);                  }              }
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: if (num == 0)              {                  expon = 0; hiMant = 0; loMant = 0;              }              else              {                  fMant = frexp(num' out expon);                  if ((expon > 16384) || !(fMant < 1))                  {   //  Infinity or NaN                       expon = sign | 0x7FFF; hiMant = 0; loMant = 0; // infinity                   }                  else                  {    // Finite                       expon += 16382;                      if (expon < 0)                      {    // denormalized                          fMant = ldexp(fMant' expon);                          expon = 0;                      }                      expon |= sign;                      fMant = ldexp(fMant' 32);                      fsMant = Math.Floor(fMant);                      hiMant = FloatToUnsigned(fsMant);                      fMant = ldexp(fMant - fsMant' 32);                      fsMant = Math.Floor(fMant);                      loMant = FloatToUnsigned(fsMant);                  }              }
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: if (num == 0)              {                  expon = 0; hiMant = 0; loMant = 0;              }              else              {                  fMant = frexp(num' out expon);                  if ((expon > 16384) || !(fMant < 1))                  {   //  Infinity or NaN                       expon = sign | 0x7FFF; hiMant = 0; loMant = 0; // infinity                   }                  else                  {    // Finite                       expon += 16382;                      if (expon < 0)                      {    // denormalized                          fMant = ldexp(fMant' expon);                          expon = 0;                      }                      expon |= sign;                      fMant = ldexp(fMant' 32);                      fsMant = Math.Floor(fMant);                      hiMant = FloatToUnsigned(fsMant);                      fMant = ldexp(fMant - fsMant' 32);                      fsMant = Math.Floor(fMant);                      loMant = FloatToUnsigned(fsMant);                  }              }
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: byte[] bytes = new byte[10];
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[0] = (byte)(expon >> 8);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[2] = (byte)(hiMant >> 24);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[2] = (byte)(hiMant >> 24);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[3] = (byte)(hiMant >> 16);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[3] = (byte)(hiMant >> 16);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[4] = (byte)(hiMant >> 8);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[4] = (byte)(hiMant >> 8);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[5] = (byte)(hiMant);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[6] = (byte)(loMant >> 24);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[6] = (byte)(loMant >> 24);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[7] = (byte)(loMant >> 16);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[7] = (byte)(loMant >> 16);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[8] = (byte)(loMant >> 8);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[8] = (byte)(loMant >> 8);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertToIeeeExtended,The following statement contains a magic number: bytes[9] = (byte)(loMant);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: if (bytes.Length != 10) throw new Exception("Incorrect length for IEEE extended.");
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: expon = ((bytes[0] & 0x7F) << 8) | bytes[1];
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: hiMant = (uint)((bytes[2] << 24) | (bytes[3] << 16) | (bytes[4] << 8) | bytes[5]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: hiMant = (uint)((bytes[2] << 24) | (bytes[3] << 16) | (bytes[4] << 8) | bytes[5]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: hiMant = (uint)((bytes[2] << 24) | (bytes[3] << 16) | (bytes[4] << 8) | bytes[5]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: hiMant = (uint)((bytes[2] << 24) | (bytes[3] << 16) | (bytes[4] << 8) | bytes[5]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: hiMant = (uint)((bytes[2] << 24) | (bytes[3] << 16) | (bytes[4] << 8) | bytes[5]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: hiMant = (uint)((bytes[2] << 24) | (bytes[3] << 16) | (bytes[4] << 8) | bytes[5]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: hiMant = (uint)((bytes[2] << 24) | (bytes[3] << 16) | (bytes[4] << 8) | bytes[5]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: loMant = (uint)((bytes[6] << 24) | (bytes[7] << 16) | (bytes[8] << 8) | bytes[9]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: loMant = (uint)((bytes[6] << 24) | (bytes[7] << 16) | (bytes[8] << 8) | bytes[9]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: loMant = (uint)((bytes[6] << 24) | (bytes[7] << 16) | (bytes[8] << 8) | bytes[9]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: loMant = (uint)((bytes[6] << 24) | (bytes[7] << 16) | (bytes[8] << 8) | bytes[9]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: loMant = (uint)((bytes[6] << 24) | (bytes[7] << 16) | (bytes[8] << 8) | bytes[9]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: loMant = (uint)((bytes[6] << 24) | (bytes[7] << 16) | (bytes[8] << 8) | bytes[9]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: loMant = (uint)((bytes[6] << 24) | (bytes[7] << 16) | (bytes[8] << 8) | bytes[9]);
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: if (expon == 0 && hiMant == 0 && loMant == 0)              {                  f = 0;              }              else              {                  if (expon == 0x7FFF)    /* Infinity or NaN */                  {                      f = double.NaN;                  }                  else                  {                      expon -= 16383;                      f = ldexp(UnsignedToFloat(hiMant)' expon -= 31);                      f += ldexp(UnsignedToFloat(loMant)' expon -= 32);                  }              }
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: if (expon == 0 && hiMant == 0 && loMant == 0)              {                  f = 0;              }              else              {                  if (expon == 0x7FFF)    /* Infinity or NaN */                  {                      f = double.NaN;                  }                  else                  {                      expon -= 16383;                      f = ldexp(UnsignedToFloat(hiMant)' expon -= 31);                      f += ldexp(UnsignedToFloat(loMant)' expon -= 32);                  }              }
Magic Number,NAudio.Utils,IEEE,C:\repos\naudio_NAudio\NAudio\Utils\IEEE.cs,ConvertFromIeeeExtended,The following statement contains a magic number: if (expon == 0 && hiMant == 0 && loMant == 0)              {                  f = 0;              }              else              {                  if (expon == 0x7FFF)    /* Infinity or NaN */                  {                      f = double.NaN;                  }                  else                  {                      expon -= 16383;                      f = ldexp(UnsignedToFloat(hiMant)' expon -= 31);                      f += ldexp(UnsignedToFloat(loMant)' expon -= 32);                  }              }
Magic Number,NAudio.Utils,HResult,C:\repos\naudio_NAudio\NAudio\Utils\HResult.cs,MAKE_HRESULT,The following statement contains a magic number: return (int) (((uint)sev) << 31 | ((uint)fac) << 16 | ((uint)code));
Magic Number,NAudio.Utils,HResult,C:\repos\naudio_NAudio\NAudio\Utils\HResult.cs,MAKE_HRESULT,The following statement contains a magic number: return (int) (((uint)sev) << 31 | ((uint)fac) << 16 | ((uint)code));
Magic Number,NAudio.Utils,MergeSort,C:\repos\naudio_NAudio\NAudio\Utils\MergeSort.cs,Sort,The following statement contains a magic number: int midIndex = (lowIndex + highIndex) / 2;
Magic Number,NAudio.Utils,ProgressLog,C:\repos\naudio_NAudio\NAudio\Utils\ProgressLog.cs,InitializeComponent,The following statement contains a magic number: this.richTextBoxLog.Size = new System.Drawing.Size(311' 129);
Magic Number,NAudio.Utils,ProgressLog,C:\repos\naudio_NAudio\NAudio\Utils\ProgressLog.cs,InitializeComponent,The following statement contains a magic number: this.richTextBoxLog.Size = new System.Drawing.Size(311' 129);
Magic Number,NAudio.Utils,ProgressLog,C:\repos\naudio_NAudio\NAudio\Utils\ProgressLog.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(313' 131);
Magic Number,NAudio.Utils,ProgressLog,C:\repos\naudio_NAudio\NAudio\Utils\ProgressLog.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(313' 131);
Magic Number,NAudio.Wave.Asio,AsioDriver,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioDriver.cs,GetDriverName,The following statement contains a magic number: var name = new StringBuilder(256);
Magic Number,NAudio.Wave.Asio,AsioDriver,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioDriver.cs,GetErrorMessage,The following statement contains a magic number: var errorMessage = new StringBuilder(256);
Magic Number,NAudio.Wave.Asio,AsioDriver,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioDriver.cs,InitFromGuid,The following statement contains a magic number: const int INDEX_VTABLE_FIRST_METHOD = 3;
Magic Number,NAudio.Wave.Asio,AsioDriverExt,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioDriverExt.cs,AsioMessageCallBack,The following statement contains a magic number: switch (selector)              {                  case AsioMessageSelector.kAsioSelectorSupported:                      AsioMessageSelector subValue = (AsioMessageSelector)Enum.ToObject(typeof(AsioMessageSelector)' value);                      switch (subValue)                      {                          case AsioMessageSelector.kAsioEngineVersion:                              return 1;                          case AsioMessageSelector.kAsioResetRequest:                              return 0;                          case AsioMessageSelector.kAsioBufferSizeChange:                              return 0;                          case AsioMessageSelector.kAsioResyncRequest:                              return 0;                          case AsioMessageSelector.kAsioLatenciesChanged:                              return 0;                          case AsioMessageSelector.kAsioSupportsTimeInfo:  //                            return 1; DON'T SUPPORT FOR NOW. NEED MORE TESTING.                              return 0;                          case AsioMessageSelector.kAsioSupportsTimeCode:  //                            return 1; DON'T SUPPORT FOR NOW. NEED MORE TESTING.                              return 0;                      }                      break;                  case AsioMessageSelector.kAsioEngineVersion:                      return 2;                  case AsioMessageSelector.kAsioResetRequest:                      return 1;                  case AsioMessageSelector.kAsioBufferSizeChange:                      return 0;                  case AsioMessageSelector.kAsioResyncRequest:                      return 0;                  case AsioMessageSelector.kAsioLatenciesChanged:                      return 0;                  case AsioMessageSelector.kAsioSupportsTimeInfo:                      return 0;                  case AsioMessageSelector.kAsioSupportsTimeCode:                      return 0;              }
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,SelectSampleConvertor,The following statement contains a magic number: bool is2Channels = waveFormat.Channels == 2;
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,SelectSampleConvertor,The following statement contains a magic number: switch (asioType)              {                  case AsioSampleType.Int32LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToInt2Channels : (SampleConvertor)ConvertorShortToIntGeneric;                              break;                          case 32:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToInt2Channels : (SampleConvertor)ConvertorFloatToIntGeneric;                              break;                      }                      break;                  case AsioSampleType.Int16LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToShort2Channels : (SampleConvertor)ConvertorShortToShortGeneric;                              break;                          case 32:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToShort2Channels : (SampleConvertor)ConvertorFloatToShortGeneric;                              break;                      }                      break;                  case AsioSampleType.Int24LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              throw new ArgumentException("Not a supported conversion");                          case 32:                              convertor = ConverterFloatTo24LSBGeneric;                              break;                      }                      break;                  case AsioSampleType.Float32LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              throw new ArgumentException("Not a supported conversion");                          case 32:                              convertor = ConverterFloatToFloatGeneric;                              break;                      }                      break;                    default:                      throw new ArgumentException(                          String.Format("ASIO Buffer Type {0} is not yet supported."'                                        Enum.GetName(typeof(AsioSampleType)' asioType)));              }
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,SelectSampleConvertor,The following statement contains a magic number: switch (asioType)              {                  case AsioSampleType.Int32LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToInt2Channels : (SampleConvertor)ConvertorShortToIntGeneric;                              break;                          case 32:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToInt2Channels : (SampleConvertor)ConvertorFloatToIntGeneric;                              break;                      }                      break;                  case AsioSampleType.Int16LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToShort2Channels : (SampleConvertor)ConvertorShortToShortGeneric;                              break;                          case 32:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToShort2Channels : (SampleConvertor)ConvertorFloatToShortGeneric;                              break;                      }                      break;                  case AsioSampleType.Int24LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              throw new ArgumentException("Not a supported conversion");                          case 32:                              convertor = ConverterFloatTo24LSBGeneric;                              break;                      }                      break;                  case AsioSampleType.Float32LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              throw new ArgumentException("Not a supported conversion");                          case 32:                              convertor = ConverterFloatToFloatGeneric;                              break;                      }                      break;                    default:                      throw new ArgumentException(                          String.Format("ASIO Buffer Type {0} is not yet supported."'                                        Enum.GetName(typeof(AsioSampleType)' asioType)));              }
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,SelectSampleConvertor,The following statement contains a magic number: switch (asioType)              {                  case AsioSampleType.Int32LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToInt2Channels : (SampleConvertor)ConvertorShortToIntGeneric;                              break;                          case 32:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToInt2Channels : (SampleConvertor)ConvertorFloatToIntGeneric;                              break;                      }                      break;                  case AsioSampleType.Int16LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToShort2Channels : (SampleConvertor)ConvertorShortToShortGeneric;                              break;                          case 32:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToShort2Channels : (SampleConvertor)ConvertorFloatToShortGeneric;                              break;                      }                      break;                  case AsioSampleType.Int24LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              throw new ArgumentException("Not a supported conversion");                          case 32:                              convertor = ConverterFloatTo24LSBGeneric;                              break;                      }                      break;                  case AsioSampleType.Float32LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              throw new ArgumentException("Not a supported conversion");                          case 32:                              convertor = ConverterFloatToFloatGeneric;                              break;                      }                      break;                    default:                      throw new ArgumentException(                          String.Format("ASIO Buffer Type {0} is not yet supported."'                                        Enum.GetName(typeof(AsioSampleType)' asioType)));              }
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,SelectSampleConvertor,The following statement contains a magic number: switch (asioType)              {                  case AsioSampleType.Int32LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToInt2Channels : (SampleConvertor)ConvertorShortToIntGeneric;                              break;                          case 32:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToInt2Channels : (SampleConvertor)ConvertorFloatToIntGeneric;                              break;                      }                      break;                  case AsioSampleType.Int16LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToShort2Channels : (SampleConvertor)ConvertorShortToShortGeneric;                              break;                          case 32:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToShort2Channels : (SampleConvertor)ConvertorFloatToShortGeneric;                              break;                      }                      break;                  case AsioSampleType.Int24LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              throw new ArgumentException("Not a supported conversion");                          case 32:                              convertor = ConverterFloatTo24LSBGeneric;                              break;                      }                      break;                  case AsioSampleType.Float32LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              throw new ArgumentException("Not a supported conversion");                          case 32:                              convertor = ConverterFloatToFloatGeneric;                              break;                      }                      break;                    default:                      throw new ArgumentException(                          String.Format("ASIO Buffer Type {0} is not yet supported."'                                        Enum.GetName(typeof(AsioSampleType)' asioType)));              }
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,SelectSampleConvertor,The following statement contains a magic number: switch (asioType)              {                  case AsioSampleType.Int32LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToInt2Channels : (SampleConvertor)ConvertorShortToIntGeneric;                              break;                          case 32:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToInt2Channels : (SampleConvertor)ConvertorFloatToIntGeneric;                              break;                      }                      break;                  case AsioSampleType.Int16LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToShort2Channels : (SampleConvertor)ConvertorShortToShortGeneric;                              break;                          case 32:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToShort2Channels : (SampleConvertor)ConvertorFloatToShortGeneric;                              break;                      }                      break;                  case AsioSampleType.Int24LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              throw new ArgumentException("Not a supported conversion");                          case 32:                              convertor = ConverterFloatTo24LSBGeneric;                              break;                      }                      break;                  case AsioSampleType.Float32LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              throw new ArgumentException("Not a supported conversion");                          case 32:                              convertor = ConverterFloatToFloatGeneric;                              break;                      }                      break;                    default:                      throw new ArgumentException(                          String.Format("ASIO Buffer Type {0} is not yet supported."'                                        Enum.GetName(typeof(AsioSampleType)' asioType)));              }
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,SelectSampleConvertor,The following statement contains a magic number: switch (asioType)              {                  case AsioSampleType.Int32LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToInt2Channels : (SampleConvertor)ConvertorShortToIntGeneric;                              break;                          case 32:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToInt2Channels : (SampleConvertor)ConvertorFloatToIntGeneric;                              break;                      }                      break;                  case AsioSampleType.Int16LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToShort2Channels : (SampleConvertor)ConvertorShortToShortGeneric;                              break;                          case 32:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToShort2Channels : (SampleConvertor)ConvertorFloatToShortGeneric;                              break;                      }                      break;                  case AsioSampleType.Int24LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              throw new ArgumentException("Not a supported conversion");                          case 32:                              convertor = ConverterFloatTo24LSBGeneric;                              break;                      }                      break;                  case AsioSampleType.Float32LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              throw new ArgumentException("Not a supported conversion");                          case 32:                              convertor = ConverterFloatToFloatGeneric;                              break;                      }                      break;                    default:                      throw new ArgumentException(                          String.Format("ASIO Buffer Type {0} is not yet supported."'                                        Enum.GetName(typeof(AsioSampleType)' asioType)));              }
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,SelectSampleConvertor,The following statement contains a magic number: switch (asioType)              {                  case AsioSampleType.Int32LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToInt2Channels : (SampleConvertor)ConvertorShortToIntGeneric;                              break;                          case 32:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToInt2Channels : (SampleConvertor)ConvertorFloatToIntGeneric;                              break;                      }                      break;                  case AsioSampleType.Int16LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToShort2Channels : (SampleConvertor)ConvertorShortToShortGeneric;                              break;                          case 32:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToShort2Channels : (SampleConvertor)ConvertorFloatToShortGeneric;                              break;                      }                      break;                  case AsioSampleType.Int24LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              throw new ArgumentException("Not a supported conversion");                          case 32:                              convertor = ConverterFloatTo24LSBGeneric;                              break;                      }                      break;                  case AsioSampleType.Float32LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              throw new ArgumentException("Not a supported conversion");                          case 32:                              convertor = ConverterFloatToFloatGeneric;                              break;                      }                      break;                    default:                      throw new ArgumentException(                          String.Format("ASIO Buffer Type {0} is not yet supported."'                                        Enum.GetName(typeof(AsioSampleType)' asioType)));              }
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,SelectSampleConvertor,The following statement contains a magic number: switch (asioType)              {                  case AsioSampleType.Int32LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToInt2Channels : (SampleConvertor)ConvertorShortToIntGeneric;                              break;                          case 32:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToInt2Channels : (SampleConvertor)ConvertorFloatToIntGeneric;                              break;                      }                      break;                  case AsioSampleType.Int16LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToShort2Channels : (SampleConvertor)ConvertorShortToShortGeneric;                              break;                          case 32:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToShort2Channels : (SampleConvertor)ConvertorFloatToShortGeneric;                              break;                      }                      break;                  case AsioSampleType.Int24LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              throw new ArgumentException("Not a supported conversion");                          case 32:                              convertor = ConverterFloatTo24LSBGeneric;                              break;                      }                      break;                  case AsioSampleType.Float32LSB:                      switch (waveFormat.BitsPerSample)                      {                          case 16:                              throw new ArgumentException("Not a supported conversion");                          case 32:                              convertor = ConverterFloatToFloatGeneric;                              break;                      }                      break;                    default:                      throw new ArgumentException(                          String.Format("ASIO Buffer Type {0} is not yet supported."'                                        Enum.GetName(typeof(AsioSampleType)' asioType)));              }
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,ConvertorShortToInt2Channels,The following statement contains a magic number: unsafe              {                  short* inputSamples = (short*)inputInterleavedBuffer;                  // Use a trick (short instead of int to avoid any convertion from 16Bit to 32Bit)                  short* leftSamples = (short*)asioOutputBuffers[0];                  short* rightSamples = (short*)asioOutputBuffers[1];                    // Point to upper 16 bits of the 32Bits.                  leftSamples++;                  rightSamples++;                  for (int i = 0; i < nbSamples; i++)                  {                      *leftSamples = inputSamples[0];                      *rightSamples = inputSamples[1];                      // Go to next sample                      inputSamples += 2;                      // Add 4 Bytes                      leftSamples += 2;                      rightSamples += 2;                  }              }
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,ConvertorShortToInt2Channels,The following statement contains a magic number: unsafe              {                  short* inputSamples = (short*)inputInterleavedBuffer;                  // Use a trick (short instead of int to avoid any convertion from 16Bit to 32Bit)                  short* leftSamples = (short*)asioOutputBuffers[0];                  short* rightSamples = (short*)asioOutputBuffers[1];                    // Point to upper 16 bits of the 32Bits.                  leftSamples++;                  rightSamples++;                  for (int i = 0; i < nbSamples; i++)                  {                      *leftSamples = inputSamples[0];                      *rightSamples = inputSamples[1];                      // Go to next sample                      inputSamples += 2;                      // Add 4 Bytes                      leftSamples += 2;                      rightSamples += 2;                  }              }
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,ConvertorShortToInt2Channels,The following statement contains a magic number: unsafe              {                  short* inputSamples = (short*)inputInterleavedBuffer;                  // Use a trick (short instead of int to avoid any convertion from 16Bit to 32Bit)                  short* leftSamples = (short*)asioOutputBuffers[0];                  short* rightSamples = (short*)asioOutputBuffers[1];                    // Point to upper 16 bits of the 32Bits.                  leftSamples++;                  rightSamples++;                  for (int i = 0; i < nbSamples; i++)                  {                      *leftSamples = inputSamples[0];                      *rightSamples = inputSamples[1];                      // Go to next sample                      inputSamples += 2;                      // Add 4 Bytes                      leftSamples += 2;                      rightSamples += 2;                  }              }
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,ConvertorShortToIntGeneric,The following statement contains a magic number: unsafe              {                  short* inputSamples = (short*)inputInterleavedBuffer;                  // Use a trick (short instead of int to avoid any convertion from 16Bit to 32Bit)                  short*[] samples = new short*[nbChannels];                  for (int i = 0; i < nbChannels; i++)                  {                      samples[i] = (short*)asioOutputBuffers[i];                      // Point to upper 16 bits of the 32Bits.                      samples[i]++;                  }                    for (int i = 0; i < nbSamples; i++)                  {                      for (int j = 0; j < nbChannels; j++)                      {                          *samples[j] = *inputSamples++;                          samples[j] += 2;                      }                  }              }
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,ConvertorFloatToInt2Channels,The following statement contains a magic number: unsafe              {                  float* inputSamples = (float*)inputInterleavedBuffer;                  int* leftSamples = (int*)asioOutputBuffers[0];                  int* rightSamples = (int*)asioOutputBuffers[1];                    for (int i = 0; i < nbSamples; i++)                  {                      *leftSamples++ = clampToInt(inputSamples[0]);                      *rightSamples++ = clampToInt(inputSamples[1]);                      inputSamples += 2;                  }              }
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,ConvertorShortToShort2Channels,The following statement contains a magic number: unsafe              {                  short* inputSamples = (short*)inputInterleavedBuffer;                  // Use a trick (short instead of int to avoid any convertion from 16Bit to 32Bit)                  short* leftSamples = (short*)asioOutputBuffers[0];                  short* rightSamples = (short*)asioOutputBuffers[1];                    // Point to upper 16 bits of the 32Bits.                  for (int i = 0; i < nbSamples; i++)                  {                      *leftSamples++ = inputSamples[0];                      *rightSamples++ = inputSamples[1];                      // Go to next sample                      inputSamples += 2;                  }              }
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,ConvertorFloatToShort2Channels,The following statement contains a magic number: unsafe              {                  float* inputSamples = (float*)inputInterleavedBuffer;                  // Use a trick (short instead of int to avoid any convertion from 16Bit to 32Bit)                  short* leftSamples = (short*)asioOutputBuffers[0];                  short* rightSamples = (short*)asioOutputBuffers[1];                    for (int i = 0; i < nbSamples; i++)                  {                      *leftSamples++ = clampToShort(inputSamples[0]);                      *rightSamples++ = clampToShort(inputSamples[1]);                      inputSamples += 2;                  }              }
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,ConverterFloatTo24LSBGeneric,The following statement contains a magic number: unsafe              {                  float* inputSamples = (float*)inputInterleavedBuffer;                                    byte*[] samples = new byte*[nbChannels];                  for (int i = 0; i < nbChannels; i++)                  {                      samples[i] = (byte*)asioOutputBuffers[i];                  }                    for (int i = 0; i < nbSamples; i++)                  {                      for (int j = 0; j < nbChannels; j++)                      {                          int sample24 = clampTo24Bit(*inputSamples++);                          *(samples[j]++) = (byte)(sample24);                          *(samples[j]++) = (byte)(sample24 >> 8);                          *(samples[j]++) = (byte)(sample24 >> 16);                      }                  }              }
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,ConverterFloatTo24LSBGeneric,The following statement contains a magic number: unsafe              {                  float* inputSamples = (float*)inputInterleavedBuffer;                                    byte*[] samples = new byte*[nbChannels];                  for (int i = 0; i < nbChannels; i++)                  {                      samples[i] = (byte*)asioOutputBuffers[i];                  }                    for (int i = 0; i < nbSamples; i++)                  {                      for (int j = 0; j < nbChannels; j++)                      {                          int sample24 = clampTo24Bit(*inputSamples++);                          *(samples[j]++) = (byte)(sample24);                          *(samples[j]++) = (byte)(sample24 >> 8);                          *(samples[j]++) = (byte)(sample24 >> 16);                      }                  }              }
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,clampTo24Bit,The following statement contains a magic number: return (int)(sampleValue * 8388607.0);
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,clampToInt,The following statement contains a magic number: return (int)(sampleValue * 2147483647.0);
Magic Number,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,clampToShort,The following statement contains a magic number: return (short)(sampleValue * 32767.0);
Magic Number,NAudio.Wave.Compression,AcmDriver,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmDriver.cs,ShowFormatChooseDialog,The following statement contains a magic number: int maxFormatSize = 200;
Magic Number,NAudio.Wave.Compression,AcmDriver,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmDriver.cs,GetFormats,The following statement contains a magic number: formatDetails.waveFormatByteSize = 1024;
Magic Number,NAudio.Wave.Compression,AcmStream,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmStream.cs,AcmStream,The following statement contains a magic number: try              {                  streamHandle = IntPtr.Zero;                  this.sourceFormat = sourceFormat;                  int sourceBufferSize = Math.Max(65536' sourceFormat.AverageBytesPerSecond);                  sourceBufferSize -= (sourceBufferSize % sourceFormat.BlockAlign);                  MmException.Try(AcmInterop.acmStreamOpen(out streamHandle' IntPtr.Zero' sourceFormat' destFormat' null' IntPtr.Zero' IntPtr.Zero' AcmStreamOpenFlags.NonRealTime)' "acmStreamOpen");                    int destBufferSize = SourceToDest(sourceBufferSize);                  streamHeader = new AcmStreamHeader(streamHandle' sourceBufferSize' destBufferSize);                  driverHandle = IntPtr.Zero;              }              catch              {                  // suppress the finalise and clean up resources                  Dispose();                  throw;              }
Magic Number,NAudio.Wave.Compression,AcmStream,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmStream.cs,AcmStream,The following statement contains a magic number: int sourceBufferSize = Math.Max(16384' sourceFormat.AverageBytesPerSecond);
Magic Number,NAudio.Wave.Compression,AcmStream,C:\repos\naudio_NAudio\NAudio\Wave\Compression\AcmStream.cs,SuggestPcmFormat,The following statement contains a magic number: WaveFormat suggestedFormat = new WaveFormat(compressedFormat.SampleRate' 16' compressedFormat.Channels);
Magic Number,NAudio.Wave.SampleProviders,FadeInOutSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\FadeInOutSampleProvider.cs,BeginFadeIn,The following statement contains a magic number: lock (lockObject)              {                  fadeSamplePosition = 0;                  fadeSampleCount = (int)((fadeDurationInMilliseconds * source.WaveFormat.SampleRate) / 1000);                  fadeState = FadeState.FadingIn;              }
Magic Number,NAudio.Wave.SampleProviders,FadeInOutSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\FadeInOutSampleProvider.cs,BeginFadeOut,The following statement contains a magic number: lock (lockObject)              {                  fadeSamplePosition = 0;                  fadeSampleCount = (int)((fadeDurationInMilliseconds * source.WaveFormat.SampleRate) / 1000);                  fadeState = FadeState.FadingOut;              }
Magic Number,NAudio.Wave.SampleProviders,OffsetSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\OffsetSampleProvider.cs,Read,The following statement contains a magic number: if (phase == 2) // skip              {                  if (SkipOverSamples > 0)                  {                      var skipBuffer = new float[WaveFormat.SampleRate * WaveFormat.Channels];                      // skip everything                      int samplesSkipped = 0;                      while (samplesSkipped < SkipOverSamples)                      {                          int samplesRequired = Math.Min(SkipOverSamples - samplesSkipped' skipBuffer.Length);                          var read = sourceProvider.Read(skipBuffer' 0' samplesRequired);                          if (read == 0) // source has ended while still in skip                          {                              break;                          }                          samplesSkipped += read;                      }                  }                  phase++;                  phasePos = 0;              }
Magic Number,NAudio.Wave.SampleProviders,OffsetSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\OffsetSampleProvider.cs,Read,The following statement contains a magic number: if (phase == 3) // take              {                  int samplesRequired = count - samplesRead;                  if (takeSamples != 0)                      samplesRequired = Math.Min(samplesRequired' takeSamples - phasePos);                  int read = sourceProvider.Read(buffer' offset + samplesRead' samplesRequired);                  phasePos += read;                  samplesRead += read;                  if (read < samplesRequired || (takeSamples > 0 && phasePos >= takeSamples))                  {                      phase++;                      phasePos = 0;                  }              }
Magic Number,NAudio.Wave.SampleProviders,OffsetSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\OffsetSampleProvider.cs,Read,The following statement contains a magic number: if (phase == 4) // lead out              {                  int samplesRequired = Math.Min(count - samplesRead' LeadOutSamples - phasePos);                  for (int n = 0; n < samplesRequired; n++)                  {                      buffer[offset + samplesRead + n] = 0;                  }                  phasePos += samplesRequired;                  samplesRead += samplesRequired;                  if (phasePos >= LeadOutSamples)                  {                      phase++;                      phasePos = 0;                  }              }
Magic Number,NAudio.Wave.SampleProviders,Pcm32BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm32BitToSampleProvider.cs,Read,The following statement contains a magic number: int sourceBytesRequired = count*4;
Magic Number,NAudio.Wave.SampleProviders,Pcm32BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm32BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 4)              {                  buffer[outIndex++] = (((sbyte) sourceBuffer[n + 3] << 24 |                                         sourceBuffer[n + 2] << 16) |                                        (sourceBuffer[n + 1] << 8) |                                        sourceBuffer[n])/2147483648f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm32BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm32BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 4)              {                  buffer[outIndex++] = (((sbyte) sourceBuffer[n + 3] << 24 |                                         sourceBuffer[n + 2] << 16) |                                        (sourceBuffer[n + 1] << 8) |                                        sourceBuffer[n])/2147483648f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm32BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm32BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 4)              {                  buffer[outIndex++] = (((sbyte) sourceBuffer[n + 3] << 24 |                                         sourceBuffer[n + 2] << 16) |                                        (sourceBuffer[n + 1] << 8) |                                        sourceBuffer[n])/2147483648f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm32BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm32BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 4)              {                  buffer[outIndex++] = (((sbyte) sourceBuffer[n + 3] << 24 |                                         sourceBuffer[n + 2] << 16) |                                        (sourceBuffer[n + 1] << 8) |                                        sourceBuffer[n])/2147483648f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm32BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm32BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 4)              {                  buffer[outIndex++] = (((sbyte) sourceBuffer[n + 3] << 24 |                                         sourceBuffer[n + 2] << 16) |                                        (sourceBuffer[n + 1] << 8) |                                        sourceBuffer[n])/2147483648f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm32BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm32BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 4)              {                  buffer[outIndex++] = (((sbyte) sourceBuffer[n + 3] << 24 |                                         sourceBuffer[n + 2] << 16) |                                        (sourceBuffer[n + 1] << 8) |                                        sourceBuffer[n])/2147483648f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm32BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm32BitToSampleProvider.cs,Read,The following statement contains a magic number: return bytesRead/4;
Magic Number,NAudio.Wave.SampleProviders,SampleProviderConverters,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleProviderConverters.cs,ConvertWaveProviderIntoSampleProvider,The following statement contains a magic number: if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.Pcm)              {                  // go to float                  if (waveProvider.WaveFormat.BitsPerSample == 8)                  {                      sampleProvider = new Pcm8BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 16)                  {                      sampleProvider = new Pcm16BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 24)                  {                      sampleProvider = new Pcm24BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 32)                  {                      sampleProvider = new Pcm32BitToSampleProvider(waveProvider);                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }              else if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  if (waveProvider.WaveFormat.BitsPerSample == 64)                      sampleProvider = new WaveToSampleProvider64(waveProvider);                  else                      sampleProvider = new WaveToSampleProvider(waveProvider);              }              else              {                  throw new ArgumentException("Unsupported source encoding");              }
Magic Number,NAudio.Wave.SampleProviders,SampleProviderConverters,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleProviderConverters.cs,ConvertWaveProviderIntoSampleProvider,The following statement contains a magic number: if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.Pcm)              {                  // go to float                  if (waveProvider.WaveFormat.BitsPerSample == 8)                  {                      sampleProvider = new Pcm8BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 16)                  {                      sampleProvider = new Pcm16BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 24)                  {                      sampleProvider = new Pcm24BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 32)                  {                      sampleProvider = new Pcm32BitToSampleProvider(waveProvider);                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }              else if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  if (waveProvider.WaveFormat.BitsPerSample == 64)                      sampleProvider = new WaveToSampleProvider64(waveProvider);                  else                      sampleProvider = new WaveToSampleProvider(waveProvider);              }              else              {                  throw new ArgumentException("Unsupported source encoding");              }
Magic Number,NAudio.Wave.SampleProviders,SampleProviderConverters,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleProviderConverters.cs,ConvertWaveProviderIntoSampleProvider,The following statement contains a magic number: if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.Pcm)              {                  // go to float                  if (waveProvider.WaveFormat.BitsPerSample == 8)                  {                      sampleProvider = new Pcm8BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 16)                  {                      sampleProvider = new Pcm16BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 24)                  {                      sampleProvider = new Pcm24BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 32)                  {                      sampleProvider = new Pcm32BitToSampleProvider(waveProvider);                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }              else if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  if (waveProvider.WaveFormat.BitsPerSample == 64)                      sampleProvider = new WaveToSampleProvider64(waveProvider);                  else                      sampleProvider = new WaveToSampleProvider(waveProvider);              }              else              {                  throw new ArgumentException("Unsupported source encoding");              }
Magic Number,NAudio.Wave.SampleProviders,SampleProviderConverters,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleProviderConverters.cs,ConvertWaveProviderIntoSampleProvider,The following statement contains a magic number: if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.Pcm)              {                  // go to float                  if (waveProvider.WaveFormat.BitsPerSample == 8)                  {                      sampleProvider = new Pcm8BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 16)                  {                      sampleProvider = new Pcm16BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 24)                  {                      sampleProvider = new Pcm24BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 32)                  {                      sampleProvider = new Pcm32BitToSampleProvider(waveProvider);                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }              else if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  if (waveProvider.WaveFormat.BitsPerSample == 64)                      sampleProvider = new WaveToSampleProvider64(waveProvider);                  else                      sampleProvider = new WaveToSampleProvider(waveProvider);              }              else              {                  throw new ArgumentException("Unsupported source encoding");              }
Magic Number,NAudio.Wave.SampleProviders,SampleProviderConverters,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleProviderConverters.cs,ConvertWaveProviderIntoSampleProvider,The following statement contains a magic number: if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.Pcm)              {                  // go to float                  if (waveProvider.WaveFormat.BitsPerSample == 8)                  {                      sampleProvider = new Pcm8BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 16)                  {                      sampleProvider = new Pcm16BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 24)                  {                      sampleProvider = new Pcm24BitToSampleProvider(waveProvider);                  }                  else if (waveProvider.WaveFormat.BitsPerSample == 32)                  {                      sampleProvider = new Pcm32BitToSampleProvider(waveProvider);                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }              else if (waveProvider.WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  if (waveProvider.WaveFormat.BitsPerSample == 64)                      sampleProvider = new WaveToSampleProvider64(waveProvider);                  else                      sampleProvider = new WaveToSampleProvider(waveProvider);              }              else              {                  throw new ArgumentException("Unsupported source encoding");              }
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider16.cs,SampleToWaveProvider16,The following statement contains a magic number: if (sourceProvider.WaveFormat.BitsPerSample != 32)                  throw new ArgumentException("Input source provider must be 32 bit"' nameof(sourceProvider));
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider16.cs,SampleToWaveProvider16,The following statement contains a magic number: waveFormat = new WaveFormat(sourceProvider.WaveFormat.SampleRate' 16' sourceProvider.WaveFormat.Channels);
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider16.cs,Read,The following statement contains a magic number: int samplesRequired = numBytes / 2;
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider16.cs,Read,The following statement contains a magic number: int destOffset = offset / 2;
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider16.cs,Read,The following statement contains a magic number: for (int sample = 0; sample < sourceSamples; sample++)              {                  // adjust volume                  float sample32 = sourceBuffer[sample] * volume;                  // clip                  if (sample32 > 1.0f)                      sample32 = 1.0f;                  if (sample32 < -1.0f)                      sample32 = -1.0f;                  destWaveBuffer.ShortBuffer[destOffset++] = (short)(sample32 * 32767);              }
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider16.cs,Read,The following statement contains a magic number: return sourceSamples * 2;
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider24,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider24.cs,SampleToWaveProvider24,The following statement contains a magic number: if (sourceProvider.WaveFormat.BitsPerSample != 32)                  throw new ArgumentException("Input source provider must be 32 bit"' "sourceProvider");
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider24,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider24.cs,SampleToWaveProvider24,The following statement contains a magic number: waveFormat = new WaveFormat(sourceProvider.WaveFormat.SampleRate' 24' sourceProvider.WaveFormat.Channels);
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider24,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider24.cs,Read,The following statement contains a magic number: var samplesRequired = numBytes / 3;
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider24,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider24.cs,Read,The following statement contains a magic number: for (var sample = 0; sample < sourceSamples; sample++)              {                  // adjust volume                  var sample32 = sourceBuffer[sample] * volume;                  // clip                  if (sample32 > 1.0f)                      sample32 = 1.0f;                  if (sample32 < -1.0f)                      sample32 = -1.0f;                    var sample24 = (int) (sample32*8388607.0);                  destBuffer[destOffset++] = (byte)(sample24);                  destBuffer[destOffset++] = (byte)(sample24 >> 8);                  destBuffer[destOffset++] = (byte)(sample24 >> 16);              }
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider24,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider24.cs,Read,The following statement contains a magic number: for (var sample = 0; sample < sourceSamples; sample++)              {                  // adjust volume                  var sample32 = sourceBuffer[sample] * volume;                  // clip                  if (sample32 > 1.0f)                      sample32 = 1.0f;                  if (sample32 < -1.0f)                      sample32 = -1.0f;                    var sample24 = (int) (sample32*8388607.0);                  destBuffer[destOffset++] = (byte)(sample24);                  destBuffer[destOffset++] = (byte)(sample24 >> 8);                  destBuffer[destOffset++] = (byte)(sample24 >> 16);              }
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider24,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider24.cs,Read,The following statement contains a magic number: for (var sample = 0; sample < sourceSamples; sample++)              {                  // adjust volume                  var sample32 = sourceBuffer[sample] * volume;                  // clip                  if (sample32 > 1.0f)                      sample32 = 1.0f;                  if (sample32 < -1.0f)                      sample32 = -1.0f;                    var sample24 = (int) (sample32*8388607.0);                  destBuffer[destOffset++] = (byte)(sample24);                  destBuffer[destOffset++] = (byte)(sample24 >> 8);                  destBuffer[destOffset++] = (byte)(sample24 >> 16);              }
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider24,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider24.cs,Read,The following statement contains a magic number: return sourceSamples * 3;
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,SignalGenerator,The following statement contains a magic number: Frequency = 440.0;
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,SignalGenerator,The following statement contains a magic number: SweepLengthSecs = 2;
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,Read,The following statement contains a magic number: for (int sampleCount = 0; sampleCount < count/waveFormat.Channels; sampleCount++)              {                  switch (Type)                  {                      case SignalGeneratorType.Sin:                            // Sinus Generator                            multiple = TwoPi*Frequency/waveFormat.SampleRate;                          sampleValue = Gain*Math.Sin(nSample*multiple);                            nSample++;                            break;                          case SignalGeneratorType.Square:                            // Square Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = sampleSaw > 0 ? Gain : -Gain;                            nSample++;                          break;                        case SignalGeneratorType.Triangle:                            // Triangle Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2);                          sampleValue = 2*sampleSaw;                          if (sampleValue > 1)                              sampleValue = 2 - sampleValue;                          if (sampleValue < -1)                              sampleValue = -2 - sampleValue;                            sampleValue *= Gain;                            nSample++;                          break;                        case SignalGeneratorType.SawTooth:                            // SawTooth Generator                            multiple = 2*Frequency/waveFormat.SampleRate;                          sampleSaw = ((nSample*multiple)%2) - 1;                          sampleValue = Gain*sampleSaw;                            nSample++;                          break;                        case SignalGeneratorType.White:                            // White Noise Generator                          sampleValue = (Gain*NextRandomTwo());                          break;                        case SignalGeneratorType.Pink:                            // Pink Noise Generator                            double white = NextRandomTwo();                          pinkNoiseBuffer[0] = 0.99886*pinkNoiseBuffer[0] + white*0.0555179;                          pinkNoiseBuffer[1] = 0.99332*pinkNoiseBuffer[1] + white*0.0750759;                          pinkNoiseBuffer[2] = 0.96900*pinkNoiseBuffer[2] + white*0.1538520;                          pinkNoiseBuffer[3] = 0.86650*pinkNoiseBuffer[3] + white*0.3104856;                          pinkNoiseBuffer[4] = 0.55000*pinkNoiseBuffer[4] + white*0.5329522;                          pinkNoiseBuffer[5] = -0.7616*pinkNoiseBuffer[5] - white*0.0168980;                          double pink = pinkNoiseBuffer[0] + pinkNoiseBuffer[1] + pinkNoiseBuffer[2] + pinkNoiseBuffer[3] + pinkNoiseBuffer[4] + pinkNoiseBuffer[5] + pinkNoiseBuffer[6] + white*0.5362;                          pinkNoiseBuffer[6] = white*0.115926;                          sampleValue = (Gain*(pink/5));                          break;                        case SignalGeneratorType.Sweep:                            // Sweep Generator                          double f = Math.Exp(FrequencyLog + (nSample*(FrequencyEndLog - FrequencyLog))/(SweepLengthSecs*waveFormat.SampleRate));                            multiple = TwoPi*f/waveFormat.SampleRate;                          phi += multiple;                          sampleValue = Gain*(Math.Sin(phi));                          nSample++;                          if (nSample > SweepLengthSecs*waveFormat.SampleRate)                          {                              nSample = 0;                              phi = 0;                          }                          break;                        default:                          sampleValue = 0.0;                          break;                  }                    // Phase Reverse Per Channel                  for (int i = 0; i < waveFormat.Channels; i++)                  {                      if (PhaseReverse[i])                          buffer[outIndex++] = (float) -sampleValue;                      else                          buffer[outIndex++] = (float) sampleValue;                  }              }
Magic Number,NAudio.Wave.SampleProviders,SignalGenerator,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SignalGenerator.cs,NextRandomTwo,The following statement contains a magic number: return 2*random.NextDouble() - 1;
Magic Number,NAudio.Wave.SampleProviders,SmbPitchShiftingSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SmbPitchShiftingSampleProvider.cs,Read,The following statement contains a magic number: if (waveFormat.Channels == 2)              {                  var left = new float[(sampRead >> 1)];                  var right = new float[(sampRead >> 1)];                  var index = 0;                  for (var sample = offset; sample <= sampRead + offset - 1; sample += 2)                  {                      left[index] = buffer[sample];                      right[index] = buffer[sample + 1];                      index += 1;                  }                  shifterLeft.PitchShift(pitch' sampRead >> 1' fftSize' osamp' waveFormat.SampleRate' left);                  shifterRight.PitchShift(pitch' sampRead >> 1' fftSize' osamp' waveFormat.SampleRate' right);                  index = 0;                  for (var sample = offset; sample <= sampRead + offset - 1; sample += 2)                  {                      buffer[sample] = Limiter(left[index]);                      buffer[sample + 1] = Limiter(right[index]);                      index += 1;                  }                  return sampRead;              }
Magic Number,NAudio.Wave.SampleProviders,SmbPitchShiftingSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SmbPitchShiftingSampleProvider.cs,Read,The following statement contains a magic number: if (waveFormat.Channels == 2)              {                  var left = new float[(sampRead >> 1)];                  var right = new float[(sampRead >> 1)];                  var index = 0;                  for (var sample = offset; sample <= sampRead + offset - 1; sample += 2)                  {                      left[index] = buffer[sample];                      right[index] = buffer[sample + 1];                      index += 1;                  }                  shifterLeft.PitchShift(pitch' sampRead >> 1' fftSize' osamp' waveFormat.SampleRate' left);                  shifterRight.PitchShift(pitch' sampRead >> 1' fftSize' osamp' waveFormat.SampleRate' right);                  index = 0;                  for (var sample = offset; sample <= sampRead + offset - 1; sample += 2)                  {                      buffer[sample] = Limiter(left[index]);                      buffer[sample + 1] = Limiter(right[index]);                      index += 1;                  }                  return sampRead;              }
Magic Number,NAudio.Wave.SampleProviders,SmbPitchShiftingSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SmbPitchShiftingSampleProvider.cs,Read,The following statement contains a magic number: if (waveFormat.Channels == 2)              {                  var left = new float[(sampRead >> 1)];                  var right = new float[(sampRead >> 1)];                  var index = 0;                  for (var sample = offset; sample <= sampRead + offset - 1; sample += 2)                  {                      left[index] = buffer[sample];                      right[index] = buffer[sample + 1];                      index += 1;                  }                  shifterLeft.PitchShift(pitch' sampRead >> 1' fftSize' osamp' waveFormat.SampleRate' left);                  shifterRight.PitchShift(pitch' sampRead >> 1' fftSize' osamp' waveFormat.SampleRate' right);                  index = 0;                  for (var sample = offset; sample <= sampRead + offset - 1; sample += 2)                  {                      buffer[sample] = Limiter(left[index]);                      buffer[sample + 1] = Limiter(right[index]);                      index += 1;                  }                  return sampRead;              }
Magic Number,NAudio.Wave.SampleProviders,StereoToMonoSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\StereoToMonoSampleProvider.cs,StereoToMonoSampleProvider,The following statement contains a magic number: if (sourceProvider.WaveFormat.Channels != 2)              {                  throw new ArgumentException("Source must be stereo");              }
Magic Number,NAudio.Wave.SampleProviders,StereoToMonoSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\StereoToMonoSampleProvider.cs,Read,The following statement contains a magic number: var sourceSamplesRequired = count * 2;
Magic Number,NAudio.Wave.SampleProviders,StereoToMonoSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\StereoToMonoSampleProvider.cs,Read,The following statement contains a magic number: var destOffset = offset / 2;
Magic Number,NAudio.Wave.SampleProviders,StereoToMonoSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\StereoToMonoSampleProvider.cs,Read,The following statement contains a magic number: for (var sourceSample = 0; sourceSample < sourceSamplesRead; sourceSample += 2)              {                  var left = sourceBuffer[sourceSample];                  var right = sourceBuffer[sourceSample + 1];                  var outSample = (left * LeftVolume) + (right * RightVolume);                    buffer[destOffset++] = outSample;              }
Magic Number,NAudio.Wave.SampleProviders,StereoToMonoSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\StereoToMonoSampleProvider.cs,Read,The following statement contains a magic number: return sourceSamplesRead / 2;
Magic Number,NAudio.Wave.SampleProviders,WaveToSampleProvider64,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\WaveToSampleProvider64.cs,Read,The following statement contains a magic number: int bytesNeeded = count * 8;
Magic Number,NAudio.Wave.SampleProviders,WaveToSampleProvider64,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\WaveToSampleProvider64.cs,Read,The following statement contains a magic number: int samplesRead = bytesRead / 8;
Magic Number,NAudio.Wave.SampleProviders,WaveToSampleProvider64,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\WaveToSampleProvider64.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 8)              {                  long sample64 = BitConverter.ToInt64(sourceBuffer' n);                  buffer[outputIndex++] = (float)BitConverter.Int64BitsToDouble(sample64);              }
Magic Number,NAudio.Wave.SampleProviders,WdlResamplingSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\WdlResamplingSampleProvider.cs,WdlResamplingSampleProvider,The following statement contains a magic number: resampler.SetMode(true' 2' false);
Magic Number,NAudio.Wave.SampleProviders,Mono16SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono16SampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.Pcm &&                  waveFormat.BitsPerSample == 16 &&                  waveFormat.Channels == 1;
Magic Number,NAudio.Wave.SampleProviders,Mono16SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono16SampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: int sourceBytesRequired = samplePairsRequired * 2;
Magic Number,NAudio.Wave.SampleProviders,Mono16SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono16SampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: sourceSamples = source.Read(sourceBuffer' 0' sourceBytesRequired) / 2;
Magic Number,NAudio.Wave.SampleProviders,Mono24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono24SampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.Pcm &&                  waveFormat.BitsPerSample == 24 &&                  waveFormat.Channels == 1;
Magic Number,NAudio.Wave.SampleProviders,Mono24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono24SampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: int sourceBytesRequired = samplePairsRequired * 3;
Magic Number,NAudio.Wave.SampleProviders,Mono24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = sampleLeft;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Mono24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = sampleLeft;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Mono24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = sampleLeft;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Mono24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = sampleLeft;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Mono8SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Mono8SampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.Pcm &&                  waveFormat.BitsPerSample == 8 &&                  waveFormat.Channels == 1;
Magic Number,NAudio.Wave.SampleProviders,MonoFloatSampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\MonoFloatSampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: int sourceBytesRequired = samplePairsRequired * 4;
Magic Number,NAudio.Wave.SampleProviders,MonoFloatSampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\MonoFloatSampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: sourceSamples = source.Read(sourceBuffer' 0' sourceBytesRequired) / 4;
Magic Number,NAudio.Wave.SampleProviders,Stereo16SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo16SampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.Pcm &&                  waveFormat.BitsPerSample == 16 &&                  waveFormat.Channels == 2;
Magic Number,NAudio.Wave.SampleProviders,Stereo16SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo16SampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.Pcm &&                  waveFormat.BitsPerSample == 16 &&                  waveFormat.Channels == 2;
Magic Number,NAudio.Wave.SampleProviders,Stereo16SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo16SampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: int sourceBytesRequired = samplePairsRequired * 4;
Magic Number,NAudio.Wave.SampleProviders,Stereo16SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo16SampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: sourceSamples = source.Read(sourceBuffer' 0' sourceBytesRequired) / 2;
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.Pcm &&                  waveFormat.BitsPerSample == 24 &&                  waveFormat.Channels == 2;
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.Pcm &&                  waveFormat.BitsPerSample == 24 &&                  waveFormat.Channels == 2;
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: int sourceBytesRequired = samplePairsRequired * 6;
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Stereo24SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo24SampleChunkConverter.cs,GetNextSample,The following statement contains a magic number: if (offset < sourceBytes)              {                  sampleLeft = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  sampleRight = (((sbyte)sourceBuffer[offset + 2] << 16) | (sourceBuffer[offset + 1] << 8) | sourceBuffer[offset]) / 8388608f;                  offset += 3;                  return true;              }              else              {                  sampleLeft = 0.0f;                  sampleRight = 0.0f;                  return false;              }
Magic Number,NAudio.Wave.SampleProviders,Stereo8SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo8SampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.Pcm &&                  waveFormat.BitsPerSample == 8 &&                  waveFormat.Channels == 2;
Magic Number,NAudio.Wave.SampleProviders,Stereo8SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo8SampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.Pcm &&                  waveFormat.BitsPerSample == 8 &&                  waveFormat.Channels == 2;
Magic Number,NAudio.Wave.SampleProviders,Stereo8SampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\Stereo8SampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: int sourceBytesRequired = samplePairsRequired * 2;
Magic Number,NAudio.Wave.SampleProviders,StereoFloatSampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\StereoFloatSampleChunkConverter.cs,Supports,The following statement contains a magic number: return waveFormat.Encoding == WaveFormatEncoding.IeeeFloat &&                  waveFormat.Channels == 2;
Magic Number,NAudio.Wave.SampleProviders,StereoFloatSampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\StereoFloatSampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: int sourceBytesRequired = samplePairsRequired * 8;
Magic Number,NAudio.Wave.SampleProviders,StereoFloatSampleChunkConverter,C:\repos\naudio_NAudio\NAudio\Wave\SampleChunkConverters\StereoFloatSampleChunkConverter.cs,LoadNextChunk,The following statement contains a magic number: sourceSamples = source.Read(sourceBuffer' 0' sourceBytesRequired) / 4;
Magic Number,NAudio.Wave.SampleProviders,PanningSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\PanningSampleProvider.cs,PanningSampleProvider,The following statement contains a magic number: waveFormat = WaveFormat.CreateIeeeFloatWaveFormat(source.WaveFormat.SampleRate' 2);
Magic Number,NAudio.Wave.SampleProviders,PanningSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\PanningSampleProvider.cs,Read,The following statement contains a magic number: int sourceSamplesRequired = count / 2;
Magic Number,NAudio.Wave.SampleProviders,PanningSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\PanningSampleProvider.cs,Read,The following statement contains a magic number: return sourceSamplesRead * 2;
Magic Number,NAudio.Wave.SampleProviders,SquareRootPanStrategy,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\PanningSampleProvider.cs,GetMultipliers,The following statement contains a magic number: float normPan = (-pan + 1) / 2;
Magic Number,NAudio.Wave.SampleProviders,SinPanStrategy,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\PanningSampleProvider.cs,GetMultipliers,The following statement contains a magic number: float normPan = (-pan + 1) / 2;
Magic Number,NAudio.Wave.SampleProviders,LinearPanStrategy,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\PanningSampleProvider.cs,GetMultipliers,The following statement contains a magic number: float normPan = (-pan + 1) / 2;
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider.cs,Read,The following statement contains a magic number: int samplesNeeded = count / 4;
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider.cs,Read,The following statement contains a magic number: int samplesRead = source.Read(wb.FloatBuffer' offset / 4' samplesNeeded);
Magic Number,NAudio.Wave.SampleProviders,SampleToWaveProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\SampleToWaveProvider.cs,Read,The following statement contains a magic number: return samplesRead * 4;
Magic Number,NAudio.Wave.SampleProviders,MonoToStereoSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\MonoToStereoSampleProvider.cs,MonoToStereoSampleProvider,The following statement contains a magic number: WaveFormat = WaveFormat.CreateIeeeFloatWaveFormat(source.WaveFormat.SampleRate' 2);
Magic Number,NAudio.Wave.SampleProviders,MonoToStereoSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\MonoToStereoSampleProvider.cs,Read,The following statement contains a magic number: var sourceSamplesRequired = count / 2;
Magic Number,NAudio.Wave.SampleProviders,MonoToStereoSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\MonoToStereoSampleProvider.cs,Read,The following statement contains a magic number: return sourceSamplesRead * 2;
Magic Number,NAudio.Wave.SampleProviders,WaveToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\WaveToSampleProvider.cs,Read,The following statement contains a magic number: int bytesNeeded = count * 4;
Magic Number,NAudio.Wave.SampleProviders,WaveToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\WaveToSampleProvider.cs,Read,The following statement contains a magic number: int samplesRead = bytesRead / 4;
Magic Number,NAudio.Wave.SampleProviders,WaveToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\WaveToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n+=4)              {                  buffer[outputIndex++] = BitConverter.ToSingle(sourceBuffer' n);              }
Magic Number,NAudio.Wave.SampleProviders,Pcm16BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm16BitToSampleProvider.cs,Read,The following statement contains a magic number: int sourceBytesRequired = count * 2;
Magic Number,NAudio.Wave.SampleProviders,Pcm16BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm16BitToSampleProvider.cs,Read,The following statement contains a magic number: for(int n = 0; n < bytesRead; n+=2)              {                  buffer[outIndex++] = BitConverter.ToInt16(sourceBuffer' n) / 32768f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm16BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm16BitToSampleProvider.cs,Read,The following statement contains a magic number: return bytesRead / 2;
Magic Number,NAudio.Wave.SampleProviders,Pcm24BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm24BitToSampleProvider.cs,Read,The following statement contains a magic number: int sourceBytesRequired = count * 3;
Magic Number,NAudio.Wave.SampleProviders,Pcm24BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm24BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 3)              {                  buffer[outIndex++] = (((sbyte)sourceBuffer[n + 2] << 16) | (sourceBuffer[n + 1] << 8) | sourceBuffer[n]) / 8388608f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm24BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm24BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 3)              {                  buffer[outIndex++] = (((sbyte)sourceBuffer[n + 2] << 16) | (sourceBuffer[n + 1] << 8) | sourceBuffer[n]) / 8388608f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm24BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm24BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 3)              {                  buffer[outIndex++] = (((sbyte)sourceBuffer[n + 2] << 16) | (sourceBuffer[n + 1] << 8) | sourceBuffer[n]) / 8388608f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm24BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm24BitToSampleProvider.cs,Read,The following statement contains a magic number: for (int n = 0; n < bytesRead; n += 3)              {                  buffer[outIndex++] = (((sbyte)sourceBuffer[n + 2] << 16) | (sourceBuffer[n + 1] << 8) | sourceBuffer[n]) / 8388608f;              }
Magic Number,NAudio.Wave.SampleProviders,Pcm24BitToSampleProvider,C:\repos\naudio_NAudio\NAudio\Wave\SampleProviders\Pcm24BitToSampleProvider.cs,Read,The following statement contains a magic number: return bytesRead / 3;
Magic Number,NAudio.Wave,WaveExtensionMethods,C:\repos\naudio_NAudio\NAudio\Wave\WaveExtensionMethods.cs,ToStereo,The following statement contains a magic number: if (sourceProvider.WaveFormat.Channels == 2) return sourceProvider;
Magic Number,NAudio.Wave,WaveInEvent,C:\repos\naudio_NAudio\NAudio\Wave\WaveInputs\WaveInEvent.cs,WaveInEvent,The following statement contains a magic number: WaveFormat = new WaveFormat(8000' 16' 1);
Magic Number,NAudio.Wave,WaveInEvent,C:\repos\naudio_NAudio\NAudio\Wave\WaveInputs\WaveInEvent.cs,WaveInEvent,The following statement contains a magic number: WaveFormat = new WaveFormat(8000' 16' 1);
Magic Number,NAudio.Wave,WaveInEvent,C:\repos\naudio_NAudio\NAudio\Wave\WaveInputs\WaveInEvent.cs,WaveInEvent,The following statement contains a magic number: BufferMilliseconds = 100;
Magic Number,NAudio.Wave,WaveInEvent,C:\repos\naudio_NAudio\NAudio\Wave\WaveInputs\WaveInEvent.cs,WaveInEvent,The following statement contains a magic number: NumberOfBuffers = 3;
Magic Number,NAudio.Wave,WaveInEvent,C:\repos\naudio_NAudio\NAudio\Wave\WaveInputs\WaveInEvent.cs,CreateBuffers,The following statement contains a magic number: int bufferSize = BufferMilliseconds * WaveFormat.AverageBytesPerSecond / 1000;
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,CreateId3v2Frame,The following statement contains a magic number: if (key.Length != 4)              {                  throw new ArgumentOutOfRangeException("key"' "key " + key + " must be 4 characters long");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,GetId3TagHeaderSize,The following statement contains a magic number: byte[] result = new byte[4];
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,GetId3TagHeaderSize,The following statement contains a magic number: for (int idx = result.Length - 1; idx >= 0; idx--)              {                  result[idx] = (byte)(size % 128);                  size = size / 128;              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,GetId3TagHeaderSize,The following statement contains a magic number: for (int idx = result.Length - 1; idx >= 0; idx--)              {                  result[idx] = (byte)(size % 128);                  size = size / 128;              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,CreateId3v2TagHeader,The following statement contains a magic number: byte[] tagHeader = ByteArrayExtensions.Concat(                  Encoding.UTF8.GetBytes("ID3")'                  new byte[] { 3' 0 }' // version                  new byte[] { 0 }' // flags                  GetId3TagHeaderSize(size));
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: byte[] headerBytes = reader.ReadBytes(10);
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Id3v2Tag,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Id3v2Tag.cs,Id3v2Tag,The following statement contains a magic number: if ((headerBytes.Length >= 3) &&                  (headerBytes[0] == (byte)'I') &&                  (headerBytes[1] == (byte)'D') &&                  (headerBytes[2] == '3'))              {                    // http://www.id3.org/develop.html                  // OK found an ID3 tag                  // bytes 3 & 4 are ID3v2 version                    if ((headerBytes[5] & 0x40) == 0x40)                  {                      // extended header present                      byte[] extendedHeader = reader.ReadBytes(4);                      int extendedHeaderLength = extendedHeader[0] * (1 << 21);                      extendedHeaderLength += extendedHeader[1] * (1 << 14);                      extendedHeaderLength += extendedHeader[2] * (1 << 7);                      extendedHeaderLength += extendedHeader[3];                  }                    // synchsafe                  int dataLength = headerBytes[6] * (1 << 21);                  dataLength += headerBytes[7] * (1 << 14);                  dataLength += headerBytes[8] * (1 << 7);                  dataLength += headerBytes[9];                  byte[] tagData = reader.ReadBytes(dataLength);                    if ((headerBytes[5] & 0x10) == 0x10)                  {                      // footer present                      byte[] footer = reader.ReadBytes(10);                  }              }              else              {                  input.Position = tagStartPosition;                  throw new FormatException("Not an ID3v2 tag");              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,LoadFromStream,The following statement contains a magic number: byte[] headerBytes = new byte[4];
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,LoadFromStream,The following statement contains a magic number: while (!IsValidHeader(headerBytes' frame))              {                  // shift down by one and try again                  headerBytes[0] = headerBytes[1];                  headerBytes[1] = headerBytes[2];                  headerBytes[2] = headerBytes[3];                  bytesRead = input.Read(headerBytes' 3' 1);                  if (bytesRead < 1)                  {                      return null;                  }                  frame.FileOffset++;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,LoadFromStream,The following statement contains a magic number: while (!IsValidHeader(headerBytes' frame))              {                  // shift down by one and try again                  headerBytes[0] = headerBytes[1];                  headerBytes[1] = headerBytes[2];                  headerBytes[2] = headerBytes[3];                  bytesRead = input.Read(headerBytes' 3' 1);                  if (bytesRead < 1)                  {                      return null;                  }                  frame.FileOffset++;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,LoadFromStream,The following statement contains a magic number: while (!IsValidHeader(headerBytes' frame))              {                  // shift down by one and try again                  headerBytes[0] = headerBytes[1];                  headerBytes[1] = headerBytes[2];                  headerBytes[2] = headerBytes[3];                  bytesRead = input.Read(headerBytes' 3' 1);                  if (bytesRead < 1)                  {                      return null;                  }                  frame.FileOffset++;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,LoadFromStream,The following statement contains a magic number: while (!IsValidHeader(headerBytes' frame))              {                  // shift down by one and try again                  headerBytes[0] = headerBytes[1];                  headerBytes[1] = headerBytes[2];                  headerBytes[2] = headerBytes[3];                  bytesRead = input.Read(headerBytes' 3' 1);                  if (bytesRead < 1)                  {                      return null;                  }                  frame.FileOffset++;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,LoadFromStream,The following statement contains a magic number: int bytesRequired = frame.FrameLength - 4;
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,LoadFromStream,The following statement contains a magic number: if (readData)              {                  frame.RawData = new byte[frame.FrameLength];                  Array.Copy(headerBytes' frame.RawData' 4);                  bytesRead = input.Read(frame.RawData' 4' bytesRequired);                  if (bytesRead < bytesRequired)                  {                      // TODO: could have an option to suppress this' although it does indicate a corrupt file                      // for now' caller should handle this exception                      throw new EndOfStreamException("Unexpected end of stream before frame complete");                  }              }              else              {                  // n.b. readData should not be false if input stream does not support seeking                  input.Position += bytesRequired;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,LoadFromStream,The following statement contains a magic number: if (readData)              {                  frame.RawData = new byte[frame.FrameLength];                  Array.Copy(headerBytes' frame.RawData' 4);                  bytesRead = input.Read(frame.RawData' 4' bytesRequired);                  if (bytesRead < bytesRequired)                  {                      // TODO: could have an option to suppress this' although it does indicate a corrupt file                      // for now' caller should handle this exception                      throw new EndOfStreamException("Unexpected end of stream before frame complete");                  }              }              else              {                  // n.b. readData should not be false if input stream does not support seeking                  input.Position += bytesRequired;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,Mp3Frame,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\Mp3Frame.cs,IsValidHeader,The following statement contains a magic number: if ((headerBytes[0] == 0xFF) && ((headerBytes[1] & 0xE0) == 0xE0))              {                  // TODO: could do with a bitstream class here                  frame.MpegVersion = (MpegVersion) ((headerBytes[1] & 0x18) >> 3);                  if (frame.MpegVersion == MpegVersion.Reserved)                  {                      //throw new FormatException("Unsupported MPEG Version");                      return false;                  }                    frame.MpegLayer = (MpegLayer) ((headerBytes[1] & 0x06) >> 1);                    if (frame.MpegLayer == MpegLayer.Reserved)                  {                      return false;                  }                  int layerIndex = frame.MpegLayer == MpegLayer.Layer1 ? 0 : frame.MpegLayer == MpegLayer.Layer2 ? 1 : 2;                  frame.CrcPresent = (headerBytes[1] & 0x01) == 0x00;                  frame.BitRateIndex = (headerBytes[2] & 0xF0) >> 4;                  if (frame.BitRateIndex == 15)                  {                      // invalid index                      return false;                  }                  int versionIndex = frame.MpegVersion == Wave.MpegVersion.Version1 ? 0 : 1;                  frame.BitRate = bitRates[versionIndex' layerIndex' frame.BitRateIndex]*1000;                  if (frame.BitRate == 0)                  {                      return false;                  }                  int sampleFrequencyIndex = (headerBytes[2] & 0x0C) >> 2;                  if (sampleFrequencyIndex == 3)                  {                      return false;                  }                    if (frame.MpegVersion == MpegVersion.Version1)                  {                      frame.SampleRate = sampleRatesVersion1[sampleFrequencyIndex];                  }                  else if (frame.MpegVersion == MpegVersion.Version2)                  {                      frame.SampleRate = sampleRatesVersion2[sampleFrequencyIndex];                  }                  else                  {                      // mpegVersion == MpegVersion.Version25                      frame.SampleRate = sampleRatesVersion25[sampleFrequencyIndex];                  }                    bool padding = (headerBytes[2] & 0x02) == 0x02;                  bool privateBit = (headerBytes[2] & 0x01) == 0x01;                  frame.ChannelMode = (ChannelMode) ((headerBytes[3] & 0xC0) >> 6);                  frame.ChannelExtension = (headerBytes[3] & 0x30) >> 4;                  if (frame.ChannelExtension != 0 && frame.ChannelMode != ChannelMode.JointStereo)                  {                      return false;                  }                      frame.Copyright = (headerBytes[3] & 0x08) == 0x08;                  bool original = (headerBytes[3] & 0x04) == 0x04;                  int emphasis = (headerBytes[3] & 0x03);                    int nPadding = padding ? 1 : 0;                    frame.SampleCount = samplesPerFrame[versionIndex' layerIndex];                  int coefficient = frame.SampleCount/8;                  if (frame.MpegLayer == MpegLayer.Layer1)                  {                      frame.FrameLength = (coefficient*frame.BitRate/frame.SampleRate + nPadding)*4;                  }                  else                  {                      frame.FrameLength = (coefficient*frame.BitRate)/frame.SampleRate + nPadding;                  }                    if (frame.FrameLength > MaxFrameLength)                  {                      return false;                  }                  return true;              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,ReadBigEndian,The following statement contains a magic number: x <<= 8;
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,ReadBigEndian,The following statement contains a magic number: x <<= 8;
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,ReadBigEndian,The following statement contains a magic number: x |= buffer[offset+2];
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,ReadBigEndian,The following statement contains a magic number: x <<= 8;
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,ReadBigEndian,The following statement contains a magic number: x |= buffer[offset+3];
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,WriteBigEndian,The following statement contains a magic number: for (int n = 0; n < 4; n++)              {                  buffer[offset + 3 - n] = littleEndian[n];              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,WriteBigEndian,The following statement contains a magic number: for (int n = 0; n < 4; n++)              {                  buffer[offset + 3 - n] = littleEndian[n];              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if (frame.MpegVersion == MpegVersion.Version1)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 32 + 4;                  else                      offset = 17 + 4;              }              else if (frame.MpegVersion == MpegVersion.Version2)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 17 + 4;                  else                      offset = 9 + 4;              }              else              {                  return null;                  // throw new FormatException("Unsupported MPEG Version");              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if (frame.MpegVersion == MpegVersion.Version1)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 32 + 4;                  else                      offset = 17 + 4;              }              else if (frame.MpegVersion == MpegVersion.Version2)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 17 + 4;                  else                      offset = 9 + 4;              }              else              {                  return null;                  // throw new FormatException("Unsupported MPEG Version");              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if (frame.MpegVersion == MpegVersion.Version1)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 32 + 4;                  else                      offset = 17 + 4;              }              else if (frame.MpegVersion == MpegVersion.Version2)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 17 + 4;                  else                      offset = 9 + 4;              }              else              {                  return null;                  // throw new FormatException("Unsupported MPEG Version");              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if (frame.MpegVersion == MpegVersion.Version1)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 32 + 4;                  else                      offset = 17 + 4;              }              else if (frame.MpegVersion == MpegVersion.Version2)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 17 + 4;                  else                      offset = 9 + 4;              }              else              {                  return null;                  // throw new FormatException("Unsupported MPEG Version");              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if (frame.MpegVersion == MpegVersion.Version1)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 32 + 4;                  else                      offset = 17 + 4;              }              else if (frame.MpegVersion == MpegVersion.Version2)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 17 + 4;                  else                      offset = 9 + 4;              }              else              {                  return null;                  // throw new FormatException("Unsupported MPEG Version");              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if (frame.MpegVersion == MpegVersion.Version1)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 32 + 4;                  else                      offset = 17 + 4;              }              else if (frame.MpegVersion == MpegVersion.Version2)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 17 + 4;                  else                      offset = 9 + 4;              }              else              {                  return null;                  // throw new FormatException("Unsupported MPEG Version");              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if (frame.MpegVersion == MpegVersion.Version1)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 32 + 4;                  else                      offset = 17 + 4;              }              else if (frame.MpegVersion == MpegVersion.Version2)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 17 + 4;                  else                      offset = 9 + 4;              }              else              {                  return null;                  // throw new FormatException("Unsupported MPEG Version");              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if (frame.MpegVersion == MpegVersion.Version1)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 32 + 4;                  else                      offset = 17 + 4;              }              else if (frame.MpegVersion == MpegVersion.Version2)              {                  if (frame.ChannelMode != ChannelMode.Mono)                      offset = 17 + 4;                  else                      offset = 9 + 4;              }              else              {                  return null;                  // throw new FormatException("Unsupported MPEG Version");              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if ((frame.RawData[offset + 0] == 'X') &&                  (frame.RawData[offset + 1] == 'i') &&                  (frame.RawData[offset + 2] == 'n') &&                  (frame.RawData[offset + 3] == 'g'))              {                  xingHeader.startOffset = offset;                  offset += 4;              }              else              {                  return null;              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if ((frame.RawData[offset + 0] == 'X') &&                  (frame.RawData[offset + 1] == 'i') &&                  (frame.RawData[offset + 2] == 'n') &&                  (frame.RawData[offset + 3] == 'g'))              {                  xingHeader.startOffset = offset;                  offset += 4;              }              else              {                  return null;              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if ((frame.RawData[offset + 0] == 'X') &&                  (frame.RawData[offset + 1] == 'i') &&                  (frame.RawData[offset + 2] == 'n') &&                  (frame.RawData[offset + 3] == 'g'))              {                  xingHeader.startOffset = offset;                  offset += 4;              }              else              {                  return null;              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: offset += 4;
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if ((flags & XingHeaderOptions.Frames) != 0)              {                  xingHeader.framesOffset = offset;                  offset += 4;              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if ((flags & XingHeaderOptions.Bytes) != 0)              {                  xingHeader.bytesOffset = offset;                  offset += 4;              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if ((flags & XingHeaderOptions.Toc) != 0)              {                  xingHeader.tocOffset = offset;                  offset += 100;              }
Magic Number,NAudio.Wave,XingHeader,C:\repos\naudio_NAudio\NAudio\FileFormats\Mp3\XingHeader.cs,LoadXingHeader,The following statement contains a magic number: if ((flags & XingHeaderOptions.VbrScale) != 0)              {                  xingHeader.vbrScale = ReadBigEndian(frame.RawData' offset);                  offset += 4;              }
Magic Number,NAudio.Wave,WaveIn,C:\repos\naudio_NAudio\NAudio\Wave\WaveInputs\WaveIn.cs,WaveIn,The following statement contains a magic number: WaveFormat = new WaveFormat(8000' 16' 1);
Magic Number,NAudio.Wave,WaveIn,C:\repos\naudio_NAudio\NAudio\Wave\WaveInputs\WaveIn.cs,WaveIn,The following statement contains a magic number: WaveFormat = new WaveFormat(8000' 16' 1);
Magic Number,NAudio.Wave,WaveIn,C:\repos\naudio_NAudio\NAudio\Wave\WaveInputs\WaveIn.cs,WaveIn,The following statement contains a magic number: BufferMilliseconds = 100;
Magic Number,NAudio.Wave,WaveIn,C:\repos\naudio_NAudio\NAudio\Wave\WaveInputs\WaveIn.cs,WaveIn,The following statement contains a magic number: NumberOfBuffers = 3;
Magic Number,NAudio.Wave,WaveIn,C:\repos\naudio_NAudio\NAudio\Wave\WaveInputs\WaveIn.cs,CreateBuffers,The following statement contains a magic number: int bufferSize = BufferMilliseconds * WaveFormat.AverageBytesPerSecond / 1000;
Magic Number,NAudio.Wave,Gsm610WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\Gsm610WaveFormat.cs,Gsm610WaveFormat,The following statement contains a magic number: averageBytesPerSecond = 1625;
Magic Number,NAudio.Wave,Gsm610WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\Gsm610WaveFormat.cs,Gsm610WaveFormat,The following statement contains a magic number: blockAlign = 65;
Magic Number,NAudio.Wave,Gsm610WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\Gsm610WaveFormat.cs,Gsm610WaveFormat,The following statement contains a magic number: sampleRate = 8000;
Magic Number,NAudio.Wave,Gsm610WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\Gsm610WaveFormat.cs,Gsm610WaveFormat,The following statement contains a magic number: extraSize = 2;
Magic Number,NAudio.Wave,Gsm610WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\Gsm610WaveFormat.cs,Gsm610WaveFormat,The following statement contains a magic number: samplesPerBlock = 320;
Magic Number,NAudio.Wave,ImaAdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\ImaAdpcmWaveFormat.cs,ImaAdpcmWaveFormat,The following statement contains a magic number: this.extraSize = 2;
Magic Number,NAudio.Wave,Mp3WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\Mp3WaveFormat.cs,Mp3WaveFormat,The following statement contains a magic number: this.averageBytesPerSecond = bitRate / 8;
Magic Number,NAudio.Wave,TrueSpeechWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\TrueSpeechWaveFormat.cs,TrueSpeechWaveFormat,The following statement contains a magic number: this.averageBytesPerSecond = 1067;
Magic Number,NAudio.Wave,TrueSpeechWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\TrueSpeechWaveFormat.cs,TrueSpeechWaveFormat,The following statement contains a magic number: this.blockAlign = 32;
Magic Number,NAudio.Wave,TrueSpeechWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\TrueSpeechWaveFormat.cs,TrueSpeechWaveFormat,The following statement contains a magic number: this.sampleRate = 8000;
Magic Number,NAudio.Wave,TrueSpeechWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\TrueSpeechWaveFormat.cs,TrueSpeechWaveFormat,The following statement contains a magic number: this.extraSize = 32;
Magic Number,NAudio.Wave,TrueSpeechWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\TrueSpeechWaveFormat.cs,TrueSpeechWaveFormat,The following statement contains a magic number: this.unknown = new short[16];
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,ConvertLatencyToByteSize,The following statement contains a magic number: int bytes = (int) ((AverageBytesPerSecond/1000.0)*milliseconds);
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,CreateALawFormat,The following statement contains a magic number: return CreateCustomFormat(WaveFormatEncoding.ALaw' sampleRate' channels' sampleRate * channels' channels' 8);
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,CreateMuLawFormat,The following statement contains a magic number: return CreateCustomFormat(WaveFormatEncoding.MuLaw' sampleRate' channels' sampleRate * channels' channels' 8);
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,WaveFormat,The following statement contains a magic number: blockAlign = (short)(channels * (bits / 8));
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,CreateIeeeFloatWaveFormat,The following statement contains a magic number: wf.bitsPerSample = 32;
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,CreateIeeeFloatWaveFormat,The following statement contains a magic number: wf.blockAlign = (short) (4*channels);
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,ReadWaveFormat,The following statement contains a magic number: if (formatChunkLength < 16)                  throw new InvalidDataException("Invalid WaveFormat Structure");
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,ReadWaveFormat,The following statement contains a magic number: if (formatChunkLength > 16)              {                  extraSize = br.ReadInt16();                  if (extraSize != formatChunkLength - 18)                  {                      Debug.WriteLine("Format chunk mismatch");                      extraSize = (short)(formatChunkLength - 18);                  }              }
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,ReadWaveFormat,The following statement contains a magic number: if (formatChunkLength > 16)              {                  extraSize = br.ReadInt16();                  if (extraSize != formatChunkLength - 18)                  {                      Debug.WriteLine("Format chunk mismatch");                      extraSize = (short)(formatChunkLength - 18);                  }              }
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,ReadWaveFormat,The following statement contains a magic number: if (formatChunkLength > 16)              {                  extraSize = br.ReadInt16();                  if (extraSize != formatChunkLength - 18)                  {                      Debug.WriteLine("Format chunk mismatch");                      extraSize = (short)(formatChunkLength - 18);                  }              }
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,ToString,The following statement contains a magic number: switch (waveFormatTag)              {                  case WaveFormatEncoding.Pcm:                  case WaveFormatEncoding.Extensible:                      // extensible just has some extra bits after the PCM header                      return $"{bitsPerSample} bit PCM: {sampleRate/1000}kHz {channels} channels";                  default:                      return waveFormatTag.ToString();              }
Magic Number,NAudio.Wave,WaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormat.cs,Serialize,The following statement contains a magic number: writer.Write((int)(18 + extraSize));
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: this.extraSize = 32;
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: switch(this.sampleRate)              {                  case 8000:                   case 11025:                      blockAlign = 256;                       break;                  case 22050:                      blockAlign = 512;                      break;                  case 44100:                  default:                      blockAlign = 1024;                      break;              }
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: switch(this.sampleRate)              {                  case 8000:                   case 11025:                      blockAlign = 256;                       break;                  case 22050:                      blockAlign = 512;                      break;                  case 44100:                  default:                      blockAlign = 1024;                      break;              }
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: switch(this.sampleRate)              {                  case 8000:                   case 11025:                      blockAlign = 256;                       break;                  case 22050:                      blockAlign = 512;                      break;                  case 44100:                  default:                      blockAlign = 1024;                      break;              }
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: switch(this.sampleRate)              {                  case 8000:                   case 11025:                      blockAlign = 256;                       break;                  case 22050:                      blockAlign = 512;                      break;                  case 44100:                  default:                      blockAlign = 1024;                      break;              }
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: switch(this.sampleRate)              {                  case 8000:                   case 11025:                      blockAlign = 256;                       break;                  case 22050:                      blockAlign = 512;                      break;                  case 44100:                  default:                      blockAlign = 1024;                      break;              }
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: switch(this.sampleRate)              {                  case 8000:                   case 11025:                      blockAlign = 256;                       break;                  case 22050:                      blockAlign = 512;                      break;                  case 44100:                  default:                      blockAlign = 1024;                      break;              }
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: switch(this.sampleRate)              {                  case 8000:                   case 11025:                      blockAlign = 256;                       break;                  case 22050:                      blockAlign = 512;                      break;                  case 44100:                  default:                      blockAlign = 1024;                      break;              }
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: this.bitsPerSample = 4;
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: this.samplesPerBlock = (short) ((((blockAlign - (7 * channels)) * 8) / (bitsPerSample * channels)) + 2);
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: this.samplesPerBlock = (short) ((((blockAlign - (7 * channels)) * 8) / (bitsPerSample * channels)) + 2);
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: this.samplesPerBlock = (short) ((((blockAlign - (7 * channels)) * 8) / (bitsPerSample * channels)) + 2);
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: numCoeff = 7;
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,AdpcmWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\AdpcmWaveFormat.cs,AdpcmWaveFormat,The following statement contains a magic number: coefficients = new short[14] {                  256'0'512'-256'0'0'192'64'240'0'460'-208'392'-232              };
Magic Number,NAudio.Wave,WaveFormatExtensible,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormatExtensible.cs,WaveFormatExtensible,The following statement contains a magic number: extraSize = 22;
Magic Number,NAudio.Wave,WaveFormatExtensible,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormatExtensible.cs,WaveFormatExtensible,The following statement contains a magic number: if (bits == 32)              {                  // KSDATAFORMAT_SUBTYPE_IEEE_FLOAT                  subFormat = AudioMediaSubtypes.MEDIASUBTYPE_IEEE_FLOAT;              }              else              {                  // KSDATAFORMAT_SUBTYPE_PCM                  subFormat = AudioMediaSubtypes.MEDIASUBTYPE_PCM;              }
Magic Number,NAudio.Wave,WaveFormatExtensible,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WaveFormatExtensible.cs,ToStandardWaveFormat,The following statement contains a magic number: if (subFormat == AudioMediaSubtypes.MEDIASUBTYPE_IEEE_FLOAT && bitsPerSample == 32)                  return CreateIeeeFloatWaveFormat(sampleRate' channels);
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,CreateAiffFile,The following statement contains a magic number: using (var writer = new AiffFileWriter(filename' sourceProvider.WaveFormat))              {                  byte[] buffer = new byte[16384];                    while (sourceProvider.Position < sourceProvider.Length)                  {                      int count = Math.Min((int)(sourceProvider.Length - sourceProvider.Position)' buffer.Length);                      int bytesRead = sourceProvider.Read(buffer' 0' count);                        if (bytesRead == 0)                      {                          // end of source provider                          break;                      }                        writer.Write(buffer' 0' bytesRead);                  }              }
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,SwapEndian,The following statement contains a magic number: return new byte[] { (byte)(n >> 8)' (byte)(n & 0xff) };
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,SwapEndian,The following statement contains a magic number: return new byte[] { (byte)((n >> 24) & 0xff)' (byte)((n >> 16) & 0xff)' (byte)((n >> 8) & 0xff)' (byte)(n & 0xff)' };
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,SwapEndian,The following statement contains a magic number: return new byte[] { (byte)((n >> 24) & 0xff)' (byte)((n >> 16) & 0xff)' (byte)((n >> 8) & 0xff)' (byte)(n & 0xff)' };
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,SwapEndian,The following statement contains a magic number: return new byte[] { (byte)((n >> 24) & 0xff)' (byte)((n >> 16) & 0xff)' (byte)((n >> 8) & 0xff)' (byte)(n & 0xff)' };
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,CreateCommChunk,The following statement contains a magic number: this.writer.Write(SwapEndian((int)18));
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,Write,The following statement contains a magic number: int align = format.BitsPerSample / 8;
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write(SwapEndian((Int16)(Int16.MaxValue * sample)));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[2] = value[1];                  value24[1] = value[2];                  value24[0] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == NAudio.Wave.WaveFormatEncoding.Extensible)              {                  writer.Write(SwapEndian(UInt16.MaxValue * (Int32)sample));                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write(SwapEndian((Int16)(Int16.MaxValue * sample)));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[2] = value[1];                  value24[1] = value[2];                  value24[0] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == NAudio.Wave.WaveFormatEncoding.Extensible)              {                  writer.Write(SwapEndian(UInt16.MaxValue * (Int32)sample));                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write(SwapEndian((Int16)(Int16.MaxValue * sample)));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[2] = value[1];                  value24[1] = value[2];                  value24[0] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == NAudio.Wave.WaveFormatEncoding.Extensible)              {                  writer.Write(SwapEndian(UInt16.MaxValue * (Int32)sample));                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write(SwapEndian((Int16)(Int16.MaxValue * sample)));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[2] = value[1];                  value24[1] = value[2];                  value24[0] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == NAudio.Wave.WaveFormatEncoding.Extensible)              {                  writer.Write(SwapEndian(UInt16.MaxValue * (Int32)sample));                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write(SwapEndian((Int16)(Int16.MaxValue * sample)));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[2] = value[1];                  value24[1] = value[2];                  value24[0] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == NAudio.Wave.WaveFormatEncoding.Extensible)              {                  writer.Write(SwapEndian(UInt16.MaxValue * (Int32)sample));                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write(SwapEndian((Int16)(Int16.MaxValue * sample)));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[2] = value[1];                  value24[1] = value[2];                  value24[0] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == NAudio.Wave.WaveFormatEncoding.Extensible)              {                  writer.Write(SwapEndian(UInt16.MaxValue * (Int32)sample));                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write(SwapEndian((Int16)(Int16.MaxValue * sample)));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[2] = value[1];                  value24[1] = value[2];                  value24[0] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == NAudio.Wave.WaveFormatEncoding.Extensible)              {                  writer.Write(SwapEndian(UInt16.MaxValue * (Int32)sample));                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write(SwapEndian((Int16)(Int16.MaxValue * sample)));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[2] = value[1];                  value24[1] = value[2];                  value24[0] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == NAudio.Wave.WaveFormatEncoding.Extensible)              {                  writer.Write(SwapEndian(UInt16.MaxValue * (Int32)sample));                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write(SwapEndian((Int16)(Int16.MaxValue * sample)));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[2] = value[1];                  value24[1] = value[2];                  value24[0] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == NAudio.Wave.WaveFormatEncoding.Extensible)              {                  writer.Write(SwapEndian(UInt16.MaxValue * (Int32)sample));                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(SwapEndian(samples[sample + offset]));                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[2] = value[1];                      value24[1] = value[2];                      value24[0] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(SwapEndian(UInt16.MaxValue * (Int32)samples[sample + offset]));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM audio data supported");              }
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(SwapEndian(samples[sample + offset]));                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[2] = value[1];                      value24[1] = value[2];                      value24[0] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(SwapEndian(UInt16.MaxValue * (Int32)samples[sample + offset]));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM audio data supported");              }
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(SwapEndian(samples[sample + offset]));                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[2] = value[1];                      value24[1] = value[2];                      value24[0] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(SwapEndian(UInt16.MaxValue * (Int32)samples[sample + offset]));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM audio data supported");              }
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(SwapEndian(samples[sample + offset]));                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[2] = value[1];                      value24[1] = value[2];                      value24[0] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(SwapEndian(UInt16.MaxValue * (Int32)samples[sample + offset]));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM audio data supported");              }
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(SwapEndian(samples[sample + offset]));                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[2] = value[1];                      value24[1] = value[2];                      value24[0] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(SwapEndian(UInt16.MaxValue * (Int32)samples[sample + offset]));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM audio data supported");              }
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(SwapEndian(samples[sample + offset]));                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[2] = value[1];                      value24[1] = value[2];                      value24[0] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(SwapEndian(UInt16.MaxValue * (Int32)samples[sample + offset]));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM audio data supported");              }
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(SwapEndian(samples[sample + offset]));                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[2] = value[1];                      value24[1] = value[2];                      value24[0] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(SwapEndian(UInt16.MaxValue * (Int32)samples[sample + offset]));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM audio data supported");              }
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(SwapEndian(samples[sample + offset]));                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[2] = value[1];                      value24[1] = value[2];                      value24[0] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(SwapEndian(UInt16.MaxValue * (Int32)samples[sample + offset]));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM audio data supported");              }
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(SwapEndian(samples[sample + offset]));                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  byte[] value;                  for (int sample = 0; sample < count; sample++)                  {                      value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[2] = value[1];                      value24[1] = value[2];                      value24[0] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(SwapEndian(UInt16.MaxValue * (Int32)samples[sample + offset]));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM audio data supported");              }
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,UpdateHeader,The following statement contains a magic number: writer.Seek(4' SeekOrigin.Begin);
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,UpdateHeader,The following statement contains a magic number: writer.Write(SwapEndian((int)(outStream.Length - 8)));
Magic Number,NAudio.Wave,AiffFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AiffFileWriter.cs,UpdateCommChunk,The following statement contains a magic number: writer.Write(SwapEndian((int)(dataChunkSize * 8 / format.BitsPerSample / format.Channels)));
Magic Number,NAudio.Wave,AsioAudioAvailableEventArgs,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AsioAudioAvailableEventArgs.cs,GetAsInterleavedSamples,The following statement contains a magic number: unsafe              {                  if (AsioSampleType == AsioSampleType.Int32LSB)                  {                      for (int n = 0; n < SamplesPerBuffer; n++)                      {                          for (int ch = 0; ch < channels; ch++)                          {                              samples[index++] = *((int*)InputBuffers[ch] + n) / (float)Int32.MaxValue;                          }                      }                  }                  else if (AsioSampleType == AsioSampleType.Int16LSB)                  {                      for (int n = 0; n < SamplesPerBuffer; n++)                      {                          for (int ch = 0; ch < channels; ch++)                          {                              samples[index++] = *((short*)InputBuffers[ch] + n) / (float)Int16.MaxValue;                          }                      }                  }                  else if (AsioSampleType == AsioSampleType.Int24LSB)                  {                      for (int n = 0; n < SamplesPerBuffer; n++)                      {                          for (int ch = 0; ch < channels; ch++)                          {                              byte *pSample = ((byte*)InputBuffers[ch] + n * 3);                                //int sample = *pSample + *(pSample+1) << 8 + (sbyte)*(pSample+2) << 16;                              int sample = pSample[0] | (pSample[1] << 8) | ((sbyte)pSample[2] << 16);                              samples[index++] = sample / 8388608.0f;                          }                      }                  }                  else if (AsioSampleType == AsioSampleType.Float32LSB)                  {                      for (int n = 0; n < SamplesPerBuffer; n++)                      {                          for (int ch = 0; ch < channels; ch++)                          {                              samples[index++] = *((float*)InputBuffers[ch] + n);                          }                      }                  }                  else                  {                      throw new NotImplementedException(String.Format("ASIO Sample Type {0} not supported"' AsioSampleType));                  }              }
Magic Number,NAudio.Wave,AsioAudioAvailableEventArgs,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AsioAudioAvailableEventArgs.cs,GetAsInterleavedSamples,The following statement contains a magic number: unsafe              {                  if (AsioSampleType == AsioSampleType.Int32LSB)                  {                      for (int n = 0; n < SamplesPerBuffer; n++)                      {                          for (int ch = 0; ch < channels; ch++)                          {                              samples[index++] = *((int*)InputBuffers[ch] + n) / (float)Int32.MaxValue;                          }                      }                  }                  else if (AsioSampleType == AsioSampleType.Int16LSB)                  {                      for (int n = 0; n < SamplesPerBuffer; n++)                      {                          for (int ch = 0; ch < channels; ch++)                          {                              samples[index++] = *((short*)InputBuffers[ch] + n) / (float)Int16.MaxValue;                          }                      }                  }                  else if (AsioSampleType == AsioSampleType.Int24LSB)                  {                      for (int n = 0; n < SamplesPerBuffer; n++)                      {                          for (int ch = 0; ch < channels; ch++)                          {                              byte *pSample = ((byte*)InputBuffers[ch] + n * 3);                                //int sample = *pSample + *(pSample+1) << 8 + (sbyte)*(pSample+2) << 16;                              int sample = pSample[0] | (pSample[1] << 8) | ((sbyte)pSample[2] << 16);                              samples[index++] = sample / 8388608.0f;                          }                      }                  }                  else if (AsioSampleType == AsioSampleType.Float32LSB)                  {                      for (int n = 0; n < SamplesPerBuffer; n++)                      {                          for (int ch = 0; ch < channels; ch++)                          {                              samples[index++] = *((float*)InputBuffers[ch] + n);                          }                      }                  }                  else                  {                      throw new NotImplementedException(String.Format("ASIO Sample Type {0} not supported"' AsioSampleType));                  }              }
Magic Number,NAudio.Wave,AsioAudioAvailableEventArgs,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AsioAudioAvailableEventArgs.cs,GetAsInterleavedSamples,The following statement contains a magic number: unsafe              {                  if (AsioSampleType == AsioSampleType.Int32LSB)                  {                      for (int n = 0; n < SamplesPerBuffer; n++)                      {                          for (int ch = 0; ch < channels; ch++)                          {                              samples[index++] = *((int*)InputBuffers[ch] + n) / (float)Int32.MaxValue;                          }                      }                  }                  else if (AsioSampleType == AsioSampleType.Int16LSB)                  {                      for (int n = 0; n < SamplesPerBuffer; n++)                      {                          for (int ch = 0; ch < channels; ch++)                          {                              samples[index++] = *((short*)InputBuffers[ch] + n) / (float)Int16.MaxValue;                          }                      }                  }                  else if (AsioSampleType == AsioSampleType.Int24LSB)                  {                      for (int n = 0; n < SamplesPerBuffer; n++)                      {                          for (int ch = 0; ch < channels; ch++)                          {                              byte *pSample = ((byte*)InputBuffers[ch] + n * 3);                                //int sample = *pSample + *(pSample+1) << 8 + (sbyte)*(pSample+2) << 16;                              int sample = pSample[0] | (pSample[1] << 8) | ((sbyte)pSample[2] << 16);                              samples[index++] = sample / 8388608.0f;                          }                      }                  }                  else if (AsioSampleType == AsioSampleType.Float32LSB)                  {                      for (int n = 0; n < SamplesPerBuffer; n++)                      {                          for (int ch = 0; ch < channels; ch++)                          {                              samples[index++] = *((float*)InputBuffers[ch] + n);                          }                      }                  }                  else                  {                      throw new NotImplementedException(String.Format("ASIO Sample Type {0} not supported"' AsioSampleType));                  }              }
Magic Number,NAudio.Wave,AsioAudioAvailableEventArgs,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AsioAudioAvailableEventArgs.cs,GetAsInterleavedSamples,The following statement contains a magic number: unsafe              {                  if (AsioSampleType == AsioSampleType.Int32LSB)                  {                      for (int n = 0; n < SamplesPerBuffer; n++)                      {                          for (int ch = 0; ch < channels; ch++)                          {                              samples[index++] = *((int*)InputBuffers[ch] + n) / (float)Int32.MaxValue;                          }                      }                  }                  else if (AsioSampleType == AsioSampleType.Int16LSB)                  {                      for (int n = 0; n < SamplesPerBuffer; n++)                      {                          for (int ch = 0; ch < channels; ch++)                          {                              samples[index++] = *((short*)InputBuffers[ch] + n) / (float)Int16.MaxValue;                          }                      }                  }                  else if (AsioSampleType == AsioSampleType.Int24LSB)                  {                      for (int n = 0; n < SamplesPerBuffer; n++)                      {                          for (int ch = 0; ch < channels; ch++)                          {                              byte *pSample = ((byte*)InputBuffers[ch] + n * 3);                                //int sample = *pSample + *(pSample+1) << 8 + (sbyte)*(pSample+2) << 16;                              int sample = pSample[0] | (pSample[1] << 8) | ((sbyte)pSample[2] << 16);                              samples[index++] = sample / 8388608.0f;                          }                      }                  }                  else if (AsioSampleType == AsioSampleType.Float32LSB)                  {                      for (int n = 0; n < SamplesPerBuffer; n++)                      {                          for (int ch = 0; ch < channels; ch++)                          {                              samples[index++] = *((float*)InputBuffers[ch] + n);                          }                      }                  }                  else                  {                      throw new NotImplementedException(String.Format("ASIO Sample Type {0} not supported"' AsioSampleType));                  }              }
Magic Number,NAudio.Wave,AsioOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\AsioOut.cs,InitRecordAndPlayback,The following statement contains a magic number: if (waveProvider != null)              {                  // make a buffer big enough to read enough from the sourceStream to fill the ASIO buffers                  waveBuffer = new byte[nbSamples * NumberOfOutputChannels * waveProvider.WaveFormat.BitsPerSample / 8];              }
Magic Number,NAudio.Wave,BextChunkInfo,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\BextChunkInfo.cs,BextChunkInfo,The following statement contains a magic number: Reserved = new byte[190];
Magic Number,NAudio.Wave,BwfWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\BwfWriter.cs,BwfWriter,The following statement contains a magic number: writer.Write(28);
Magic Number,NAudio.Wave,BwfWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\BwfWriter.cs,BwfWriter,The following statement contains a magic number: var bextLength = 602 + codingHistory.Length;
Magic Number,NAudio.Wave,BwfWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\BwfWriter.cs,BwfWriter,The following statement contains a magic number: if (bextLength % 2 != 0)                  bextLength++;
Magic Number,NAudio.Wave,BwfWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\BwfWriter.cs,BwfWriter,The following statement contains a magic number: writer.Write(GetAsBytes(bextChunkInfo.Description' 256));
Magic Number,NAudio.Wave,BwfWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\BwfWriter.cs,BwfWriter,The following statement contains a magic number: writer.Write(GetAsBytes(bextChunkInfo.Originator' 32));
Magic Number,NAudio.Wave,BwfWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\BwfWriter.cs,BwfWriter,The following statement contains a magic number: writer.Write(GetAsBytes(bextChunkInfo.OriginatorReference' 32));
Magic Number,NAudio.Wave,BwfWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\BwfWriter.cs,BwfWriter,The following statement contains a magic number: writer.Write(GetAsBytes(bextChunkInfo.OriginationDate' 10));
Magic Number,NAudio.Wave,BwfWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\BwfWriter.cs,BwfWriter,The following statement contains a magic number: writer.Write(GetAsBytes(bextChunkInfo.OriginationTime' 8));
Magic Number,NAudio.Wave,BwfWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\BwfWriter.cs,BwfWriter,The following statement contains a magic number: writer.Write(GetAsBytes(bextChunkInfo.UniqueMaterialIdentifier' 64));
Magic Number,NAudio.Wave,BwfWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\BwfWriter.cs,BwfWriter,The following statement contains a magic number: if (codingHistory.Length % 2 != 0)                  writer.Write((byte)0);
Magic Number,NAudio.Wave,BwfWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\BwfWriter.cs,FixUpChunkSizes,The following statement contains a magic number: var riffSize = writer.BaseStream.Length - 8;
Magic Number,NAudio.Wave,BwfWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\BwfWriter.cs,FixUpChunkSizes,The following statement contains a magic number: if (isLarge)              {                  var bytesPerSample = (format.BitsPerSample / 8) * format.Channels;                  writer.BaseStream.Position = 0;                  writer.Write(Encoding.UTF8.GetBytes("RF64"));                  writer.Write(-1);                  writer.BaseStream.Position += 4; // skip over WAVE                  writer.Write(Encoding.UTF8.GetBytes("ds64"));                  writer.BaseStream.Position += 4; // skip over ds64 chunk size                  writer.Write(riffSize);                  writer.Write(dataLength);                  writer.Write(dataLength / bytesPerSample);                    // data chunk size can stay as -1              }              else              {                  // fix up the RIFF size                  writer.BaseStream.Position = 4;                  writer.Write((uint)riffSize);                  // fix up the data chunk size                  writer.BaseStream.Position = dataChunkSizePosition;                  writer.Write((uint)dataLength);              }
Magic Number,NAudio.Wave,BwfWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\BwfWriter.cs,FixUpChunkSizes,The following statement contains a magic number: if (isLarge)              {                  var bytesPerSample = (format.BitsPerSample / 8) * format.Channels;                  writer.BaseStream.Position = 0;                  writer.Write(Encoding.UTF8.GetBytes("RF64"));                  writer.Write(-1);                  writer.BaseStream.Position += 4; // skip over WAVE                  writer.Write(Encoding.UTF8.GetBytes("ds64"));                  writer.BaseStream.Position += 4; // skip over ds64 chunk size                  writer.Write(riffSize);                  writer.Write(dataLength);                  writer.Write(dataLength / bytesPerSample);                    // data chunk size can stay as -1              }              else              {                  // fix up the RIFF size                  writer.BaseStream.Position = 4;                  writer.Write((uint)riffSize);                  // fix up the data chunk size                  writer.BaseStream.Position = dataChunkSizePosition;                  writer.Write((uint)dataLength);              }
Magic Number,NAudio.Wave,BwfWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\BwfWriter.cs,FixUpChunkSizes,The following statement contains a magic number: if (isLarge)              {                  var bytesPerSample = (format.BitsPerSample / 8) * format.Channels;                  writer.BaseStream.Position = 0;                  writer.Write(Encoding.UTF8.GetBytes("RF64"));                  writer.Write(-1);                  writer.BaseStream.Position += 4; // skip over WAVE                  writer.Write(Encoding.UTF8.GetBytes("ds64"));                  writer.BaseStream.Position += 4; // skip over ds64 chunk size                  writer.Write(riffSize);                  writer.Write(dataLength);                  writer.Write(dataLength / bytesPerSample);                    // data chunk size can stay as -1              }              else              {                  // fix up the RIFF size                  writer.BaseStream.Position = 4;                  writer.Write((uint)riffSize);                  // fix up the data chunk size                  writer.BaseStream.Position = dataChunkSizePosition;                  writer.Write((uint)dataLength);              }
Magic Number,NAudio.Wave,BwfWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\BwfWriter.cs,FixUpChunkSizes,The following statement contains a magic number: if (isLarge)              {                  var bytesPerSample = (format.BitsPerSample / 8) * format.Channels;                  writer.BaseStream.Position = 0;                  writer.Write(Encoding.UTF8.GetBytes("RF64"));                  writer.Write(-1);                  writer.BaseStream.Position += 4; // skip over WAVE                  writer.Write(Encoding.UTF8.GetBytes("ds64"));                  writer.BaseStream.Position += 4; // skip over ds64 chunk size                  writer.Write(riffSize);                  writer.Write(dataLength);                  writer.Write(dataLength / bytesPerSample);                    // data chunk size can stay as -1              }              else              {                  // fix up the RIFF size                  writer.BaseStream.Position = 4;                  writer.Write((uint)riffSize);                  // fix up the data chunk size                  writer.BaseStream.Position = dataChunkSizePosition;                  writer.Write((uint)dataLength);              }
Magic Number,NAudio.Wave,CueWaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\CueWaveFileWriter.cs,WriteCues,The following statement contains a magic number: if (cues != null)              {                  byte[] cueChunks = cues.GetRiffChunks();                  int cueChunksSize = cueChunks.Length;                  w.Seek(0' SeekOrigin.End);                                    if (w.BaseStream.Length % 2 == 1)                  {                      w.Write((Byte)0x00);                  }                                    w.Write(cues.GetRiffChunks()' 0' cueChunksSize);                  w.Seek(4' SeekOrigin.Begin);                  w.Write((int)(w.BaseStream.Length - 8));              }
Magic Number,NAudio.Wave,CueWaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\CueWaveFileWriter.cs,WriteCues,The following statement contains a magic number: if (cues != null)              {                  byte[] cueChunks = cues.GetRiffChunks();                  int cueChunksSize = cueChunks.Length;                  w.Seek(0' SeekOrigin.End);                                    if (w.BaseStream.Length % 2 == 1)                  {                      w.Write((Byte)0x00);                  }                                    w.Write(cues.GetRiffChunks()' 0' cueChunksSize);                  w.Seek(4' SeekOrigin.Begin);                  w.Write((int)(w.BaseStream.Length - 8));              }
Magic Number,NAudio.Wave,CueWaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\CueWaveFileWriter.cs,WriteCues,The following statement contains a magic number: if (cues != null)              {                  byte[] cueChunks = cues.GetRiffChunks();                  int cueChunksSize = cueChunks.Length;                  w.Seek(0' SeekOrigin.End);                                    if (w.BaseStream.Length % 2 == 1)                  {                      w.Write((Byte)0x00);                  }                                    w.Write(cues.GetRiffChunks()' 0' cueChunksSize);                  w.Seek(4' SeekOrigin.Begin);                  w.Write((int)(w.BaseStream.Length - 8));              }
Magic Number,NAudio.Wave,MediaFoundationEncoder,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\MediaFoundationEncoder.cs,GetEncodeBitrates,The following statement contains a magic number: return GetOutputMediaTypes(audioSubtype)                  .Where(mt => mt.SampleRate == sampleRate && mt.ChannelCount == channels)                  .Select(mt => mt.AverageBytesPerSecond*8)                  .Distinct()                  .OrderBy(br => br)                  .ToArray();
Magic Number,NAudio.Wave,MediaFoundationEncoder,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\MediaFoundationEncoder.cs,SelectMediaType,The following statement contains a magic number: return GetOutputMediaTypes(audioSubtype)                  .Where(mt => mt.SampleRate == inputFormat.SampleRate && mt.ChannelCount == inputFormat.Channels)                  .Select(mt => new { MediaType = mt' Delta = Math.Abs(desiredBitRate - mt.AverageBytesPerSecond * 8) } )                  .OrderBy(mt => mt.Delta)                  .Select(mt => mt.MediaType)                  .FirstOrDefault();
Magic Number,NAudio.Wave,MediaFoundationEncoder,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\MediaFoundationEncoder.cs,PerformEncode,The following statement contains a magic number: int maxLength = inputProvider.WaveFormat.AverageBytesPerSecond * 4;
Magic Number,NAudio.Wave,DirectSoundOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\DirectSoundOut.cs,EnumCallback,The following statement contains a magic number: if (lpGuid == IntPtr.Zero)              {                  device.Guid = Guid.Empty;              }              else              {                  byte[] guidBytes = new byte[16];                  Marshal.Copy(lpGuid' guidBytes' 0' 16);                  device.Guid = new Guid(guidBytes);              }
Magic Number,NAudio.Wave,DirectSoundOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\DirectSoundOut.cs,EnumCallback,The following statement contains a magic number: if (lpGuid == IntPtr.Zero)              {                  device.Guid = Guid.Empty;              }              else              {                  byte[] guidBytes = new byte[16];                  Marshal.Copy(lpGuid' guidBytes' 0' 16);                  device.Guid = new Guid(guidBytes);              }
Magic Number,NAudio.Wave,DirectSoundOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\DirectSoundOut.cs,Stop,The following statement contains a magic number: if (Monitor.TryEnter(m_LockObject' 50))              {                  playbackState = PlaybackState.Stopped;                  Monitor.Exit(m_LockObject);              }              else              {                  // No joy - abort the thread!                  if (notifyThread != null)                  {                      notifyThread.Abort();                      notifyThread = null;                  }              }
Magic Number,NAudio.Wave,DirectSoundOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\DirectSoundOut.cs,InitializeDirectSound,The following statement contains a magic number: lock (this.m_LockObject)              {                  directSound = null;                  DirectSoundCreate(ref device' out directSound' IntPtr.Zero);                    if (directSound != null)                  {                      // Set Cooperative Level to PRIORITY (priority level can call the SetFormat and Compact methods)                      directSound.SetCooperativeLevel(GetDesktopWindow()' DirectSoundCooperativeLevel.DSSCL_PRIORITY);                        // -------------------------------------------------------------------------------------                      // Create PrimaryBuffer                      // -------------------------------------------------------------------------------------                        // Fill BufferDescription for PrimaryBuffer                      BufferDescription bufferDesc = new BufferDescription();                      bufferDesc.dwSize = Marshal.SizeOf(bufferDesc);                      bufferDesc.dwBufferBytes = 0;                      bufferDesc.dwFlags = DirectSoundBufferCaps.DSBCAPS_PRIMARYBUFFER;                      bufferDesc.dwReserved = 0;                      bufferDesc.lpwfxFormat = IntPtr.Zero;                      bufferDesc.guidAlgo = Guid.Empty;                        object soundBufferObj;                      // Create PrimaryBuffer                      directSound.CreateSoundBuffer(bufferDesc' out soundBufferObj' IntPtr.Zero);                      primarySoundBuffer = (IDirectSoundBuffer)soundBufferObj;                        // Play & Loop on the PrimarySound Buffer                       primarySoundBuffer.Play(0' 0' DirectSoundPlayFlags.DSBPLAY_LOOPING);                        // -------------------------------------------------------------------------------------                      // Create SecondaryBuffer                      // -------------------------------------------------------------------------------------                        // A frame of samples equals to Desired Latency                      samplesFrameSize = MsToBytes(desiredLatency);                        // Fill BufferDescription for SecondaryBuffer                      BufferDescription bufferDesc2 = new BufferDescription();                      bufferDesc2.dwSize = Marshal.SizeOf(bufferDesc2);                      bufferDesc2.dwBufferBytes = (uint)(samplesFrameSize * 2);                      bufferDesc2.dwFlags = DirectSoundBufferCaps.DSBCAPS_GETCURRENTPOSITION2                          | DirectSoundBufferCaps.DSBCAPS_CTRLPOSITIONNOTIFY                          | DirectSoundBufferCaps.DSBCAPS_GLOBALFOCUS                          | DirectSoundBufferCaps.DSBCAPS_CTRLVOLUME                          | DirectSoundBufferCaps.DSBCAPS_STICKYFOCUS                          | DirectSoundBufferCaps.DSBCAPS_GETCURRENTPOSITION2;                      bufferDesc2.dwReserved = 0;                      GCHandle handleOnWaveFormat = GCHandle.Alloc(waveFormat' GCHandleType.Pinned); // Ptr to waveFormat                      bufferDesc2.lpwfxFormat = handleOnWaveFormat.AddrOfPinnedObject(); // set Ptr to waveFormat                      bufferDesc2.guidAlgo = Guid.Empty;                        // Create SecondaryBuffer                      directSound.CreateSoundBuffer(bufferDesc2' out soundBufferObj' IntPtr.Zero);                      secondaryBuffer = (IDirectSoundBuffer)soundBufferObj;                      handleOnWaveFormat.Free();                        // Get effective SecondaryBuffer size                      BufferCaps dsbCaps = new BufferCaps();                      dsbCaps.dwSize = Marshal.SizeOf(dsbCaps);                      secondaryBuffer.GetCaps(dsbCaps);                        nextSamplesWriteIndex = 0;                      samplesTotalSize = dsbCaps.dwBufferBytes;                      samples = new byte[samplesTotalSize];                      System.Diagnostics.Debug.Assert(samplesTotalSize == (2 * samplesFrameSize)' "Invalid SamplesTotalSize vs SamplesFrameSize");                        // -------------------------------------------------------------------------------------                      // Create double buffering notification.                      // Use DirectSoundNotify at Position [0' 1/2] and Stop Position (0xFFFFFFFF)                      // -------------------------------------------------------------------------------------                      IDirectSoundNotify notify = (IDirectSoundNotify)soundBufferObj;                        frameEventWaitHandle1 = new EventWaitHandle(false' EventResetMode.AutoReset);                      frameEventWaitHandle2 = new EventWaitHandle(false' EventResetMode.AutoReset);                      endEventWaitHandle = new EventWaitHandle(false' EventResetMode.AutoReset);                        DirectSoundBufferPositionNotify[] notifies = new DirectSoundBufferPositionNotify[3];                      notifies[0] = new DirectSoundBufferPositionNotify();                      notifies[0].dwOffset = 0;                      notifies[0].hEventNotify = frameEventWaitHandle1.SafeWaitHandle.DangerousGetHandle();                        notifies[1] = new DirectSoundBufferPositionNotify();                      notifies[1].dwOffset = (uint)samplesFrameSize;                      notifies[1].hEventNotify = frameEventWaitHandle2.SafeWaitHandle.DangerousGetHandle();                        notifies[2] = new DirectSoundBufferPositionNotify();                      notifies[2].dwOffset = 0xFFFFFFFF;                      notifies[2].hEventNotify = endEventWaitHandle.SafeWaitHandle.DangerousGetHandle();                        notify.SetNotificationPositions(3' notifies);                  }              }
Magic Number,NAudio.Wave,DirectSoundOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\DirectSoundOut.cs,InitializeDirectSound,The following statement contains a magic number: lock (this.m_LockObject)              {                  directSound = null;                  DirectSoundCreate(ref device' out directSound' IntPtr.Zero);                    if (directSound != null)                  {                      // Set Cooperative Level to PRIORITY (priority level can call the SetFormat and Compact methods)                      directSound.SetCooperativeLevel(GetDesktopWindow()' DirectSoundCooperativeLevel.DSSCL_PRIORITY);                        // -------------------------------------------------------------------------------------                      // Create PrimaryBuffer                      // -------------------------------------------------------------------------------------                        // Fill BufferDescription for PrimaryBuffer                      BufferDescription bufferDesc = new BufferDescription();                      bufferDesc.dwSize = Marshal.SizeOf(bufferDesc);                      bufferDesc.dwBufferBytes = 0;                      bufferDesc.dwFlags = DirectSoundBufferCaps.DSBCAPS_PRIMARYBUFFER;                      bufferDesc.dwReserved = 0;                      bufferDesc.lpwfxFormat = IntPtr.Zero;                      bufferDesc.guidAlgo = Guid.Empty;                        object soundBufferObj;                      // Create PrimaryBuffer                      directSound.CreateSoundBuffer(bufferDesc' out soundBufferObj' IntPtr.Zero);                      primarySoundBuffer = (IDirectSoundBuffer)soundBufferObj;                        // Play & Loop on the PrimarySound Buffer                       primarySoundBuffer.Play(0' 0' DirectSoundPlayFlags.DSBPLAY_LOOPING);                        // -------------------------------------------------------------------------------------                      // Create SecondaryBuffer                      // -------------------------------------------------------------------------------------                        // A frame of samples equals to Desired Latency                      samplesFrameSize = MsToBytes(desiredLatency);                        // Fill BufferDescription for SecondaryBuffer                      BufferDescription bufferDesc2 = new BufferDescription();                      bufferDesc2.dwSize = Marshal.SizeOf(bufferDesc2);                      bufferDesc2.dwBufferBytes = (uint)(samplesFrameSize * 2);                      bufferDesc2.dwFlags = DirectSoundBufferCaps.DSBCAPS_GETCURRENTPOSITION2                          | DirectSoundBufferCaps.DSBCAPS_CTRLPOSITIONNOTIFY                          | DirectSoundBufferCaps.DSBCAPS_GLOBALFOCUS                          | DirectSoundBufferCaps.DSBCAPS_CTRLVOLUME                          | DirectSoundBufferCaps.DSBCAPS_STICKYFOCUS                          | DirectSoundBufferCaps.DSBCAPS_GETCURRENTPOSITION2;                      bufferDesc2.dwReserved = 0;                      GCHandle handleOnWaveFormat = GCHandle.Alloc(waveFormat' GCHandleType.Pinned); // Ptr to waveFormat                      bufferDesc2.lpwfxFormat = handleOnWaveFormat.AddrOfPinnedObject(); // set Ptr to waveFormat                      bufferDesc2.guidAlgo = Guid.Empty;                        // Create SecondaryBuffer                      directSound.CreateSoundBuffer(bufferDesc2' out soundBufferObj' IntPtr.Zero);                      secondaryBuffer = (IDirectSoundBuffer)soundBufferObj;                      handleOnWaveFormat.Free();                        // Get effective SecondaryBuffer size                      BufferCaps dsbCaps = new BufferCaps();                      dsbCaps.dwSize = Marshal.SizeOf(dsbCaps);                      secondaryBuffer.GetCaps(dsbCaps);                        nextSamplesWriteIndex = 0;                      samplesTotalSize = dsbCaps.dwBufferBytes;                      samples = new byte[samplesTotalSize];                      System.Diagnostics.Debug.Assert(samplesTotalSize == (2 * samplesFrameSize)' "Invalid SamplesTotalSize vs SamplesFrameSize");                        // -------------------------------------------------------------------------------------                      // Create double buffering notification.                      // Use DirectSoundNotify at Position [0' 1/2] and Stop Position (0xFFFFFFFF)                      // -------------------------------------------------------------------------------------                      IDirectSoundNotify notify = (IDirectSoundNotify)soundBufferObj;                        frameEventWaitHandle1 = new EventWaitHandle(false' EventResetMode.AutoReset);                      frameEventWaitHandle2 = new EventWaitHandle(false' EventResetMode.AutoReset);                      endEventWaitHandle = new EventWaitHandle(false' EventResetMode.AutoReset);                        DirectSoundBufferPositionNotify[] notifies = new DirectSoundBufferPositionNotify[3];                      notifies[0] = new DirectSoundBufferPositionNotify();                      notifies[0].dwOffset = 0;                      notifies[0].hEventNotify = frameEventWaitHandle1.SafeWaitHandle.DangerousGetHandle();                        notifies[1] = new DirectSoundBufferPositionNotify();                      notifies[1].dwOffset = (uint)samplesFrameSize;                      notifies[1].hEventNotify = frameEventWaitHandle2.SafeWaitHandle.DangerousGetHandle();                        notifies[2] = new DirectSoundBufferPositionNotify();                      notifies[2].dwOffset = 0xFFFFFFFF;                      notifies[2].hEventNotify = endEventWaitHandle.SafeWaitHandle.DangerousGetHandle();                        notify.SetNotificationPositions(3' notifies);                  }              }
Magic Number,NAudio.Wave,DirectSoundOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\DirectSoundOut.cs,InitializeDirectSound,The following statement contains a magic number: lock (this.m_LockObject)              {                  directSound = null;                  DirectSoundCreate(ref device' out directSound' IntPtr.Zero);                    if (directSound != null)                  {                      // Set Cooperative Level to PRIORITY (priority level can call the SetFormat and Compact methods)                      directSound.SetCooperativeLevel(GetDesktopWindow()' DirectSoundCooperativeLevel.DSSCL_PRIORITY);                        // -------------------------------------------------------------------------------------                      // Create PrimaryBuffer                      // -------------------------------------------------------------------------------------                        // Fill BufferDescription for PrimaryBuffer                      BufferDescription bufferDesc = new BufferDescription();                      bufferDesc.dwSize = Marshal.SizeOf(bufferDesc);                      bufferDesc.dwBufferBytes = 0;                      bufferDesc.dwFlags = DirectSoundBufferCaps.DSBCAPS_PRIMARYBUFFER;                      bufferDesc.dwReserved = 0;                      bufferDesc.lpwfxFormat = IntPtr.Zero;                      bufferDesc.guidAlgo = Guid.Empty;                        object soundBufferObj;                      // Create PrimaryBuffer                      directSound.CreateSoundBuffer(bufferDesc' out soundBufferObj' IntPtr.Zero);                      primarySoundBuffer = (IDirectSoundBuffer)soundBufferObj;                        // Play & Loop on the PrimarySound Buffer                       primarySoundBuffer.Play(0' 0' DirectSoundPlayFlags.DSBPLAY_LOOPING);                        // -------------------------------------------------------------------------------------                      // Create SecondaryBuffer                      // -------------------------------------------------------------------------------------                        // A frame of samples equals to Desired Latency                      samplesFrameSize = MsToBytes(desiredLatency);                        // Fill BufferDescription for SecondaryBuffer                      BufferDescription bufferDesc2 = new BufferDescription();                      bufferDesc2.dwSize = Marshal.SizeOf(bufferDesc2);                      bufferDesc2.dwBufferBytes = (uint)(samplesFrameSize * 2);                      bufferDesc2.dwFlags = DirectSoundBufferCaps.DSBCAPS_GETCURRENTPOSITION2                          | DirectSoundBufferCaps.DSBCAPS_CTRLPOSITIONNOTIFY                          | DirectSoundBufferCaps.DSBCAPS_GLOBALFOCUS                          | DirectSoundBufferCaps.DSBCAPS_CTRLVOLUME                          | DirectSoundBufferCaps.DSBCAPS_STICKYFOCUS                          | DirectSoundBufferCaps.DSBCAPS_GETCURRENTPOSITION2;                      bufferDesc2.dwReserved = 0;                      GCHandle handleOnWaveFormat = GCHandle.Alloc(waveFormat' GCHandleType.Pinned); // Ptr to waveFormat                      bufferDesc2.lpwfxFormat = handleOnWaveFormat.AddrOfPinnedObject(); // set Ptr to waveFormat                      bufferDesc2.guidAlgo = Guid.Empty;                        // Create SecondaryBuffer                      directSound.CreateSoundBuffer(bufferDesc2' out soundBufferObj' IntPtr.Zero);                      secondaryBuffer = (IDirectSoundBuffer)soundBufferObj;                      handleOnWaveFormat.Free();                        // Get effective SecondaryBuffer size                      BufferCaps dsbCaps = new BufferCaps();                      dsbCaps.dwSize = Marshal.SizeOf(dsbCaps);                      secondaryBuffer.GetCaps(dsbCaps);                        nextSamplesWriteIndex = 0;                      samplesTotalSize = dsbCaps.dwBufferBytes;                      samples = new byte[samplesTotalSize];                      System.Diagnostics.Debug.Assert(samplesTotalSize == (2 * samplesFrameSize)' "Invalid SamplesTotalSize vs SamplesFrameSize");                        // -------------------------------------------------------------------------------------                      // Create double buffering notification.                      // Use DirectSoundNotify at Position [0' 1/2] and Stop Position (0xFFFFFFFF)                      // -------------------------------------------------------------------------------------                      IDirectSoundNotify notify = (IDirectSoundNotify)soundBufferObj;                        frameEventWaitHandle1 = new EventWaitHandle(false' EventResetMode.AutoReset);                      frameEventWaitHandle2 = new EventWaitHandle(false' EventResetMode.AutoReset);                      endEventWaitHandle = new EventWaitHandle(false' EventResetMode.AutoReset);                        DirectSoundBufferPositionNotify[] notifies = new DirectSoundBufferPositionNotify[3];                      notifies[0] = new DirectSoundBufferPositionNotify();                      notifies[0].dwOffset = 0;                      notifies[0].hEventNotify = frameEventWaitHandle1.SafeWaitHandle.DangerousGetHandle();                        notifies[1] = new DirectSoundBufferPositionNotify();                      notifies[1].dwOffset = (uint)samplesFrameSize;                      notifies[1].hEventNotify = frameEventWaitHandle2.SafeWaitHandle.DangerousGetHandle();                        notifies[2] = new DirectSoundBufferPositionNotify();                      notifies[2].dwOffset = 0xFFFFFFFF;                      notifies[2].hEventNotify = endEventWaitHandle.SafeWaitHandle.DangerousGetHandle();                        notify.SetNotificationPositions(3' notifies);                  }              }
Magic Number,NAudio.Wave,DirectSoundOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\DirectSoundOut.cs,InitializeDirectSound,The following statement contains a magic number: lock (this.m_LockObject)              {                  directSound = null;                  DirectSoundCreate(ref device' out directSound' IntPtr.Zero);                    if (directSound != null)                  {                      // Set Cooperative Level to PRIORITY (priority level can call the SetFormat and Compact methods)                      directSound.SetCooperativeLevel(GetDesktopWindow()' DirectSoundCooperativeLevel.DSSCL_PRIORITY);                        // -------------------------------------------------------------------------------------                      // Create PrimaryBuffer                      // -------------------------------------------------------------------------------------                        // Fill BufferDescription for PrimaryBuffer                      BufferDescription bufferDesc = new BufferDescription();                      bufferDesc.dwSize = Marshal.SizeOf(bufferDesc);                      bufferDesc.dwBufferBytes = 0;                      bufferDesc.dwFlags = DirectSoundBufferCaps.DSBCAPS_PRIMARYBUFFER;                      bufferDesc.dwReserved = 0;                      bufferDesc.lpwfxFormat = IntPtr.Zero;                      bufferDesc.guidAlgo = Guid.Empty;                        object soundBufferObj;                      // Create PrimaryBuffer                      directSound.CreateSoundBuffer(bufferDesc' out soundBufferObj' IntPtr.Zero);                      primarySoundBuffer = (IDirectSoundBuffer)soundBufferObj;                        // Play & Loop on the PrimarySound Buffer                       primarySoundBuffer.Play(0' 0' DirectSoundPlayFlags.DSBPLAY_LOOPING);                        // -------------------------------------------------------------------------------------                      // Create SecondaryBuffer                      // -------------------------------------------------------------------------------------                        // A frame of samples equals to Desired Latency                      samplesFrameSize = MsToBytes(desiredLatency);                        // Fill BufferDescription for SecondaryBuffer                      BufferDescription bufferDesc2 = new BufferDescription();                      bufferDesc2.dwSize = Marshal.SizeOf(bufferDesc2);                      bufferDesc2.dwBufferBytes = (uint)(samplesFrameSize * 2);                      bufferDesc2.dwFlags = DirectSoundBufferCaps.DSBCAPS_GETCURRENTPOSITION2                          | DirectSoundBufferCaps.DSBCAPS_CTRLPOSITIONNOTIFY                          | DirectSoundBufferCaps.DSBCAPS_GLOBALFOCUS                          | DirectSoundBufferCaps.DSBCAPS_CTRLVOLUME                          | DirectSoundBufferCaps.DSBCAPS_STICKYFOCUS                          | DirectSoundBufferCaps.DSBCAPS_GETCURRENTPOSITION2;                      bufferDesc2.dwReserved = 0;                      GCHandle handleOnWaveFormat = GCHandle.Alloc(waveFormat' GCHandleType.Pinned); // Ptr to waveFormat                      bufferDesc2.lpwfxFormat = handleOnWaveFormat.AddrOfPinnedObject(); // set Ptr to waveFormat                      bufferDesc2.guidAlgo = Guid.Empty;                        // Create SecondaryBuffer                      directSound.CreateSoundBuffer(bufferDesc2' out soundBufferObj' IntPtr.Zero);                      secondaryBuffer = (IDirectSoundBuffer)soundBufferObj;                      handleOnWaveFormat.Free();                        // Get effective SecondaryBuffer size                      BufferCaps dsbCaps = new BufferCaps();                      dsbCaps.dwSize = Marshal.SizeOf(dsbCaps);                      secondaryBuffer.GetCaps(dsbCaps);                        nextSamplesWriteIndex = 0;                      samplesTotalSize = dsbCaps.dwBufferBytes;                      samples = new byte[samplesTotalSize];                      System.Diagnostics.Debug.Assert(samplesTotalSize == (2 * samplesFrameSize)' "Invalid SamplesTotalSize vs SamplesFrameSize");                        // -------------------------------------------------------------------------------------                      // Create double buffering notification.                      // Use DirectSoundNotify at Position [0' 1/2] and Stop Position (0xFFFFFFFF)                      // -------------------------------------------------------------------------------------                      IDirectSoundNotify notify = (IDirectSoundNotify)soundBufferObj;                        frameEventWaitHandle1 = new EventWaitHandle(false' EventResetMode.AutoReset);                      frameEventWaitHandle2 = new EventWaitHandle(false' EventResetMode.AutoReset);                      endEventWaitHandle = new EventWaitHandle(false' EventResetMode.AutoReset);                        DirectSoundBufferPositionNotify[] notifies = new DirectSoundBufferPositionNotify[3];                      notifies[0] = new DirectSoundBufferPositionNotify();                      notifies[0].dwOffset = 0;                      notifies[0].hEventNotify = frameEventWaitHandle1.SafeWaitHandle.DangerousGetHandle();                        notifies[1] = new DirectSoundBufferPositionNotify();                      notifies[1].dwOffset = (uint)samplesFrameSize;                      notifies[1].hEventNotify = frameEventWaitHandle2.SafeWaitHandle.DangerousGetHandle();                        notifies[2] = new DirectSoundBufferPositionNotify();                      notifies[2].dwOffset = 0xFFFFFFFF;                      notifies[2].hEventNotify = endEventWaitHandle.SafeWaitHandle.DangerousGetHandle();                        notify.SetNotificationPositions(3' notifies);                  }              }
Magic Number,NAudio.Wave,DirectSoundOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\DirectSoundOut.cs,InitializeDirectSound,The following statement contains a magic number: lock (this.m_LockObject)              {                  directSound = null;                  DirectSoundCreate(ref device' out directSound' IntPtr.Zero);                    if (directSound != null)                  {                      // Set Cooperative Level to PRIORITY (priority level can call the SetFormat and Compact methods)                      directSound.SetCooperativeLevel(GetDesktopWindow()' DirectSoundCooperativeLevel.DSSCL_PRIORITY);                        // -------------------------------------------------------------------------------------                      // Create PrimaryBuffer                      // -------------------------------------------------------------------------------------                        // Fill BufferDescription for PrimaryBuffer                      BufferDescription bufferDesc = new BufferDescription();                      bufferDesc.dwSize = Marshal.SizeOf(bufferDesc);                      bufferDesc.dwBufferBytes = 0;                      bufferDesc.dwFlags = DirectSoundBufferCaps.DSBCAPS_PRIMARYBUFFER;                      bufferDesc.dwReserved = 0;                      bufferDesc.lpwfxFormat = IntPtr.Zero;                      bufferDesc.guidAlgo = Guid.Empty;                        object soundBufferObj;                      // Create PrimaryBuffer                      directSound.CreateSoundBuffer(bufferDesc' out soundBufferObj' IntPtr.Zero);                      primarySoundBuffer = (IDirectSoundBuffer)soundBufferObj;                        // Play & Loop on the PrimarySound Buffer                       primarySoundBuffer.Play(0' 0' DirectSoundPlayFlags.DSBPLAY_LOOPING);                        // -------------------------------------------------------------------------------------                      // Create SecondaryBuffer                      // -------------------------------------------------------------------------------------                        // A frame of samples equals to Desired Latency                      samplesFrameSize = MsToBytes(desiredLatency);                        // Fill BufferDescription for SecondaryBuffer                      BufferDescription bufferDesc2 = new BufferDescription();                      bufferDesc2.dwSize = Marshal.SizeOf(bufferDesc2);                      bufferDesc2.dwBufferBytes = (uint)(samplesFrameSize * 2);                      bufferDesc2.dwFlags = DirectSoundBufferCaps.DSBCAPS_GETCURRENTPOSITION2                          | DirectSoundBufferCaps.DSBCAPS_CTRLPOSITIONNOTIFY                          | DirectSoundBufferCaps.DSBCAPS_GLOBALFOCUS                          | DirectSoundBufferCaps.DSBCAPS_CTRLVOLUME                          | DirectSoundBufferCaps.DSBCAPS_STICKYFOCUS                          | DirectSoundBufferCaps.DSBCAPS_GETCURRENTPOSITION2;                      bufferDesc2.dwReserved = 0;                      GCHandle handleOnWaveFormat = GCHandle.Alloc(waveFormat' GCHandleType.Pinned); // Ptr to waveFormat                      bufferDesc2.lpwfxFormat = handleOnWaveFormat.AddrOfPinnedObject(); // set Ptr to waveFormat                      bufferDesc2.guidAlgo = Guid.Empty;                        // Create SecondaryBuffer                      directSound.CreateSoundBuffer(bufferDesc2' out soundBufferObj' IntPtr.Zero);                      secondaryBuffer = (IDirectSoundBuffer)soundBufferObj;                      handleOnWaveFormat.Free();                        // Get effective SecondaryBuffer size                      BufferCaps dsbCaps = new BufferCaps();                      dsbCaps.dwSize = Marshal.SizeOf(dsbCaps);                      secondaryBuffer.GetCaps(dsbCaps);                        nextSamplesWriteIndex = 0;                      samplesTotalSize = dsbCaps.dwBufferBytes;                      samples = new byte[samplesTotalSize];                      System.Diagnostics.Debug.Assert(samplesTotalSize == (2 * samplesFrameSize)' "Invalid SamplesTotalSize vs SamplesFrameSize");                        // -------------------------------------------------------------------------------------                      // Create double buffering notification.                      // Use DirectSoundNotify at Position [0' 1/2] and Stop Position (0xFFFFFFFF)                      // -------------------------------------------------------------------------------------                      IDirectSoundNotify notify = (IDirectSoundNotify)soundBufferObj;                        frameEventWaitHandle1 = new EventWaitHandle(false' EventResetMode.AutoReset);                      frameEventWaitHandle2 = new EventWaitHandle(false' EventResetMode.AutoReset);                      endEventWaitHandle = new EventWaitHandle(false' EventResetMode.AutoReset);                        DirectSoundBufferPositionNotify[] notifies = new DirectSoundBufferPositionNotify[3];                      notifies[0] = new DirectSoundBufferPositionNotify();                      notifies[0].dwOffset = 0;                      notifies[0].hEventNotify = frameEventWaitHandle1.SafeWaitHandle.DangerousGetHandle();                        notifies[1] = new DirectSoundBufferPositionNotify();                      notifies[1].dwOffset = (uint)samplesFrameSize;                      notifies[1].hEventNotify = frameEventWaitHandle2.SafeWaitHandle.DangerousGetHandle();                        notifies[2] = new DirectSoundBufferPositionNotify();                      notifies[2].dwOffset = 0xFFFFFFFF;                      notifies[2].hEventNotify = endEventWaitHandle.SafeWaitHandle.DangerousGetHandle();                        notify.SetNotificationPositions(3' notifies);                  }              }
Magic Number,NAudio.Wave,DirectSoundOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\DirectSoundOut.cs,InitializeDirectSound,The following statement contains a magic number: lock (this.m_LockObject)              {                  directSound = null;                  DirectSoundCreate(ref device' out directSound' IntPtr.Zero);                    if (directSound != null)                  {                      // Set Cooperative Level to PRIORITY (priority level can call the SetFormat and Compact methods)                      directSound.SetCooperativeLevel(GetDesktopWindow()' DirectSoundCooperativeLevel.DSSCL_PRIORITY);                        // -------------------------------------------------------------------------------------                      // Create PrimaryBuffer                      // -------------------------------------------------------------------------------------                        // Fill BufferDescription for PrimaryBuffer                      BufferDescription bufferDesc = new BufferDescription();                      bufferDesc.dwSize = Marshal.SizeOf(bufferDesc);                      bufferDesc.dwBufferBytes = 0;                      bufferDesc.dwFlags = DirectSoundBufferCaps.DSBCAPS_PRIMARYBUFFER;                      bufferDesc.dwReserved = 0;                      bufferDesc.lpwfxFormat = IntPtr.Zero;                      bufferDesc.guidAlgo = Guid.Empty;                        object soundBufferObj;                      // Create PrimaryBuffer                      directSound.CreateSoundBuffer(bufferDesc' out soundBufferObj' IntPtr.Zero);                      primarySoundBuffer = (IDirectSoundBuffer)soundBufferObj;                        // Play & Loop on the PrimarySound Buffer                       primarySoundBuffer.Play(0' 0' DirectSoundPlayFlags.DSBPLAY_LOOPING);                        // -------------------------------------------------------------------------------------                      // Create SecondaryBuffer                      // -------------------------------------------------------------------------------------                        // A frame of samples equals to Desired Latency                      samplesFrameSize = MsToBytes(desiredLatency);                        // Fill BufferDescription for SecondaryBuffer                      BufferDescription bufferDesc2 = new BufferDescription();                      bufferDesc2.dwSize = Marshal.SizeOf(bufferDesc2);                      bufferDesc2.dwBufferBytes = (uint)(samplesFrameSize * 2);                      bufferDesc2.dwFlags = DirectSoundBufferCaps.DSBCAPS_GETCURRENTPOSITION2                          | DirectSoundBufferCaps.DSBCAPS_CTRLPOSITIONNOTIFY                          | DirectSoundBufferCaps.DSBCAPS_GLOBALFOCUS                          | DirectSoundBufferCaps.DSBCAPS_CTRLVOLUME                          | DirectSoundBufferCaps.DSBCAPS_STICKYFOCUS                          | DirectSoundBufferCaps.DSBCAPS_GETCURRENTPOSITION2;                      bufferDesc2.dwReserved = 0;                      GCHandle handleOnWaveFormat = GCHandle.Alloc(waveFormat' GCHandleType.Pinned); // Ptr to waveFormat                      bufferDesc2.lpwfxFormat = handleOnWaveFormat.AddrOfPinnedObject(); // set Ptr to waveFormat                      bufferDesc2.guidAlgo = Guid.Empty;                        // Create SecondaryBuffer                      directSound.CreateSoundBuffer(bufferDesc2' out soundBufferObj' IntPtr.Zero);                      secondaryBuffer = (IDirectSoundBuffer)soundBufferObj;                      handleOnWaveFormat.Free();                        // Get effective SecondaryBuffer size                      BufferCaps dsbCaps = new BufferCaps();                      dsbCaps.dwSize = Marshal.SizeOf(dsbCaps);                      secondaryBuffer.GetCaps(dsbCaps);                        nextSamplesWriteIndex = 0;                      samplesTotalSize = dsbCaps.dwBufferBytes;                      samples = new byte[samplesTotalSize];                      System.Diagnostics.Debug.Assert(samplesTotalSize == (2 * samplesFrameSize)' "Invalid SamplesTotalSize vs SamplesFrameSize");                        // -------------------------------------------------------------------------------------                      // Create double buffering notification.                      // Use DirectSoundNotify at Position [0' 1/2] and Stop Position (0xFFFFFFFF)                      // -------------------------------------------------------------------------------------                      IDirectSoundNotify notify = (IDirectSoundNotify)soundBufferObj;                        frameEventWaitHandle1 = new EventWaitHandle(false' EventResetMode.AutoReset);                      frameEventWaitHandle2 = new EventWaitHandle(false' EventResetMode.AutoReset);                      endEventWaitHandle = new EventWaitHandle(false' EventResetMode.AutoReset);                        DirectSoundBufferPositionNotify[] notifies = new DirectSoundBufferPositionNotify[3];                      notifies[0] = new DirectSoundBufferPositionNotify();                      notifies[0].dwOffset = 0;                      notifies[0].hEventNotify = frameEventWaitHandle1.SafeWaitHandle.DangerousGetHandle();                        notifies[1] = new DirectSoundBufferPositionNotify();                      notifies[1].dwOffset = (uint)samplesFrameSize;                      notifies[1].hEventNotify = frameEventWaitHandle2.SafeWaitHandle.DangerousGetHandle();                        notifies[2] = new DirectSoundBufferPositionNotify();                      notifies[2].dwOffset = 0xFFFFFFFF;                      notifies[2].hEventNotify = endEventWaitHandle.SafeWaitHandle.DangerousGetHandle();                        notify.SetNotificationPositions(3' notifies);                  }              }
Magic Number,NAudio.Wave,DirectSoundOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\DirectSoundOut.cs,InitializeDirectSound,The following statement contains a magic number: lock (this.m_LockObject)              {                  directSound = null;                  DirectSoundCreate(ref device' out directSound' IntPtr.Zero);                    if (directSound != null)                  {                      // Set Cooperative Level to PRIORITY (priority level can call the SetFormat and Compact methods)                      directSound.SetCooperativeLevel(GetDesktopWindow()' DirectSoundCooperativeLevel.DSSCL_PRIORITY);                        // -------------------------------------------------------------------------------------                      // Create PrimaryBuffer                      // -------------------------------------------------------------------------------------                        // Fill BufferDescription for PrimaryBuffer                      BufferDescription bufferDesc = new BufferDescription();                      bufferDesc.dwSize = Marshal.SizeOf(bufferDesc);                      bufferDesc.dwBufferBytes = 0;                      bufferDesc.dwFlags = DirectSoundBufferCaps.DSBCAPS_PRIMARYBUFFER;                      bufferDesc.dwReserved = 0;                      bufferDesc.lpwfxFormat = IntPtr.Zero;                      bufferDesc.guidAlgo = Guid.Empty;                        object soundBufferObj;                      // Create PrimaryBuffer                      directSound.CreateSoundBuffer(bufferDesc' out soundBufferObj' IntPtr.Zero);                      primarySoundBuffer = (IDirectSoundBuffer)soundBufferObj;                        // Play & Loop on the PrimarySound Buffer                       primarySoundBuffer.Play(0' 0' DirectSoundPlayFlags.DSBPLAY_LOOPING);                        // -------------------------------------------------------------------------------------                      // Create SecondaryBuffer                      // -------------------------------------------------------------------------------------                        // A frame of samples equals to Desired Latency                      samplesFrameSize = MsToBytes(desiredLatency);                        // Fill BufferDescription for SecondaryBuffer                      BufferDescription bufferDesc2 = new BufferDescription();                      bufferDesc2.dwSize = Marshal.SizeOf(bufferDesc2);                      bufferDesc2.dwBufferBytes = (uint)(samplesFrameSize * 2);                      bufferDesc2.dwFlags = DirectSoundBufferCaps.DSBCAPS_GETCURRENTPOSITION2                          | DirectSoundBufferCaps.DSBCAPS_CTRLPOSITIONNOTIFY                          | DirectSoundBufferCaps.DSBCAPS_GLOBALFOCUS                          | DirectSoundBufferCaps.DSBCAPS_CTRLVOLUME                          | DirectSoundBufferCaps.DSBCAPS_STICKYFOCUS                          | DirectSoundBufferCaps.DSBCAPS_GETCURRENTPOSITION2;                      bufferDesc2.dwReserved = 0;                      GCHandle handleOnWaveFormat = GCHandle.Alloc(waveFormat' GCHandleType.Pinned); // Ptr to waveFormat                      bufferDesc2.lpwfxFormat = handleOnWaveFormat.AddrOfPinnedObject(); // set Ptr to waveFormat                      bufferDesc2.guidAlgo = Guid.Empty;                        // Create SecondaryBuffer                      directSound.CreateSoundBuffer(bufferDesc2' out soundBufferObj' IntPtr.Zero);                      secondaryBuffer = (IDirectSoundBuffer)soundBufferObj;                      handleOnWaveFormat.Free();                        // Get effective SecondaryBuffer size                      BufferCaps dsbCaps = new BufferCaps();                      dsbCaps.dwSize = Marshal.SizeOf(dsbCaps);                      secondaryBuffer.GetCaps(dsbCaps);                        nextSamplesWriteIndex = 0;                      samplesTotalSize = dsbCaps.dwBufferBytes;                      samples = new byte[samplesTotalSize];                      System.Diagnostics.Debug.Assert(samplesTotalSize == (2 * samplesFrameSize)' "Invalid SamplesTotalSize vs SamplesFrameSize");                        // -------------------------------------------------------------------------------------                      // Create double buffering notification.                      // Use DirectSoundNotify at Position [0' 1/2] and Stop Position (0xFFFFFFFF)                      // -------------------------------------------------------------------------------------                      IDirectSoundNotify notify = (IDirectSoundNotify)soundBufferObj;                        frameEventWaitHandle1 = new EventWaitHandle(false' EventResetMode.AutoReset);                      frameEventWaitHandle2 = new EventWaitHandle(false' EventResetMode.AutoReset);                      endEventWaitHandle = new EventWaitHandle(false' EventResetMode.AutoReset);                        DirectSoundBufferPositionNotify[] notifies = new DirectSoundBufferPositionNotify[3];                      notifies[0] = new DirectSoundBufferPositionNotify();                      notifies[0].dwOffset = 0;                      notifies[0].hEventNotify = frameEventWaitHandle1.SafeWaitHandle.DangerousGetHandle();                        notifies[1] = new DirectSoundBufferPositionNotify();                      notifies[1].dwOffset = (uint)samplesFrameSize;                      notifies[1].hEventNotify = frameEventWaitHandle2.SafeWaitHandle.DangerousGetHandle();                        notifies[2] = new DirectSoundBufferPositionNotify();                      notifies[2].dwOffset = 0xFFFFFFFF;                      notifies[2].hEventNotify = endEventWaitHandle.SafeWaitHandle.DangerousGetHandle();                        notify.SetNotificationPositions(3' notifies);                  }              }
Magic Number,NAudio.Wave,DirectSoundOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\DirectSoundOut.cs,MsToBytes,The following statement contains a magic number: int bytes = ms * (waveFormat.AverageBytesPerSecond / 1000);
Magic Number,NAudio.Wave,DirectSoundOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\DirectSoundOut.cs,PlaybackThreadFunc,The following statement contains a magic number: try              {                  InitializeDirectSound();                  int lResult = 1;                    if (PlaybackState == PlaybackState.Stopped)                  {                      secondaryBuffer.SetCurrentPosition(0);                      nextSamplesWriteIndex = 0;                      lResult = Feed(samplesTotalSize);                  }                    // Incase the previous Feed method returns 0                  if (lResult > 0)                  {                      lock (m_LockObject)                      {                          playbackState = PlaybackState.Playing;                      }                        secondaryBuffer.Play(0' 0' DirectSoundPlayFlags.DSBPLAY_LOOPING);                        var waitHandles = new WaitHandle[] { frameEventWaitHandle1' frameEventWaitHandle2' endEventWaitHandle };                        bool lContinuePlayback = true;                      while (PlaybackState != PlaybackState.Stopped && lContinuePlayback)                      {                          // Wait for signals on frameEventWaitHandle1 (Position 0)' frameEventWaitHandle2 (Position 1/2)                          int indexHandle = WaitHandle.WaitAny(waitHandles' 3 * desiredLatency' false);                            // TimeOut is ok                          if (indexHandle != WaitHandle.WaitTimeout)                          {                              // Buffer is Stopped                              if (indexHandle == 2)                              {                                  // (Gee) - Not sure whether to stop playback in this case or not!                                  StopPlayback();                                  lPlaybackHalted = true;                                  lContinuePlayback = false;                              }                              else                              {                                  if (indexHandle == 0)                                  {                                      // we're at the beginning of the buffer...                                      if (firstBufferStarted)                                      {                                          // because this notification is based on the *playback" cursor' this should be reasonably accurate                                          bytesPlayed += samplesFrameSize * 2;                                      }                                  }                                  else                                  {                                      firstBufferStarted = true;                                  }                                    indexHandle = (indexHandle == 0) ? 1 : 0;                                  nextSamplesWriteIndex = indexHandle * samplesFrameSize;                                    // Only carry on playing if we can!                                  if (Feed(samplesFrameSize) == 0)                                  {                                      StopPlayback();                                      lPlaybackHalted = true;                                      lContinuePlayback = false;                                  }                              }                          }                          else                          {                              // Timed out!                              StopPlayback();                              lPlaybackHalted = true;                              lContinuePlayback = false;                              // report this as an error in the Playback Stopped                              // seems to happen when device is unplugged                              throw new Exception("DirectSound buffer timeout");                          }                      }                  }              }              catch (Exception e)              {                  // Do nothing (except report error)                  Debug.WriteLine(e.ToString());                  exception = e;              }              finally              {                  if (!lPlaybackHalted)                  {                      try                      {                          StopPlayback();                      }                      catch (Exception e)                      {                          Debug.WriteLine(e.ToString());                          // don't overwrite the original reason we exited the playback loop                          if (exception == null) exception = e;                      }                  }                    lock (m_LockObject)                  {                      playbackState = PlaybackState.Stopped;                  }                    bytesPlayed = 0;                    // Fire playback stopped event                  RaisePlaybackStopped(exception);              }
Magic Number,NAudio.Wave,DirectSoundOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\DirectSoundOut.cs,PlaybackThreadFunc,The following statement contains a magic number: try              {                  InitializeDirectSound();                  int lResult = 1;                    if (PlaybackState == PlaybackState.Stopped)                  {                      secondaryBuffer.SetCurrentPosition(0);                      nextSamplesWriteIndex = 0;                      lResult = Feed(samplesTotalSize);                  }                    // Incase the previous Feed method returns 0                  if (lResult > 0)                  {                      lock (m_LockObject)                      {                          playbackState = PlaybackState.Playing;                      }                        secondaryBuffer.Play(0' 0' DirectSoundPlayFlags.DSBPLAY_LOOPING);                        var waitHandles = new WaitHandle[] { frameEventWaitHandle1' frameEventWaitHandle2' endEventWaitHandle };                        bool lContinuePlayback = true;                      while (PlaybackState != PlaybackState.Stopped && lContinuePlayback)                      {                          // Wait for signals on frameEventWaitHandle1 (Position 0)' frameEventWaitHandle2 (Position 1/2)                          int indexHandle = WaitHandle.WaitAny(waitHandles' 3 * desiredLatency' false);                            // TimeOut is ok                          if (indexHandle != WaitHandle.WaitTimeout)                          {                              // Buffer is Stopped                              if (indexHandle == 2)                              {                                  // (Gee) - Not sure whether to stop playback in this case or not!                                  StopPlayback();                                  lPlaybackHalted = true;                                  lContinuePlayback = false;                              }                              else                              {                                  if (indexHandle == 0)                                  {                                      // we're at the beginning of the buffer...                                      if (firstBufferStarted)                                      {                                          // because this notification is based on the *playback" cursor' this should be reasonably accurate                                          bytesPlayed += samplesFrameSize * 2;                                      }                                  }                                  else                                  {                                      firstBufferStarted = true;                                  }                                    indexHandle = (indexHandle == 0) ? 1 : 0;                                  nextSamplesWriteIndex = indexHandle * samplesFrameSize;                                    // Only carry on playing if we can!                                  if (Feed(samplesFrameSize) == 0)                                  {                                      StopPlayback();                                      lPlaybackHalted = true;                                      lContinuePlayback = false;                                  }                              }                          }                          else                          {                              // Timed out!                              StopPlayback();                              lPlaybackHalted = true;                              lContinuePlayback = false;                              // report this as an error in the Playback Stopped                              // seems to happen when device is unplugged                              throw new Exception("DirectSound buffer timeout");                          }                      }                  }              }              catch (Exception e)              {                  // Do nothing (except report error)                  Debug.WriteLine(e.ToString());                  exception = e;              }              finally              {                  if (!lPlaybackHalted)                  {                      try                      {                          StopPlayback();                      }                      catch (Exception e)                      {                          Debug.WriteLine(e.ToString());                          // don't overwrite the original reason we exited the playback loop                          if (exception == null) exception = e;                      }                  }                    lock (m_LockObject)                  {                      playbackState = PlaybackState.Stopped;                  }                    bytesPlayed = 0;                    // Fire playback stopped event                  RaisePlaybackStopped(exception);              }
Magic Number,NAudio.Wave,DirectSoundOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\DirectSoundOut.cs,PlaybackThreadFunc,The following statement contains a magic number: try              {                  InitializeDirectSound();                  int lResult = 1;                    if (PlaybackState == PlaybackState.Stopped)                  {                      secondaryBuffer.SetCurrentPosition(0);                      nextSamplesWriteIndex = 0;                      lResult = Feed(samplesTotalSize);                  }                    // Incase the previous Feed method returns 0                  if (lResult > 0)                  {                      lock (m_LockObject)                      {                          playbackState = PlaybackState.Playing;                      }                        secondaryBuffer.Play(0' 0' DirectSoundPlayFlags.DSBPLAY_LOOPING);                        var waitHandles = new WaitHandle[] { frameEventWaitHandle1' frameEventWaitHandle2' endEventWaitHandle };                        bool lContinuePlayback = true;                      while (PlaybackState != PlaybackState.Stopped && lContinuePlayback)                      {                          // Wait for signals on frameEventWaitHandle1 (Position 0)' frameEventWaitHandle2 (Position 1/2)                          int indexHandle = WaitHandle.WaitAny(waitHandles' 3 * desiredLatency' false);                            // TimeOut is ok                          if (indexHandle != WaitHandle.WaitTimeout)                          {                              // Buffer is Stopped                              if (indexHandle == 2)                              {                                  // (Gee) - Not sure whether to stop playback in this case or not!                                  StopPlayback();                                  lPlaybackHalted = true;                                  lContinuePlayback = false;                              }                              else                              {                                  if (indexHandle == 0)                                  {                                      // we're at the beginning of the buffer...                                      if (firstBufferStarted)                                      {                                          // because this notification is based on the *playback" cursor' this should be reasonably accurate                                          bytesPlayed += samplesFrameSize * 2;                                      }                                  }                                  else                                  {                                      firstBufferStarted = true;                                  }                                    indexHandle = (indexHandle == 0) ? 1 : 0;                                  nextSamplesWriteIndex = indexHandle * samplesFrameSize;                                    // Only carry on playing if we can!                                  if (Feed(samplesFrameSize) == 0)                                  {                                      StopPlayback();                                      lPlaybackHalted = true;                                      lContinuePlayback = false;                                  }                              }                          }                          else                          {                              // Timed out!                              StopPlayback();                              lPlaybackHalted = true;                              lContinuePlayback = false;                              // report this as an error in the Playback Stopped                              // seems to happen when device is unplugged                              throw new Exception("DirectSound buffer timeout");                          }                      }                  }              }              catch (Exception e)              {                  // Do nothing (except report error)                  Debug.WriteLine(e.ToString());                  exception = e;              }              finally              {                  if (!lPlaybackHalted)                  {                      try                      {                          StopPlayback();                      }                      catch (Exception e)                      {                          Debug.WriteLine(e.ToString());                          // don't overwrite the original reason we exited the playback loop                          if (exception == null) exception = e;                      }                  }                    lock (m_LockObject)                  {                      playbackState = PlaybackState.Stopped;                  }                    bytesPlayed = 0;                    // Fire playback stopped event                  RaisePlaybackStopped(exception);              }
Magic Number,NAudio.Wave,WasapiOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WasapiOut.cs,GetDefaultAudioEndpoint,The following statement contains a magic number: if (Environment.OSVersion.Version.Major < 6)              {                  throw new NotSupportedException("WASAPI supported only on Windows Vista and above");              }
Magic Number,NAudio.Wave,WasapiOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WasapiOut.cs,PlayThread,The following statement contains a magic number: try              {                  if (dmoResamplerNeeded)                  {                      resamplerDmoStream = new ResamplerDmoStream(sourceProvider' outputFormat);                      playbackProvider = resamplerDmoStream;                  }                    // fill a whole buffer                  bufferFrameCount = audioClient.BufferSize;                  bytesPerFrame = outputFormat.Channels * outputFormat.BitsPerSample / 8;                  readBuffer = new byte[bufferFrameCount * bytesPerFrame];                  FillBuffer(playbackProvider' bufferFrameCount);                    // Create WaitHandle for sync                  var waitHandles = new WaitHandle[] { frameEventWaitHandle };                    audioClient.Start();                    while (playbackState != PlaybackState.Stopped)                  {                      // If using Event Sync' Wait for notification from AudioClient or Sleep half latency                      int indexHandle = 0;                      if (isUsingEventSync)                      {                          indexHandle = WaitHandle.WaitAny(waitHandles' 3 * latencyMilliseconds' false);                      }                      else                      {                          Thread.Sleep(latencyMilliseconds / 2);                      }                        // If still playing and notification is ok                      if (playbackState == PlaybackState.Playing && indexHandle != WaitHandle.WaitTimeout)                      {                          // See how much buffer space is available.                          int numFramesPadding;                          if (isUsingEventSync)                          {                              // In exclusive mode' always ask the max = bufferFrameCount = audioClient.BufferSize                              numFramesPadding = (shareMode == AudioClientShareMode.Shared) ? audioClient.CurrentPadding : 0;                          }                          else                          {                              numFramesPadding = audioClient.CurrentPadding;                          }                          int numFramesAvailable = bufferFrameCount - numFramesPadding;                          if (numFramesAvailable > 10) // see https://naudio.codeplex.com/workitem/16363                          {                              FillBuffer(playbackProvider' numFramesAvailable);                          }                      }                  }                  Thread.Sleep(latencyMilliseconds / 2);                  audioClient.Stop();                  if (playbackState == PlaybackState.Stopped)                  {                      audioClient.Reset();                  }              }              catch (Exception e)              {                  exception = e;              }              finally              {                  if (resamplerDmoStream != null)                  {                      resamplerDmoStream.Dispose();                  }                  RaisePlaybackStopped(exception);              }
Magic Number,NAudio.Wave,WasapiOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WasapiOut.cs,PlayThread,The following statement contains a magic number: try              {                  if (dmoResamplerNeeded)                  {                      resamplerDmoStream = new ResamplerDmoStream(sourceProvider' outputFormat);                      playbackProvider = resamplerDmoStream;                  }                    // fill a whole buffer                  bufferFrameCount = audioClient.BufferSize;                  bytesPerFrame = outputFormat.Channels * outputFormat.BitsPerSample / 8;                  readBuffer = new byte[bufferFrameCount * bytesPerFrame];                  FillBuffer(playbackProvider' bufferFrameCount);                    // Create WaitHandle for sync                  var waitHandles = new WaitHandle[] { frameEventWaitHandle };                    audioClient.Start();                    while (playbackState != PlaybackState.Stopped)                  {                      // If using Event Sync' Wait for notification from AudioClient or Sleep half latency                      int indexHandle = 0;                      if (isUsingEventSync)                      {                          indexHandle = WaitHandle.WaitAny(waitHandles' 3 * latencyMilliseconds' false);                      }                      else                      {                          Thread.Sleep(latencyMilliseconds / 2);                      }                        // If still playing and notification is ok                      if (playbackState == PlaybackState.Playing && indexHandle != WaitHandle.WaitTimeout)                      {                          // See how much buffer space is available.                          int numFramesPadding;                          if (isUsingEventSync)                          {                              // In exclusive mode' always ask the max = bufferFrameCount = audioClient.BufferSize                              numFramesPadding = (shareMode == AudioClientShareMode.Shared) ? audioClient.CurrentPadding : 0;                          }                          else                          {                              numFramesPadding = audioClient.CurrentPadding;                          }                          int numFramesAvailable = bufferFrameCount - numFramesPadding;                          if (numFramesAvailable > 10) // see https://naudio.codeplex.com/workitem/16363                          {                              FillBuffer(playbackProvider' numFramesAvailable);                          }                      }                  }                  Thread.Sleep(latencyMilliseconds / 2);                  audioClient.Stop();                  if (playbackState == PlaybackState.Stopped)                  {                      audioClient.Reset();                  }              }              catch (Exception e)              {                  exception = e;              }              finally              {                  if (resamplerDmoStream != null)                  {                      resamplerDmoStream.Dispose();                  }                  RaisePlaybackStopped(exception);              }
Magic Number,NAudio.Wave,WasapiOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WasapiOut.cs,PlayThread,The following statement contains a magic number: try              {                  if (dmoResamplerNeeded)                  {                      resamplerDmoStream = new ResamplerDmoStream(sourceProvider' outputFormat);                      playbackProvider = resamplerDmoStream;                  }                    // fill a whole buffer                  bufferFrameCount = audioClient.BufferSize;                  bytesPerFrame = outputFormat.Channels * outputFormat.BitsPerSample / 8;                  readBuffer = new byte[bufferFrameCount * bytesPerFrame];                  FillBuffer(playbackProvider' bufferFrameCount);                    // Create WaitHandle for sync                  var waitHandles = new WaitHandle[] { frameEventWaitHandle };                    audioClient.Start();                    while (playbackState != PlaybackState.Stopped)                  {                      // If using Event Sync' Wait for notification from AudioClient or Sleep half latency                      int indexHandle = 0;                      if (isUsingEventSync)                      {                          indexHandle = WaitHandle.WaitAny(waitHandles' 3 * latencyMilliseconds' false);                      }                      else                      {                          Thread.Sleep(latencyMilliseconds / 2);                      }                        // If still playing and notification is ok                      if (playbackState == PlaybackState.Playing && indexHandle != WaitHandle.WaitTimeout)                      {                          // See how much buffer space is available.                          int numFramesPadding;                          if (isUsingEventSync)                          {                              // In exclusive mode' always ask the max = bufferFrameCount = audioClient.BufferSize                              numFramesPadding = (shareMode == AudioClientShareMode.Shared) ? audioClient.CurrentPadding : 0;                          }                          else                          {                              numFramesPadding = audioClient.CurrentPadding;                          }                          int numFramesAvailable = bufferFrameCount - numFramesPadding;                          if (numFramesAvailable > 10) // see https://naudio.codeplex.com/workitem/16363                          {                              FillBuffer(playbackProvider' numFramesAvailable);                          }                      }                  }                  Thread.Sleep(latencyMilliseconds / 2);                  audioClient.Stop();                  if (playbackState == PlaybackState.Stopped)                  {                      audioClient.Reset();                  }              }              catch (Exception e)              {                  exception = e;              }              finally              {                  if (resamplerDmoStream != null)                  {                      resamplerDmoStream.Dispose();                  }                  RaisePlaybackStopped(exception);              }
Magic Number,NAudio.Wave,WasapiOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WasapiOut.cs,PlayThread,The following statement contains a magic number: try              {                  if (dmoResamplerNeeded)                  {                      resamplerDmoStream = new ResamplerDmoStream(sourceProvider' outputFormat);                      playbackProvider = resamplerDmoStream;                  }                    // fill a whole buffer                  bufferFrameCount = audioClient.BufferSize;                  bytesPerFrame = outputFormat.Channels * outputFormat.BitsPerSample / 8;                  readBuffer = new byte[bufferFrameCount * bytesPerFrame];                  FillBuffer(playbackProvider' bufferFrameCount);                    // Create WaitHandle for sync                  var waitHandles = new WaitHandle[] { frameEventWaitHandle };                    audioClient.Start();                    while (playbackState != PlaybackState.Stopped)                  {                      // If using Event Sync' Wait for notification from AudioClient or Sleep half latency                      int indexHandle = 0;                      if (isUsingEventSync)                      {                          indexHandle = WaitHandle.WaitAny(waitHandles' 3 * latencyMilliseconds' false);                      }                      else                      {                          Thread.Sleep(latencyMilliseconds / 2);                      }                        // If still playing and notification is ok                      if (playbackState == PlaybackState.Playing && indexHandle != WaitHandle.WaitTimeout)                      {                          // See how much buffer space is available.                          int numFramesPadding;                          if (isUsingEventSync)                          {                              // In exclusive mode' always ask the max = bufferFrameCount = audioClient.BufferSize                              numFramesPadding = (shareMode == AudioClientShareMode.Shared) ? audioClient.CurrentPadding : 0;                          }                          else                          {                              numFramesPadding = audioClient.CurrentPadding;                          }                          int numFramesAvailable = bufferFrameCount - numFramesPadding;                          if (numFramesAvailable > 10) // see https://naudio.codeplex.com/workitem/16363                          {                              FillBuffer(playbackProvider' numFramesAvailable);                          }                      }                  }                  Thread.Sleep(latencyMilliseconds / 2);                  audioClient.Stop();                  if (playbackState == PlaybackState.Stopped)                  {                      audioClient.Reset();                  }              }              catch (Exception e)              {                  exception = e;              }              finally              {                  if (resamplerDmoStream != null)                  {                      resamplerDmoStream.Dispose();                  }                  RaisePlaybackStopped(exception);              }
Magic Number,NAudio.Wave,WasapiOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WasapiOut.cs,PlayThread,The following statement contains a magic number: try              {                  if (dmoResamplerNeeded)                  {                      resamplerDmoStream = new ResamplerDmoStream(sourceProvider' outputFormat);                      playbackProvider = resamplerDmoStream;                  }                    // fill a whole buffer                  bufferFrameCount = audioClient.BufferSize;                  bytesPerFrame = outputFormat.Channels * outputFormat.BitsPerSample / 8;                  readBuffer = new byte[bufferFrameCount * bytesPerFrame];                  FillBuffer(playbackProvider' bufferFrameCount);                    // Create WaitHandle for sync                  var waitHandles = new WaitHandle[] { frameEventWaitHandle };                    audioClient.Start();                    while (playbackState != PlaybackState.Stopped)                  {                      // If using Event Sync' Wait for notification from AudioClient or Sleep half latency                      int indexHandle = 0;                      if (isUsingEventSync)                      {                          indexHandle = WaitHandle.WaitAny(waitHandles' 3 * latencyMilliseconds' false);                      }                      else                      {                          Thread.Sleep(latencyMilliseconds / 2);                      }                        // If still playing and notification is ok                      if (playbackState == PlaybackState.Playing && indexHandle != WaitHandle.WaitTimeout)                      {                          // See how much buffer space is available.                          int numFramesPadding;                          if (isUsingEventSync)                          {                              // In exclusive mode' always ask the max = bufferFrameCount = audioClient.BufferSize                              numFramesPadding = (shareMode == AudioClientShareMode.Shared) ? audioClient.CurrentPadding : 0;                          }                          else                          {                              numFramesPadding = audioClient.CurrentPadding;                          }                          int numFramesAvailable = bufferFrameCount - numFramesPadding;                          if (numFramesAvailable > 10) // see https://naudio.codeplex.com/workitem/16363                          {                              FillBuffer(playbackProvider' numFramesAvailable);                          }                      }                  }                  Thread.Sleep(latencyMilliseconds / 2);                  audioClient.Stop();                  if (playbackState == PlaybackState.Stopped)                  {                      audioClient.Reset();                  }              }              catch (Exception e)              {                  exception = e;              }              finally              {                  if (resamplerDmoStream != null)                  {                      resamplerDmoStream.Dispose();                  }                  RaisePlaybackStopped(exception);              }
Magic Number,NAudio.Wave,WasapiOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WasapiOut.cs,Init,The following statement contains a magic number: long latencyRefTimes = latencyMilliseconds * 10000;
Magic Number,NAudio.Wave,WasapiOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WasapiOut.cs,Init,The following statement contains a magic number: if (!audioClient.IsFormatSupported(shareMode' outputFormat' out closestSampleRateFormat))              {                  // Use closesSampleRateFormat (in sharedMode' it equals usualy to the audioClient.MixFormat)                  // See documentation : http://msdn.microsoft.com/en-us/library/ms678737(VS.85).aspx                   // They say : "In shared mode' the audio engine always supports the mix format"                  // The MixFormat is more likely to be a WaveFormatExtensible.                  if (closestSampleRateFormat == null)                  {                      WaveFormat correctSampleRateFormat = audioClient.MixFormat;                          /*WaveFormat.CreateIeeeFloatWaveFormat(                          audioClient.MixFormat.SampleRate'                          audioClient.MixFormat.Channels);*/                        if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                      {                          // Iterate from Worst to Best Format                          WaveFormatExtensible[] bestToWorstFormats = {                                    new WaveFormatExtensible(                                        outputFormat.SampleRate' 32'                                        outputFormat.Channels)'                                    new WaveFormatExtensible(                                        outputFormat.SampleRate' 24'                                        outputFormat.Channels)'                                    new WaveFormatExtensible(                                        outputFormat.SampleRate' 16'                                        outputFormat.Channels)'                                };                            // Check from best Format to worst format ( Float32' Int24' Int16 )                          for (int i = 0; i < bestToWorstFormats.Length; i++ )                          {                              correctSampleRateFormat = bestToWorstFormats[i];                              if ( audioClient.IsFormatSupported(shareMode' correctSampleRateFormat) )                              {                                  break;                              }                              correctSampleRateFormat = null;                          }                            // If still null' then test on the PCM16' 2 channels                          if (correctSampleRateFormat == null)                          {                              // Last Last Last Chance (Thanks WASAPI)                              correctSampleRateFormat = new WaveFormatExtensible(outputFormat.SampleRate' 16' 2);                              if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                              {                                  throw new NotSupportedException("Can't find a supported format to use");                              }                          }                      }                      outputFormat = correctSampleRateFormat;                  }                  else                  {                      outputFormat = closestSampleRateFormat;                  }                    // just check that we can make it.                  using (new ResamplerDmoStream(waveProvider' outputFormat))                  {                  }                  dmoResamplerNeeded = true;              }              else              {                  dmoResamplerNeeded = false;              }
Magic Number,NAudio.Wave,WasapiOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WasapiOut.cs,Init,The following statement contains a magic number: if (!audioClient.IsFormatSupported(shareMode' outputFormat' out closestSampleRateFormat))              {                  // Use closesSampleRateFormat (in sharedMode' it equals usualy to the audioClient.MixFormat)                  // See documentation : http://msdn.microsoft.com/en-us/library/ms678737(VS.85).aspx                   // They say : "In shared mode' the audio engine always supports the mix format"                  // The MixFormat is more likely to be a WaveFormatExtensible.                  if (closestSampleRateFormat == null)                  {                      WaveFormat correctSampleRateFormat = audioClient.MixFormat;                          /*WaveFormat.CreateIeeeFloatWaveFormat(                          audioClient.MixFormat.SampleRate'                          audioClient.MixFormat.Channels);*/                        if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                      {                          // Iterate from Worst to Best Format                          WaveFormatExtensible[] bestToWorstFormats = {                                    new WaveFormatExtensible(                                        outputFormat.SampleRate' 32'                                        outputFormat.Channels)'                                    new WaveFormatExtensible(                                        outputFormat.SampleRate' 24'                                        outputFormat.Channels)'                                    new WaveFormatExtensible(                                        outputFormat.SampleRate' 16'                                        outputFormat.Channels)'                                };                            // Check from best Format to worst format ( Float32' Int24' Int16 )                          for (int i = 0; i < bestToWorstFormats.Length; i++ )                          {                              correctSampleRateFormat = bestToWorstFormats[i];                              if ( audioClient.IsFormatSupported(shareMode' correctSampleRateFormat) )                              {                                  break;                              }                              correctSampleRateFormat = null;                          }                            // If still null' then test on the PCM16' 2 channels                          if (correctSampleRateFormat == null)                          {                              // Last Last Last Chance (Thanks WASAPI)                              correctSampleRateFormat = new WaveFormatExtensible(outputFormat.SampleRate' 16' 2);                              if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                              {                                  throw new NotSupportedException("Can't find a supported format to use");                              }                          }                      }                      outputFormat = correctSampleRateFormat;                  }                  else                  {                      outputFormat = closestSampleRateFormat;                  }                    // just check that we can make it.                  using (new ResamplerDmoStream(waveProvider' outputFormat))                  {                  }                  dmoResamplerNeeded = true;              }              else              {                  dmoResamplerNeeded = false;              }
Magic Number,NAudio.Wave,WasapiOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WasapiOut.cs,Init,The following statement contains a magic number: if (!audioClient.IsFormatSupported(shareMode' outputFormat' out closestSampleRateFormat))              {                  // Use closesSampleRateFormat (in sharedMode' it equals usualy to the audioClient.MixFormat)                  // See documentation : http://msdn.microsoft.com/en-us/library/ms678737(VS.85).aspx                   // They say : "In shared mode' the audio engine always supports the mix format"                  // The MixFormat is more likely to be a WaveFormatExtensible.                  if (closestSampleRateFormat == null)                  {                      WaveFormat correctSampleRateFormat = audioClient.MixFormat;                          /*WaveFormat.CreateIeeeFloatWaveFormat(                          audioClient.MixFormat.SampleRate'                          audioClient.MixFormat.Channels);*/                        if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                      {                          // Iterate from Worst to Best Format                          WaveFormatExtensible[] bestToWorstFormats = {                                    new WaveFormatExtensible(                                        outputFormat.SampleRate' 32'                                        outputFormat.Channels)'                                    new WaveFormatExtensible(                                        outputFormat.SampleRate' 24'                                        outputFormat.Channels)'                                    new WaveFormatExtensible(                                        outputFormat.SampleRate' 16'                                        outputFormat.Channels)'                                };                            // Check from best Format to worst format ( Float32' Int24' Int16 )                          for (int i = 0; i < bestToWorstFormats.Length; i++ )                          {                              correctSampleRateFormat = bestToWorstFormats[i];                              if ( audioClient.IsFormatSupported(shareMode' correctSampleRateFormat) )                              {                                  break;                              }                              correctSampleRateFormat = null;                          }                            // If still null' then test on the PCM16' 2 channels                          if (correctSampleRateFormat == null)                          {                              // Last Last Last Chance (Thanks WASAPI)                              correctSampleRateFormat = new WaveFormatExtensible(outputFormat.SampleRate' 16' 2);                              if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                              {                                  throw new NotSupportedException("Can't find a supported format to use");                              }                          }                      }                      outputFormat = correctSampleRateFormat;                  }                  else                  {                      outputFormat = closestSampleRateFormat;                  }                    // just check that we can make it.                  using (new ResamplerDmoStream(waveProvider' outputFormat))                  {                  }                  dmoResamplerNeeded = true;              }              else              {                  dmoResamplerNeeded = false;              }
Magic Number,NAudio.Wave,WasapiOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WasapiOut.cs,Init,The following statement contains a magic number: if (!audioClient.IsFormatSupported(shareMode' outputFormat' out closestSampleRateFormat))              {                  // Use closesSampleRateFormat (in sharedMode' it equals usualy to the audioClient.MixFormat)                  // See documentation : http://msdn.microsoft.com/en-us/library/ms678737(VS.85).aspx                   // They say : "In shared mode' the audio engine always supports the mix format"                  // The MixFormat is more likely to be a WaveFormatExtensible.                  if (closestSampleRateFormat == null)                  {                      WaveFormat correctSampleRateFormat = audioClient.MixFormat;                          /*WaveFormat.CreateIeeeFloatWaveFormat(                          audioClient.MixFormat.SampleRate'                          audioClient.MixFormat.Channels);*/                        if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                      {                          // Iterate from Worst to Best Format                          WaveFormatExtensible[] bestToWorstFormats = {                                    new WaveFormatExtensible(                                        outputFormat.SampleRate' 32'                                        outputFormat.Channels)'                                    new WaveFormatExtensible(                                        outputFormat.SampleRate' 24'                                        outputFormat.Channels)'                                    new WaveFormatExtensible(                                        outputFormat.SampleRate' 16'                                        outputFormat.Channels)'                                };                            // Check from best Format to worst format ( Float32' Int24' Int16 )                          for (int i = 0; i < bestToWorstFormats.Length; i++ )                          {                              correctSampleRateFormat = bestToWorstFormats[i];                              if ( audioClient.IsFormatSupported(shareMode' correctSampleRateFormat) )                              {                                  break;                              }                              correctSampleRateFormat = null;                          }                            // If still null' then test on the PCM16' 2 channels                          if (correctSampleRateFormat == null)                          {                              // Last Last Last Chance (Thanks WASAPI)                              correctSampleRateFormat = new WaveFormatExtensible(outputFormat.SampleRate' 16' 2);                              if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                              {                                  throw new NotSupportedException("Can't find a supported format to use");                              }                          }                      }                      outputFormat = correctSampleRateFormat;                  }                  else                  {                      outputFormat = closestSampleRateFormat;                  }                    // just check that we can make it.                  using (new ResamplerDmoStream(waveProvider' outputFormat))                  {                  }                  dmoResamplerNeeded = true;              }              else              {                  dmoResamplerNeeded = false;              }
Magic Number,NAudio.Wave,WasapiOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WasapiOut.cs,Init,The following statement contains a magic number: if (!audioClient.IsFormatSupported(shareMode' outputFormat' out closestSampleRateFormat))              {                  // Use closesSampleRateFormat (in sharedMode' it equals usualy to the audioClient.MixFormat)                  // See documentation : http://msdn.microsoft.com/en-us/library/ms678737(VS.85).aspx                   // They say : "In shared mode' the audio engine always supports the mix format"                  // The MixFormat is more likely to be a WaveFormatExtensible.                  if (closestSampleRateFormat == null)                  {                      WaveFormat correctSampleRateFormat = audioClient.MixFormat;                          /*WaveFormat.CreateIeeeFloatWaveFormat(                          audioClient.MixFormat.SampleRate'                          audioClient.MixFormat.Channels);*/                        if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                      {                          // Iterate from Worst to Best Format                          WaveFormatExtensible[] bestToWorstFormats = {                                    new WaveFormatExtensible(                                        outputFormat.SampleRate' 32'                                        outputFormat.Channels)'                                    new WaveFormatExtensible(                                        outputFormat.SampleRate' 24'                                        outputFormat.Channels)'                                    new WaveFormatExtensible(                                        outputFormat.SampleRate' 16'                                        outputFormat.Channels)'                                };                            // Check from best Format to worst format ( Float32' Int24' Int16 )                          for (int i = 0; i < bestToWorstFormats.Length; i++ )                          {                              correctSampleRateFormat = bestToWorstFormats[i];                              if ( audioClient.IsFormatSupported(shareMode' correctSampleRateFormat) )                              {                                  break;                              }                              correctSampleRateFormat = null;                          }                            // If still null' then test on the PCM16' 2 channels                          if (correctSampleRateFormat == null)                          {                              // Last Last Last Chance (Thanks WASAPI)                              correctSampleRateFormat = new WaveFormatExtensible(outputFormat.SampleRate' 16' 2);                              if (!audioClient.IsFormatSupported(shareMode' correctSampleRateFormat))                              {                                  throw new NotSupportedException("Can't find a supported format to use");                              }                          }                      }                      outputFormat = correctSampleRateFormat;                  }                  else                  {                      outputFormat = closestSampleRateFormat;                  }                    // just check that we can make it.                  using (new ResamplerDmoStream(waveProvider' outputFormat))                  {                  }                  dmoResamplerNeeded = true;              }              else              {                  dmoResamplerNeeded = false;              }
Magic Number,NAudio.Wave,WasapiOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WasapiOut.cs,Init,The following statement contains a magic number: if (isUsingEventSync)              {                  // Init Shared or Exclusive                  if (shareMode == AudioClientShareMode.Shared)                  {                      // With EventCallBack and Shared' both latencies must be set to 0 (update - not sure this is true anymore)                      //                       audioClient.Initialize(shareMode' AudioClientStreamFlags.EventCallback' latencyRefTimes' 0'                          outputFormat' Guid.Empty);                        // Windows 10 returns 0 from stream latency' resulting in maxing out CPU usage later                      var streamLatency = audioClient.StreamLatency;                      if (streamLatency != 0)                      {                          // Get back the effective latency from AudioClient                          latencyMilliseconds = (int)(streamLatency / 10000);                      }                  }                  else                  {                      // With EventCallBack and Exclusive' both latencies must equals                      audioClient.Initialize(shareMode' AudioClientStreamFlags.EventCallback' latencyRefTimes' latencyRefTimes'                                          outputFormat' Guid.Empty);                  }                    // Create the Wait Event Handle                  frameEventWaitHandle = new EventWaitHandle(false' EventResetMode.AutoReset);                  audioClient.SetEventHandle(frameEventWaitHandle.SafeWaitHandle.DangerousGetHandle());              }              else              {                  // Normal setup for both sharedMode                  audioClient.Initialize(shareMode' AudioClientStreamFlags.None' latencyRefTimes' 0'                                      outputFormat' Guid.Empty);              }
Magic Number,NAudio.Wave,WaveBuffer,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveBuffer.cs,WaveBuffer,The following statement contains a magic number: int aligned4Bytes = sizeToAllocateInBytes%4;
Magic Number,NAudio.Wave,WaveBuffer,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveBuffer.cs,WaveBuffer,The following statement contains a magic number: sizeToAllocateInBytes = (aligned4Bytes == 0) ? sizeToAllocateInBytes : sizeToAllocateInBytes + 4 - aligned4Bytes;
Magic Number,NAudio.Wave,WaveBuffer,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveBuffer.cs,CheckValidityCount,The following statement contains a magic number: if ( (newNumberOfBytes % 4) != 0 )              {                  throw new ArgumentOutOfRangeException(argName' String.Format("{0} cannot set a count ({1}) that is not 4 bytes aligned "' argName' newNumberOfBytes));              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,CreateWaveFile,The following statement contains a magic number: using (var writer = new WaveFileWriter(filename' sourceProvider.WaveFormat))              {                  var buffer = new byte[sourceProvider.WaveFormat.AverageBytesPerSecond * 4];                  while (true)                  {                      int bytesRead = sourceProvider.Read(buffer' 0' buffer.Length);                      if (bytesRead == 0)                      {                          // end of source provider                          break;                      }                      // Write will throw exception if WAV file becomes too large                      writer.Write(buffer' 0' bytesRead);                  }              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteWavFileToStream,The following statement contains a magic number: using (var writer = new WaveFileWriter(new IgnoreDisposeStream(outStream)' sourceProvider.WaveFormat))               {                  var buffer = new byte[sourceProvider.WaveFormat.AverageBytesPerSecond * 4];                  while(true)                   {                      var bytesRead = sourceProvider.Read(buffer' 0' buffer.Length);                      if (bytesRead == 0)                       {                          // end of source provider                          outStream.Flush();                          break;                      }                        writer.Write(buffer' 0' bytesRead);                  }              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,CreateFactChunk,The following statement contains a magic number: if (HasFactChunk())              {                  writer.Write(System.Text.Encoding.UTF8.GetBytes("fact"));                  writer.Write((int)4);                  factSampleCountPos = outStream.Position;                  writer.Write((int)0); // number of samples              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSample,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  writer.Write((Int16)(Int16.MaxValue * sample));                  dataChunkSize += 2;              }              else if (WaveFormat.BitsPerSample == 24)              {                  var value = BitConverter.GetBytes((Int32)(Int32.MaxValue * sample));                  value24[0] = value[1];                  value24[1] = value[2];                  value24[2] = value[3];                  writer.Write(value24);                  dataChunkSize += 3;              }              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  writer.Write(UInt16.MaxValue * (Int32)sample);                  dataChunkSize += 4;              }              else if (WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  writer.Write(sample);                  dataChunkSize += 4;              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  for (int sample = 0; sample < count; sample++)                  {                      var value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  for (int sample = 0; sample < count; sample++)                  {                      var value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  for (int sample = 0; sample < count; sample++)                  {                      var value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  for (int sample = 0; sample < count; sample++)                  {                      var value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  for (int sample = 0; sample < count; sample++)                  {                      var value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  for (int sample = 0; sample < count; sample++)                  {                      var value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  for (int sample = 0; sample < count; sample++)                  {                      var value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  for (int sample = 0; sample < count; sample++)                  {                      var value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  for (int sample = 0; sample < count; sample++)                  {                      var value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  for (int sample = 0; sample < count; sample++)                  {                      var value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,WriteSamples,The following statement contains a magic number: if (WaveFormat.BitsPerSample == 16)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(samples[sample + offset]);                  }                  dataChunkSize += (count * 2);              }              // 24 bit PCM data              else if (WaveFormat.BitsPerSample == 24)              {                  for (int sample = 0; sample < count; sample++)                  {                      var value = BitConverter.GetBytes(UInt16.MaxValue * (Int32)samples[sample + offset]);                      value24[0] = value[1];                      value24[1] = value[2];                      value24[2] = value[3];                      writer.Write(value24);                  }                  dataChunkSize += (count * 3);              }              // 32 bit PCM data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.Extensible)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write(UInt16.MaxValue * (Int32)samples[sample + offset]);                  }                  dataChunkSize += (count * 4);              }              // IEEE float data              else if (WaveFormat.BitsPerSample == 32 && WaveFormat.Encoding == WaveFormatEncoding.IeeeFloat)              {                  for (int sample = 0; sample < count; sample++)                  {                      writer.Write((float)samples[sample + offset] / (float)(Int16.MaxValue + 1));                  }                  dataChunkSize += (count * 4);              }              else              {                  throw new InvalidOperationException("Only 16' 24 or 32 bit PCM or IEEE float audio data supported");              }
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,UpdateRiffChunk,The following statement contains a magic number: writer.Seek(4' SeekOrigin.Begin);
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,UpdateRiffChunk,The following statement contains a magic number: writer.Write((UInt32)(outStream.Length - 8));
Magic Number,NAudio.Wave,WaveFileWriter,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveFileWriter.cs,UpdateFactChunk,The following statement contains a magic number: if (HasFactChunk())              {                  int bitsPerSample = (format.BitsPerSample * format.Channels);                  if (bitsPerSample != 0)                  {                      writer.Seek((int)factSampleCountPos' SeekOrigin.Begin);                                            writer.Write((int)((dataChunkSize * 8) / bitsPerSample));                  }              }
Magic Number,NAudio.Wave,WaveOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveOut.cs,WaveOut,The following statement contains a magic number: DesiredLatency = 300;
Magic Number,NAudio.Wave,WaveOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveOut.cs,WaveOut,The following statement contains a magic number: NumberOfBuffers = 2;
Magic Number,NAudio.Wave,WaveOut,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveOut.cs,SetWaveOutVolume,The following statement contains a magic number: int stereoVolume = (int) (left*0xFFFF) + ((int) (right*0xFFFF) << 16);
Magic Number,NAudio.Wave,WaveOutEvent,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveOutEvent.cs,WaveOutEvent,The following statement contains a magic number: DesiredLatency = 300;
Magic Number,NAudio.Wave,WaveOutEvent,C:\repos\naudio_NAudio\NAudio\Wave\WaveOutputs\WaveOutEvent.cs,WaveOutEvent,The following statement contains a magic number: NumberOfBuffers = 2;
Magic Number,NAudio.Wave,BufferedWaveProvider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\BufferedWaveProvider.cs,BufferedWaveProvider,The following statement contains a magic number: BufferLength = waveFormat.AverageBytesPerSecond * 5;
Magic Number,NAudio.Wave,MediaFoundationResampler,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MediaFoundationResampler.cs,MediaFoundationResampler,The following statement contains a magic number: ResamplerQuality = 60;
Magic Number,NAudio.Wave,MixingWaveProvider32,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MixingWaveProvider32.cs,MixingWaveProvider32,The following statement contains a magic number: this.waveFormat = WaveFormat.CreateIeeeFloatWaveFormat(44100' 2);
Magic Number,NAudio.Wave,MixingWaveProvider32,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MixingWaveProvider32.cs,MixingWaveProvider32,The following statement contains a magic number: this.waveFormat = WaveFormat.CreateIeeeFloatWaveFormat(44100' 2);
Magic Number,NAudio.Wave,MixingWaveProvider32,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MixingWaveProvider32.cs,MixingWaveProvider32,The following statement contains a magic number: this.bytesPerSample = 4;
Magic Number,NAudio.Wave,MixingWaveProvider32,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MixingWaveProvider32.cs,AddInputStream,The following statement contains a magic number: if (waveProvider.WaveFormat.BitsPerSample != 32)                  throw new ArgumentException("Only 32 bit audio currently supported"' "waveProvider.WaveFormat");
Magic Number,NAudio.Wave,MixingWaveProvider32,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MixingWaveProvider32.cs,Sum32BitAudio,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                        pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  float* pfReadBuffer = (float*)pSourceBuffer;                  int samplesRead = bytesRead / 4;                  for (int n = 0; n < samplesRead; n++)                  {                      pfDestBuffer[n] += pfReadBuffer[n];                  }              }
Magic Number,NAudio.Wave,MultiplexingWaveProvider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MultiplexingWaveProvider.cs,MultiplexingWaveProvider,The following statement contains a magic number: bytesPerSample = WaveFormat.BitsPerSample / 8;
Magic Number,NAudio.Wave,StereoToMonoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\StereoToMonoProvider16.cs,StereoToMonoProvider16,The following statement contains a magic number: if (sourceProvider.WaveFormat.Channels != 2)              {                  throw new ArgumentException("Source must be stereo");              }
Magic Number,NAudio.Wave,StereoToMonoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\StereoToMonoProvider16.cs,StereoToMonoProvider16,The following statement contains a magic number: if (sourceProvider.WaveFormat.BitsPerSample != 16)              {                  throw new ArgumentException("Source must be 16 bit");              }
Magic Number,NAudio.Wave,StereoToMonoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\StereoToMonoProvider16.cs,Read,The following statement contains a magic number: int sourceBytesRequired = count * 2;
Magic Number,NAudio.Wave,StereoToMonoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\StereoToMonoProvider16.cs,Read,The following statement contains a magic number: int samplesRead = sourceBytesRead / 2;
Magic Number,NAudio.Wave,StereoToMonoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\StereoToMonoProvider16.cs,Read,The following statement contains a magic number: int destOffset = offset / 2;
Magic Number,NAudio.Wave,StereoToMonoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\StereoToMonoProvider16.cs,Read,The following statement contains a magic number: for (int sample = 0; sample < samplesRead; sample+=2)              {                  short left = sourceWaveBuffer.ShortBuffer[sample];                  short right = sourceWaveBuffer.ShortBuffer[sample+1];                  float outSample = (left * LeftVolume) + (right * RightVolume);                  // hard limiting                  if (outSample > Int16.MaxValue) outSample = Int16.MaxValue;                  if (outSample < Int16.MinValue) outSample = Int16.MinValue;                    destWaveBuffer.ShortBuffer[destOffset++] = (short)outSample;              }
Magic Number,NAudio.Wave,StereoToMonoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\StereoToMonoProvider16.cs,Read,The following statement contains a magic number: return sourceBytesRead / 2;
Magic Number,NAudio.Wave,MonoToStereoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MonoToStereoProvider16.cs,MonoToStereoProvider16,The following statement contains a magic number: if (sourceProvider.WaveFormat.BitsPerSample != 16)              {                  throw new ArgumentException("Source must be 16 bit");              }
Magic Number,NAudio.Wave,MonoToStereoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MonoToStereoProvider16.cs,MonoToStereoProvider16,The following statement contains a magic number: WaveFormat = new WaveFormat(sourceProvider.WaveFormat.SampleRate' 2);
Magic Number,NAudio.Wave,MonoToStereoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MonoToStereoProvider16.cs,Read,The following statement contains a magic number: var sourceBytesRequired = count / 2;
Magic Number,NAudio.Wave,MonoToStereoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MonoToStereoProvider16.cs,Read,The following statement contains a magic number: var samplesRead = sourceBytesRead / 2;
Magic Number,NAudio.Wave,MonoToStereoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MonoToStereoProvider16.cs,Read,The following statement contains a magic number: var destOffset = offset / 2;
Magic Number,NAudio.Wave,MonoToStereoProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\MonoToStereoProvider16.cs,Read,The following statement contains a magic number: return samplesRead * 4;
Magic Number,NAudio.Wave,VolumeWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\VolumeWaveProvider16.cs,VolumeWaveProvider16,The following statement contains a magic number: if (sourceProvider.WaveFormat.BitsPerSample != 16)                  throw new ArgumentException("Expecting 16 bit");
Magic Number,NAudio.Wave,VolumeWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\VolumeWaveProvider16.cs,Read,The following statement contains a magic number: if (this.volume == 0.0f)              {                  for (int n = 0; n < bytesRead; n++)                  {                      buffer[offset++] = 0;                  }              }              else if (this.volume != 1.0f)              {                  for (int n = 0; n < bytesRead; n += 2)                  {                      short sample = (short)((buffer[offset + 1] << 8) | buffer[offset]);                      var newSample = sample * this.volume;                      sample = (short)newSample;                      // clip if necessary                      if (this.Volume > 1.0f)                      {                          if (newSample > Int16.MaxValue) sample = Int16.MaxValue;                          else if (newSample < Int16.MinValue) sample = Int16.MinValue;                      }                        buffer[offset++] = (byte)(sample & 0xFF);                      buffer[offset++] = (byte)(sample >> 8);                  }              }
Magic Number,NAudio.Wave,VolumeWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\VolumeWaveProvider16.cs,Read,The following statement contains a magic number: if (this.volume == 0.0f)              {                  for (int n = 0; n < bytesRead; n++)                  {                      buffer[offset++] = 0;                  }              }              else if (this.volume != 1.0f)              {                  for (int n = 0; n < bytesRead; n += 2)                  {                      short sample = (short)((buffer[offset + 1] << 8) | buffer[offset]);                      var newSample = sample * this.volume;                      sample = (short)newSample;                      // clip if necessary                      if (this.Volume > 1.0f)                      {                          if (newSample > Int16.MaxValue) sample = Int16.MaxValue;                          else if (newSample < Int16.MinValue) sample = Int16.MinValue;                      }                        buffer[offset++] = (byte)(sample & 0xFF);                      buffer[offset++] = (byte)(sample >> 8);                  }              }
Magic Number,NAudio.Wave,VolumeWaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\VolumeWaveProvider16.cs,Read,The following statement contains a magic number: if (this.volume == 0.0f)              {                  for (int n = 0; n < bytesRead; n++)                  {                      buffer[offset++] = 0;                  }              }              else if (this.volume != 1.0f)              {                  for (int n = 0; n < bytesRead; n += 2)                  {                      short sample = (short)((buffer[offset + 1] << 8) | buffer[offset]);                      var newSample = sample * this.volume;                      sample = (short)newSample;                      // clip if necessary                      if (this.Volume > 1.0f)                      {                          if (newSample > Int16.MaxValue) sample = Int16.MaxValue;                          else if (newSample < Int16.MinValue) sample = Int16.MinValue;                      }                        buffer[offset++] = (byte)(sample & 0xFF);                      buffer[offset++] = (byte)(sample >> 8);                  }              }
Magic Number,NAudio.Wave,WaveFloatTo16Provider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveFloatTo16Provider.cs,WaveFloatTo16Provider,The following statement contains a magic number: if (sourceProvider.WaveFormat.BitsPerSample != 32)                  throw new ArgumentException("Input wave provider must be 32 bit"' "sourceProvider");
Magic Number,NAudio.Wave,WaveFloatTo16Provider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveFloatTo16Provider.cs,WaveFloatTo16Provider,The following statement contains a magic number: waveFormat = new WaveFormat(sourceProvider.WaveFormat.SampleRate' 16' sourceProvider.WaveFormat.Channels);
Magic Number,NAudio.Wave,WaveFloatTo16Provider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveFloatTo16Provider.cs,Read,The following statement contains a magic number: int sourceBytesRequired = numBytes * 2;
Magic Number,NAudio.Wave,WaveFloatTo16Provider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveFloatTo16Provider.cs,Read,The following statement contains a magic number: int sourceSamples = sourceBytesRead / 4;
Magic Number,NAudio.Wave,WaveFloatTo16Provider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveFloatTo16Provider.cs,Read,The following statement contains a magic number: int destOffset = offset / 2;
Magic Number,NAudio.Wave,WaveFloatTo16Provider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveFloatTo16Provider.cs,Read,The following statement contains a magic number: for (int sample = 0; sample < sourceSamples; sample++)              {                  // adjust volume                  float sample32 = sourceWaveBuffer.FloatBuffer[sample] * volume;                  // clip                  if (sample32 > 1.0f)                      sample32 = 1.0f;                  if (sample32 < -1.0f)                      sample32 = -1.0f;                  destWaveBuffer.ShortBuffer[destOffset++] = (short)(sample32 * 32767);              }
Magic Number,NAudio.Wave,WaveFloatTo16Provider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveFloatTo16Provider.cs,Read,The following statement contains a magic number: return sourceSamples * 2;
Magic Number,NAudio.Wave,Wave16ToFloatProvider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\Wave16ToFloatProvider.cs,Wave16ToFloatProvider,The following statement contains a magic number: if (sourceProvider.WaveFormat.BitsPerSample != 16)                  throw new ArgumentException("Only 16 bit audio supported");
Magic Number,NAudio.Wave,Wave16ToFloatProvider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\Wave16ToFloatProvider.cs,Read,The following statement contains a magic number: int sourceBytesRequired = numBytes / 2;
Magic Number,NAudio.Wave,Wave16ToFloatProvider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\Wave16ToFloatProvider.cs,Read,The following statement contains a magic number: int sourceSamples = sourceBytesRead / 2;
Magic Number,NAudio.Wave,Wave16ToFloatProvider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\Wave16ToFloatProvider.cs,Read,The following statement contains a magic number: int destOffset = offset / 4;
Magic Number,NAudio.Wave,Wave16ToFloatProvider,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\Wave16ToFloatProvider.cs,Read,The following statement contains a magic number: return sourceSamples * 4;
Magic Number,NAudio.Wave,WaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveProvider16.cs,SetWaveFormat,The following statement contains a magic number: this.waveFormat = new WaveFormat(sampleRate' 16' channels);
Magic Number,NAudio.Wave,WaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveProvider16.cs,Read,The following statement contains a magic number: int samplesRequired = count / 2;
Magic Number,NAudio.Wave,WaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveProvider16.cs,Read,The following statement contains a magic number: int samplesRead = Read(waveBuffer.ShortBuffer' offset / 2' samplesRequired);
Magic Number,NAudio.Wave,WaveProvider16,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveProvider16.cs,Read,The following statement contains a magic number: return samplesRead * 2;
Magic Number,NAudio.Wave,WaveProvider32,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveProvider32.cs,Read,The following statement contains a magic number: int samplesRequired = count / 4;
Magic Number,NAudio.Wave,WaveProvider32,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveProvider32.cs,Read,The following statement contains a magic number: int samplesRead = Read(waveBuffer.FloatBuffer' offset / 4' samplesRequired);
Magic Number,NAudio.Wave,WaveProvider32,C:\repos\naudio_NAudio\NAudio\Wave\WaveProviders\WaveProvider32.cs,Read,The following statement contains a magic number: return samplesRead * 4;
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ReadAiffHeader,The following statement contains a magic number: uint fileSize = ConvertInt(br.ReadBytes(4));
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ReadAiffHeader,The following statement contains a magic number: while (br.BaseStream.Position < br.BaseStream.Length)              {                  AiffChunk nextChunk = ReadChunkHeader(br);                  if (nextChunk.ChunkName == "\0\0\0\0") break;                    if (br.BaseStream.Position + nextChunk.ChunkLength > br.BaseStream.Length)                  {                      break;                  }                  if (nextChunk.ChunkName == "COMM")                  {                      short numChannels = ConvertShort(br.ReadBytes(2));                      uint numSampleFrames = ConvertInt(br.ReadBytes(4));                      short sampleSize = ConvertShort(br.ReadBytes(2));                      double sampleRate = IEEE.ConvertFromIeeeExtended(br.ReadBytes(10));                        format = new WaveFormat((int)sampleRate' (int)sampleSize' (int)numChannels);                        if (nextChunk.ChunkLength > 18 && formType == "AIFC")                      {                             // In an AIFC file' the compression format is tacked on to the COMM chunk                          string compress = new string(br.ReadChars(4)).ToLower();                          if (compress != "none") throw new FormatException("Compressed AIFC is not supported.");                          br.ReadBytes((int)nextChunk.ChunkLength - 22);                      }                      else br.ReadBytes((int)nextChunk.ChunkLength - 18);                  }                  else if (nextChunk.ChunkName == "SSND")                  {                      uint offset = ConvertInt(br.ReadBytes(4));                      uint blockSize = ConvertInt(br.ReadBytes(4));                      dataChunkPosition = nextChunk.ChunkStart + 16 + offset;                      dataChunkLength = (int)nextChunk.ChunkLength - 8;                      br.BaseStream.Position += (nextChunk.ChunkLength - 8);                  }                  else                  {                      if (chunks != null)                      {                          chunks.Add(nextChunk);                      }                      br.BaseStream.Position += nextChunk.ChunkLength;                  }                                  }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ReadAiffHeader,The following statement contains a magic number: while (br.BaseStream.Position < br.BaseStream.Length)              {                  AiffChunk nextChunk = ReadChunkHeader(br);                  if (nextChunk.ChunkName == "\0\0\0\0") break;                    if (br.BaseStream.Position + nextChunk.ChunkLength > br.BaseStream.Length)                  {                      break;                  }                  if (nextChunk.ChunkName == "COMM")                  {                      short numChannels = ConvertShort(br.ReadBytes(2));                      uint numSampleFrames = ConvertInt(br.ReadBytes(4));                      short sampleSize = ConvertShort(br.ReadBytes(2));                      double sampleRate = IEEE.ConvertFromIeeeExtended(br.ReadBytes(10));                        format = new WaveFormat((int)sampleRate' (int)sampleSize' (int)numChannels);                        if (nextChunk.ChunkLength > 18 && formType == "AIFC")                      {                             // In an AIFC file' the compression format is tacked on to the COMM chunk                          string compress = new string(br.ReadChars(4)).ToLower();                          if (compress != "none") throw new FormatException("Compressed AIFC is not supported.");                          br.ReadBytes((int)nextChunk.ChunkLength - 22);                      }                      else br.ReadBytes((int)nextChunk.ChunkLength - 18);                  }                  else if (nextChunk.ChunkName == "SSND")                  {                      uint offset = ConvertInt(br.ReadBytes(4));                      uint blockSize = ConvertInt(br.ReadBytes(4));                      dataChunkPosition = nextChunk.ChunkStart + 16 + offset;                      dataChunkLength = (int)nextChunk.ChunkLength - 8;                      br.BaseStream.Position += (nextChunk.ChunkLength - 8);                  }                  else                  {                      if (chunks != null)                      {                          chunks.Add(nextChunk);                      }                      br.BaseStream.Position += nextChunk.ChunkLength;                  }                                  }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ReadAiffHeader,The following statement contains a magic number: while (br.BaseStream.Position < br.BaseStream.Length)              {                  AiffChunk nextChunk = ReadChunkHeader(br);                  if (nextChunk.ChunkName == "\0\0\0\0") break;                    if (br.BaseStream.Position + nextChunk.ChunkLength > br.BaseStream.Length)                  {                      break;                  }                  if (nextChunk.ChunkName == "COMM")                  {                      short numChannels = ConvertShort(br.ReadBytes(2));                      uint numSampleFrames = ConvertInt(br.ReadBytes(4));                      short sampleSize = ConvertShort(br.ReadBytes(2));                      double sampleRate = IEEE.ConvertFromIeeeExtended(br.ReadBytes(10));                        format = new WaveFormat((int)sampleRate' (int)sampleSize' (int)numChannels);                        if (nextChunk.ChunkLength > 18 && formType == "AIFC")                      {                             // In an AIFC file' the compression format is tacked on to the COMM chunk                          string compress = new string(br.ReadChars(4)).ToLower();                          if (compress != "none") throw new FormatException("Compressed AIFC is not supported.");                          br.ReadBytes((int)nextChunk.ChunkLength - 22);                      }                      else br.ReadBytes((int)nextChunk.ChunkLength - 18);                  }                  else if (nextChunk.ChunkName == "SSND")                  {                      uint offset = ConvertInt(br.ReadBytes(4));                      uint blockSize = ConvertInt(br.ReadBytes(4));                      dataChunkPosition = nextChunk.ChunkStart + 16 + offset;                      dataChunkLength = (int)nextChunk.ChunkLength - 8;                      br.BaseStream.Position += (nextChunk.ChunkLength - 8);                  }                  else                  {                      if (chunks != null)                      {                          chunks.Add(nextChunk);                      }                      br.BaseStream.Position += nextChunk.ChunkLength;                  }                                  }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ReadAiffHeader,The following statement contains a magic number: while (br.BaseStream.Position < br.BaseStream.Length)              {                  AiffChunk nextChunk = ReadChunkHeader(br);                  if (nextChunk.ChunkName == "\0\0\0\0") break;                    if (br.BaseStream.Position + nextChunk.ChunkLength > br.BaseStream.Length)                  {                      break;                  }                  if (nextChunk.ChunkName == "COMM")                  {                      short numChannels = ConvertShort(br.ReadBytes(2));                      uint numSampleFrames = ConvertInt(br.ReadBytes(4));                      short sampleSize = ConvertShort(br.ReadBytes(2));                      double sampleRate = IEEE.ConvertFromIeeeExtended(br.ReadBytes(10));                        format = new WaveFormat((int)sampleRate' (int)sampleSize' (int)numChannels);                        if (nextChunk.ChunkLength > 18 && formType == "AIFC")                      {                             // In an AIFC file' the compression format is tacked on to the COMM chunk                          string compress = new string(br.ReadChars(4)).ToLower();                          if (compress != "none") throw new FormatException("Compressed AIFC is not supported.");                          br.ReadBytes((int)nextChunk.ChunkLength - 22);                      }                      else br.ReadBytes((int)nextChunk.ChunkLength - 18);                  }                  else if (nextChunk.ChunkName == "SSND")                  {                      uint offset = ConvertInt(br.ReadBytes(4));                      uint blockSize = ConvertInt(br.ReadBytes(4));                      dataChunkPosition = nextChunk.ChunkStart + 16 + offset;                      dataChunkLength = (int)nextChunk.ChunkLength - 8;                      br.BaseStream.Position += (nextChunk.ChunkLength - 8);                  }                  else                  {                      if (chunks != null)                      {                          chunks.Add(nextChunk);                      }                      br.BaseStream.Position += nextChunk.ChunkLength;                  }                                  }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ReadAiffHeader,The following statement contains a magic number: while (br.BaseStream.Position < br.BaseStream.Length)              {                  AiffChunk nextChunk = ReadChunkHeader(br);                  if (nextChunk.ChunkName == "\0\0\0\0") break;                    if (br.BaseStream.Position + nextChunk.ChunkLength > br.BaseStream.Length)                  {                      break;                  }                  if (nextChunk.ChunkName == "COMM")                  {                      short numChannels = ConvertShort(br.ReadBytes(2));                      uint numSampleFrames = ConvertInt(br.ReadBytes(4));                      short sampleSize = ConvertShort(br.ReadBytes(2));                      double sampleRate = IEEE.ConvertFromIeeeExtended(br.ReadBytes(10));                        format = new WaveFormat((int)sampleRate' (int)sampleSize' (int)numChannels);                        if (nextChunk.ChunkLength > 18 && formType == "AIFC")                      {                             // In an AIFC file' the compression format is tacked on to the COMM chunk                          string compress = new string(br.ReadChars(4)).ToLower();                          if (compress != "none") throw new FormatException("Compressed AIFC is not supported.");                          br.ReadBytes((int)nextChunk.ChunkLength - 22);                      }                      else br.ReadBytes((int)nextChunk.ChunkLength - 18);                  }                  else if (nextChunk.ChunkName == "SSND")                  {                      uint offset = ConvertInt(br.ReadBytes(4));                      uint blockSize = ConvertInt(br.ReadBytes(4));                      dataChunkPosition = nextChunk.ChunkStart + 16 + offset;                      dataChunkLength = (int)nextChunk.ChunkLength - 8;                      br.BaseStream.Position += (nextChunk.ChunkLength - 8);                  }                  else                  {                      if (chunks != null)                      {                          chunks.Add(nextChunk);                      }                      br.BaseStream.Position += nextChunk.ChunkLength;                  }                                  }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ReadAiffHeader,The following statement contains a magic number: while (br.BaseStream.Position < br.BaseStream.Length)              {                  AiffChunk nextChunk = ReadChunkHeader(br);                  if (nextChunk.ChunkName == "\0\0\0\0") break;                    if (br.BaseStream.Position + nextChunk.ChunkLength > br.BaseStream.Length)                  {                      break;                  }                  if (nextChunk.ChunkName == "COMM")                  {                      short numChannels = ConvertShort(br.ReadBytes(2));                      uint numSampleFrames = ConvertInt(br.ReadBytes(4));                      short sampleSize = ConvertShort(br.ReadBytes(2));                      double sampleRate = IEEE.ConvertFromIeeeExtended(br.ReadBytes(10));                        format = new WaveFormat((int)sampleRate' (int)sampleSize' (int)numChannels);                        if (nextChunk.ChunkLength > 18 && formType == "AIFC")                      {                             // In an AIFC file' the compression format is tacked on to the COMM chunk                          string compress = new string(br.ReadChars(4)).ToLower();                          if (compress != "none") throw new FormatException("Compressed AIFC is not supported.");                          br.ReadBytes((int)nextChunk.ChunkLength - 22);                      }                      else br.ReadBytes((int)nextChunk.ChunkLength - 18);                  }                  else if (nextChunk.ChunkName == "SSND")                  {                      uint offset = ConvertInt(br.ReadBytes(4));                      uint blockSize = ConvertInt(br.ReadBytes(4));                      dataChunkPosition = nextChunk.ChunkStart + 16 + offset;                      dataChunkLength = (int)nextChunk.ChunkLength - 8;                      br.BaseStream.Position += (nextChunk.ChunkLength - 8);                  }                  else                  {                      if (chunks != null)                      {                          chunks.Add(nextChunk);                      }                      br.BaseStream.Position += nextChunk.ChunkLength;                  }                                  }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ReadAiffHeader,The following statement contains a magic number: while (br.BaseStream.Position < br.BaseStream.Length)              {                  AiffChunk nextChunk = ReadChunkHeader(br);                  if (nextChunk.ChunkName == "\0\0\0\0") break;                    if (br.BaseStream.Position + nextChunk.ChunkLength > br.BaseStream.Length)                  {                      break;                  }                  if (nextChunk.ChunkName == "COMM")                  {                      short numChannels = ConvertShort(br.ReadBytes(2));                      uint numSampleFrames = ConvertInt(br.ReadBytes(4));                      short sampleSize = ConvertShort(br.ReadBytes(2));                      double sampleRate = IEEE.ConvertFromIeeeExtended(br.ReadBytes(10));                        format = new WaveFormat((int)sampleRate' (int)sampleSize' (int)numChannels);                        if (nextChunk.ChunkLength > 18 && formType == "AIFC")                      {                             // In an AIFC file' the compression format is tacked on to the COMM chunk                          string compress = new string(br.ReadChars(4)).ToLower();                          if (compress != "none") throw new FormatException("Compressed AIFC is not supported.");                          br.ReadBytes((int)nextChunk.ChunkLength - 22);                      }                      else br.ReadBytes((int)nextChunk.ChunkLength - 18);                  }                  else if (nextChunk.ChunkName == "SSND")                  {                      uint offset = ConvertInt(br.ReadBytes(4));                      uint blockSize = ConvertInt(br.ReadBytes(4));                      dataChunkPosition = nextChunk.ChunkStart + 16 + offset;                      dataChunkLength = (int)nextChunk.ChunkLength - 8;                      br.BaseStream.Position += (nextChunk.ChunkLength - 8);                  }                  else                  {                      if (chunks != null)                      {                          chunks.Add(nextChunk);                      }                      br.BaseStream.Position += nextChunk.ChunkLength;                  }                                  }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ReadAiffHeader,The following statement contains a magic number: while (br.BaseStream.Position < br.BaseStream.Length)              {                  AiffChunk nextChunk = ReadChunkHeader(br);                  if (nextChunk.ChunkName == "\0\0\0\0") break;                    if (br.BaseStream.Position + nextChunk.ChunkLength > br.BaseStream.Length)                  {                      break;                  }                  if (nextChunk.ChunkName == "COMM")                  {                      short numChannels = ConvertShort(br.ReadBytes(2));                      uint numSampleFrames = ConvertInt(br.ReadBytes(4));                      short sampleSize = ConvertShort(br.ReadBytes(2));                      double sampleRate = IEEE.ConvertFromIeeeExtended(br.ReadBytes(10));                        format = new WaveFormat((int)sampleRate' (int)sampleSize' (int)numChannels);                        if (nextChunk.ChunkLength > 18 && formType == "AIFC")                      {                             // In an AIFC file' the compression format is tacked on to the COMM chunk                          string compress = new string(br.ReadChars(4)).ToLower();                          if (compress != "none") throw new FormatException("Compressed AIFC is not supported.");                          br.ReadBytes((int)nextChunk.ChunkLength - 22);                      }                      else br.ReadBytes((int)nextChunk.ChunkLength - 18);                  }                  else if (nextChunk.ChunkName == "SSND")                  {                      uint offset = ConvertInt(br.ReadBytes(4));                      uint blockSize = ConvertInt(br.ReadBytes(4));                      dataChunkPosition = nextChunk.ChunkStart + 16 + offset;                      dataChunkLength = (int)nextChunk.ChunkLength - 8;                      br.BaseStream.Position += (nextChunk.ChunkLength - 8);                  }                  else                  {                      if (chunks != null)                      {                          chunks.Add(nextChunk);                      }                      br.BaseStream.Position += nextChunk.ChunkLength;                  }                                  }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ReadAiffHeader,The following statement contains a magic number: while (br.BaseStream.Position < br.BaseStream.Length)              {                  AiffChunk nextChunk = ReadChunkHeader(br);                  if (nextChunk.ChunkName == "\0\0\0\0") break;                    if (br.BaseStream.Position + nextChunk.ChunkLength > br.BaseStream.Length)                  {                      break;                  }                  if (nextChunk.ChunkName == "COMM")                  {                      short numChannels = ConvertShort(br.ReadBytes(2));                      uint numSampleFrames = ConvertInt(br.ReadBytes(4));                      short sampleSize = ConvertShort(br.ReadBytes(2));                      double sampleRate = IEEE.ConvertFromIeeeExtended(br.ReadBytes(10));                        format = new WaveFormat((int)sampleRate' (int)sampleSize' (int)numChannels);                        if (nextChunk.ChunkLength > 18 && formType == "AIFC")                      {                             // In an AIFC file' the compression format is tacked on to the COMM chunk                          string compress = new string(br.ReadChars(4)).ToLower();                          if (compress != "none") throw new FormatException("Compressed AIFC is not supported.");                          br.ReadBytes((int)nextChunk.ChunkLength - 22);                      }                      else br.ReadBytes((int)nextChunk.ChunkLength - 18);                  }                  else if (nextChunk.ChunkName == "SSND")                  {                      uint offset = ConvertInt(br.ReadBytes(4));                      uint blockSize = ConvertInt(br.ReadBytes(4));                      dataChunkPosition = nextChunk.ChunkStart + 16 + offset;                      dataChunkLength = (int)nextChunk.ChunkLength - 8;                      br.BaseStream.Position += (nextChunk.ChunkLength - 8);                  }                  else                  {                      if (chunks != null)                      {                          chunks.Add(nextChunk);                      }                      br.BaseStream.Position += nextChunk.ChunkLength;                  }                                  }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ReadAiffHeader,The following statement contains a magic number: while (br.BaseStream.Position < br.BaseStream.Length)              {                  AiffChunk nextChunk = ReadChunkHeader(br);                  if (nextChunk.ChunkName == "\0\0\0\0") break;                    if (br.BaseStream.Position + nextChunk.ChunkLength > br.BaseStream.Length)                  {                      break;                  }                  if (nextChunk.ChunkName == "COMM")                  {                      short numChannels = ConvertShort(br.ReadBytes(2));                      uint numSampleFrames = ConvertInt(br.ReadBytes(4));                      short sampleSize = ConvertShort(br.ReadBytes(2));                      double sampleRate = IEEE.ConvertFromIeeeExtended(br.ReadBytes(10));                        format = new WaveFormat((int)sampleRate' (int)sampleSize' (int)numChannels);                        if (nextChunk.ChunkLength > 18 && formType == "AIFC")                      {                             // In an AIFC file' the compression format is tacked on to the COMM chunk                          string compress = new string(br.ReadChars(4)).ToLower();                          if (compress != "none") throw new FormatException("Compressed AIFC is not supported.");                          br.ReadBytes((int)nextChunk.ChunkLength - 22);                      }                      else br.ReadBytes((int)nextChunk.ChunkLength - 18);                  }                  else if (nextChunk.ChunkName == "SSND")                  {                      uint offset = ConvertInt(br.ReadBytes(4));                      uint blockSize = ConvertInt(br.ReadBytes(4));                      dataChunkPosition = nextChunk.ChunkStart + 16 + offset;                      dataChunkLength = (int)nextChunk.ChunkLength - 8;                      br.BaseStream.Position += (nextChunk.ChunkLength - 8);                  }                  else                  {                      if (chunks != null)                      {                          chunks.Add(nextChunk);                      }                      br.BaseStream.Position += nextChunk.ChunkLength;                  }                                  }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ReadAiffHeader,The following statement contains a magic number: while (br.BaseStream.Position < br.BaseStream.Length)              {                  AiffChunk nextChunk = ReadChunkHeader(br);                  if (nextChunk.ChunkName == "\0\0\0\0") break;                    if (br.BaseStream.Position + nextChunk.ChunkLength > br.BaseStream.Length)                  {                      break;                  }                  if (nextChunk.ChunkName == "COMM")                  {                      short numChannels = ConvertShort(br.ReadBytes(2));                      uint numSampleFrames = ConvertInt(br.ReadBytes(4));                      short sampleSize = ConvertShort(br.ReadBytes(2));                      double sampleRate = IEEE.ConvertFromIeeeExtended(br.ReadBytes(10));                        format = new WaveFormat((int)sampleRate' (int)sampleSize' (int)numChannels);                        if (nextChunk.ChunkLength > 18 && formType == "AIFC")                      {                             // In an AIFC file' the compression format is tacked on to the COMM chunk                          string compress = new string(br.ReadChars(4)).ToLower();                          if (compress != "none") throw new FormatException("Compressed AIFC is not supported.");                          br.ReadBytes((int)nextChunk.ChunkLength - 22);                      }                      else br.ReadBytes((int)nextChunk.ChunkLength - 18);                  }                  else if (nextChunk.ChunkName == "SSND")                  {                      uint offset = ConvertInt(br.ReadBytes(4));                      uint blockSize = ConvertInt(br.ReadBytes(4));                      dataChunkPosition = nextChunk.ChunkStart + 16 + offset;                      dataChunkLength = (int)nextChunk.ChunkLength - 8;                      br.BaseStream.Position += (nextChunk.ChunkLength - 8);                  }                  else                  {                      if (chunks != null)                      {                          chunks.Add(nextChunk);                      }                      br.BaseStream.Position += nextChunk.ChunkLength;                  }                                  }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ReadAiffHeader,The following statement contains a magic number: while (br.BaseStream.Position < br.BaseStream.Length)              {                  AiffChunk nextChunk = ReadChunkHeader(br);                  if (nextChunk.ChunkName == "\0\0\0\0") break;                    if (br.BaseStream.Position + nextChunk.ChunkLength > br.BaseStream.Length)                  {                      break;                  }                  if (nextChunk.ChunkName == "COMM")                  {                      short numChannels = ConvertShort(br.ReadBytes(2));                      uint numSampleFrames = ConvertInt(br.ReadBytes(4));                      short sampleSize = ConvertShort(br.ReadBytes(2));                      double sampleRate = IEEE.ConvertFromIeeeExtended(br.ReadBytes(10));                        format = new WaveFormat((int)sampleRate' (int)sampleSize' (int)numChannels);                        if (nextChunk.ChunkLength > 18 && formType == "AIFC")                      {                             // In an AIFC file' the compression format is tacked on to the COMM chunk                          string compress = new string(br.ReadChars(4)).ToLower();                          if (compress != "none") throw new FormatException("Compressed AIFC is not supported.");                          br.ReadBytes((int)nextChunk.ChunkLength - 22);                      }                      else br.ReadBytes((int)nextChunk.ChunkLength - 18);                  }                  else if (nextChunk.ChunkName == "SSND")                  {                      uint offset = ConvertInt(br.ReadBytes(4));                      uint blockSize = ConvertInt(br.ReadBytes(4));                      dataChunkPosition = nextChunk.ChunkStart + 16 + offset;                      dataChunkLength = (int)nextChunk.ChunkLength - 8;                      br.BaseStream.Position += (nextChunk.ChunkLength - 8);                  }                  else                  {                      if (chunks != null)                      {                          chunks.Add(nextChunk);                      }                      br.BaseStream.Position += nextChunk.ChunkLength;                  }                                  }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ReadAiffHeader,The following statement contains a magic number: while (br.BaseStream.Position < br.BaseStream.Length)              {                  AiffChunk nextChunk = ReadChunkHeader(br);                  if (nextChunk.ChunkName == "\0\0\0\0") break;                    if (br.BaseStream.Position + nextChunk.ChunkLength > br.BaseStream.Length)                  {                      break;                  }                  if (nextChunk.ChunkName == "COMM")                  {                      short numChannels = ConvertShort(br.ReadBytes(2));                      uint numSampleFrames = ConvertInt(br.ReadBytes(4));                      short sampleSize = ConvertShort(br.ReadBytes(2));                      double sampleRate = IEEE.ConvertFromIeeeExtended(br.ReadBytes(10));                        format = new WaveFormat((int)sampleRate' (int)sampleSize' (int)numChannels);                        if (nextChunk.ChunkLength > 18 && formType == "AIFC")                      {                             // In an AIFC file' the compression format is tacked on to the COMM chunk                          string compress = new string(br.ReadChars(4)).ToLower();                          if (compress != "none") throw new FormatException("Compressed AIFC is not supported.");                          br.ReadBytes((int)nextChunk.ChunkLength - 22);                      }                      else br.ReadBytes((int)nextChunk.ChunkLength - 18);                  }                  else if (nextChunk.ChunkName == "SSND")                  {                      uint offset = ConvertInt(br.ReadBytes(4));                      uint blockSize = ConvertInt(br.ReadBytes(4));                      dataChunkPosition = nextChunk.ChunkStart + 16 + offset;                      dataChunkLength = (int)nextChunk.ChunkLength - 8;                      br.BaseStream.Position += (nextChunk.ChunkLength - 8);                  }                  else                  {                      if (chunks != null)                      {                          chunks.Add(nextChunk);                      }                      br.BaseStream.Position += nextChunk.ChunkLength;                  }                                  }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  // sometimes there is more junk at the end of the file past the data chunk                  if (Position + count > dataChunkLength)                  {                      count = dataChunkLength - (int) Position;                  }                    // Need to fix the endianness since intel expect little endian' and apple is big endian.                  byte[] buffer = new byte[count];                  int length = waveStream.Read(buffer' offset' count);                    int bytesPerSample = WaveFormat.BitsPerSample/8;                  for (int i = 0; i < length; i += bytesPerSample)                  {                      if (WaveFormat.BitsPerSample == 8)                      {                          array[i] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 16)                      {                          array[i + 0] = buffer[i + 1];                          array[i + 1] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 24)                      {                          array[i + 0] = buffer[i + 2];                          array[i + 1] = buffer[i + 1];                          array[i + 2] = buffer[i + 0];                      }                      else if (WaveFormat.BitsPerSample == 32)                      {                          array[i + 0] = buffer[i + 3];                          array[i + 1] = buffer[i + 2];                          array[i + 2] = buffer[i + 1];                          array[i + 3] = buffer[i + 0];                      }                      else throw new FormatException("Unsupported PCM format.");                  }                    return length;              }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  // sometimes there is more junk at the end of the file past the data chunk                  if (Position + count > dataChunkLength)                  {                      count = dataChunkLength - (int) Position;                  }                    // Need to fix the endianness since intel expect little endian' and apple is big endian.                  byte[] buffer = new byte[count];                  int length = waveStream.Read(buffer' offset' count);                    int bytesPerSample = WaveFormat.BitsPerSample/8;                  for (int i = 0; i < length; i += bytesPerSample)                  {                      if (WaveFormat.BitsPerSample == 8)                      {                          array[i] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 16)                      {                          array[i + 0] = buffer[i + 1];                          array[i + 1] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 24)                      {                          array[i + 0] = buffer[i + 2];                          array[i + 1] = buffer[i + 1];                          array[i + 2] = buffer[i + 0];                      }                      else if (WaveFormat.BitsPerSample == 32)                      {                          array[i + 0] = buffer[i + 3];                          array[i + 1] = buffer[i + 2];                          array[i + 2] = buffer[i + 1];                          array[i + 3] = buffer[i + 0];                      }                      else throw new FormatException("Unsupported PCM format.");                  }                    return length;              }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  // sometimes there is more junk at the end of the file past the data chunk                  if (Position + count > dataChunkLength)                  {                      count = dataChunkLength - (int) Position;                  }                    // Need to fix the endianness since intel expect little endian' and apple is big endian.                  byte[] buffer = new byte[count];                  int length = waveStream.Read(buffer' offset' count);                    int bytesPerSample = WaveFormat.BitsPerSample/8;                  for (int i = 0; i < length; i += bytesPerSample)                  {                      if (WaveFormat.BitsPerSample == 8)                      {                          array[i] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 16)                      {                          array[i + 0] = buffer[i + 1];                          array[i + 1] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 24)                      {                          array[i + 0] = buffer[i + 2];                          array[i + 1] = buffer[i + 1];                          array[i + 2] = buffer[i + 0];                      }                      else if (WaveFormat.BitsPerSample == 32)                      {                          array[i + 0] = buffer[i + 3];                          array[i + 1] = buffer[i + 2];                          array[i + 2] = buffer[i + 1];                          array[i + 3] = buffer[i + 0];                      }                      else throw new FormatException("Unsupported PCM format.");                  }                    return length;              }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  // sometimes there is more junk at the end of the file past the data chunk                  if (Position + count > dataChunkLength)                  {                      count = dataChunkLength - (int) Position;                  }                    // Need to fix the endianness since intel expect little endian' and apple is big endian.                  byte[] buffer = new byte[count];                  int length = waveStream.Read(buffer' offset' count);                    int bytesPerSample = WaveFormat.BitsPerSample/8;                  for (int i = 0; i < length; i += bytesPerSample)                  {                      if (WaveFormat.BitsPerSample == 8)                      {                          array[i] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 16)                      {                          array[i + 0] = buffer[i + 1];                          array[i + 1] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 24)                      {                          array[i + 0] = buffer[i + 2];                          array[i + 1] = buffer[i + 1];                          array[i + 2] = buffer[i + 0];                      }                      else if (WaveFormat.BitsPerSample == 32)                      {                          array[i + 0] = buffer[i + 3];                          array[i + 1] = buffer[i + 2];                          array[i + 2] = buffer[i + 1];                          array[i + 3] = buffer[i + 0];                      }                      else throw new FormatException("Unsupported PCM format.");                  }                    return length;              }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  // sometimes there is more junk at the end of the file past the data chunk                  if (Position + count > dataChunkLength)                  {                      count = dataChunkLength - (int) Position;                  }                    // Need to fix the endianness since intel expect little endian' and apple is big endian.                  byte[] buffer = new byte[count];                  int length = waveStream.Read(buffer' offset' count);                    int bytesPerSample = WaveFormat.BitsPerSample/8;                  for (int i = 0; i < length; i += bytesPerSample)                  {                      if (WaveFormat.BitsPerSample == 8)                      {                          array[i] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 16)                      {                          array[i + 0] = buffer[i + 1];                          array[i + 1] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 24)                      {                          array[i + 0] = buffer[i + 2];                          array[i + 1] = buffer[i + 1];                          array[i + 2] = buffer[i + 0];                      }                      else if (WaveFormat.BitsPerSample == 32)                      {                          array[i + 0] = buffer[i + 3];                          array[i + 1] = buffer[i + 2];                          array[i + 2] = buffer[i + 1];                          array[i + 3] = buffer[i + 0];                      }                      else throw new FormatException("Unsupported PCM format.");                  }                    return length;              }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  // sometimes there is more junk at the end of the file past the data chunk                  if (Position + count > dataChunkLength)                  {                      count = dataChunkLength - (int) Position;                  }                    // Need to fix the endianness since intel expect little endian' and apple is big endian.                  byte[] buffer = new byte[count];                  int length = waveStream.Read(buffer' offset' count);                    int bytesPerSample = WaveFormat.BitsPerSample/8;                  for (int i = 0; i < length; i += bytesPerSample)                  {                      if (WaveFormat.BitsPerSample == 8)                      {                          array[i] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 16)                      {                          array[i + 0] = buffer[i + 1];                          array[i + 1] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 24)                      {                          array[i + 0] = buffer[i + 2];                          array[i + 1] = buffer[i + 1];                          array[i + 2] = buffer[i + 0];                      }                      else if (WaveFormat.BitsPerSample == 32)                      {                          array[i + 0] = buffer[i + 3];                          array[i + 1] = buffer[i + 2];                          array[i + 2] = buffer[i + 1];                          array[i + 3] = buffer[i + 0];                      }                      else throw new FormatException("Unsupported PCM format.");                  }                    return length;              }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  // sometimes there is more junk at the end of the file past the data chunk                  if (Position + count > dataChunkLength)                  {                      count = dataChunkLength - (int) Position;                  }                    // Need to fix the endianness since intel expect little endian' and apple is big endian.                  byte[] buffer = new byte[count];                  int length = waveStream.Read(buffer' offset' count);                    int bytesPerSample = WaveFormat.BitsPerSample/8;                  for (int i = 0; i < length; i += bytesPerSample)                  {                      if (WaveFormat.BitsPerSample == 8)                      {                          array[i] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 16)                      {                          array[i + 0] = buffer[i + 1];                          array[i + 1] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 24)                      {                          array[i + 0] = buffer[i + 2];                          array[i + 1] = buffer[i + 1];                          array[i + 2] = buffer[i + 0];                      }                      else if (WaveFormat.BitsPerSample == 32)                      {                          array[i + 0] = buffer[i + 3];                          array[i + 1] = buffer[i + 2];                          array[i + 2] = buffer[i + 1];                          array[i + 3] = buffer[i + 0];                      }                      else throw new FormatException("Unsupported PCM format.");                  }                    return length;              }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  // sometimes there is more junk at the end of the file past the data chunk                  if (Position + count > dataChunkLength)                  {                      count = dataChunkLength - (int) Position;                  }                    // Need to fix the endianness since intel expect little endian' and apple is big endian.                  byte[] buffer = new byte[count];                  int length = waveStream.Read(buffer' offset' count);                    int bytesPerSample = WaveFormat.BitsPerSample/8;                  for (int i = 0; i < length; i += bytesPerSample)                  {                      if (WaveFormat.BitsPerSample == 8)                      {                          array[i] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 16)                      {                          array[i + 0] = buffer[i + 1];                          array[i + 1] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 24)                      {                          array[i + 0] = buffer[i + 2];                          array[i + 1] = buffer[i + 1];                          array[i + 2] = buffer[i + 0];                      }                      else if (WaveFormat.BitsPerSample == 32)                      {                          array[i + 0] = buffer[i + 3];                          array[i + 1] = buffer[i + 2];                          array[i + 2] = buffer[i + 1];                          array[i + 3] = buffer[i + 0];                      }                      else throw new FormatException("Unsupported PCM format.");                  }                    return length;              }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  // sometimes there is more junk at the end of the file past the data chunk                  if (Position + count > dataChunkLength)                  {                      count = dataChunkLength - (int) Position;                  }                    // Need to fix the endianness since intel expect little endian' and apple is big endian.                  byte[] buffer = new byte[count];                  int length = waveStream.Read(buffer' offset' count);                    int bytesPerSample = WaveFormat.BitsPerSample/8;                  for (int i = 0; i < length; i += bytesPerSample)                  {                      if (WaveFormat.BitsPerSample == 8)                      {                          array[i] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 16)                      {                          array[i + 0] = buffer[i + 1];                          array[i + 1] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 24)                      {                          array[i + 0] = buffer[i + 2];                          array[i + 1] = buffer[i + 1];                          array[i + 2] = buffer[i + 0];                      }                      else if (WaveFormat.BitsPerSample == 32)                      {                          array[i + 0] = buffer[i + 3];                          array[i + 1] = buffer[i + 2];                          array[i + 2] = buffer[i + 1];                          array[i + 3] = buffer[i + 0];                      }                      else throw new FormatException("Unsupported PCM format.");                  }                    return length;              }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  // sometimes there is more junk at the end of the file past the data chunk                  if (Position + count > dataChunkLength)                  {                      count = dataChunkLength - (int) Position;                  }                    // Need to fix the endianness since intel expect little endian' and apple is big endian.                  byte[] buffer = new byte[count];                  int length = waveStream.Read(buffer' offset' count);                    int bytesPerSample = WaveFormat.BitsPerSample/8;                  for (int i = 0; i < length; i += bytesPerSample)                  {                      if (WaveFormat.BitsPerSample == 8)                      {                          array[i] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 16)                      {                          array[i + 0] = buffer[i + 1];                          array[i + 1] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 24)                      {                          array[i + 0] = buffer[i + 2];                          array[i + 1] = buffer[i + 1];                          array[i + 2] = buffer[i + 0];                      }                      else if (WaveFormat.BitsPerSample == 32)                      {                          array[i + 0] = buffer[i + 3];                          array[i + 1] = buffer[i + 2];                          array[i + 2] = buffer[i + 1];                          array[i + 3] = buffer[i + 0];                      }                      else throw new FormatException("Unsupported PCM format.");                  }                    return length;              }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  // sometimes there is more junk at the end of the file past the data chunk                  if (Position + count > dataChunkLength)                  {                      count = dataChunkLength - (int) Position;                  }                    // Need to fix the endianness since intel expect little endian' and apple is big endian.                  byte[] buffer = new byte[count];                  int length = waveStream.Read(buffer' offset' count);                    int bytesPerSample = WaveFormat.BitsPerSample/8;                  for (int i = 0; i < length; i += bytesPerSample)                  {                      if (WaveFormat.BitsPerSample == 8)                      {                          array[i] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 16)                      {                          array[i + 0] = buffer[i + 1];                          array[i + 1] = buffer[i];                      }                      else if (WaveFormat.BitsPerSample == 24)                      {                          array[i + 0] = buffer[i + 2];                          array[i + 1] = buffer[i + 1];                          array[i + 2] = buffer[i + 0];                      }                      else if (WaveFormat.BitsPerSample == 32)                      {                          array[i + 0] = buffer[i + 3];                          array[i + 1] = buffer[i + 2];                          array[i + 2] = buffer[i + 1];                          array[i + 3] = buffer[i + 0];                      }                      else throw new FormatException("Unsupported PCM format.");                  }                    return length;              }
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ConvertInt,The following statement contains a magic number: if (buffer.Length != 4) throw new Exception("Incorrect length for long.");
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ConvertInt,The following statement contains a magic number: return (uint)((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]);
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ConvertInt,The following statement contains a magic number: return (uint)((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]);
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ConvertInt,The following statement contains a magic number: return (uint)((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]);
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ConvertInt,The following statement contains a magic number: return (uint)((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]);
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ConvertInt,The following statement contains a magic number: return (uint)((buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]);
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ConvertShort,The following statement contains a magic number: if (buffer.Length != 2) throw new Exception("Incorrect length for int.");
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ConvertShort,The following statement contains a magic number: return (short)((buffer[0] << 8) | buffer[1]);
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ReadChunkHeader,The following statement contains a magic number: var chunk = new AiffChunk((uint)br.BaseStream.Position' ReadChunkName(br)' ConvertInt(br.ReadBytes(4)));
Magic Number,NAudio.Wave,AiffFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,ReadChunkName,The following statement contains a magic number: return new string(br.ReadChars(4));
Magic Number,NAudio.Wave,AiffChunk,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AiffFileReader.cs,AiffChunk,The following statement contains a magic number: ChunkLength = length + (uint)(length % 2 == 1 ? 1 : 0);
Magic Number,NAudio.Wave,AudioFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AudioFileReader.cs,AudioFileReader,The following statement contains a magic number: sourceBytesPerSample = (readerStream.WaveFormat.BitsPerSample / 8) * readerStream.WaveFormat.Channels;
Magic Number,NAudio.Wave,AudioFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AudioFileReader.cs,AudioFileReader,The following statement contains a magic number: destBytesPerSample = 4*sampleChannel.WaveFormat.Channels;
Magic Number,NAudio.Wave,AudioFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AudioFileReader.cs,Read,The following statement contains a magic number: int samplesRequired = count / 4;
Magic Number,NAudio.Wave,AudioFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AudioFileReader.cs,Read,The following statement contains a magic number: int samplesRead = Read(waveBuffer.FloatBuffer' offset / 4' samplesRequired);
Magic Number,NAudio.Wave,AudioFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\AudioFileReader.cs,Read,The following statement contains a magic number: return samplesRead * 4;
Magic Number,NAudio.Wave,BlockAlignReductionStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\BlockAlignReductionStream.cs,BlockAlignReductionStream,The following statement contains a magic number: circularBuffer = new CircularBuffer(sourceStream.WaveFormat.AverageBytesPerSecond * 4);
Magic Number,NAudio.Wave,BlockAlignReductionStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\BlockAlignReductionStream.cs,GetSourceBuffer,The following statement contains a magic number: if (sourceBuffer == null || sourceBuffer.Length < size)              {                  // let's give ourselves some leeway                  sourceBuffer = new byte[size * 2];              }
Magic Number,NAudio.Wave,ComStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\ComStream.cs,Stat,The following statement contains a magic number: var tmp = new System.Runtime.InteropServices.ComTypes.STATSTG { type = 2' cbSize = Length' grfMode = 0 };
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,CueList,The following statement contains a magic number: for (int p = 4; cueChunkData.Length - p >= 24; p += 24' cue++)              {                  cueIndex[BitConverter.ToInt32(cueChunkData' p)] = cue;                  positions[cue] = BitConverter.ToInt32(cueChunkData' p + 20);              }
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,CueList,The following statement contains a magic number: for (int p = 4; cueChunkData.Length - p >= 24; p += 24' cue++)              {                  cueIndex[BitConverter.ToInt32(cueChunkData' p)] = cue;                  positions[cue] = BitConverter.ToInt32(cueChunkData' p + 20);              }
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,CueList,The following statement contains a magic number: for (int p = 4; cueChunkData.Length - p >= 24; p += 24' cue++)              {                  cueIndex[BitConverter.ToInt32(cueChunkData' p)] = cue;                  positions[cue] = BitConverter.ToInt32(cueChunkData' p + 20);              }
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,CueList,The following statement contains a magic number: for (int p = 4; cueChunkData.Length - p >= 24; p += 24' cue++)              {                  cueIndex[BitConverter.ToInt32(cueChunkData' p)] = cue;                  positions[cue] = BitConverter.ToInt32(cueChunkData' p + 20);              }
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,CueList,The following statement contains a magic number: for (int p = 4; listChunkData.Length - p >= 16; p += labelLength + labelLength % 2 + 12)              {                  if (BitConverter.ToInt32(listChunkData' p) == labelChunkId)                  {                      labelLength = BitConverter.ToInt32(listChunkData' p + 4) - 4;                      var cueId = BitConverter.ToInt32(listChunkData' p + 8);                      cue = cueIndex[cueId];                      labels[cue] = Encoding.Default.GetString(listChunkData' p + 12' labelLength - 1);                  }              }
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,CueList,The following statement contains a magic number: for (int p = 4; listChunkData.Length - p >= 16; p += labelLength + labelLength % 2 + 12)              {                  if (BitConverter.ToInt32(listChunkData' p) == labelChunkId)                  {                      labelLength = BitConverter.ToInt32(listChunkData' p + 4) - 4;                      var cueId = BitConverter.ToInt32(listChunkData' p + 8);                      cue = cueIndex[cueId];                      labels[cue] = Encoding.Default.GetString(listChunkData' p + 12' labelLength - 1);                  }              }
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,CueList,The following statement contains a magic number: for (int p = 4; listChunkData.Length - p >= 16; p += labelLength + labelLength % 2 + 12)              {                  if (BitConverter.ToInt32(listChunkData' p) == labelChunkId)                  {                      labelLength = BitConverter.ToInt32(listChunkData' p + 4) - 4;                      var cueId = BitConverter.ToInt32(listChunkData' p + 8);                      cue = cueIndex[cueId];                      labels[cue] = Encoding.Default.GetString(listChunkData' p + 12' labelLength - 1);                  }              }
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,CueList,The following statement contains a magic number: for (int p = 4; listChunkData.Length - p >= 16; p += labelLength + labelLength % 2 + 12)              {                  if (BitConverter.ToInt32(listChunkData' p) == labelChunkId)                  {                      labelLength = BitConverter.ToInt32(listChunkData' p + 4) - 4;                      var cueId = BitConverter.ToInt32(listChunkData' p + 8);                      cue = cueIndex[cueId];                      labels[cue] = Encoding.Default.GetString(listChunkData' p + 12' labelLength - 1);                  }              }
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,CueList,The following statement contains a magic number: for (int p = 4; listChunkData.Length - p >= 16; p += labelLength + labelLength % 2 + 12)              {                  if (BitConverter.ToInt32(listChunkData' p) == labelChunkId)                  {                      labelLength = BitConverter.ToInt32(listChunkData' p + 4) - 4;                      var cueId = BitConverter.ToInt32(listChunkData' p + 8);                      cue = cueIndex[cueId];                      labels[cue] = Encoding.Default.GetString(listChunkData' p + 12' labelLength - 1);                  }              }
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,CueList,The following statement contains a magic number: for (int p = 4; listChunkData.Length - p >= 16; p += labelLength + labelLength % 2 + 12)              {                  if (BitConverter.ToInt32(listChunkData' p) == labelChunkId)                  {                      labelLength = BitConverter.ToInt32(listChunkData' p + 4) - 4;                      var cueId = BitConverter.ToInt32(listChunkData' p + 8);                      cue = cueIndex[cueId];                      labels[cue] = Encoding.Default.GetString(listChunkData' p + 12' labelLength - 1);                  }              }
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,CueList,The following statement contains a magic number: for (int p = 4; listChunkData.Length - p >= 16; p += labelLength + labelLength % 2 + 12)              {                  if (BitConverter.ToInt32(listChunkData' p) == labelChunkId)                  {                      labelLength = BitConverter.ToInt32(listChunkData' p + 4) - 4;                      var cueId = BitConverter.ToInt32(listChunkData' p + 8);                      cue = cueIndex[cueId];                      labels[cue] = Encoding.Default.GetString(listChunkData' p + 12' labelLength - 1);                  }              }
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,CueList,The following statement contains a magic number: for (int p = 4; listChunkData.Length - p >= 16; p += labelLength + labelLength % 2 + 12)              {                  if (BitConverter.ToInt32(listChunkData' p) == labelChunkId)                  {                      labelLength = BitConverter.ToInt32(listChunkData' p + 4) - 4;                      var cueId = BitConverter.ToInt32(listChunkData' p + 8);                      cue = cueIndex[cueId];                      labels[cue] = Encoding.Default.GetString(listChunkData' p + 12' labelLength - 1);                  }              }
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,GetRiffChunks,The following statement contains a magic number: var cueChunkLength = 12 + 24 * Count;
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,GetRiffChunks,The following statement contains a magic number: var cueChunkLength = 12 + 24 * Count;
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,GetRiffChunks,The following statement contains a magic number: var listChunkLength = 12;
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,GetRiffChunks,The following statement contains a magic number: for (int i = 0; i < Count; i++)              {                  var labelChunkLength = this[i].Label.Length + 1;                  listChunkLength += labelChunkLength + labelChunkLength % 2 + 12;              }
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,GetRiffChunks,The following statement contains a magic number: for (int i = 0; i < Count; i++)              {                  var labelChunkLength = this[i].Label.Length + 1;                  listChunkLength += labelChunkLength + labelChunkLength % 2 + 12;              }
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,GetRiffChunks,The following statement contains a magic number: using (var stream = new MemoryStream(chunks))              {                  using (var writer = new BinaryWriter(stream))                  {                      writer.Write(cueChunkId);                      writer.Write(cueChunkLength - 8);                      writer.Write(Count);                      for (int cue = 0; cue < Count; cue++)                      {                          int position = this[cue].Position;                            writer.Write(cue);                          writer.Write(position);                          writer.Write(dataChunkId);                          writer.Seek(8' SeekOrigin.Current);                          writer.Write(position);                      }                      writer.Write(listChunkId);                      writer.Write(listChunkLength - 8);                      writer.Write(adtlTypeId);                      for (int cue = 0; cue < Count; cue++)                      {                          writer.Write(labelChunkId);                          writer.Write(this[cue].Label.Length + 1 + 4);                          writer.Write(cue);                          writer.Write(Encoding.Default.GetBytes(this[cue].Label.ToCharArray()));                          if (this[cue].Label.Length % 2 == 0)                          {                              writer.Seek(2' SeekOrigin.Current);                          }                          else                          {                              writer.Seek(1' SeekOrigin.Current);                          }                      }                  }              }
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,GetRiffChunks,The following statement contains a magic number: using (var stream = new MemoryStream(chunks))              {                  using (var writer = new BinaryWriter(stream))                  {                      writer.Write(cueChunkId);                      writer.Write(cueChunkLength - 8);                      writer.Write(Count);                      for (int cue = 0; cue < Count; cue++)                      {                          int position = this[cue].Position;                            writer.Write(cue);                          writer.Write(position);                          writer.Write(dataChunkId);                          writer.Seek(8' SeekOrigin.Current);                          writer.Write(position);                      }                      writer.Write(listChunkId);                      writer.Write(listChunkLength - 8);                      writer.Write(adtlTypeId);                      for (int cue = 0; cue < Count; cue++)                      {                          writer.Write(labelChunkId);                          writer.Write(this[cue].Label.Length + 1 + 4);                          writer.Write(cue);                          writer.Write(Encoding.Default.GetBytes(this[cue].Label.ToCharArray()));                          if (this[cue].Label.Length % 2 == 0)                          {                              writer.Seek(2' SeekOrigin.Current);                          }                          else                          {                              writer.Seek(1' SeekOrigin.Current);                          }                      }                  }              }
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,GetRiffChunks,The following statement contains a magic number: using (var stream = new MemoryStream(chunks))              {                  using (var writer = new BinaryWriter(stream))                  {                      writer.Write(cueChunkId);                      writer.Write(cueChunkLength - 8);                      writer.Write(Count);                      for (int cue = 0; cue < Count; cue++)                      {                          int position = this[cue].Position;                            writer.Write(cue);                          writer.Write(position);                          writer.Write(dataChunkId);                          writer.Seek(8' SeekOrigin.Current);                          writer.Write(position);                      }                      writer.Write(listChunkId);                      writer.Write(listChunkLength - 8);                      writer.Write(adtlTypeId);                      for (int cue = 0; cue < Count; cue++)                      {                          writer.Write(labelChunkId);                          writer.Write(this[cue].Label.Length + 1 + 4);                          writer.Write(cue);                          writer.Write(Encoding.Default.GetBytes(this[cue].Label.ToCharArray()));                          if (this[cue].Label.Length % 2 == 0)                          {                              writer.Seek(2' SeekOrigin.Current);                          }                          else                          {                              writer.Seek(1' SeekOrigin.Current);                          }                      }                  }              }
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,GetRiffChunks,The following statement contains a magic number: using (var stream = new MemoryStream(chunks))              {                  using (var writer = new BinaryWriter(stream))                  {                      writer.Write(cueChunkId);                      writer.Write(cueChunkLength - 8);                      writer.Write(Count);                      for (int cue = 0; cue < Count; cue++)                      {                          int position = this[cue].Position;                            writer.Write(cue);                          writer.Write(position);                          writer.Write(dataChunkId);                          writer.Seek(8' SeekOrigin.Current);                          writer.Write(position);                      }                      writer.Write(listChunkId);                      writer.Write(listChunkLength - 8);                      writer.Write(adtlTypeId);                      for (int cue = 0; cue < Count; cue++)                      {                          writer.Write(labelChunkId);                          writer.Write(this[cue].Label.Length + 1 + 4);                          writer.Write(cue);                          writer.Write(Encoding.Default.GetBytes(this[cue].Label.ToCharArray()));                          if (this[cue].Label.Length % 2 == 0)                          {                              writer.Seek(2' SeekOrigin.Current);                          }                          else                          {                              writer.Seek(1' SeekOrigin.Current);                          }                      }                  }              }
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,GetRiffChunks,The following statement contains a magic number: using (var stream = new MemoryStream(chunks))              {                  using (var writer = new BinaryWriter(stream))                  {                      writer.Write(cueChunkId);                      writer.Write(cueChunkLength - 8);                      writer.Write(Count);                      for (int cue = 0; cue < Count; cue++)                      {                          int position = this[cue].Position;                            writer.Write(cue);                          writer.Write(position);                          writer.Write(dataChunkId);                          writer.Seek(8' SeekOrigin.Current);                          writer.Write(position);                      }                      writer.Write(listChunkId);                      writer.Write(listChunkLength - 8);                      writer.Write(adtlTypeId);                      for (int cue = 0; cue < Count; cue++)                      {                          writer.Write(labelChunkId);                          writer.Write(this[cue].Label.Length + 1 + 4);                          writer.Write(cue);                          writer.Write(Encoding.Default.GetBytes(this[cue].Label.ToCharArray()));                          if (this[cue].Label.Length % 2 == 0)                          {                              writer.Seek(2' SeekOrigin.Current);                          }                          else                          {                              writer.Seek(1' SeekOrigin.Current);                          }                      }                  }              }
Magic Number,NAudio.Wave,CueList,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\CueList.cs,GetRiffChunks,The following statement contains a magic number: using (var stream = new MemoryStream(chunks))              {                  using (var writer = new BinaryWriter(stream))                  {                      writer.Write(cueChunkId);                      writer.Write(cueChunkLength - 8);                      writer.Write(Count);                      for (int cue = 0; cue < Count; cue++)                      {                          int position = this[cue].Position;                            writer.Write(cue);                          writer.Write(position);                          writer.Write(dataChunkId);                          writer.Seek(8' SeekOrigin.Current);                          writer.Write(position);                      }                      writer.Write(listChunkId);                      writer.Write(listChunkLength - 8);                      writer.Write(adtlTypeId);                      for (int cue = 0; cue < Count; cue++)                      {                          writer.Write(labelChunkId);                          writer.Write(this[cue].Label.Length + 1 + 4);                          writer.Write(cue);                          writer.Write(Encoding.Default.GetBytes(this[cue].Label.ToCharArray()));                          if (this[cue].Label.Length % 2 == 0)                          {                              writer.Seek(2' SeekOrigin.Current);                          }                          else                          {                              writer.Seek(1' SeekOrigin.Current);                          }                      }                  }              }
Magic Number,NAudio.Wave,MediaFoundationReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\MediaFoundationReader.cs,CreateReader,The following statement contains a magic number: try              {                  // set the media type                  // can return MF_E_INVALIDMEDIATYPE if not supported                  reader.SetCurrentMediaType(MediaFoundationInterop.MF_SOURCE_READER_FIRST_AUDIO_STREAM' IntPtr.Zero' partialMediaType.MediaFoundationObject);              }              catch (COMException ex) when (ex.GetHResult() == MediaFoundationErrors.MF_E_INVALIDMEDIATYPE)              {                                 // HE-AAC (and v2) seems to halve the samplerate                  if (currentMediaType.SubType == AudioSubtypes.MFAudioFormat_AAC && currentMediaType.ChannelCount == 1)                  {                      partialMediaType.SampleRate = currentMediaType.SampleRate *= 2;                      partialMediaType.ChannelCount = currentMediaType.ChannelCount *= 2;                      reader.SetCurrentMediaType(MediaFoundationInterop.MF_SOURCE_READER_FIRST_AUDIO_STREAM' IntPtr.Zero' partialMediaType.MediaFoundationObject);                  }                  else { throw; }              }
Magic Number,NAudio.Wave,MediaFoundationReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\MediaFoundationReader.cs,CreateReader,The following statement contains a magic number: try              {                  // set the media type                  // can return MF_E_INVALIDMEDIATYPE if not supported                  reader.SetCurrentMediaType(MediaFoundationInterop.MF_SOURCE_READER_FIRST_AUDIO_STREAM' IntPtr.Zero' partialMediaType.MediaFoundationObject);              }              catch (COMException ex) when (ex.GetHResult() == MediaFoundationErrors.MF_E_INVALIDMEDIATYPE)              {                                 // HE-AAC (and v2) seems to halve the samplerate                  if (currentMediaType.SubType == AudioSubtypes.MFAudioFormat_AAC && currentMediaType.ChannelCount == 1)                  {                      partialMediaType.SampleRate = currentMediaType.SampleRate *= 2;                      partialMediaType.ChannelCount = currentMediaType.ChannelCount *= 2;                      reader.SetCurrentMediaType(MediaFoundationInterop.MF_SOURCE_READER_FIRST_AUDIO_STREAM' IntPtr.Zero' partialMediaType.MediaFoundationObject);                  }                  else { throw; }              }
Magic Number,NAudio.Wave,Mp3FileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Mp3FileReader.cs,Mp3FileReader,The following statement contains a magic number: try              {                  mp3Stream = inputStream;                  Id3v2Tag = Id3v2Tag.ReadTag(mp3Stream);                    dataStartPosition = mp3Stream.Position;                  var firstFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (firstFrame == null)                      throw new InvalidDataException("Invalid MP3 file - no MP3 Frames Detected");                  double bitRate = firstFrame.BitRate;                  xingHeader = XingHeader.LoadXingHeader(firstFrame);                  // If the header exists' we can skip over it when decoding the rest of the file                  if (xingHeader != null) dataStartPosition = mp3Stream.Position;                    // workaround for a longstanding issue with some files failing to load                  // because they report a spurious sample rate change                  var secondFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (secondFrame != null &&                      (secondFrame.SampleRate != firstFrame.SampleRate ||                       secondFrame.ChannelMode != firstFrame.ChannelMode))                  {                      // assume that the first frame was some kind of VBR/LAME header that we failed to recognise properly                      dataStartPosition = secondFrame.FileOffset;                      // forget about the first frame' the second one is the first one we really care about                      firstFrame = secondFrame;                  }                    mp3DataLength = mp3Stream.Length - dataStartPosition;                    // try for an ID3v1 tag as well                  mp3Stream.Position = mp3Stream.Length - 128;                  byte[] tag = new byte[128];                  mp3Stream.Read(tag' 0' 128);                  if (tag[0] == 'T' && tag[1] == 'A' && tag[2] == 'G')                  {                      Id3v1Tag = tag;                      mp3DataLength -= 128;                  }                    mp3Stream.Position = dataStartPosition;                    // create a temporary MP3 format before we know the real bitrate                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                    CreateTableOfContents();                  tocIndex = 0;                    // [Bit rate in Kilobits/sec] = [Length in kbits] / [time in seconds]                   //                            = [Length in bits ] / [time in milliseconds]                    // Note: in audio' 1 kilobit = 1000 bits.                  // Calculated as a double to minimize rounding errors                  bitRate = (mp3DataLength*8.0/TotalSeconds());                    mp3Stream.Position = dataStartPosition;                    // now we know the real bitrate we can create an accurate MP3 WaveFormat                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                  decompressor = frameDecompressorBuilder(Mp3WaveFormat);                  waveFormat = decompressor.OutputFormat;                  bytesPerSample = (decompressor.OutputFormat.BitsPerSample)/8*decompressor.OutputFormat.Channels;                  // no MP3 frames have more than 1152 samples in them                  bytesPerDecodedFrame = 1152 * bytesPerSample;                  // some MP3s I seem to get double                  decompressBuffer = new byte[bytesPerDecodedFrame * 2];              }              catch (Exception)              {                  if (ownInputStream) inputStream.Dispose();                  throw;              }
Magic Number,NAudio.Wave,Mp3FileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Mp3FileReader.cs,Mp3FileReader,The following statement contains a magic number: try              {                  mp3Stream = inputStream;                  Id3v2Tag = Id3v2Tag.ReadTag(mp3Stream);                    dataStartPosition = mp3Stream.Position;                  var firstFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (firstFrame == null)                      throw new InvalidDataException("Invalid MP3 file - no MP3 Frames Detected");                  double bitRate = firstFrame.BitRate;                  xingHeader = XingHeader.LoadXingHeader(firstFrame);                  // If the header exists' we can skip over it when decoding the rest of the file                  if (xingHeader != null) dataStartPosition = mp3Stream.Position;                    // workaround for a longstanding issue with some files failing to load                  // because they report a spurious sample rate change                  var secondFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (secondFrame != null &&                      (secondFrame.SampleRate != firstFrame.SampleRate ||                       secondFrame.ChannelMode != firstFrame.ChannelMode))                  {                      // assume that the first frame was some kind of VBR/LAME header that we failed to recognise properly                      dataStartPosition = secondFrame.FileOffset;                      // forget about the first frame' the second one is the first one we really care about                      firstFrame = secondFrame;                  }                    mp3DataLength = mp3Stream.Length - dataStartPosition;                    // try for an ID3v1 tag as well                  mp3Stream.Position = mp3Stream.Length - 128;                  byte[] tag = new byte[128];                  mp3Stream.Read(tag' 0' 128);                  if (tag[0] == 'T' && tag[1] == 'A' && tag[2] == 'G')                  {                      Id3v1Tag = tag;                      mp3DataLength -= 128;                  }                    mp3Stream.Position = dataStartPosition;                    // create a temporary MP3 format before we know the real bitrate                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                    CreateTableOfContents();                  tocIndex = 0;                    // [Bit rate in Kilobits/sec] = [Length in kbits] / [time in seconds]                   //                            = [Length in bits ] / [time in milliseconds]                    // Note: in audio' 1 kilobit = 1000 bits.                  // Calculated as a double to minimize rounding errors                  bitRate = (mp3DataLength*8.0/TotalSeconds());                    mp3Stream.Position = dataStartPosition;                    // now we know the real bitrate we can create an accurate MP3 WaveFormat                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                  decompressor = frameDecompressorBuilder(Mp3WaveFormat);                  waveFormat = decompressor.OutputFormat;                  bytesPerSample = (decompressor.OutputFormat.BitsPerSample)/8*decompressor.OutputFormat.Channels;                  // no MP3 frames have more than 1152 samples in them                  bytesPerDecodedFrame = 1152 * bytesPerSample;                  // some MP3s I seem to get double                  decompressBuffer = new byte[bytesPerDecodedFrame * 2];              }              catch (Exception)              {                  if (ownInputStream) inputStream.Dispose();                  throw;              }
Magic Number,NAudio.Wave,Mp3FileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Mp3FileReader.cs,Mp3FileReader,The following statement contains a magic number: try              {                  mp3Stream = inputStream;                  Id3v2Tag = Id3v2Tag.ReadTag(mp3Stream);                    dataStartPosition = mp3Stream.Position;                  var firstFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (firstFrame == null)                      throw new InvalidDataException("Invalid MP3 file - no MP3 Frames Detected");                  double bitRate = firstFrame.BitRate;                  xingHeader = XingHeader.LoadXingHeader(firstFrame);                  // If the header exists' we can skip over it when decoding the rest of the file                  if (xingHeader != null) dataStartPosition = mp3Stream.Position;                    // workaround for a longstanding issue with some files failing to load                  // because they report a spurious sample rate change                  var secondFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (secondFrame != null &&                      (secondFrame.SampleRate != firstFrame.SampleRate ||                       secondFrame.ChannelMode != firstFrame.ChannelMode))                  {                      // assume that the first frame was some kind of VBR/LAME header that we failed to recognise properly                      dataStartPosition = secondFrame.FileOffset;                      // forget about the first frame' the second one is the first one we really care about                      firstFrame = secondFrame;                  }                    mp3DataLength = mp3Stream.Length - dataStartPosition;                    // try for an ID3v1 tag as well                  mp3Stream.Position = mp3Stream.Length - 128;                  byte[] tag = new byte[128];                  mp3Stream.Read(tag' 0' 128);                  if (tag[0] == 'T' && tag[1] == 'A' && tag[2] == 'G')                  {                      Id3v1Tag = tag;                      mp3DataLength -= 128;                  }                    mp3Stream.Position = dataStartPosition;                    // create a temporary MP3 format before we know the real bitrate                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                    CreateTableOfContents();                  tocIndex = 0;                    // [Bit rate in Kilobits/sec] = [Length in kbits] / [time in seconds]                   //                            = [Length in bits ] / [time in milliseconds]                    // Note: in audio' 1 kilobit = 1000 bits.                  // Calculated as a double to minimize rounding errors                  bitRate = (mp3DataLength*8.0/TotalSeconds());                    mp3Stream.Position = dataStartPosition;                    // now we know the real bitrate we can create an accurate MP3 WaveFormat                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                  decompressor = frameDecompressorBuilder(Mp3WaveFormat);                  waveFormat = decompressor.OutputFormat;                  bytesPerSample = (decompressor.OutputFormat.BitsPerSample)/8*decompressor.OutputFormat.Channels;                  // no MP3 frames have more than 1152 samples in them                  bytesPerDecodedFrame = 1152 * bytesPerSample;                  // some MP3s I seem to get double                  decompressBuffer = new byte[bytesPerDecodedFrame * 2];              }              catch (Exception)              {                  if (ownInputStream) inputStream.Dispose();                  throw;              }
Magic Number,NAudio.Wave,Mp3FileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Mp3FileReader.cs,Mp3FileReader,The following statement contains a magic number: try              {                  mp3Stream = inputStream;                  Id3v2Tag = Id3v2Tag.ReadTag(mp3Stream);                    dataStartPosition = mp3Stream.Position;                  var firstFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (firstFrame == null)                      throw new InvalidDataException("Invalid MP3 file - no MP3 Frames Detected");                  double bitRate = firstFrame.BitRate;                  xingHeader = XingHeader.LoadXingHeader(firstFrame);                  // If the header exists' we can skip over it when decoding the rest of the file                  if (xingHeader != null) dataStartPosition = mp3Stream.Position;                    // workaround for a longstanding issue with some files failing to load                  // because they report a spurious sample rate change                  var secondFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (secondFrame != null &&                      (secondFrame.SampleRate != firstFrame.SampleRate ||                       secondFrame.ChannelMode != firstFrame.ChannelMode))                  {                      // assume that the first frame was some kind of VBR/LAME header that we failed to recognise properly                      dataStartPosition = secondFrame.FileOffset;                      // forget about the first frame' the second one is the first one we really care about                      firstFrame = secondFrame;                  }                    mp3DataLength = mp3Stream.Length - dataStartPosition;                    // try for an ID3v1 tag as well                  mp3Stream.Position = mp3Stream.Length - 128;                  byte[] tag = new byte[128];                  mp3Stream.Read(tag' 0' 128);                  if (tag[0] == 'T' && tag[1] == 'A' && tag[2] == 'G')                  {                      Id3v1Tag = tag;                      mp3DataLength -= 128;                  }                    mp3Stream.Position = dataStartPosition;                    // create a temporary MP3 format before we know the real bitrate                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                    CreateTableOfContents();                  tocIndex = 0;                    // [Bit rate in Kilobits/sec] = [Length in kbits] / [time in seconds]                   //                            = [Length in bits ] / [time in milliseconds]                    // Note: in audio' 1 kilobit = 1000 bits.                  // Calculated as a double to minimize rounding errors                  bitRate = (mp3DataLength*8.0/TotalSeconds());                    mp3Stream.Position = dataStartPosition;                    // now we know the real bitrate we can create an accurate MP3 WaveFormat                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                  decompressor = frameDecompressorBuilder(Mp3WaveFormat);                  waveFormat = decompressor.OutputFormat;                  bytesPerSample = (decompressor.OutputFormat.BitsPerSample)/8*decompressor.OutputFormat.Channels;                  // no MP3 frames have more than 1152 samples in them                  bytesPerDecodedFrame = 1152 * bytesPerSample;                  // some MP3s I seem to get double                  decompressBuffer = new byte[bytesPerDecodedFrame * 2];              }              catch (Exception)              {                  if (ownInputStream) inputStream.Dispose();                  throw;              }
Magic Number,NAudio.Wave,Mp3FileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Mp3FileReader.cs,Mp3FileReader,The following statement contains a magic number: try              {                  mp3Stream = inputStream;                  Id3v2Tag = Id3v2Tag.ReadTag(mp3Stream);                    dataStartPosition = mp3Stream.Position;                  var firstFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (firstFrame == null)                      throw new InvalidDataException("Invalid MP3 file - no MP3 Frames Detected");                  double bitRate = firstFrame.BitRate;                  xingHeader = XingHeader.LoadXingHeader(firstFrame);                  // If the header exists' we can skip over it when decoding the rest of the file                  if (xingHeader != null) dataStartPosition = mp3Stream.Position;                    // workaround for a longstanding issue with some files failing to load                  // because they report a spurious sample rate change                  var secondFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (secondFrame != null &&                      (secondFrame.SampleRate != firstFrame.SampleRate ||                       secondFrame.ChannelMode != firstFrame.ChannelMode))                  {                      // assume that the first frame was some kind of VBR/LAME header that we failed to recognise properly                      dataStartPosition = secondFrame.FileOffset;                      // forget about the first frame' the second one is the first one we really care about                      firstFrame = secondFrame;                  }                    mp3DataLength = mp3Stream.Length - dataStartPosition;                    // try for an ID3v1 tag as well                  mp3Stream.Position = mp3Stream.Length - 128;                  byte[] tag = new byte[128];                  mp3Stream.Read(tag' 0' 128);                  if (tag[0] == 'T' && tag[1] == 'A' && tag[2] == 'G')                  {                      Id3v1Tag = tag;                      mp3DataLength -= 128;                  }                    mp3Stream.Position = dataStartPosition;                    // create a temporary MP3 format before we know the real bitrate                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                    CreateTableOfContents();                  tocIndex = 0;                    // [Bit rate in Kilobits/sec] = [Length in kbits] / [time in seconds]                   //                            = [Length in bits ] / [time in milliseconds]                    // Note: in audio' 1 kilobit = 1000 bits.                  // Calculated as a double to minimize rounding errors                  bitRate = (mp3DataLength*8.0/TotalSeconds());                    mp3Stream.Position = dataStartPosition;                    // now we know the real bitrate we can create an accurate MP3 WaveFormat                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                  decompressor = frameDecompressorBuilder(Mp3WaveFormat);                  waveFormat = decompressor.OutputFormat;                  bytesPerSample = (decompressor.OutputFormat.BitsPerSample)/8*decompressor.OutputFormat.Channels;                  // no MP3 frames have more than 1152 samples in them                  bytesPerDecodedFrame = 1152 * bytesPerSample;                  // some MP3s I seem to get double                  decompressBuffer = new byte[bytesPerDecodedFrame * 2];              }              catch (Exception)              {                  if (ownInputStream) inputStream.Dispose();                  throw;              }
Magic Number,NAudio.Wave,Mp3FileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Mp3FileReader.cs,Mp3FileReader,The following statement contains a magic number: try              {                  mp3Stream = inputStream;                  Id3v2Tag = Id3v2Tag.ReadTag(mp3Stream);                    dataStartPosition = mp3Stream.Position;                  var firstFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (firstFrame == null)                      throw new InvalidDataException("Invalid MP3 file - no MP3 Frames Detected");                  double bitRate = firstFrame.BitRate;                  xingHeader = XingHeader.LoadXingHeader(firstFrame);                  // If the header exists' we can skip over it when decoding the rest of the file                  if (xingHeader != null) dataStartPosition = mp3Stream.Position;                    // workaround for a longstanding issue with some files failing to load                  // because they report a spurious sample rate change                  var secondFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (secondFrame != null &&                      (secondFrame.SampleRate != firstFrame.SampleRate ||                       secondFrame.ChannelMode != firstFrame.ChannelMode))                  {                      // assume that the first frame was some kind of VBR/LAME header that we failed to recognise properly                      dataStartPosition = secondFrame.FileOffset;                      // forget about the first frame' the second one is the first one we really care about                      firstFrame = secondFrame;                  }                    mp3DataLength = mp3Stream.Length - dataStartPosition;                    // try for an ID3v1 tag as well                  mp3Stream.Position = mp3Stream.Length - 128;                  byte[] tag = new byte[128];                  mp3Stream.Read(tag' 0' 128);                  if (tag[0] == 'T' && tag[1] == 'A' && tag[2] == 'G')                  {                      Id3v1Tag = tag;                      mp3DataLength -= 128;                  }                    mp3Stream.Position = dataStartPosition;                    // create a temporary MP3 format before we know the real bitrate                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                    CreateTableOfContents();                  tocIndex = 0;                    // [Bit rate in Kilobits/sec] = [Length in kbits] / [time in seconds]                   //                            = [Length in bits ] / [time in milliseconds]                    // Note: in audio' 1 kilobit = 1000 bits.                  // Calculated as a double to minimize rounding errors                  bitRate = (mp3DataLength*8.0/TotalSeconds());                    mp3Stream.Position = dataStartPosition;                    // now we know the real bitrate we can create an accurate MP3 WaveFormat                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                  decompressor = frameDecompressorBuilder(Mp3WaveFormat);                  waveFormat = decompressor.OutputFormat;                  bytesPerSample = (decompressor.OutputFormat.BitsPerSample)/8*decompressor.OutputFormat.Channels;                  // no MP3 frames have more than 1152 samples in them                  bytesPerDecodedFrame = 1152 * bytesPerSample;                  // some MP3s I seem to get double                  decompressBuffer = new byte[bytesPerDecodedFrame * 2];              }              catch (Exception)              {                  if (ownInputStream) inputStream.Dispose();                  throw;              }
Magic Number,NAudio.Wave,Mp3FileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Mp3FileReader.cs,Mp3FileReader,The following statement contains a magic number: try              {                  mp3Stream = inputStream;                  Id3v2Tag = Id3v2Tag.ReadTag(mp3Stream);                    dataStartPosition = mp3Stream.Position;                  var firstFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (firstFrame == null)                      throw new InvalidDataException("Invalid MP3 file - no MP3 Frames Detected");                  double bitRate = firstFrame.BitRate;                  xingHeader = XingHeader.LoadXingHeader(firstFrame);                  // If the header exists' we can skip over it when decoding the rest of the file                  if (xingHeader != null) dataStartPosition = mp3Stream.Position;                    // workaround for a longstanding issue with some files failing to load                  // because they report a spurious sample rate change                  var secondFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (secondFrame != null &&                      (secondFrame.SampleRate != firstFrame.SampleRate ||                       secondFrame.ChannelMode != firstFrame.ChannelMode))                  {                      // assume that the first frame was some kind of VBR/LAME header that we failed to recognise properly                      dataStartPosition = secondFrame.FileOffset;                      // forget about the first frame' the second one is the first one we really care about                      firstFrame = secondFrame;                  }                    mp3DataLength = mp3Stream.Length - dataStartPosition;                    // try for an ID3v1 tag as well                  mp3Stream.Position = mp3Stream.Length - 128;                  byte[] tag = new byte[128];                  mp3Stream.Read(tag' 0' 128);                  if (tag[0] == 'T' && tag[1] == 'A' && tag[2] == 'G')                  {                      Id3v1Tag = tag;                      mp3DataLength -= 128;                  }                    mp3Stream.Position = dataStartPosition;                    // create a temporary MP3 format before we know the real bitrate                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                    CreateTableOfContents();                  tocIndex = 0;                    // [Bit rate in Kilobits/sec] = [Length in kbits] / [time in seconds]                   //                            = [Length in bits ] / [time in milliseconds]                    // Note: in audio' 1 kilobit = 1000 bits.                  // Calculated as a double to minimize rounding errors                  bitRate = (mp3DataLength*8.0/TotalSeconds());                    mp3Stream.Position = dataStartPosition;                    // now we know the real bitrate we can create an accurate MP3 WaveFormat                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                  decompressor = frameDecompressorBuilder(Mp3WaveFormat);                  waveFormat = decompressor.OutputFormat;                  bytesPerSample = (decompressor.OutputFormat.BitsPerSample)/8*decompressor.OutputFormat.Channels;                  // no MP3 frames have more than 1152 samples in them                  bytesPerDecodedFrame = 1152 * bytesPerSample;                  // some MP3s I seem to get double                  decompressBuffer = new byte[bytesPerDecodedFrame * 2];              }              catch (Exception)              {                  if (ownInputStream) inputStream.Dispose();                  throw;              }
Magic Number,NAudio.Wave,Mp3FileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Mp3FileReader.cs,Mp3FileReader,The following statement contains a magic number: try              {                  mp3Stream = inputStream;                  Id3v2Tag = Id3v2Tag.ReadTag(mp3Stream);                    dataStartPosition = mp3Stream.Position;                  var firstFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (firstFrame == null)                      throw new InvalidDataException("Invalid MP3 file - no MP3 Frames Detected");                  double bitRate = firstFrame.BitRate;                  xingHeader = XingHeader.LoadXingHeader(firstFrame);                  // If the header exists' we can skip over it when decoding the rest of the file                  if (xingHeader != null) dataStartPosition = mp3Stream.Position;                    // workaround for a longstanding issue with some files failing to load                  // because they report a spurious sample rate change                  var secondFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (secondFrame != null &&                      (secondFrame.SampleRate != firstFrame.SampleRate ||                       secondFrame.ChannelMode != firstFrame.ChannelMode))                  {                      // assume that the first frame was some kind of VBR/LAME header that we failed to recognise properly                      dataStartPosition = secondFrame.FileOffset;                      // forget about the first frame' the second one is the first one we really care about                      firstFrame = secondFrame;                  }                    mp3DataLength = mp3Stream.Length - dataStartPosition;                    // try for an ID3v1 tag as well                  mp3Stream.Position = mp3Stream.Length - 128;                  byte[] tag = new byte[128];                  mp3Stream.Read(tag' 0' 128);                  if (tag[0] == 'T' && tag[1] == 'A' && tag[2] == 'G')                  {                      Id3v1Tag = tag;                      mp3DataLength -= 128;                  }                    mp3Stream.Position = dataStartPosition;                    // create a temporary MP3 format before we know the real bitrate                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                    CreateTableOfContents();                  tocIndex = 0;                    // [Bit rate in Kilobits/sec] = [Length in kbits] / [time in seconds]                   //                            = [Length in bits ] / [time in milliseconds]                    // Note: in audio' 1 kilobit = 1000 bits.                  // Calculated as a double to minimize rounding errors                  bitRate = (mp3DataLength*8.0/TotalSeconds());                    mp3Stream.Position = dataStartPosition;                    // now we know the real bitrate we can create an accurate MP3 WaveFormat                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                  decompressor = frameDecompressorBuilder(Mp3WaveFormat);                  waveFormat = decompressor.OutputFormat;                  bytesPerSample = (decompressor.OutputFormat.BitsPerSample)/8*decompressor.OutputFormat.Channels;                  // no MP3 frames have more than 1152 samples in them                  bytesPerDecodedFrame = 1152 * bytesPerSample;                  // some MP3s I seem to get double                  decompressBuffer = new byte[bytesPerDecodedFrame * 2];              }              catch (Exception)              {                  if (ownInputStream) inputStream.Dispose();                  throw;              }
Magic Number,NAudio.Wave,Mp3FileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Mp3FileReader.cs,Mp3FileReader,The following statement contains a magic number: try              {                  mp3Stream = inputStream;                  Id3v2Tag = Id3v2Tag.ReadTag(mp3Stream);                    dataStartPosition = mp3Stream.Position;                  var firstFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (firstFrame == null)                      throw new InvalidDataException("Invalid MP3 file - no MP3 Frames Detected");                  double bitRate = firstFrame.BitRate;                  xingHeader = XingHeader.LoadXingHeader(firstFrame);                  // If the header exists' we can skip over it when decoding the rest of the file                  if (xingHeader != null) dataStartPosition = mp3Stream.Position;                    // workaround for a longstanding issue with some files failing to load                  // because they report a spurious sample rate change                  var secondFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (secondFrame != null &&                      (secondFrame.SampleRate != firstFrame.SampleRate ||                       secondFrame.ChannelMode != firstFrame.ChannelMode))                  {                      // assume that the first frame was some kind of VBR/LAME header that we failed to recognise properly                      dataStartPosition = secondFrame.FileOffset;                      // forget about the first frame' the second one is the first one we really care about                      firstFrame = secondFrame;                  }                    mp3DataLength = mp3Stream.Length - dataStartPosition;                    // try for an ID3v1 tag as well                  mp3Stream.Position = mp3Stream.Length - 128;                  byte[] tag = new byte[128];                  mp3Stream.Read(tag' 0' 128);                  if (tag[0] == 'T' && tag[1] == 'A' && tag[2] == 'G')                  {                      Id3v1Tag = tag;                      mp3DataLength -= 128;                  }                    mp3Stream.Position = dataStartPosition;                    // create a temporary MP3 format before we know the real bitrate                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                    CreateTableOfContents();                  tocIndex = 0;                    // [Bit rate in Kilobits/sec] = [Length in kbits] / [time in seconds]                   //                            = [Length in bits ] / [time in milliseconds]                    // Note: in audio' 1 kilobit = 1000 bits.                  // Calculated as a double to minimize rounding errors                  bitRate = (mp3DataLength*8.0/TotalSeconds());                    mp3Stream.Position = dataStartPosition;                    // now we know the real bitrate we can create an accurate MP3 WaveFormat                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                  decompressor = frameDecompressorBuilder(Mp3WaveFormat);                  waveFormat = decompressor.OutputFormat;                  bytesPerSample = (decompressor.OutputFormat.BitsPerSample)/8*decompressor.OutputFormat.Channels;                  // no MP3 frames have more than 1152 samples in them                  bytesPerDecodedFrame = 1152 * bytesPerSample;                  // some MP3s I seem to get double                  decompressBuffer = new byte[bytesPerDecodedFrame * 2];              }              catch (Exception)              {                  if (ownInputStream) inputStream.Dispose();                  throw;              }
Magic Number,NAudio.Wave,Mp3FileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Mp3FileReader.cs,Mp3FileReader,The following statement contains a magic number: try              {                  mp3Stream = inputStream;                  Id3v2Tag = Id3v2Tag.ReadTag(mp3Stream);                    dataStartPosition = mp3Stream.Position;                  var firstFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (firstFrame == null)                      throw new InvalidDataException("Invalid MP3 file - no MP3 Frames Detected");                  double bitRate = firstFrame.BitRate;                  xingHeader = XingHeader.LoadXingHeader(firstFrame);                  // If the header exists' we can skip over it when decoding the rest of the file                  if (xingHeader != null) dataStartPosition = mp3Stream.Position;                    // workaround for a longstanding issue with some files failing to load                  // because they report a spurious sample rate change                  var secondFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (secondFrame != null &&                      (secondFrame.SampleRate != firstFrame.SampleRate ||                       secondFrame.ChannelMode != firstFrame.ChannelMode))                  {                      // assume that the first frame was some kind of VBR/LAME header that we failed to recognise properly                      dataStartPosition = secondFrame.FileOffset;                      // forget about the first frame' the second one is the first one we really care about                      firstFrame = secondFrame;                  }                    mp3DataLength = mp3Stream.Length - dataStartPosition;                    // try for an ID3v1 tag as well                  mp3Stream.Position = mp3Stream.Length - 128;                  byte[] tag = new byte[128];                  mp3Stream.Read(tag' 0' 128);                  if (tag[0] == 'T' && tag[1] == 'A' && tag[2] == 'G')                  {                      Id3v1Tag = tag;                      mp3DataLength -= 128;                  }                    mp3Stream.Position = dataStartPosition;                    // create a temporary MP3 format before we know the real bitrate                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                    CreateTableOfContents();                  tocIndex = 0;                    // [Bit rate in Kilobits/sec] = [Length in kbits] / [time in seconds]                   //                            = [Length in bits ] / [time in milliseconds]                    // Note: in audio' 1 kilobit = 1000 bits.                  // Calculated as a double to minimize rounding errors                  bitRate = (mp3DataLength*8.0/TotalSeconds());                    mp3Stream.Position = dataStartPosition;                    // now we know the real bitrate we can create an accurate MP3 WaveFormat                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                  decompressor = frameDecompressorBuilder(Mp3WaveFormat);                  waveFormat = decompressor.OutputFormat;                  bytesPerSample = (decompressor.OutputFormat.BitsPerSample)/8*decompressor.OutputFormat.Channels;                  // no MP3 frames have more than 1152 samples in them                  bytesPerDecodedFrame = 1152 * bytesPerSample;                  // some MP3s I seem to get double                  decompressBuffer = new byte[bytesPerDecodedFrame * 2];              }              catch (Exception)              {                  if (ownInputStream) inputStream.Dispose();                  throw;              }
Magic Number,NAudio.Wave,Mp3FileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Mp3FileReader.cs,Mp3FileReader,The following statement contains a magic number: try              {                  mp3Stream = inputStream;                  Id3v2Tag = Id3v2Tag.ReadTag(mp3Stream);                    dataStartPosition = mp3Stream.Position;                  var firstFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (firstFrame == null)                      throw new InvalidDataException("Invalid MP3 file - no MP3 Frames Detected");                  double bitRate = firstFrame.BitRate;                  xingHeader = XingHeader.LoadXingHeader(firstFrame);                  // If the header exists' we can skip over it when decoding the rest of the file                  if (xingHeader != null) dataStartPosition = mp3Stream.Position;                    // workaround for a longstanding issue with some files failing to load                  // because they report a spurious sample rate change                  var secondFrame = Mp3Frame.LoadFromStream(mp3Stream);                  if (secondFrame != null &&                      (secondFrame.SampleRate != firstFrame.SampleRate ||                       secondFrame.ChannelMode != firstFrame.ChannelMode))                  {                      // assume that the first frame was some kind of VBR/LAME header that we failed to recognise properly                      dataStartPosition = secondFrame.FileOffset;                      // forget about the first frame' the second one is the first one we really care about                      firstFrame = secondFrame;                  }                    mp3DataLength = mp3Stream.Length - dataStartPosition;                    // try for an ID3v1 tag as well                  mp3Stream.Position = mp3Stream.Length - 128;                  byte[] tag = new byte[128];                  mp3Stream.Read(tag' 0' 128);                  if (tag[0] == 'T' && tag[1] == 'A' && tag[2] == 'G')                  {                      Id3v1Tag = tag;                      mp3DataLength -= 128;                  }                    mp3Stream.Position = dataStartPosition;                    // create a temporary MP3 format before we know the real bitrate                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                    CreateTableOfContents();                  tocIndex = 0;                    // [Bit rate in Kilobits/sec] = [Length in kbits] / [time in seconds]                   //                            = [Length in bits ] / [time in milliseconds]                    // Note: in audio' 1 kilobit = 1000 bits.                  // Calculated as a double to minimize rounding errors                  bitRate = (mp3DataLength*8.0/TotalSeconds());                    mp3Stream.Position = dataStartPosition;                    // now we know the real bitrate we can create an accurate MP3 WaveFormat                  Mp3WaveFormat = new Mp3WaveFormat(firstFrame.SampleRate'                      firstFrame.ChannelMode == ChannelMode.Mono ? 1 : 2' firstFrame.FrameLength' (int) bitRate);                  decompressor = frameDecompressorBuilder(Mp3WaveFormat);                  waveFormat = decompressor.OutputFormat;                  bytesPerSample = (decompressor.OutputFormat.BitsPerSample)/8*decompressor.OutputFormat.Channels;                  // no MP3 frames have more than 1152 samples in them                  bytesPerDecodedFrame = 1152 * bytesPerSample;                  // some MP3s I seem to get double                  decompressBuffer = new byte[bytesPerDecodedFrame * 2];              }              catch (Exception)              {                  if (ownInputStream) inputStream.Dispose();                  throw;              }
Magic Number,NAudio.Wave,Mp3FileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Mp3FileReader.cs,CreateTableOfContents,The following statement contains a magic number: try              {                  // Just a guess at how many entries we'll need so the internal array need not resize very much                  // 400 bytes per frame is probably a good enough approximation.                  tableOfContents = new List<Mp3Index>((int)(mp3DataLength / 400));                  Mp3Frame frame;                  do                  {                      var index = new Mp3Index();                      index.FilePosition = mp3Stream.Position;                      index.SamplePosition = totalSamples;                      frame = ReadNextFrame(false);                      if (frame != null)                      {                          ValidateFrameFormat(frame);                            totalSamples += frame.SampleCount;                          index.SampleCount = frame.SampleCount;                          index.ByteCount = (int)(mp3Stream.Position - index.FilePosition);                          tableOfContents.Add(index);                      }                  } while (frame != null);              }              catch (EndOfStreamException)              {                  // not necessarily a problem              }
Magic Number,NAudio.Wave,Mp3FileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Mp3FileReader.cs,ValidateFrameFormat,The following statement contains a magic number: int channels = frame.ChannelMode == ChannelMode.Mono ? 1 : 2;
Magic Number,NAudio.Wave,Mp3FileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Mp3FileReader.cs,Read,The following statement contains a magic number: lock (repositionLock)              {                  if (decompressLeftovers != 0)                  {                      int toCopy = Math.Min(decompressLeftovers' numBytes);                      Array.Copy(decompressBuffer' decompressBufferOffset' sampleBuffer' offset' toCopy);                      decompressLeftovers -= toCopy;                      if (decompressLeftovers == 0)                      {                          decompressBufferOffset = 0;                      }                      else                      {                          decompressBufferOffset += toCopy;                      }                      bytesRead += toCopy;                      offset += toCopy;                  }                    int targetTocIndex = tocIndex; // the frame index that contains the requested data                    if (repositionedFlag)                  {                      decompressor.Reset();                        // Seek back a few frames of the stream to get the reset decoder decode a few                      // warm-up frames before reading the requested data. Without the warm-up phase'                      // the first half of the frame after the reset is attenuated and does not resemble                      // the data as it would be when reading sequentially from the beginning' because                       // the decoder is missing the required overlap from the previous frame.                      tocIndex = Math.Max(0' tocIndex - 3); // no warm-up at the beginning of the stream                      mp3Stream.Position = tableOfContents[tocIndex].FilePosition;                        repositionedFlag = false;                  }                    while (bytesRead < numBytes)                  {                      Mp3Frame frame = ReadNextFrame(true); // internal read - should not advance position                      if (frame != null)                      {                          int decompressed = decompressor.DecompressFrame(frame' decompressBuffer' 0);                            if (tocIndex <= targetTocIndex || decompressed == 0)                          {                              // The first frame after a reset usually does not immediately yield decoded samples.                              // Because the next instructions will fail if a buffer offset is set and the frame                               // decoding didn't return data' we skip the part.                              // We skip the following instructions also after decoding a warm-up frame.                              continue;                          }                          // Two special cases can happen here:                          // 1. We are interested in the first frame of the stream' but need to read the second frame too                          //    for the decoder to return decoded data                          // 2. We are interested in the second frame of the stream' but because reading the first frame                          //    as warm-up didn't yield any data (because the decoder needs two frames to return data)' we                          //    get data from the first and second frame.                           //    This case needs special handling' and we have to purge the data of the first frame.                          else if (tocIndex == targetTocIndex + 1 && decompressed == bytesPerDecodedFrame * 2)                          {                              // Purge the first frame's data                              Array.Copy(decompressBuffer' bytesPerDecodedFrame' decompressBuffer' 0' bytesPerDecodedFrame);                              decompressed = bytesPerDecodedFrame;                          }                            int toCopy = Math.Min(decompressed - decompressBufferOffset' numBytes - bytesRead);                          Array.Copy(decompressBuffer' decompressBufferOffset' sampleBuffer' offset' toCopy);                          if ((toCopy + decompressBufferOffset) < decompressed)                          {                              decompressBufferOffset = toCopy + decompressBufferOffset;                              decompressLeftovers = decompressed - decompressBufferOffset;                          }                          else                          {                              // no lefovers                              decompressBufferOffset = 0;                              decompressLeftovers = 0;                          }                          offset += toCopy;                          bytesRead += toCopy;                      }                      else                      {                          break;                      }                  }              }
Magic Number,NAudio.Wave,Mp3FileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Mp3FileReader.cs,Read,The following statement contains a magic number: lock (repositionLock)              {                  if (decompressLeftovers != 0)                  {                      int toCopy = Math.Min(decompressLeftovers' numBytes);                      Array.Copy(decompressBuffer' decompressBufferOffset' sampleBuffer' offset' toCopy);                      decompressLeftovers -= toCopy;                      if (decompressLeftovers == 0)                      {                          decompressBufferOffset = 0;                      }                      else                      {                          decompressBufferOffset += toCopy;                      }                      bytesRead += toCopy;                      offset += toCopy;                  }                    int targetTocIndex = tocIndex; // the frame index that contains the requested data                    if (repositionedFlag)                  {                      decompressor.Reset();                        // Seek back a few frames of the stream to get the reset decoder decode a few                      // warm-up frames before reading the requested data. Without the warm-up phase'                      // the first half of the frame after the reset is attenuated and does not resemble                      // the data as it would be when reading sequentially from the beginning' because                       // the decoder is missing the required overlap from the previous frame.                      tocIndex = Math.Max(0' tocIndex - 3); // no warm-up at the beginning of the stream                      mp3Stream.Position = tableOfContents[tocIndex].FilePosition;                        repositionedFlag = false;                  }                    while (bytesRead < numBytes)                  {                      Mp3Frame frame = ReadNextFrame(true); // internal read - should not advance position                      if (frame != null)                      {                          int decompressed = decompressor.DecompressFrame(frame' decompressBuffer' 0);                            if (tocIndex <= targetTocIndex || decompressed == 0)                          {                              // The first frame after a reset usually does not immediately yield decoded samples.                              // Because the next instructions will fail if a buffer offset is set and the frame                               // decoding didn't return data' we skip the part.                              // We skip the following instructions also after decoding a warm-up frame.                              continue;                          }                          // Two special cases can happen here:                          // 1. We are interested in the first frame of the stream' but need to read the second frame too                          //    for the decoder to return decoded data                          // 2. We are interested in the second frame of the stream' but because reading the first frame                          //    as warm-up didn't yield any data (because the decoder needs two frames to return data)' we                          //    get data from the first and second frame.                           //    This case needs special handling' and we have to purge the data of the first frame.                          else if (tocIndex == targetTocIndex + 1 && decompressed == bytesPerDecodedFrame * 2)                          {                              // Purge the first frame's data                              Array.Copy(decompressBuffer' bytesPerDecodedFrame' decompressBuffer' 0' bytesPerDecodedFrame);                              decompressed = bytesPerDecodedFrame;                          }                            int toCopy = Math.Min(decompressed - decompressBufferOffset' numBytes - bytesRead);                          Array.Copy(decompressBuffer' decompressBufferOffset' sampleBuffer' offset' toCopy);                          if ((toCopy + decompressBufferOffset) < decompressed)                          {                              decompressBufferOffset = toCopy + decompressBufferOffset;                              decompressLeftovers = decompressed - decompressBufferOffset;                          }                          else                          {                              // no lefovers                              decompressBufferOffset = 0;                              decompressLeftovers = 0;                          }                          offset += toCopy;                          bytesRead += toCopy;                      }                      else                      {                          break;                      }                  }              }
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,SimpleCompressorStream,The following statement contains a magic number: bytesPerSample = sourceStream.WaveFormat.BitsPerSample / 8;
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,SimpleCompressorStream,The following statement contains a magic number: simpleCompressor = new SimpleCompressor(5.0' 10.0' sourceStream.WaveFormat.SampleRate);
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,SimpleCompressorStream,The following statement contains a magic number: simpleCompressor = new SimpleCompressor(5.0' 10.0' sourceStream.WaveFormat.SampleRate);
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,SimpleCompressorStream,The following statement contains a magic number: simpleCompressor.Threshold = 16;
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,SimpleCompressorStream,The following statement contains a magic number: simpleCompressor.Ratio = 6;
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,SimpleCompressorStream,The following statement contains a magic number: simpleCompressor.MakeUpGain = 16;
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,ReadSamples,The following statement contains a magic number: if (bytesPerSample == 4)              {                  left = BitConverter.ToSingle(buffer' start);                  if (channels > 1)                  {                      right = BitConverter.ToSingle(buffer' start + bytesPerSample);                  }                  else                  {                      right = left;                  }              }              else if (bytesPerSample == 2)              {                  left = BitConverter.ToInt16(buffer' start) / 32768.0;                  if (channels > 1)                  {                      right = BitConverter.ToInt16(buffer' start + bytesPerSample) / 32768.0;                  }                  else                  {                      right = left;                  }              }              else              {                  throw new InvalidOperationException(String.Format("Unsupported bytes per sample: {0}"' bytesPerSample));              }
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,ReadSamples,The following statement contains a magic number: if (bytesPerSample == 4)              {                  left = BitConverter.ToSingle(buffer' start);                  if (channels > 1)                  {                      right = BitConverter.ToSingle(buffer' start + bytesPerSample);                  }                  else                  {                      right = left;                  }              }              else if (bytesPerSample == 2)              {                  left = BitConverter.ToInt16(buffer' start) / 32768.0;                  if (channels > 1)                  {                      right = BitConverter.ToInt16(buffer' start + bytesPerSample) / 32768.0;                  }                  else                  {                      right = left;                  }              }              else              {                  throw new InvalidOperationException(String.Format("Unsupported bytes per sample: {0}"' bytesPerSample));              }
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,ReadSamples,The following statement contains a magic number: if (bytesPerSample == 4)              {                  left = BitConverter.ToSingle(buffer' start);                  if (channels > 1)                  {                      right = BitConverter.ToSingle(buffer' start + bytesPerSample);                  }                  else                  {                      right = left;                  }              }              else if (bytesPerSample == 2)              {                  left = BitConverter.ToInt16(buffer' start) / 32768.0;                  if (channels > 1)                  {                      right = BitConverter.ToInt16(buffer' start + bytesPerSample) / 32768.0;                  }                  else                  {                      right = left;                  }              }              else              {                  throw new InvalidOperationException(String.Format("Unsupported bytes per sample: {0}"' bytesPerSample));              }
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,ReadSamples,The following statement contains a magic number: if (bytesPerSample == 4)              {                  left = BitConverter.ToSingle(buffer' start);                  if (channels > 1)                  {                      right = BitConverter.ToSingle(buffer' start + bytesPerSample);                  }                  else                  {                      right = left;                  }              }              else if (bytesPerSample == 2)              {                  left = BitConverter.ToInt16(buffer' start) / 32768.0;                  if (channels > 1)                  {                      right = BitConverter.ToInt16(buffer' start + bytesPerSample) / 32768.0;                  }                  else                  {                      right = left;                  }              }              else              {                  throw new InvalidOperationException(String.Format("Unsupported bytes per sample: {0}"' bytesPerSample));              }
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,WriteSamples,The following statement contains a magic number: if (bytesPerSample == 4)              {                  Array.Copy(BitConverter.GetBytes((float)left)' 0' buffer' start' bytesPerSample);                  if (channels > 1)                  {                      Array.Copy(BitConverter.GetBytes((float)right)' 0' buffer' start + bytesPerSample' bytesPerSample);                  }              }              else if (bytesPerSample == 2)              {                  Array.Copy(BitConverter.GetBytes((short)(left * 32768.0))' 0' buffer' start' bytesPerSample);                  if (channels > 1)                  {                      Array.Copy(BitConverter.GetBytes((short)(right * 32768.0))' 0' buffer' start + bytesPerSample' bytesPerSample);                  }              }
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,WriteSamples,The following statement contains a magic number: if (bytesPerSample == 4)              {                  Array.Copy(BitConverter.GetBytes((float)left)' 0' buffer' start' bytesPerSample);                  if (channels > 1)                  {                      Array.Copy(BitConverter.GetBytes((float)right)' 0' buffer' start + bytesPerSample' bytesPerSample);                  }              }              else if (bytesPerSample == 2)              {                  Array.Copy(BitConverter.GetBytes((short)(left * 32768.0))' 0' buffer' start' bytesPerSample);                  if (channels > 1)                  {                      Array.Copy(BitConverter.GetBytes((short)(right * 32768.0))' 0' buffer' start + bytesPerSample' bytesPerSample);                  }              }
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,WriteSamples,The following statement contains a magic number: if (bytesPerSample == 4)              {                  Array.Copy(BitConverter.GetBytes((float)left)' 0' buffer' start' bytesPerSample);                  if (channels > 1)                  {                      Array.Copy(BitConverter.GetBytes((float)right)' 0' buffer' start + bytesPerSample' bytesPerSample);                  }              }              else if (bytesPerSample == 2)              {                  Array.Copy(BitConverter.GetBytes((short)(left * 32768.0))' 0' buffer' start' bytesPerSample);                  if (channels > 1)                  {                      Array.Copy(BitConverter.GetBytes((short)(right * 32768.0))' 0' buffer' start + bytesPerSample' bytesPerSample);                  }              }
Magic Number,NAudio.Wave,SimpleCompressorStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\SimpleCompressorStream.cs,WriteSamples,The following statement contains a magic number: if (bytesPerSample == 4)              {                  Array.Copy(BitConverter.GetBytes((float)left)' 0' buffer' start' bytesPerSample);                  if (channels > 1)                  {                      Array.Copy(BitConverter.GetBytes((float)right)' 0' buffer' start + bytesPerSample' bytesPerSample);                  }              }              else if (bytesPerSample == 2)              {                  Array.Copy(BitConverter.GetBytes((short)(left * 32768.0))' 0' buffer' start' bytesPerSample);                  if (channels > 1)                  {                      Array.Copy(BitConverter.GetBytes((short)(right * 32768.0))' 0' buffer' start + bytesPerSample' bytesPerSample);                  }              }
Magic Number,NAudio.Wave,StreamMediaFoundationReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\StreamMediaFoundationReader.cs,CreateReader,The following statement contains a magic number: ppSourceReader.SetStreamSelection(-2' false);
Magic Number,NAudio.Wave,StreamMediaFoundationReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\StreamMediaFoundationReader.cs,CreateReader,The following statement contains a magic number: ppSourceReader.SetStreamSelection(-3' true);
Magic Number,NAudio.Wave,StreamMediaFoundationReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\StreamMediaFoundationReader.cs,CreateReader,The following statement contains a magic number: ppSourceReader.SetCurrentMediaType(-3' IntPtr.Zero' new MediaType              {                  MajorType = MediaTypes.MFMediaType_Audio'                  SubType = settings.RequestFloatOutput ? AudioSubtypes.MFAudioFormat_Float : AudioSubtypes.MFAudioFormat_PCM              }.MediaFoundationObject);
Magic Number,NAudio.Wave,Wave32To16Stream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Wave32To16Stream.cs,Wave32To16Stream,The following statement contains a magic number: if (sourceStream.WaveFormat.BitsPerSample != 32)                  throw new ArgumentException("Only 32 bit Floating point supported");
Magic Number,NAudio.Wave,Wave32To16Stream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Wave32To16Stream.cs,Wave32To16Stream,The following statement contains a magic number: waveFormat = new WaveFormat(sourceStream.WaveFormat.SampleRate' 16' sourceStream.WaveFormat.Channels);
Magic Number,NAudio.Wave,Wave32To16Stream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Wave32To16Stream.cs,Wave32To16Stream,The following statement contains a magic number: length = sourceStream.Length / 2;
Magic Number,NAudio.Wave,Wave32To16Stream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Wave32To16Stream.cs,Wave32To16Stream,The following statement contains a magic number: position = sourceStream.Position / 2;
Magic Number,NAudio.Wave,Wave32To16Stream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Wave32To16Stream.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  int count = numBytes*2;                  sourceBuffer = BufferHelpers.Ensure(sourceBuffer' count);                  int bytesRead = sourceStream.Read(sourceBuffer' 0' count);                  Convert32To16(destBuffer' offset' sourceBuffer' bytesRead);                  position += (bytesRead/2);                  return bytesRead/2;              }
Magic Number,NAudio.Wave,Wave32To16Stream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Wave32To16Stream.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  int count = numBytes*2;                  sourceBuffer = BufferHelpers.Ensure(sourceBuffer' count);                  int bytesRead = sourceStream.Read(sourceBuffer' 0' count);                  Convert32To16(destBuffer' offset' sourceBuffer' bytesRead);                  position += (bytesRead/2);                  return bytesRead/2;              }
Magic Number,NAudio.Wave,Wave32To16Stream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Wave32To16Stream.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  int count = numBytes*2;                  sourceBuffer = BufferHelpers.Ensure(sourceBuffer' count);                  int bytesRead = sourceStream.Read(sourceBuffer' 0' count);                  Convert32To16(destBuffer' offset' sourceBuffer' bytesRead);                  position += (bytesRead/2);                  return bytesRead/2;              }
Magic Number,NAudio.Wave,Wave32To16Stream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Wave32To16Stream.cs,Convert32To16,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &source[0])              {                  short* psDestBuffer = (short*)pDestBuffer;                  float* pfSourceBuffer = (float*)pSourceBuffer;                    int samplesRead = bytesRead / 4;                  for (int n = 0; n < samplesRead; n++)                  {                      float sampleVal = pfSourceBuffer[n] * volume;                      if (sampleVal > 1.0f)                      {                          psDestBuffer[n] = short.MaxValue;                          clip = true;                      }                      else if (sampleVal < -1.0f)                      {                          psDestBuffer[n] = short.MinValue;                          clip = true;                      }                      else                      {                          psDestBuffer[n] = (short)(sampleVal * 32767);                      }                  }              }
Magic Number,NAudio.Wave,Wave32To16Stream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\Wave32To16Stream.cs,Convert32To16,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                  pSourceBuffer = &source[0])              {                  short* psDestBuffer = (short*)pDestBuffer;                  float* pfSourceBuffer = (float*)pSourceBuffer;                    int samplesRead = bytesRead / 4;                  for (int n = 0; n < samplesRead; n++)                  {                      float sampleVal = pfSourceBuffer[n] * volume;                      if (sampleVal > 1.0f)                      {                          psDestBuffer[n] = short.MaxValue;                          clip = true;                      }                      else if (sampleVal < -1.0f)                      {                          psDestBuffer[n] = short.MinValue;                          clip = true;                      }                      else                      {                          psDestBuffer[n] = (short)(sampleVal * 32767);                      }                  }              }
Magic Number,NAudio.Wave,WaveChannel32,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveChannel32.cs,WaveChannel32,The following statement contains a magic number: waveFormat = WaveFormat.CreateIeeeFloatWaveFormat(sourceStream.WaveFormat.SampleRate' 2);
Magic Number,NAudio.Wave,WaveChannel32,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveChannel32.cs,WaveChannel32,The following statement contains a magic number: destBytesPerSample = 8;
Magic Number,NAudio.Wave,WaveChannel32,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveChannel32.cs,WaveChannel32,The following statement contains a magic number: sourceBytesPerSample = sourceStream.WaveFormat.Channels * sourceStream.WaveFormat.BitsPerSample / 8;
Magic Number,NAudio.Wave,WaveChannel32,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveChannel32.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  int bytesWritten = 0;                  WaveBuffer destWaveBuffer = new WaveBuffer(destBuffer);                    // 1. fill with silence                  if (position < 0)                  {                      bytesWritten = (int) Math.Min(numBytes' 0 - position);                      for (int n = 0; n < bytesWritten; n++)                          destBuffer[n + offset] = 0;                  }                  if (bytesWritten < numBytes)                  {                      sampleProvider.LoadNextChunk(sourceStream' (numBytes - bytesWritten)/8);                      float left' right;                        int outIndex = (offset/4) + bytesWritten/4;                      while (this.sampleProvider.GetNextSample(out left' out right) && bytesWritten < numBytes)                      {                          // implement better panning laws.                           left = (pan <= 0) ? left : (left*(1 - pan)/2.0f);                          right = (pan >= 0) ? right : (right*(pan + 1)/2.0f);                          left *= volume;                          right *= volume;                          destWaveBuffer.FloatBuffer[outIndex++] = left;                          destWaveBuffer.FloatBuffer[outIndex++] = right;                          bytesWritten += 8;                          if (Sample != null) RaiseSample(left' right);                      }                  }                  // 3. Fill out with zeroes                  if (PadWithZeroes && bytesWritten < numBytes)                  {                      Array.Clear(destBuffer' offset + bytesWritten' numBytes - bytesWritten);                      bytesWritten = numBytes;                  }                  position += bytesWritten;                  return bytesWritten;              }
Magic Number,NAudio.Wave,WaveChannel32,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveChannel32.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  int bytesWritten = 0;                  WaveBuffer destWaveBuffer = new WaveBuffer(destBuffer);                    // 1. fill with silence                  if (position < 0)                  {                      bytesWritten = (int) Math.Min(numBytes' 0 - position);                      for (int n = 0; n < bytesWritten; n++)                          destBuffer[n + offset] = 0;                  }                  if (bytesWritten < numBytes)                  {                      sampleProvider.LoadNextChunk(sourceStream' (numBytes - bytesWritten)/8);                      float left' right;                        int outIndex = (offset/4) + bytesWritten/4;                      while (this.sampleProvider.GetNextSample(out left' out right) && bytesWritten < numBytes)                      {                          // implement better panning laws.                           left = (pan <= 0) ? left : (left*(1 - pan)/2.0f);                          right = (pan >= 0) ? right : (right*(pan + 1)/2.0f);                          left *= volume;                          right *= volume;                          destWaveBuffer.FloatBuffer[outIndex++] = left;                          destWaveBuffer.FloatBuffer[outIndex++] = right;                          bytesWritten += 8;                          if (Sample != null) RaiseSample(left' right);                      }                  }                  // 3. Fill out with zeroes                  if (PadWithZeroes && bytesWritten < numBytes)                  {                      Array.Clear(destBuffer' offset + bytesWritten' numBytes - bytesWritten);                      bytesWritten = numBytes;                  }                  position += bytesWritten;                  return bytesWritten;              }
Magic Number,NAudio.Wave,WaveChannel32,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveChannel32.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  int bytesWritten = 0;                  WaveBuffer destWaveBuffer = new WaveBuffer(destBuffer);                    // 1. fill with silence                  if (position < 0)                  {                      bytesWritten = (int) Math.Min(numBytes' 0 - position);                      for (int n = 0; n < bytesWritten; n++)                          destBuffer[n + offset] = 0;                  }                  if (bytesWritten < numBytes)                  {                      sampleProvider.LoadNextChunk(sourceStream' (numBytes - bytesWritten)/8);                      float left' right;                        int outIndex = (offset/4) + bytesWritten/4;                      while (this.sampleProvider.GetNextSample(out left' out right) && bytesWritten < numBytes)                      {                          // implement better panning laws.                           left = (pan <= 0) ? left : (left*(1 - pan)/2.0f);                          right = (pan >= 0) ? right : (right*(pan + 1)/2.0f);                          left *= volume;                          right *= volume;                          destWaveBuffer.FloatBuffer[outIndex++] = left;                          destWaveBuffer.FloatBuffer[outIndex++] = right;                          bytesWritten += 8;                          if (Sample != null) RaiseSample(left' right);                      }                  }                  // 3. Fill out with zeroes                  if (PadWithZeroes && bytesWritten < numBytes)                  {                      Array.Clear(destBuffer' offset + bytesWritten' numBytes - bytesWritten);                      bytesWritten = numBytes;                  }                  position += bytesWritten;                  return bytesWritten;              }
Magic Number,NAudio.Wave,WaveChannel32,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveChannel32.cs,Read,The following statement contains a magic number: lock (lockObject)              {                  int bytesWritten = 0;                  WaveBuffer destWaveBuffer = new WaveBuffer(destBuffer);                    // 1. fill with silence                  if (position < 0)                  {                      bytesWritten = (int) Math.Min(numBytes' 0 - position);                      for (int n = 0; n < bytesWritten; n++)                          destBuffer[n + offset] = 0;                  }                  if (bytesWritten < numBytes)                  {                      sampleProvider.LoadNextChunk(sourceStream' (numBytes - bytesWritten)/8);                      float left' right;                        int outIndex = (offset/4) + bytesWritten/4;                      while (this.sampleProvider.GetNextSample(out left' out right) && bytesWritten < numBytes)                      {                          // implement better panning laws.                           left = (pan <= 0) ? left : (left*(1 - pan)/2.0f);                          right = (pan >= 0) ? right : (right*(pan + 1)/2.0f);                          left *= volume;                          right *= volume;                          destWaveBuffer.FloatBuffer[outIndex++] = left;                          destWaveBuffer.FloatBuffer[outIndex++] = right;                          bytesWritten += 8;                          if (Sample != null) RaiseSample(left' right);                      }                  }                  // 3. Fill out with zeroes                  if (PadWithZeroes && bytesWritten < numBytes)                  {                      Array.Clear(destBuffer' offset + bytesWritten' numBytes - bytesWritten);                      bytesWritten = numBytes;                  }                  position += bytesWritten;                  return bytesWritten;              }
Magic Number,NAudio.Wave,WaveFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveFileReader.cs,ReadNextSampleFrame,The following statement contains a magic number: int bytesToRead = waveFormat.Channels*(waveFormat.BitsPerSample/8);
Magic Number,NAudio.Wave,WaveFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveFileReader.cs,ReadNextSampleFrame,The following statement contains a magic number: for (int channel = 0; channel < waveFormat.Channels; channel++)              {                  if (waveFormat.BitsPerSample == 16)                  {                      sampleFrame[channel] = BitConverter.ToInt16(raw' offset)/32768f;                      offset += 2;                  }                  else if (waveFormat.BitsPerSample == 24)                  {                      sampleFrame[channel] = (((sbyte)raw[offset + 2] << 16) | (raw[offset + 1] << 8) | raw[offset]) / 8388608f;                      offset += 3;                  }                  else if (waveFormat.BitsPerSample == 32 && waveFormat.Encoding == WaveFormatEncoding.IeeeFloat)                  {                      sampleFrame[channel] = BitConverter.ToSingle(raw' offset);                      offset += 4;                  }                  else if (waveFormat.BitsPerSample == 32)                  {                      sampleFrame[channel] = BitConverter.ToInt32(raw' offset) / (Int32.MaxValue + 1f);                      offset += 4;                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }
Magic Number,NAudio.Wave,WaveFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveFileReader.cs,ReadNextSampleFrame,The following statement contains a magic number: for (int channel = 0; channel < waveFormat.Channels; channel++)              {                  if (waveFormat.BitsPerSample == 16)                  {                      sampleFrame[channel] = BitConverter.ToInt16(raw' offset)/32768f;                      offset += 2;                  }                  else if (waveFormat.BitsPerSample == 24)                  {                      sampleFrame[channel] = (((sbyte)raw[offset + 2] << 16) | (raw[offset + 1] << 8) | raw[offset]) / 8388608f;                      offset += 3;                  }                  else if (waveFormat.BitsPerSample == 32 && waveFormat.Encoding == WaveFormatEncoding.IeeeFloat)                  {                      sampleFrame[channel] = BitConverter.ToSingle(raw' offset);                      offset += 4;                  }                  else if (waveFormat.BitsPerSample == 32)                  {                      sampleFrame[channel] = BitConverter.ToInt32(raw' offset) / (Int32.MaxValue + 1f);                      offset += 4;                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }
Magic Number,NAudio.Wave,WaveFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveFileReader.cs,ReadNextSampleFrame,The following statement contains a magic number: for (int channel = 0; channel < waveFormat.Channels; channel++)              {                  if (waveFormat.BitsPerSample == 16)                  {                      sampleFrame[channel] = BitConverter.ToInt16(raw' offset)/32768f;                      offset += 2;                  }                  else if (waveFormat.BitsPerSample == 24)                  {                      sampleFrame[channel] = (((sbyte)raw[offset + 2] << 16) | (raw[offset + 1] << 8) | raw[offset]) / 8388608f;                      offset += 3;                  }                  else if (waveFormat.BitsPerSample == 32 && waveFormat.Encoding == WaveFormatEncoding.IeeeFloat)                  {                      sampleFrame[channel] = BitConverter.ToSingle(raw' offset);                      offset += 4;                  }                  else if (waveFormat.BitsPerSample == 32)                  {                      sampleFrame[channel] = BitConverter.ToInt32(raw' offset) / (Int32.MaxValue + 1f);                      offset += 4;                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }
Magic Number,NAudio.Wave,WaveFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveFileReader.cs,ReadNextSampleFrame,The following statement contains a magic number: for (int channel = 0; channel < waveFormat.Channels; channel++)              {                  if (waveFormat.BitsPerSample == 16)                  {                      sampleFrame[channel] = BitConverter.ToInt16(raw' offset)/32768f;                      offset += 2;                  }                  else if (waveFormat.BitsPerSample == 24)                  {                      sampleFrame[channel] = (((sbyte)raw[offset + 2] << 16) | (raw[offset + 1] << 8) | raw[offset]) / 8388608f;                      offset += 3;                  }                  else if (waveFormat.BitsPerSample == 32 && waveFormat.Encoding == WaveFormatEncoding.IeeeFloat)                  {                      sampleFrame[channel] = BitConverter.ToSingle(raw' offset);                      offset += 4;                  }                  else if (waveFormat.BitsPerSample == 32)                  {                      sampleFrame[channel] = BitConverter.ToInt32(raw' offset) / (Int32.MaxValue + 1f);                      offset += 4;                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }
Magic Number,NAudio.Wave,WaveFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveFileReader.cs,ReadNextSampleFrame,The following statement contains a magic number: for (int channel = 0; channel < waveFormat.Channels; channel++)              {                  if (waveFormat.BitsPerSample == 16)                  {                      sampleFrame[channel] = BitConverter.ToInt16(raw' offset)/32768f;                      offset += 2;                  }                  else if (waveFormat.BitsPerSample == 24)                  {                      sampleFrame[channel] = (((sbyte)raw[offset + 2] << 16) | (raw[offset + 1] << 8) | raw[offset]) / 8388608f;                      offset += 3;                  }                  else if (waveFormat.BitsPerSample == 32 && waveFormat.Encoding == WaveFormatEncoding.IeeeFloat)                  {                      sampleFrame[channel] = BitConverter.ToSingle(raw' offset);                      offset += 4;                  }                  else if (waveFormat.BitsPerSample == 32)                  {                      sampleFrame[channel] = BitConverter.ToInt32(raw' offset) / (Int32.MaxValue + 1f);                      offset += 4;                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }
Magic Number,NAudio.Wave,WaveFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveFileReader.cs,ReadNextSampleFrame,The following statement contains a magic number: for (int channel = 0; channel < waveFormat.Channels; channel++)              {                  if (waveFormat.BitsPerSample == 16)                  {                      sampleFrame[channel] = BitConverter.ToInt16(raw' offset)/32768f;                      offset += 2;                  }                  else if (waveFormat.BitsPerSample == 24)                  {                      sampleFrame[channel] = (((sbyte)raw[offset + 2] << 16) | (raw[offset + 1] << 8) | raw[offset]) / 8388608f;                      offset += 3;                  }                  else if (waveFormat.BitsPerSample == 32 && waveFormat.Encoding == WaveFormatEncoding.IeeeFloat)                  {                      sampleFrame[channel] = BitConverter.ToSingle(raw' offset);                      offset += 4;                  }                  else if (waveFormat.BitsPerSample == 32)                  {                      sampleFrame[channel] = BitConverter.ToInt32(raw' offset) / (Int32.MaxValue + 1f);                      offset += 4;                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }
Magic Number,NAudio.Wave,WaveFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveFileReader.cs,ReadNextSampleFrame,The following statement contains a magic number: for (int channel = 0; channel < waveFormat.Channels; channel++)              {                  if (waveFormat.BitsPerSample == 16)                  {                      sampleFrame[channel] = BitConverter.ToInt16(raw' offset)/32768f;                      offset += 2;                  }                  else if (waveFormat.BitsPerSample == 24)                  {                      sampleFrame[channel] = (((sbyte)raw[offset + 2] << 16) | (raw[offset + 1] << 8) | raw[offset]) / 8388608f;                      offset += 3;                  }                  else if (waveFormat.BitsPerSample == 32 && waveFormat.Encoding == WaveFormatEncoding.IeeeFloat)                  {                      sampleFrame[channel] = BitConverter.ToSingle(raw' offset);                      offset += 4;                  }                  else if (waveFormat.BitsPerSample == 32)                  {                      sampleFrame[channel] = BitConverter.ToInt32(raw' offset) / (Int32.MaxValue + 1f);                      offset += 4;                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }
Magic Number,NAudio.Wave,WaveFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveFileReader.cs,ReadNextSampleFrame,The following statement contains a magic number: for (int channel = 0; channel < waveFormat.Channels; channel++)              {                  if (waveFormat.BitsPerSample == 16)                  {                      sampleFrame[channel] = BitConverter.ToInt16(raw' offset)/32768f;                      offset += 2;                  }                  else if (waveFormat.BitsPerSample == 24)                  {                      sampleFrame[channel] = (((sbyte)raw[offset + 2] << 16) | (raw[offset + 1] << 8) | raw[offset]) / 8388608f;                      offset += 3;                  }                  else if (waveFormat.BitsPerSample == 32 && waveFormat.Encoding == WaveFormatEncoding.IeeeFloat)                  {                      sampleFrame[channel] = BitConverter.ToSingle(raw' offset);                      offset += 4;                  }                  else if (waveFormat.BitsPerSample == 32)                  {                      sampleFrame[channel] = BitConverter.ToInt32(raw' offset) / (Int32.MaxValue + 1f);                      offset += 4;                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }
Magic Number,NAudio.Wave,WaveFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveFileReader.cs,ReadNextSampleFrame,The following statement contains a magic number: for (int channel = 0; channel < waveFormat.Channels; channel++)              {                  if (waveFormat.BitsPerSample == 16)                  {                      sampleFrame[channel] = BitConverter.ToInt16(raw' offset)/32768f;                      offset += 2;                  }                  else if (waveFormat.BitsPerSample == 24)                  {                      sampleFrame[channel] = (((sbyte)raw[offset + 2] << 16) | (raw[offset + 1] << 8) | raw[offset]) / 8388608f;                      offset += 3;                  }                  else if (waveFormat.BitsPerSample == 32 && waveFormat.Encoding == WaveFormatEncoding.IeeeFloat)                  {                      sampleFrame[channel] = BitConverter.ToSingle(raw' offset);                      offset += 4;                  }                  else if (waveFormat.BitsPerSample == 32)                  {                      sampleFrame[channel] = BitConverter.ToInt32(raw' offset) / (Int32.MaxValue + 1f);                      offset += 4;                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }
Magic Number,NAudio.Wave,WaveFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveFileReader.cs,ReadNextSampleFrame,The following statement contains a magic number: for (int channel = 0; channel < waveFormat.Channels; channel++)              {                  if (waveFormat.BitsPerSample == 16)                  {                      sampleFrame[channel] = BitConverter.ToInt16(raw' offset)/32768f;                      offset += 2;                  }                  else if (waveFormat.BitsPerSample == 24)                  {                      sampleFrame[channel] = (((sbyte)raw[offset + 2] << 16) | (raw[offset + 1] << 8) | raw[offset]) / 8388608f;                      offset += 3;                  }                  else if (waveFormat.BitsPerSample == 32 && waveFormat.Encoding == WaveFormatEncoding.IeeeFloat)                  {                      sampleFrame[channel] = BitConverter.ToSingle(raw' offset);                      offset += 4;                  }                  else if (waveFormat.BitsPerSample == 32)                  {                      sampleFrame[channel] = BitConverter.ToInt32(raw' offset) / (Int32.MaxValue + 1f);                      offset += 4;                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }
Magic Number,NAudio.Wave,WaveFileReader,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveFileReader.cs,ReadNextSampleFrame,The following statement contains a magic number: for (int channel = 0; channel < waveFormat.Channels; channel++)              {                  if (waveFormat.BitsPerSample == 16)                  {                      sampleFrame[channel] = BitConverter.ToInt16(raw' offset)/32768f;                      offset += 2;                  }                  else if (waveFormat.BitsPerSample == 24)                  {                      sampleFrame[channel] = (((sbyte)raw[offset + 2] << 16) | (raw[offset + 1] << 8) | raw[offset]) / 8388608f;                      offset += 3;                  }                  else if (waveFormat.BitsPerSample == 32 && waveFormat.Encoding == WaveFormatEncoding.IeeeFloat)                  {                      sampleFrame[channel] = BitConverter.ToSingle(raw' offset);                      offset += 4;                  }                  else if (waveFormat.BitsPerSample == 32)                  {                      sampleFrame[channel] = BitConverter.ToInt32(raw' offset) / (Int32.MaxValue + 1f);                      offset += 4;                  }                  else                  {                      throw new InvalidOperationException("Unsupported bit depth");                  }              }
Magic Number,NAudio.Wave,WaveFormatConversionStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveFormatConversionStream.cs,CreatePcmStream,The following statement contains a magic number: if (pcmFormat.SampleRate < 8000)              {                  if (sourceStream.WaveFormat.Encoding == WaveFormatEncoding.G723)                  {                      pcmFormat = new WaveFormat(8000' 16' 1);                  }                  else                  {                      throw new InvalidOperationException("Invalid suggested output format' please explicitly provide a target format");                  }              }
Magic Number,NAudio.Wave,WaveFormatConversionStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveFormatConversionStream.cs,CreatePcmStream,The following statement contains a magic number: if (pcmFormat.SampleRate < 8000)              {                  if (sourceStream.WaveFormat.Encoding == WaveFormatEncoding.G723)                  {                      pcmFormat = new WaveFormat(8000' 16' 1);                  }                  else                  {                      throw new InvalidOperationException("Invalid suggested output format' please explicitly provide a target format");                  }              }
Magic Number,NAudio.Wave,WaveFormatConversionStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveFormatConversionStream.cs,CreatePcmStream,The following statement contains a magic number: if (pcmFormat.SampleRate < 8000)              {                  if (sourceStream.WaveFormat.Encoding == WaveFormatEncoding.G723)                  {                      pcmFormat = new WaveFormat(8000' 16' 1);                  }                  else                  {                      throw new InvalidOperationException("Invalid suggested output format' please explicitly provide a target format");                  }              }
Magic Number,NAudio.Wave,WaveMixerStream32,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveMixerStream32.cs,WaveMixerStream32,The following statement contains a magic number: waveFormat = WaveFormat.CreateIeeeFloatWaveFormat(44100' 2);
Magic Number,NAudio.Wave,WaveMixerStream32,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveMixerStream32.cs,WaveMixerStream32,The following statement contains a magic number: waveFormat = WaveFormat.CreateIeeeFloatWaveFormat(44100' 2);
Magic Number,NAudio.Wave,WaveMixerStream32,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveMixerStream32.cs,WaveMixerStream32,The following statement contains a magic number: bytesPerSample = 4;
Magic Number,NAudio.Wave,WaveMixerStream32,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveMixerStream32.cs,AddInputStream,The following statement contains a magic number: if (waveStream.WaveFormat.BitsPerSample != 32)                  throw new ArgumentException("Only 32 bit audio currently supported"' "waveStream");
Magic Number,NAudio.Wave,WaveMixerStream32,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveMixerStream32.cs,Sum32BitAudio,The following statement contains a magic number: fixed (byte* pDestBuffer = &destBuffer[offset]'                        pSourceBuffer = &sourceBuffer[0])              {                  float* pfDestBuffer = (float*)pDestBuffer;                  float* pfReadBuffer = (float*)pSourceBuffer;                  int samplesRead = bytesRead / 4;                  for (int n = 0; n < samplesRead; n++)                  {                      pfDestBuffer[n] += pfReadBuffer[n];                  }              }
Magic Number,NAudio.Wave,WaveOffsetStream,C:\repos\naudio_NAudio\NAudio\Wave\WaveStreams\WaveOffsetStream.cs,WaveOffsetStream,The following statement contains a magic number: bytesPerSample = (sourceStream.WaveFormat.BitsPerSample / 8) * sourceStream.WaveFormat.Channels;
Magic Number,NAudio.FileFormats.Map,CakewalkDrumMapping,C:\repos\naudio_NAudio\NAudio\FileFormats\Map\CakewalkDrumMapping.cs,ToString,The following statement contains a magic number: return String.Format("{0} In:{1} Out:{2} Ch:{3} Port:{4} Vel+:{5} Vel:{6}%"'                  NoteName' InNote' OutNote' Channel' OutPort' VelocityAdjust' VelocityScale*100);
Magic Number,NAudio.FileFormats.Map,CakewalkMapFile,C:\repos\naudio_NAudio\NAudio\FileFormats\Map\CakewalkMapFile.cs,ReadMapEntry,The following statement contains a magic number: char[] name = reader.ReadChars(32);
Magic Number,NAudio.FileFormats.Map,CakewalkMapFile,C:\repos\naudio_NAudio\NAudio\FileFormats\Map\CakewalkMapFile.cs,ReadMapName,The following statement contains a magic number: char[] name = reader.ReadChars(34);
Magic Number,NAudio.FileFormats.Map,CakewalkMapFile,C:\repos\naudio_NAudio\NAudio\FileFormats\Map\CakewalkMapFile.cs,ReadMapName,The following statement contains a magic number: reader.ReadBytes(98);
Magic Number,NAudio.FileFormats.Map,CakewalkMapFile,C:\repos\naudio_NAudio\NAudio\FileFormats\Map\CakewalkMapFile.cs,ReadOutputsSection1,The following statement contains a magic number: for (int n = 0; n < outputs1Count; n++)              {                  reader.ReadBytes(20); // data              }
Magic Number,NAudio.FileFormats.Map,CakewalkMapFile,C:\repos\naudio_NAudio\NAudio\FileFormats\Map\CakewalkMapFile.cs,ReadOutputsSection2,The following statement contains a magic number: for (int n = 0; n < outputs2Count; n++)              {                  reader.ReadBytes(24); // data              }
Magic Number,NAudio.FileFormats.Map,CakewalkMapFile,C:\repos\naudio_NAudio\NAudio\FileFormats\Map\CakewalkMapFile.cs,ReadOutputsSection3,The following statement contains a magic number: if (outputs3Header.Length > 0)              {                  outputs3Count = reader.ReadInt32();                  for (int n = 0; n < outputs3Count; n++)                  {                      reader.ReadBytes(36); // data                  }              }
Magic Number,NAudio.SoundFont,InstrumentBuilder,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\InstrumentBuilder.cs,Read,The following statement contains a magic number: string s = Encoding.UTF8.GetString(br.ReadBytes(20)' 0' 20);
Magic Number,NAudio.SoundFont,InstrumentBuilder,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\InstrumentBuilder.cs,Read,The following statement contains a magic number: string s = Encoding.UTF8.GetString(br.ReadBytes(20)' 0' 20);
Magic Number,NAudio.SoundFont,ModulatorType,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\ModulatorType.cs,ModulatorType,The following statement contains a magic number: sourceType = (SourceTypeEnum) ((raw & (0xFC00)) >> 10);
Magic Number,NAudio.SoundFont,PresetBuilder,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\PresetBuilder.cs,Read,The following statement contains a magic number: string s = Encoding.UTF8.GetString(br.ReadBytes(20)' 0' 20);
Magic Number,NAudio.SoundFont,PresetBuilder,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\PresetBuilder.cs,Read,The following statement contains a magic number: string s = Encoding.UTF8.GetString(br.ReadBytes(20)' 0' 20);
Magic Number,NAudio.SoundFont,RiffChunk,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\RiffChunk.cs,ReadChunkID,The following statement contains a magic number: byte []cid = riffFile.ReadBytes(4);
Magic Number,NAudio.SoundFont,RiffChunk,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\RiffChunk.cs,ReadChunkID,The following statement contains a magic number: if(cid.Length != 4)   			{  				throw new InvalidDataException("Couldn't read Chunk ID");  			}
Magic Number,NAudio.SoundFont,RiffChunk,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\RiffChunk.cs,GetNextSubChunk,The following statement contains a magic number: if(riffFile.BaseStream.Position + 8 < dataOffset + chunkSize)   			{  				RiffChunk chunk = new RiffChunk(riffFile);  				chunk.ReadChunk();  				return chunk;  			}
Magic Number,NAudio.SoundFont,SampleHeaderBuilder,C:\repos\naudio_NAudio\NAudio\FileFormats\SoundFont\SampleHeaderBuilder.cs,Read,The following statement contains a magic number: var s = br.ReadBytes(20);
Magic Number,NAudio.Gui,Fader,C:\repos\naudio_NAudio\NAudio\Gui\Fader.cs,DrawSlider,The following statement contains a magic number: sliderRectangle.X = (this.Width - SliderWidth) / 2;
Magic Number,NAudio.Gui,Fader,C:\repos\naudio_NAudio\NAudio\Gui\Fader.cs,DrawSlider,The following statement contains a magic number: g.DrawLine(centreLine'sliderRectangle.Left'sliderRectangle.Top + sliderRectangle.Height/2'sliderRectangle.Right'sliderRectangle.Top + sliderRectangle.Height/2);
Magic Number,NAudio.Gui,Fader,C:\repos\naudio_NAudio\NAudio\Gui\Fader.cs,DrawSlider,The following statement contains a magic number: g.DrawLine(centreLine'sliderRectangle.Left'sliderRectangle.Top + sliderRectangle.Height/2'sliderRectangle.Right'sliderRectangle.Top + sliderRectangle.Height/2);
Magic Number,NAudio.Gui,Fader,C:\repos\naudio_NAudio\NAudio\Gui\Fader.cs,OnPaint,The following statement contains a magic number: if(this.Orientation == Orientation.Vertical)              {                  Brush groove = new SolidBrush(Color.Black);                  g.FillRectangle(groove' this.Width / 2' SliderHeight / 2' 2' this.Height - SliderHeight);                  groove.Dispose();                  DrawSlider(g);              }
Magic Number,NAudio.Gui,Fader,C:\repos\naudio_NAudio\NAudio\Gui\Fader.cs,OnPaint,The following statement contains a magic number: if(this.Orientation == Orientation.Vertical)              {                  Brush groove = new SolidBrush(Color.Black);                  g.FillRectangle(groove' this.Width / 2' SliderHeight / 2' 2' this.Height - SliderHeight);                  groove.Dispose();                  DrawSlider(g);              }
Magic Number,NAudio.Gui,Fader,C:\repos\naudio_NAudio\NAudio\Gui\Fader.cs,OnPaint,The following statement contains a magic number: if(this.Orientation == Orientation.Vertical)              {                  Brush groove = new SolidBrush(Color.Black);                  g.FillRectangle(groove' this.Width / 2' SliderHeight / 2' 2' this.Height - SliderHeight);                  groove.Dispose();                  DrawSlider(g);              }
Magic Number,NAudio.Gui,PanSlider,C:\repos\naudio_NAudio\NAudio\Gui\PanSlider.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(104' 16);
Magic Number,NAudio.Gui,PanSlider,C:\repos\naudio_NAudio\NAudio\Gui\PanSlider.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(104' 16);
Magic Number,NAudio.Gui,PanSlider,C:\repos\naudio_NAudio\NAudio\Gui\PanSlider.cs,OnPaint,The following statement contains a magic number: if(pan == 0.0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2) - 1  '1'3'this.Height-2);  				panValue = "C";  			}  			else if(pan > 0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2)'1'(int) ((this.Width/2) * pan)'this.Height-2);  				panValue = String.Format("{0:F0}%R"'pan*100);  			}  			else  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(int)((this.Width/2) * (pan+1))'1'(int) ((this.Width/2) * (0-pan))'this.Height-2);  				panValue = String.Format("{0:F0}%L"'pan*-100);  			}
Magic Number,NAudio.Gui,PanSlider,C:\repos\naudio_NAudio\NAudio\Gui\PanSlider.cs,OnPaint,The following statement contains a magic number: if(pan == 0.0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2) - 1  '1'3'this.Height-2);  				panValue = "C";  			}  			else if(pan > 0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2)'1'(int) ((this.Width/2) * pan)'this.Height-2);  				panValue = String.Format("{0:F0}%R"'pan*100);  			}  			else  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(int)((this.Width/2) * (pan+1))'1'(int) ((this.Width/2) * (0-pan))'this.Height-2);  				panValue = String.Format("{0:F0}%L"'pan*-100);  			}
Magic Number,NAudio.Gui,PanSlider,C:\repos\naudio_NAudio\NAudio\Gui\PanSlider.cs,OnPaint,The following statement contains a magic number: if(pan == 0.0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2) - 1  '1'3'this.Height-2);  				panValue = "C";  			}  			else if(pan > 0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2)'1'(int) ((this.Width/2) * pan)'this.Height-2);  				panValue = String.Format("{0:F0}%R"'pan*100);  			}  			else  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(int)((this.Width/2) * (pan+1))'1'(int) ((this.Width/2) * (0-pan))'this.Height-2);  				panValue = String.Format("{0:F0}%L"'pan*-100);  			}
Magic Number,NAudio.Gui,PanSlider,C:\repos\naudio_NAudio\NAudio\Gui\PanSlider.cs,OnPaint,The following statement contains a magic number: if(pan == 0.0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2) - 1  '1'3'this.Height-2);  				panValue = "C";  			}  			else if(pan > 0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2)'1'(int) ((this.Width/2) * pan)'this.Height-2);  				panValue = String.Format("{0:F0}%R"'pan*100);  			}  			else  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(int)((this.Width/2) * (pan+1))'1'(int) ((this.Width/2) * (0-pan))'this.Height-2);  				panValue = String.Format("{0:F0}%L"'pan*-100);  			}
Magic Number,NAudio.Gui,PanSlider,C:\repos\naudio_NAudio\NAudio\Gui\PanSlider.cs,OnPaint,The following statement contains a magic number: if(pan == 0.0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2) - 1  '1'3'this.Height-2);  				panValue = "C";  			}  			else if(pan > 0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2)'1'(int) ((this.Width/2) * pan)'this.Height-2);  				panValue = String.Format("{0:F0}%R"'pan*100);  			}  			else  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(int)((this.Width/2) * (pan+1))'1'(int) ((this.Width/2) * (0-pan))'this.Height-2);  				panValue = String.Format("{0:F0}%L"'pan*-100);  			}
Magic Number,NAudio.Gui,PanSlider,C:\repos\naudio_NAudio\NAudio\Gui\PanSlider.cs,OnPaint,The following statement contains a magic number: if(pan == 0.0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2) - 1  '1'3'this.Height-2);  				panValue = "C";  			}  			else if(pan > 0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2)'1'(int) ((this.Width/2) * pan)'this.Height-2);  				panValue = String.Format("{0:F0}%R"'pan*100);  			}  			else  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(int)((this.Width/2) * (pan+1))'1'(int) ((this.Width/2) * (0-pan))'this.Height-2);  				panValue = String.Format("{0:F0}%L"'pan*-100);  			}
Magic Number,NAudio.Gui,PanSlider,C:\repos\naudio_NAudio\NAudio\Gui\PanSlider.cs,OnPaint,The following statement contains a magic number: if(pan == 0.0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2) - 1  '1'3'this.Height-2);  				panValue = "C";  			}  			else if(pan > 0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2)'1'(int) ((this.Width/2) * pan)'this.Height-2);  				panValue = String.Format("{0:F0}%R"'pan*100);  			}  			else  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(int)((this.Width/2) * (pan+1))'1'(int) ((this.Width/2) * (0-pan))'this.Height-2);  				panValue = String.Format("{0:F0}%L"'pan*-100);  			}
Magic Number,NAudio.Gui,PanSlider,C:\repos\naudio_NAudio\NAudio\Gui\PanSlider.cs,OnPaint,The following statement contains a magic number: if(pan == 0.0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2) - 1  '1'3'this.Height-2);  				panValue = "C";  			}  			else if(pan > 0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2)'1'(int) ((this.Width/2) * pan)'this.Height-2);  				panValue = String.Format("{0:F0}%R"'pan*100);  			}  			else  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(int)((this.Width/2) * (pan+1))'1'(int) ((this.Width/2) * (0-pan))'this.Height-2);  				panValue = String.Format("{0:F0}%L"'pan*-100);  			}
Magic Number,NAudio.Gui,PanSlider,C:\repos\naudio_NAudio\NAudio\Gui\PanSlider.cs,OnPaint,The following statement contains a magic number: if(pan == 0.0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2) - 1  '1'3'this.Height-2);  				panValue = "C";  			}  			else if(pan > 0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2)'1'(int) ((this.Width/2) * pan)'this.Height-2);  				panValue = String.Format("{0:F0}%R"'pan*100);  			}  			else  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(int)((this.Width/2) * (pan+1))'1'(int) ((this.Width/2) * (0-pan))'this.Height-2);  				panValue = String.Format("{0:F0}%L"'pan*-100);  			}
Magic Number,NAudio.Gui,PanSlider,C:\repos\naudio_NAudio\NAudio\Gui\PanSlider.cs,OnPaint,The following statement contains a magic number: if(pan == 0.0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2) - 1  '1'3'this.Height-2);  				panValue = "C";  			}  			else if(pan > 0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2)'1'(int) ((this.Width/2) * pan)'this.Height-2);  				panValue = String.Format("{0:F0}%R"'pan*100);  			}  			else  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(int)((this.Width/2) * (pan+1))'1'(int) ((this.Width/2) * (0-pan))'this.Height-2);  				panValue = String.Format("{0:F0}%L"'pan*-100);  			}
Magic Number,NAudio.Gui,PanSlider,C:\repos\naudio_NAudio\NAudio\Gui\PanSlider.cs,OnPaint,The following statement contains a magic number: if(pan == 0.0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2) - 1  '1'3'this.Height-2);  				panValue = "C";  			}  			else if(pan > 0)  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(this.Width/2)'1'(int) ((this.Width/2) * pan)'this.Height-2);  				panValue = String.Format("{0:F0}%R"'pan*100);  			}  			else  			{  				pe.Graphics.FillRectangle(Brushes.Orange'(int)((this.Width/2) * (pan+1))'1'(int) ((this.Width/2) * (0-pan))'this.Height-2);  				panValue = String.Format("{0:F0}%L"'pan*-100);  			}
Magic Number,NAudio.Gui,Pot,C:\repos\naudio_NAudio\NAudio\Gui\Pot.cs,OnPaint,The following statement contains a magic number: int diameter = Math.Min(this.Width-4'this.Height-4);
Magic Number,NAudio.Gui,Pot,C:\repos\naudio_NAudio\NAudio\Gui\Pot.cs,OnPaint,The following statement contains a magic number: int diameter = Math.Min(this.Width-4'this.Height-4);
Magic Number,NAudio.Gui,Pot,C:\repos\naudio_NAudio\NAudio\Gui\Pot.cs,OnPaint,The following statement contains a magic number: e.Graphics.TranslateTransform(this.Width / 2' this.Height / 2);
Magic Number,NAudio.Gui,Pot,C:\repos\naudio_NAudio\NAudio\Gui\Pot.cs,OnPaint,The following statement contains a magic number: e.Graphics.TranslateTransform(this.Width / 2' this.Height / 2);
Magic Number,NAudio.Gui,Pot,C:\repos\naudio_NAudio\NAudio\Gui\Pot.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawArc(potPen' new Rectangle(diameter / -2' diameter / -2' diameter' diameter)' 135' 270);
Magic Number,NAudio.Gui,Pot,C:\repos\naudio_NAudio\NAudio\Gui\Pot.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawArc(potPen' new Rectangle(diameter / -2' diameter / -2' diameter' diameter)' 135' 270);
Magic Number,NAudio.Gui,Pot,C:\repos\naudio_NAudio\NAudio\Gui\Pot.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawArc(potPen' new Rectangle(diameter / -2' diameter / -2' diameter' diameter)' 135' 270);
Magic Number,NAudio.Gui,Pot,C:\repos\naudio_NAudio\NAudio\Gui\Pot.cs,OnPaint,The following statement contains a magic number: e.Graphics.DrawArc(potPen' new Rectangle(diameter / -2' diameter / -2' diameter' diameter)' 135' 270);
Magic Number,NAudio.Gui,Pot,C:\repos\naudio_NAudio\NAudio\Gui\Pot.cs,OnPaint,The following statement contains a magic number: double degrees = 135 + (percent * 270);
Magic Number,NAudio.Gui,Pot,C:\repos\naudio_NAudio\NAudio\Gui\Pot.cs,OnPaint,The following statement contains a magic number: double degrees = 135 + (percent * 270);
Magic Number,NAudio.Gui,Pot,C:\repos\naudio_NAudio\NAudio\Gui\Pot.cs,OnPaint,The following statement contains a magic number: double x = (diameter / 2.0) * Math.Cos(Math.PI * degrees / 180);
Magic Number,NAudio.Gui,Pot,C:\repos\naudio_NAudio\NAudio\Gui\Pot.cs,OnPaint,The following statement contains a magic number: double x = (diameter / 2.0) * Math.Cos(Math.PI * degrees / 180);
Magic Number,NAudio.Gui,Pot,C:\repos\naudio_NAudio\NAudio\Gui\Pot.cs,OnPaint,The following statement contains a magic number: double y = (diameter / 2.0) * Math.Sin(Math.PI * degrees / 180);
Magic Number,NAudio.Gui,Pot,C:\repos\naudio_NAudio\NAudio\Gui\Pot.cs,OnPaint,The following statement contains a magic number: double y = (diameter / 2.0) * Math.Sin(Math.PI * degrees / 180);
Magic Number,NAudio.Gui,Pot,C:\repos\naudio_NAudio\NAudio\Gui\Pot.cs,OnMouseMove,The following statement contains a magic number: if (dragging)              {                  int yDifference = beginDragY - e.Y;                  // 100 is the number of pixels of vertical movement that represents the whole scale                  double delta = (maximum - minimum) * (yDifference / 150.0);                  double newValue = beginDragValue + delta;                  if (newValue < minimum)                      newValue = minimum;                  if (newValue > maximum)                      newValue = maximum;                  SetValue(newValue'true);              }
Magic Number,NAudio.Gui,Pot,C:\repos\naudio_NAudio\NAudio\Gui\Pot.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(32' 32);
Magic Number,NAudio.Gui,Pot,C:\repos\naudio_NAudio\NAudio\Gui\Pot.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(32' 32);
Magic Number,NAudio.Gui,VolumeMeter,C:\repos\naudio_NAudio\NAudio\Gui\VolumeMeter.cs,VolumeMeter,The following statement contains a magic number: MinDb = -60;
Magic Number,NAudio.Gui,VolumeMeter,C:\repos\naudio_NAudio\NAudio\Gui\VolumeMeter.cs,VolumeMeter,The following statement contains a magic number: MaxDb = 18;
Magic Number,NAudio.Gui,VolumeMeter,C:\repos\naudio_NAudio\NAudio\Gui\VolumeMeter.cs,OnPaint,The following statement contains a magic number: double db = 20 * Math.Log10(Amplitude);
Magic Number,NAudio.Gui,VolumeMeter,C:\repos\naudio_NAudio\NAudio\Gui\VolumeMeter.cs,OnPaint,The following statement contains a magic number: int width = this.Width - 2;
Magic Number,NAudio.Gui,VolumeMeter,C:\repos\naudio_NAudio\NAudio\Gui\VolumeMeter.cs,OnPaint,The following statement contains a magic number: int height = this.Height - 2;
Magic Number,NAudio.Gui,VolumeSlider,C:\repos\naudio_NAudio\NAudio\Gui\VolumeSlider.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(96' 16);
Magic Number,NAudio.Gui,VolumeSlider,C:\repos\naudio_NAudio\NAudio\Gui\VolumeSlider.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(96' 16);
Magic Number,NAudio.Gui,VolumeSlider,C:\repos\naudio_NAudio\NAudio\Gui\VolumeSlider.cs,OnPaint,The following statement contains a magic number: float db = 20 * (float)Math.Log10(Volume);
Magic Number,NAudio.Gui,VolumeSlider,C:\repos\naudio_NAudio\NAudio\Gui\VolumeSlider.cs,OnPaint,The following statement contains a magic number: pe.Graphics.FillRectangle(Brushes.LightGreen' 1' 1' (int)((this.Width - 2) * percent)' this.Height - 2);
Magic Number,NAudio.Gui,VolumeSlider,C:\repos\naudio_NAudio\NAudio\Gui\VolumeSlider.cs,OnPaint,The following statement contains a magic number: pe.Graphics.FillRectangle(Brushes.LightGreen' 1' 1' (int)((this.Width - 2) * percent)' this.Height - 2);
Magic Number,NAudio.Gui,VolumeSlider,C:\repos\naudio_NAudio\NAudio\Gui\VolumeSlider.cs,SetVolumeFromMouse,The following statement contains a magic number: if (x <= 0)                  Volume = 0;              else                  Volume = (float)Math.Pow(10' dbVolume / 20);
Magic Number,NAudio.Gui,VolumeSlider,C:\repos\naudio_NAudio\NAudio\Gui\VolumeSlider.cs,SetVolumeFromMouse,The following statement contains a magic number: if (x <= 0)                  Volume = 0;              else                  Volume = (float)Math.Pow(10' dbVolume / 20);
Magic Number,NAudio.Gui,WaveformPainter,C:\repos\naudio_NAudio\NAudio\Gui\WaveformPainter.cs,OnPaint,The following statement contains a magic number: for (int x = 0; x < this.Width; x++)              {                  float lineHeight = this.Height * GetSample(x - this.Width + insertPos);                  float y1 = (this.Height - lineHeight) / 2;                  pe.Graphics.DrawLine(foregroundPen' x' y1' x' y1 + lineHeight);              }
Magic Number,NAudio.Gui,WaveViewer,C:\repos\naudio_NAudio\NAudio\Gui\WaveViewer.cs,OnPaint,The following statement contains a magic number: if(waveStream != null)              {                  waveStream.Position = 0;                  int bytesRead;                  byte[] waveData = new byte[samplesPerPixel*bytesPerSample];                  waveStream.Position = startPosition + (e.ClipRectangle.Left * bytesPerSample * samplesPerPixel);                                    for(float x = e.ClipRectangle.X; x < e.ClipRectangle.Right; x+=1)                  {                      short low = 0;                      short high = 0;                      bytesRead = waveStream.Read(waveData' 0' samplesPerPixel * bytesPerSample);                      if(bytesRead == 0)                          break;                      for(int n = 0; n < bytesRead; n+=2)                      {                          short sample = BitConverter.ToInt16(waveData' n);                          if(sample < low) low = sample;                          if(sample > high) high = sample;                      }                      float lowPercent = ((((float) low) - short.MinValue) / ushort.MaxValue);                      float highPercent = ((((float) high) - short.MinValue) / ushort.MaxValue);                      e.Graphics.DrawLine(Pens.Black'x'this.Height * lowPercent'x'this.Height * highPercent);					                  }               }
Magic Number,NAudio.Wave.WaveFormats,WmaWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WmaWaveFormat.cs,WmaWaveFormat,The following statement contains a magic number: if (channels == 1)                  dwChannelMask = 1;              else if (channels == 2)                  dwChannelMask = 3;
Magic Number,NAudio.Wave.WaveFormats,WmaWaveFormat,C:\repos\naudio_NAudio\NAudio\Wave\WaveFormats\WmaWaveFormat.cs,WmaWaveFormat,The following statement contains a magic number: if (channels == 1)                  dwChannelMask = 1;              else if (channels == 2)                  dwChannelMask = 3;
Missing Default,NAudio.Dsp,EnvelopeGenerator,C:\repos\naudio_NAudio\NAudio\Dsp\EnvelopeGenerator.cs,Process,The following switch statement is missing a default case: switch (state)              {                  case EnvelopeState.Idle:                      break;                  case EnvelopeState.Attack:                      output = attackBase + output * attackCoef;                      if (output >= 1.0f)                      {                          output = 1.0f;                          state = EnvelopeState.Decay;                      }                      break;                  case EnvelopeState.Decay:                      output = decayBase + output * decayCoef;                      if (output <= sustainLevel)                      {                          output = sustainLevel;                          state = EnvelopeState.Sustain;                      }                      break;                  case EnvelopeState.Sustain:                      break;                  case EnvelopeState.Release:                      output = releaseBase + output * releaseCoef;                      if (output <= 0.0)                      {                          output = 0.0f;                          state = EnvelopeState.Idle;                      }                      break;              }
Missing Default,NAudio.Midi,MidiIn,C:\repos\naudio_NAudio\NAudio\Midi\MidiIn.cs,Callback,The following switch statement is missing a default case: switch(message)              {                  case MidiInterop.MidiInMessage.Open:                      // message Parameter 1 & 2 are not used                      break;                  case MidiInterop.MidiInMessage.Data:                      // parameter 1 is packed MIDI message                      // parameter 2 is milliseconds since MidiInStart                      if (MessageReceived != null)                      {                          MessageReceived(this' new MidiInMessageEventArgs(messageParameter1.ToInt32()' messageParameter2.ToInt32()));                      }                      break;                  case MidiInterop.MidiInMessage.Error:                      // parameter 1 is invalid MIDI message                      if (ErrorReceived != null)                      {                          ErrorReceived(this' new MidiInMessageEventArgs(messageParameter1.ToInt32()' messageParameter2.ToInt32()));                      }                       break;                  case MidiInterop.MidiInMessage.Close:                      // message Parameter 1 & 2 are not used                      break;                  case MidiInterop.MidiInMessage.LongData:                      // parameter 1 is pointer to MIDI header                      // parameter 2 is milliseconds since MidiInStart                      break;                  case MidiInterop.MidiInMessage.LongError:                      // parameter 1 is pointer to MIDI header                      // parameter 2 is milliseconds since MidiInStart                      break;                  case MidiInterop.MidiInMessage.MoreData:                      // parameter 1 is packed MIDI message                      // parameter 2 is milliseconds since MidiInStart                      break;              }
Missing Default,NAudio.Wave.Asio,AsioDriverExt,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioDriverExt.cs,AsioMessageCallBack,The following switch statement is missing a default case: switch (selector)              {                  case AsioMessageSelector.kAsioSelectorSupported:                      AsioMessageSelector subValue = (AsioMessageSelector)Enum.ToObject(typeof(AsioMessageSelector)' value);                      switch (subValue)                      {                          case AsioMessageSelector.kAsioEngineVersion:                              return 1;                          case AsioMessageSelector.kAsioResetRequest:                              return 0;                          case AsioMessageSelector.kAsioBufferSizeChange:                              return 0;                          case AsioMessageSelector.kAsioResyncRequest:                              return 0;                          case AsioMessageSelector.kAsioLatenciesChanged:                              return 0;                          case AsioMessageSelector.kAsioSupportsTimeInfo:  //                            return 1; DON'T SUPPORT FOR NOW. NEED MORE TESTING.                              return 0;                          case AsioMessageSelector.kAsioSupportsTimeCode:  //                            return 1; DON'T SUPPORT FOR NOW. NEED MORE TESTING.                              return 0;                      }                      break;                  case AsioMessageSelector.kAsioEngineVersion:                      return 2;                  case AsioMessageSelector.kAsioResetRequest:                      return 1;                  case AsioMessageSelector.kAsioBufferSizeChange:                      return 0;                  case AsioMessageSelector.kAsioResyncRequest:                      return 0;                  case AsioMessageSelector.kAsioLatenciesChanged:                      return 0;                  case AsioMessageSelector.kAsioSupportsTimeInfo:                      return 0;                  case AsioMessageSelector.kAsioSupportsTimeCode:                      return 0;              }
Missing Default,NAudio.Wave.Asio,AsioDriverExt,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioDriverExt.cs,AsioMessageCallBack,The following switch statement is missing a default case: switch (subValue)                      {                          case AsioMessageSelector.kAsioEngineVersion:                              return 1;                          case AsioMessageSelector.kAsioResetRequest:                              return 0;                          case AsioMessageSelector.kAsioBufferSizeChange:                              return 0;                          case AsioMessageSelector.kAsioResyncRequest:                              return 0;                          case AsioMessageSelector.kAsioLatenciesChanged:                              return 0;                          case AsioMessageSelector.kAsioSupportsTimeInfo:  //                            return 1; DON'T SUPPORT FOR NOW. NEED MORE TESTING.                              return 0;                          case AsioMessageSelector.kAsioSupportsTimeCode:  //                            return 1; DON'T SUPPORT FOR NOW. NEED MORE TESTING.                              return 0;                      }
Missing Default,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,SelectSampleConvertor,The following switch statement is missing a default case: switch (waveFormat.BitsPerSample)                      {                          case 16:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToInt2Channels : (SampleConvertor)ConvertorShortToIntGeneric;                              break;                          case 32:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToInt2Channels : (SampleConvertor)ConvertorFloatToIntGeneric;                              break;                      }
Missing Default,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,SelectSampleConvertor,The following switch statement is missing a default case: switch (waveFormat.BitsPerSample)                      {                          case 16:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorShortToShort2Channels : (SampleConvertor)ConvertorShortToShortGeneric;                              break;                          case 32:                              convertor = (is2Channels) ? (SampleConvertor)ConvertorFloatToShort2Channels : (SampleConvertor)ConvertorFloatToShortGeneric;                              break;                      }
Missing Default,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,SelectSampleConvertor,The following switch statement is missing a default case: switch (waveFormat.BitsPerSample)                      {                          case 16:                              throw new ArgumentException("Not a supported conversion");                          case 32:                              convertor = ConverterFloatTo24LSBGeneric;                              break;                      }
Missing Default,NAudio.Wave.Asio,AsioSampleConvertor,C:\repos\naudio_NAudio\NAudio\Wave\Asio\AsioSampleConvertor.cs,SelectSampleConvertor,The following switch statement is missing a default case: switch (waveFormat.BitsPerSample)                      {                          case 16:                              throw new ArgumentException("Not a supported conversion");                          case 32:                              convertor = ConverterFloatToFloatGeneric;                              break;                      }
