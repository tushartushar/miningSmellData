Implementation smell,Namespace,Class,File,Method,Description
Long Method,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The method has 103 lines of code.
Complex Method,CassandraSharp.CQLBinaryProtocol,ValueSerializer<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\ValueSerializer.cs,GenerateObjectSerializer,Cyclomatic complexity of the method is 13
Complex Method,CassandraSharp.CQLBinaryProtocol,ValueSerializer<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\ValueSerializer.cs,GenerateObjectDeserializer,Cyclomatic complexity of the method is 13
Long Parameter List,CassandraSharp.Cluster,SingleConnectionPerEndpointCluster,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Cluster\SingleConnectionPerEndpointCluster.cs,SingleConnectionPerEndpointCluster,The method has 5 parameters. Parameters: endpointStrategy' logger' connectionFactory' recoveryService' partitioner
Long Parameter List,CassandraSharp.CQLBinaryProtocol,ColumnSpec,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\ColumnSpec.cs,ColumnSpec,The method has 8 parameters. Parameters: index' keyspace' table' name' columnType' customData' collectionKeyType' collectionValueType
Long Parameter List,CassandraSharp.CQLBinaryProtocol,PreparedQuery<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\PreparedQuery.cs,PreparedQuery,The method has 6 parameters. Parameters: cluster' consistencyLevel' executionFlags' factoryIn' factoryOut' cql
Long Parameter List,CassandraSharp.CQLBinaryProtocol.Queries,AuthenticateQuery,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\Queries\AuthenticateQuery.cs,AuthenticateQuery,The method has 5 parameters. Parameters: connection' consistencyLevel' executionFlags' user' password
Long Parameter List,CassandraSharp.CQLBinaryProtocol.Queries,CqlQuery<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\Queries\CqlQuery.cs,CqlQuery,The method has 5 parameters. Parameters: connection' consistencyLevel' executionFlags' cql' mapperOut
Long Parameter List,CassandraSharp.CQLBinaryProtocol.Queries,CqlQuery<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\Queries\CqlQuery.cs,ReadColumnSpecs,The method has 5 parameters. Parameters: colCount' keyspace' table' globalTablesSpec' stream
Long Parameter List,CassandraSharp.CQLBinaryProtocol.Queries,ExecuteQuery<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\Queries\ExecuteQuery.cs,ExecuteQuery,The method has 9 parameters. Parameters: connection' consistencyLevel' executionFlags' cql' id' columnSpecs' dataSource' mapperIn' mapperOut
Long Parameter List,CassandraSharp.Transport,LongRunningConnection,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\LongRunningConnection.cs,LongRunningConnection,The method has 5 parameters. Parameters: address' config' keyspaceConfig' logger' instrumentation
Long Statement,CassandraSharp.CQLBinaryProtocol,PreparedQuery<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\PreparedQuery.cs,Execute,The length of the statement  "            var futQuery = new ExecuteQuery<T>(connection' cl' executionFlags' _cql' _id' _columnSpecs' dataSource' mapperIn' mapperOut); " is 125.
Long Statement,CassandraSharp.CQLBinaryProtocol,ValueSerialization,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\ValueSerialization.cs,Serialize,The length of the statement  "                    return SerializeMap((IDictionary)data' key => Serialize(columnSpec.CollectionKeyType' key)' value => Serialize(columnSpec.CollectionValueType' value)); " is 151.
Long Statement,CassandraSharp.CQLBinaryProtocol,ValueSerialization,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\ValueSerialization.cs,Deserialize,The length of the statement  "                    return DeserializeMap(rawData' dic' key => Deserialize(columnSpec.CollectionKeyType' key)' val => Deserialize(columnSpec.CollectionValueType' val)); " is 148.
Long Statement,CassandraSharp.CQLBinaryProtocol,ValueSerializer<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\ValueSerializer.cs,GenerateObjectSerializer,The length of the statement  "            var customSerializer = type.GetCustomAttributes(typeof(CassandraTypeSerializerAttribute)' false).FirstOrDefault() as CassandraTypeSerializerAttribute; " is 150.
Long Statement,CassandraSharp.CQLBinaryProtocol,ValueSerializer<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\ValueSerializer.cs,GenerateObjectSerializer,The length of the statement  "                var dictionaryTypeDef = type.GetInterfaces().FirstOrDefault(x => x.IsGenericType && x.GetGenericTypeDefinition() == typeof(IDictionary<'>)); " is 140.
Long Statement,CassandraSharp.CQLBinaryProtocol,ValueSerializer<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\ValueSerializer.cs,GenerateObjectSerializer,The length of the statement  "                var listTypeDef = type.GetInterfaces().FirstOrDefault(x => x.IsGenericType && x.GetGenericTypeDefinition() == typeof(IList<>)); " is 127.
Long Statement,CassandraSharp.CQLBinaryProtocol,ValueSerializer<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\ValueSerializer.cs,GenerateObjectSerializer,The length of the statement  "            var hashSetTypeDef = type.GetInterfaces().FirstOrDefault(x => x.IsGenericType && x.GetGenericTypeDefinition() == typeof(ISet<>)); " is 129.
Long Statement,CassandraSharp.CQLBinaryProtocol,ValueSerializer<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\ValueSerializer.cs,GenerateObjectSerializer,The length of the statement  "            throw new NotSupportedException(string.Format("Type {0} neither belongs to Cassandra native types nor has custom serializer defined. Use CassandraTypeSerializerAttribute to define custom type serializer to store data inside Blob column."' type.FullName)); " is 255.
Long Statement,CassandraSharp.CQLBinaryProtocol,ValueSerializer<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\ValueSerializer.cs,GenerateObjectDeserializer,The length of the statement  "            var customSerializer = type.GetCustomAttributes(typeof(CassandraTypeSerializerAttribute)' false).FirstOrDefault() as CassandraTypeSerializerAttribute; " is 150.
Long Statement,CassandraSharp.CQLBinaryProtocol,ValueSerializer<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\ValueSerializer.cs,GenerateObjectDeserializer,The length of the statement  "                return value => (DateTimeOffset) DateTime.SpecifyKind((DateTime) ValueSerialization.Deserialize(ColumnType.Timestamp' value)' DateTimeKind.Local); " is 146.
Long Statement,CassandraSharp.CQLBinaryProtocol,ValueSerializer<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\ValueSerializer.cs,GenerateObjectDeserializer,The length of the statement  "                var dictionaryTypeDef = type.GetInterfaces().FirstOrDefault(x => x.IsGenericType && x.GetGenericTypeDefinition() == typeof(IDictionary<'>)); " is 140.
Long Statement,CassandraSharp.CQLBinaryProtocol,ValueSerializer<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\ValueSerializer.cs,GenerateObjectDeserializer,The length of the statement  "                var listTypeDef = type.GetInterfaces().FirstOrDefault(x => x.IsGenericType && x.GetGenericTypeDefinition() == typeof(IList<>)); " is 127.
Long Statement,CassandraSharp.CQLBinaryProtocol,ValueSerializer<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\ValueSerializer.cs,GenerateObjectDeserializer,The length of the statement  "            var hashSetTypeDef = type.GetInterfaces().FirstOrDefault(x => x.IsGenericType && x.GetGenericTypeDefinition() == typeof(ISet<>)); " is 129.
Long Statement,CassandraSharp.CQLBinaryProtocol,ValueSerializer<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\ValueSerializer.cs,GenerateObjectDeserializer,The length of the statement  "            throw new NotSupportedException(string.Format("Type {0} neither belongs to Cassandra native types nor has custom serializer defined. Use CassandraTypeSerializerAttribute to define custom type serializer to store data inside Blob column."' type.FullName)); " is 255.
Long Statement,CassandraSharp.CQLBinaryProtocol.Queries,CqlQuery<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\Queries\CqlQuery.cs,ReadColumnSpecs,The length of the statement  "                columnSpecs[colIdx] = new ColumnSpec(colIdx' colKeyspace' colTable' colName' colType' colCustom' colKeyType' colValueType); " is 123.
Long Statement,CassandraSharp.CQLPoco,ClassMap,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLPoco\ClassMap.cs,GetMappedMembers,The length of the statement  "            const BindingFlags bindingFlags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.FlattenHierarchy; " is 135.
Long Statement,CassandraSharp.Discovery,SystemPeersDiscoveryService,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Discovery\SystemPeersDiscoveryService.cs,TryDiscover,The length of the statement  "                var obsLocalPeer = new CqlQuery<DiscoveredPeer>(connection' ConsistencyLevel.ONE' ExecutionFlags.None' "select data_center'rack'tokens from system.local"' " is 154.
Long Statement,CassandraSharp.Discovery,SystemPeersDiscoveryService,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Discovery\SystemPeersDiscoveryService.cs,TryDiscover,The length of the statement  "                obsLocalPeer.Subscribe(x => Notify(connection.Endpoint' x.Datacenter' x.Rack' x.Tokens)' ex => _logger.Error("SystemPeersDiscoveryService failed with error {0}"' ex)); " is 167.
Long Statement,CassandraSharp.Discovery,SystemPeersDiscoveryService,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Discovery\SystemPeersDiscoveryService.cs,TryDiscover,The length of the statement  "                        new CqlQuery<DiscoveredPeer>(connection' ConsistencyLevel.ONE' ExecutionFlags.None' "select rpc_address'data_center'rack'tokens from system.peers"' " is 147.
Long Statement,CassandraSharp.Discovery,SystemPeersDiscoveryService,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Discovery\SystemPeersDiscoveryService.cs,TryDiscover,The length of the statement  "                obsPeers.Subscribe(x => Notify(x.RpcAddress' x.Datacenter' x.Rack' x.Tokens)' ex => _logger.Error("SystemPeersDiscoveryService failed with error {0}"' ex)); " is 156.
Long Statement,CassandraSharp.Enlightenment,ClusterManager,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Enlightenment\ClusterManager.cs,GetCluster,The length of the statement  "            IEnumerable<IPAddress> endpoints = clusterConfig.Endpoints.Servers.Select(Network.Find).Where(x => null != x).ToArray(); " is 120.
Long Statement,CassandraSharp.Enlightenment,ClusterManager,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Enlightenment\ClusterManager.cs,GetCluster,The length of the statement  "            IEndpointStrategy endpointsManager = ServiceActivator<EndpointStrategy.Factory>.Create<IEndpointStrategy>(clusterConfig.Endpoints.Strategy' " is 139.
Long Statement,CassandraSharp.Enlightenment,ClusterManager,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Enlightenment\ClusterManager.cs,GetCluster,The length of the statement  "            IConnectionFactory connectionFactory = ServiceActivator<Transport.Factory>.Create<IConnectionFactory>(transportConfig.Type' transportConfig' keyspaceConfig' _logger' " is 165.
Long Statement,CassandraSharp.Enlightenment,ClusterManager,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Enlightenment\ClusterManager.cs,GetCluster,The length of the statement  "            ICluster cluster = ServiceActivator<Cluster.Factory>.Create<ICluster>(clusterConfig.Type' endpointsManager' _logger' connectionFactory' " is 135.
Long Statement,CassandraSharp.Enlightenment,ClusterManager,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Enlightenment\ClusterManager.cs,GetCluster,The length of the statement  "            IDiscoveryService discoveryService = ServiceActivator<Discovery.Factory>.Create<IDiscoveryService>(clusterConfig.Endpoints.Discovery.Type' " is 138.
Long Statement,CassandraSharp.Enlightenment,ClusterManager,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Enlightenment\ClusterManager.cs,Configure,The length of the statement  "                _recoveryService = ServiceActivator<Recovery.Factory>.Create<IRecoveryService>(config.Recovery.Type' config.Recovery' _logger); " is 127.
Long Statement,CassandraSharp.Enlightenment,ClusterManager,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Enlightenment\ClusterManager.cs,Configure,The length of the statement  "                _instrumentation = ServiceActivator<Instrumentation.Factory>.Create<IInstrumentation>(config.Instrumentation.Type' config.Instrumentation); " is 139.
Long Statement,CassandraSharp.Transport,LongRunningConnection,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\LongRunningConnection.cs,Authenticate,The length of the statement  "            var obsAuth = new AuthenticateQuery(this' ConsistencyLevel.ONE' ExecutionFlags.None' _config.User' _config.Password).AsFuture(); " is 128.
Long Statement,CassandraSharp.Transport,LongRunningConnectionFactory,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\LongRunningConnectionFactory.cs,Create,The length of the statement  "                LongRunningConnection connection = new LongRunningConnection(address' _config' _keyspaceConfig' _logger' _instrumentation); " is 123.
Long Statement,CassandraSharp.Utils,ServiceActivator<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\ServiceActivator.cs,Create,The length of the statement  "                string emptyTypeMsg = string.Format("Expecting nickname or qualified class name for '{0}'"' typeof(TI).AssemblyQualifiedName); " is 126.
Virtual Method Call from Constructor,CassandraSharp.Transport,StreamingFrameReader,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\StreamingFrameReader.cs,StreamingFrameReader,The constructor "StreamingFrameReader" calls a virtual method "CreateStream".
Empty Catch Block,CassandraSharp.Utils,DisposableExtensions,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\DisposableExtensions.cs,SafeDispose,The method has an empty catch block.
Empty Catch Block,CassandraSharp.Utils,ExceptionExtensions,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\ExceptionExtensions.cs,SafeExecute,The method has an empty catch block.
Magic Number,CassandraSharp.Discovery,SystemPeersDiscoveryService,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Discovery\SystemPeersDiscoveryService.cs,SystemPeersDiscoveryService,The following statement contains a magic number: _timer = new Timer(config.Interval*1000);
Magic Number,CassandraSharp.Partitioner,PartitionerBase,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Partitioner\PartitionerBase.cs,ComputeToken,The following statement contains a magic number: int length = keys.Length * 3 + rawValues.Sum(val => val.Length);
Magic Number,CassandraSharp.Partitioner,PartitionerBase,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Partitioner\PartitionerBase.cs,ComputeToken,The following statement contains a magic number: using (var stream = new MemoryStream(length))              {                  foreach (var rawValue in rawValues)                  {                      //write length of composite key part as short                      var len = (short) rawValue.Length;                      stream.WriteByte((byte) (len >> 8));                      stream.WriteByte((byte) (len));                        //write value                      stream.Write(rawValue' 0' len);                        //write terminator byte                      stream.WriteByte(0);                  }                    byte[] buffer = stream.GetBuffer();                  return Hash(buffer' 0' length);              }
Magic Number,CassandraSharp.Recovery,AttemptConnectRecoveryService,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Recovery\AttemptConnectRecoveryService.cs,AttemptConnectRecoveryService,The following statement contains a magic number: _timer = new Timer(config.Interval * 1000);
Magic Number,CassandraSharp.Snitch,RackInferringSnitch,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Snitch\RackInferringSnitch.cs,GetRack,The following statement contains a magic number: string dc = addrBytes[2].ToString(CultureInfo.InvariantCulture);
Magic Number,CassandraSharp.Transport,BufferingFrameWriter,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\BufferingFrameWriter.cs,SendFrame,The following statement contains a magic number: byte[] header = new byte[5];
Magic Number,CassandraSharp.Transport,BufferingFrameWriter,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\BufferingFrameWriter.cs,SendFrame,The following statement contains a magic number: header[2] = (byte)(streamId >> 8);
Magic Number,CassandraSharp.Transport,BufferingFrameWriter,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\BufferingFrameWriter.cs,SendFrame,The following statement contains a magic number: header[2] = (byte)(streamId >> 8);
Magic Number,CassandraSharp.Transport,BufferingFrameWriter,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\BufferingFrameWriter.cs,SendFrame,The following statement contains a magic number: header[3] = (byte)streamId;
Magic Number,CassandraSharp.Transport,BufferingFrameWriter,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\BufferingFrameWriter.cs,SendFrame,The following statement contains a magic number: header[4] = (byte) _msgOpcode;
Magic Number,CassandraSharp.Transport,LongRunningConnection,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\LongRunningConnection.cs,LongRunningConnection,The following statement contains a magic number: try              {                  for (ushort streamId = 0; streamId < MAX_STREAMID; ++streamId)                  {                      _availableStreamIds.Push(streamId);                  }                    _config = config;                  _keyspaceConfig = keyspaceConfig;                  _logger = logger;                  _instrumentation = instrumentation;                    Endpoint = address;                  DefaultConsistencyLevel = config.DefaultConsistencyLevel;                  DefaultExecutionFlags = config.DefaultExecutionFlags;                    _tcpClient = new TcpClient                      {                          ReceiveTimeout = _config.ReceiveTimeout'                          SendTimeout = _config.SendTimeout'                          NoDelay = true'                          LingerState = { Enabled = true' LingerTime = 0 }'                      };                    if(0 < _config.ConnectionTimeout)                  {                      // TODO: refactor this and this probably is not robust in front of error                      IAsyncResult asyncResult = _tcpClient.BeginConnect(address' _config.Port' null' null);                      bool success = asyncResult.AsyncWaitHandle.WaitOne(TimeSpan.FromSeconds(_config.ConnectionTimeout)' true);                        if (! success)                      {                          throw new InvalidOperationException("Connection timeout occured.");                      }                        if (! _tcpClient.Connected)                      {                          _tcpClient.Close();                          throw new InvalidOperationException("Can't connect to node.");                      }                        _tcpClient.EndConnect(asyncResult);                  }                  else                  {                      _tcpClient.Connect(address' _config.Port);                  }                        _socket = _tcpClient.Client;                    _socket.SetSocketOption(SocketOptionLevel.Socket' SocketOptionName.KeepAlive' _config.KeepAlive);                  if (_config.KeepAlive && 0 != _config.KeepAliveTime)                  {                      SetTcpKeepAlive(_socket' _config.KeepAliveTime' 1000);                  }                    _pushResult = _config.ReceiveBuffering                                        ? (Action<QueryInfo' IFrameReader' bool>)((qi' fr' a) => Task.Factory.StartNew(() => PushResult(qi' fr' a)))                                        : PushResult;                  _responseWorker = Task.Factory.StartNew(() => RunWorker(ReadResponse)' TaskCreationOptions.LongRunning);                  _queryWorker = Task.Factory.StartNew(() => RunWorker(SendQuery)' TaskCreationOptions.LongRunning);                    // readify the connection                  _logger.Debug("Readyfying connection for {0}"' Endpoint);                  //GetOptions();                  ReadifyConnection();                  _logger.Debug("Connection to {0} is ready"' Endpoint);              }              catch (Exception ex)              {                  Dispose();                    _logger.Error("Failed building connection {0}"' ex);                  throw;              }
Magic Number,CassandraSharp.Transport,LongRunningConnection,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\LongRunningConnection.cs,SetTcpKeepAlive,The following statement contains a magic number: byte[] inOptionValues = new byte[12];
Magic Number,CassandraSharp.Transport,LongRunningConnection,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\LongRunningConnection.cs,SetTcpKeepAlive,The following statement contains a magic number: BitConverter.GetBytes(keepaliveTime).CopyTo(inOptionValues' 4);
Magic Number,CassandraSharp.Transport,LongRunningConnection,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\LongRunningConnection.cs,SetTcpKeepAlive,The following statement contains a magic number: BitConverter.GetBytes(keepaliveInterval).CopyTo(inOptionValues' 8);
Magic Number,CassandraSharp.Transport,SocketReadOnlyStream,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\SocketReadOnlyStream.cs,Dispose,The following statement contains a magic number: if (disposing)              {                  byte[] buffer = new byte[32];                    // skip unread data                  while (0 < _len)                  {                      int left = Math.Min(_len' buffer.Length);                      _len -= SocketReceiveBuffer(_socket' buffer' 0' left);                  }              }
Magic Number,CassandraSharp.Transport,StreamingFrameReader,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\StreamingFrameReader.cs,StreamingFrameReader,The following statement contains a magic number: try              {                  SocketReadOnlyStream.SocketReceiveBuffer(socket' _tempBuffer' 0' 9);                    FrameType version = (FrameType) _tempBuffer[0];                  if (0 == (version & FrameType.Response))                  {                      throw new ArgumentException("Expecting response frame");                  }                  if (FrameType.ProtocolVersion != (version & FrameType.ProtocolVersionMask))                  {                      throw new ArgumentException("Unknown protocol version");                  }                    FrameHeaderFlags flags = (FrameHeaderFlags) _tempBuffer[1];                    StreamId = (ushort)((_tempBuffer[2] << 8) | _tempBuffer[3]);                    MessageOpcode = (MessageOpcodes) _tempBuffer[4];                  int frameBytesLeft = _tempBuffer.ToInt(5);                    bool tracing = 0 != (flags & FrameHeaderFlags.Tracing);                  if (tracing)                  {                      SocketReadOnlyStream.SocketReceiveBuffer(socket' _tempBuffer' 0' 16);                      frameBytesLeft -= 16;                        TraceId = _tempBuffer.ToGuid();                  }    // ReSharper disable DoNotCallOverridableMethodsInConstructor                  ReadOnlyStream = CreateStream(socket' frameBytesLeft);  // ReSharper restore DoNotCallOverridableMethodsInConstructor                    if (MessageOpcodes.Error == MessageOpcode)                  {                      ResponseException = CreateExceptionFromError(ReadOnlyStream);                  }              }              catch              {                  Dispose();                  throw;              }
Magic Number,CassandraSharp.Transport,StreamingFrameReader,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\StreamingFrameReader.cs,StreamingFrameReader,The following statement contains a magic number: try              {                  SocketReadOnlyStream.SocketReceiveBuffer(socket' _tempBuffer' 0' 9);                    FrameType version = (FrameType) _tempBuffer[0];                  if (0 == (version & FrameType.Response))                  {                      throw new ArgumentException("Expecting response frame");                  }                  if (FrameType.ProtocolVersion != (version & FrameType.ProtocolVersionMask))                  {                      throw new ArgumentException("Unknown protocol version");                  }                    FrameHeaderFlags flags = (FrameHeaderFlags) _tempBuffer[1];                    StreamId = (ushort)((_tempBuffer[2] << 8) | _tempBuffer[3]);                    MessageOpcode = (MessageOpcodes) _tempBuffer[4];                  int frameBytesLeft = _tempBuffer.ToInt(5);                    bool tracing = 0 != (flags & FrameHeaderFlags.Tracing);                  if (tracing)                  {                      SocketReadOnlyStream.SocketReceiveBuffer(socket' _tempBuffer' 0' 16);                      frameBytesLeft -= 16;                        TraceId = _tempBuffer.ToGuid();                  }    // ReSharper disable DoNotCallOverridableMethodsInConstructor                  ReadOnlyStream = CreateStream(socket' frameBytesLeft);  // ReSharper restore DoNotCallOverridableMethodsInConstructor                    if (MessageOpcodes.Error == MessageOpcode)                  {                      ResponseException = CreateExceptionFromError(ReadOnlyStream);                  }              }              catch              {                  Dispose();                  throw;              }
Magic Number,CassandraSharp.Transport,StreamingFrameReader,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\StreamingFrameReader.cs,StreamingFrameReader,The following statement contains a magic number: try              {                  SocketReadOnlyStream.SocketReceiveBuffer(socket' _tempBuffer' 0' 9);                    FrameType version = (FrameType) _tempBuffer[0];                  if (0 == (version & FrameType.Response))                  {                      throw new ArgumentException("Expecting response frame");                  }                  if (FrameType.ProtocolVersion != (version & FrameType.ProtocolVersionMask))                  {                      throw new ArgumentException("Unknown protocol version");                  }                    FrameHeaderFlags flags = (FrameHeaderFlags) _tempBuffer[1];                    StreamId = (ushort)((_tempBuffer[2] << 8) | _tempBuffer[3]);                    MessageOpcode = (MessageOpcodes) _tempBuffer[4];                  int frameBytesLeft = _tempBuffer.ToInt(5);                    bool tracing = 0 != (flags & FrameHeaderFlags.Tracing);                  if (tracing)                  {                      SocketReadOnlyStream.SocketReceiveBuffer(socket' _tempBuffer' 0' 16);                      frameBytesLeft -= 16;                        TraceId = _tempBuffer.ToGuid();                  }    // ReSharper disable DoNotCallOverridableMethodsInConstructor                  ReadOnlyStream = CreateStream(socket' frameBytesLeft);  // ReSharper restore DoNotCallOverridableMethodsInConstructor                    if (MessageOpcodes.Error == MessageOpcode)                  {                      ResponseException = CreateExceptionFromError(ReadOnlyStream);                  }              }              catch              {                  Dispose();                  throw;              }
Magic Number,CassandraSharp.Transport,StreamingFrameReader,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\StreamingFrameReader.cs,StreamingFrameReader,The following statement contains a magic number: try              {                  SocketReadOnlyStream.SocketReceiveBuffer(socket' _tempBuffer' 0' 9);                    FrameType version = (FrameType) _tempBuffer[0];                  if (0 == (version & FrameType.Response))                  {                      throw new ArgumentException("Expecting response frame");                  }                  if (FrameType.ProtocolVersion != (version & FrameType.ProtocolVersionMask))                  {                      throw new ArgumentException("Unknown protocol version");                  }                    FrameHeaderFlags flags = (FrameHeaderFlags) _tempBuffer[1];                    StreamId = (ushort)((_tempBuffer[2] << 8) | _tempBuffer[3]);                    MessageOpcode = (MessageOpcodes) _tempBuffer[4];                  int frameBytesLeft = _tempBuffer.ToInt(5);                    bool tracing = 0 != (flags & FrameHeaderFlags.Tracing);                  if (tracing)                  {                      SocketReadOnlyStream.SocketReceiveBuffer(socket' _tempBuffer' 0' 16);                      frameBytesLeft -= 16;                        TraceId = _tempBuffer.ToGuid();                  }    // ReSharper disable DoNotCallOverridableMethodsInConstructor                  ReadOnlyStream = CreateStream(socket' frameBytesLeft);  // ReSharper restore DoNotCallOverridableMethodsInConstructor                    if (MessageOpcodes.Error == MessageOpcode)                  {                      ResponseException = CreateExceptionFromError(ReadOnlyStream);                  }              }              catch              {                  Dispose();                  throw;              }
Magic Number,CassandraSharp.Transport,StreamingFrameReader,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\StreamingFrameReader.cs,StreamingFrameReader,The following statement contains a magic number: try              {                  SocketReadOnlyStream.SocketReceiveBuffer(socket' _tempBuffer' 0' 9);                    FrameType version = (FrameType) _tempBuffer[0];                  if (0 == (version & FrameType.Response))                  {                      throw new ArgumentException("Expecting response frame");                  }                  if (FrameType.ProtocolVersion != (version & FrameType.ProtocolVersionMask))                  {                      throw new ArgumentException("Unknown protocol version");                  }                    FrameHeaderFlags flags = (FrameHeaderFlags) _tempBuffer[1];                    StreamId = (ushort)((_tempBuffer[2] << 8) | _tempBuffer[3]);                    MessageOpcode = (MessageOpcodes) _tempBuffer[4];                  int frameBytesLeft = _tempBuffer.ToInt(5);                    bool tracing = 0 != (flags & FrameHeaderFlags.Tracing);                  if (tracing)                  {                      SocketReadOnlyStream.SocketReceiveBuffer(socket' _tempBuffer' 0' 16);                      frameBytesLeft -= 16;                        TraceId = _tempBuffer.ToGuid();                  }    // ReSharper disable DoNotCallOverridableMethodsInConstructor                  ReadOnlyStream = CreateStream(socket' frameBytesLeft);  // ReSharper restore DoNotCallOverridableMethodsInConstructor                    if (MessageOpcodes.Error == MessageOpcode)                  {                      ResponseException = CreateExceptionFromError(ReadOnlyStream);                  }              }              catch              {                  Dispose();                  throw;              }
Magic Number,CassandraSharp.Transport,StreamingFrameReader,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\StreamingFrameReader.cs,StreamingFrameReader,The following statement contains a magic number: try              {                  SocketReadOnlyStream.SocketReceiveBuffer(socket' _tempBuffer' 0' 9);                    FrameType version = (FrameType) _tempBuffer[0];                  if (0 == (version & FrameType.Response))                  {                      throw new ArgumentException("Expecting response frame");                  }                  if (FrameType.ProtocolVersion != (version & FrameType.ProtocolVersionMask))                  {                      throw new ArgumentException("Unknown protocol version");                  }                    FrameHeaderFlags flags = (FrameHeaderFlags) _tempBuffer[1];                    StreamId = (ushort)((_tempBuffer[2] << 8) | _tempBuffer[3]);                    MessageOpcode = (MessageOpcodes) _tempBuffer[4];                  int frameBytesLeft = _tempBuffer.ToInt(5);                    bool tracing = 0 != (flags & FrameHeaderFlags.Tracing);                  if (tracing)                  {                      SocketReadOnlyStream.SocketReceiveBuffer(socket' _tempBuffer' 0' 16);                      frameBytesLeft -= 16;                        TraceId = _tempBuffer.ToGuid();                  }    // ReSharper disable DoNotCallOverridableMethodsInConstructor                  ReadOnlyStream = CreateStream(socket' frameBytesLeft);  // ReSharper restore DoNotCallOverridableMethodsInConstructor                    if (MessageOpcodes.Error == MessageOpcode)                  {                      ResponseException = CreateExceptionFromError(ReadOnlyStream);                  }              }              catch              {                  Dispose();                  throw;              }
Magic Number,CassandraSharp.Transport,StreamingFrameReader,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\StreamingFrameReader.cs,StreamingFrameReader,The following statement contains a magic number: try              {                  SocketReadOnlyStream.SocketReceiveBuffer(socket' _tempBuffer' 0' 9);                    FrameType version = (FrameType) _tempBuffer[0];                  if (0 == (version & FrameType.Response))                  {                      throw new ArgumentException("Expecting response frame");                  }                  if (FrameType.ProtocolVersion != (version & FrameType.ProtocolVersionMask))                  {                      throw new ArgumentException("Unknown protocol version");                  }                    FrameHeaderFlags flags = (FrameHeaderFlags) _tempBuffer[1];                    StreamId = (ushort)((_tempBuffer[2] << 8) | _tempBuffer[3]);                    MessageOpcode = (MessageOpcodes) _tempBuffer[4];                  int frameBytesLeft = _tempBuffer.ToInt(5);                    bool tracing = 0 != (flags & FrameHeaderFlags.Tracing);                  if (tracing)                  {                      SocketReadOnlyStream.SocketReceiveBuffer(socket' _tempBuffer' 0' 16);                      frameBytesLeft -= 16;                        TraceId = _tempBuffer.ToGuid();                  }    // ReSharper disable DoNotCallOverridableMethodsInConstructor                  ReadOnlyStream = CreateStream(socket' frameBytesLeft);  // ReSharper restore DoNotCallOverridableMethodsInConstructor                    if (MessageOpcodes.Error == MessageOpcode)                  {                      ResponseException = CreateExceptionFromError(ReadOnlyStream);                  }              }              catch              {                  Dispose();                  throw;              }
Magic Number,CassandraSharp.Transport,StreamingFrameReader,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Transport\StreamingFrameReader.cs,StreamingFrameReader,The following statement contains a magic number: try              {                  SocketReadOnlyStream.SocketReceiveBuffer(socket' _tempBuffer' 0' 9);                    FrameType version = (FrameType) _tempBuffer[0];                  if (0 == (version & FrameType.Response))                  {                      throw new ArgumentException("Expecting response frame");                  }                  if (FrameType.ProtocolVersion != (version & FrameType.ProtocolVersionMask))                  {                      throw new ArgumentException("Unknown protocol version");                  }                    FrameHeaderFlags flags = (FrameHeaderFlags) _tempBuffer[1];                    StreamId = (ushort)((_tempBuffer[2] << 8) | _tempBuffer[3]);                    MessageOpcode = (MessageOpcodes) _tempBuffer[4];                  int frameBytesLeft = _tempBuffer.ToInt(5);                    bool tracing = 0 != (flags & FrameHeaderFlags.Tracing);                  if (tracing)                  {                      SocketReadOnlyStream.SocketReceiveBuffer(socket' _tempBuffer' 0' 16);                      frameBytesLeft -= 16;                        TraceId = _tempBuffer.ToGuid();                  }    // ReSharper disable DoNotCallOverridableMethodsInConstructor                  ReadOnlyStream = CreateStream(socket' frameBytesLeft);  // ReSharper restore DoNotCallOverridableMethodsInConstructor                    if (MessageOpcodes.Error == MessageOpcode)                  {                      ResponseException = CreateExceptionFromError(ReadOnlyStream);                  }              }              catch              {                  Dispose();                  throw;              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,GetBlock,The following statement contains a magic number: int i_8 = index << 3;
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,GetBlock,The following statement contains a magic number: return ((long) key[blockOffset + 0] & 0xff) + (((long) key[blockOffset + 1] & 0xff) << 8) +                     (((long) key[blockOffset + 2] & 0xff) << 16) + (((long) key[blockOffset + 3] & 0xff) << 24) +                     (((long) key[blockOffset + 4] & 0xff) << 32) + (((long) key[blockOffset + 5] & 0xff) << 40) +                     (((long) key[blockOffset + 6] & 0xff) << 48) + (((long) key[blockOffset + 7] & 0xff) << 56);
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,GetBlock,The following statement contains a magic number: return ((long) key[blockOffset + 0] & 0xff) + (((long) key[blockOffset + 1] & 0xff) << 8) +                     (((long) key[blockOffset + 2] & 0xff) << 16) + (((long) key[blockOffset + 3] & 0xff) << 24) +                     (((long) key[blockOffset + 4] & 0xff) << 32) + (((long) key[blockOffset + 5] & 0xff) << 40) +                     (((long) key[blockOffset + 6] & 0xff) << 48) + (((long) key[blockOffset + 7] & 0xff) << 56);
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,GetBlock,The following statement contains a magic number: return ((long) key[blockOffset + 0] & 0xff) + (((long) key[blockOffset + 1] & 0xff) << 8) +                     (((long) key[blockOffset + 2] & 0xff) << 16) + (((long) key[blockOffset + 3] & 0xff) << 24) +                     (((long) key[blockOffset + 4] & 0xff) << 32) + (((long) key[blockOffset + 5] & 0xff) << 40) +                     (((long) key[blockOffset + 6] & 0xff) << 48) + (((long) key[blockOffset + 7] & 0xff) << 56);
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,GetBlock,The following statement contains a magic number: return ((long) key[blockOffset + 0] & 0xff) + (((long) key[blockOffset + 1] & 0xff) << 8) +                     (((long) key[blockOffset + 2] & 0xff) << 16) + (((long) key[blockOffset + 3] & 0xff) << 24) +                     (((long) key[blockOffset + 4] & 0xff) << 32) + (((long) key[blockOffset + 5] & 0xff) << 40) +                     (((long) key[blockOffset + 6] & 0xff) << 48) + (((long) key[blockOffset + 7] & 0xff) << 56);
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,GetBlock,The following statement contains a magic number: return ((long) key[blockOffset + 0] & 0xff) + (((long) key[blockOffset + 1] & 0xff) << 8) +                     (((long) key[blockOffset + 2] & 0xff) << 16) + (((long) key[blockOffset + 3] & 0xff) << 24) +                     (((long) key[blockOffset + 4] & 0xff) << 32) + (((long) key[blockOffset + 5] & 0xff) << 40) +                     (((long) key[blockOffset + 6] & 0xff) << 48) + (((long) key[blockOffset + 7] & 0xff) << 56);
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,GetBlock,The following statement contains a magic number: return ((long) key[blockOffset + 0] & 0xff) + (((long) key[blockOffset + 1] & 0xff) << 8) +                     (((long) key[blockOffset + 2] & 0xff) << 16) + (((long) key[blockOffset + 3] & 0xff) << 24) +                     (((long) key[blockOffset + 4] & 0xff) << 32) + (((long) key[blockOffset + 5] & 0xff) << 40) +                     (((long) key[blockOffset + 6] & 0xff) << 48) + (((long) key[blockOffset + 7] & 0xff) << 56);
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,GetBlock,The following statement contains a magic number: return ((long) key[blockOffset + 0] & 0xff) + (((long) key[blockOffset + 1] & 0xff) << 8) +                     (((long) key[blockOffset + 2] & 0xff) << 16) + (((long) key[blockOffset + 3] & 0xff) << 24) +                     (((long) key[blockOffset + 4] & 0xff) << 32) + (((long) key[blockOffset + 5] & 0xff) << 40) +                     (((long) key[blockOffset + 6] & 0xff) << 48) + (((long) key[blockOffset + 7] & 0xff) << 56);
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,GetBlock,The following statement contains a magic number: return ((long) key[blockOffset + 0] & 0xff) + (((long) key[blockOffset + 1] & 0xff) << 8) +                     (((long) key[blockOffset + 2] & 0xff) << 16) + (((long) key[blockOffset + 3] & 0xff) << 24) +                     (((long) key[blockOffset + 4] & 0xff) << 32) + (((long) key[blockOffset + 5] & 0xff) << 40) +                     (((long) key[blockOffset + 6] & 0xff) << 48) + (((long) key[blockOffset + 7] & 0xff) << 56);
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,GetBlock,The following statement contains a magic number: return ((long) key[blockOffset + 0] & 0xff) + (((long) key[blockOffset + 1] & 0xff) << 8) +                     (((long) key[blockOffset + 2] & 0xff) << 16) + (((long) key[blockOffset + 3] & 0xff) << 24) +                     (((long) key[blockOffset + 4] & 0xff) << 32) + (((long) key[blockOffset + 5] & 0xff) << 40) +                     (((long) key[blockOffset + 6] & 0xff) << 48) + (((long) key[blockOffset + 7] & 0xff) << 56);
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,GetBlock,The following statement contains a magic number: return ((long) key[blockOffset + 0] & 0xff) + (((long) key[blockOffset + 1] & 0xff) << 8) +                     (((long) key[blockOffset + 2] & 0xff) << 16) + (((long) key[blockOffset + 3] & 0xff) << 24) +                     (((long) key[blockOffset + 4] & 0xff) << 32) + (((long) key[blockOffset + 5] & 0xff) << 40) +                     (((long) key[blockOffset + 6] & 0xff) << 48) + (((long) key[blockOffset + 7] & 0xff) << 56);
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,GetBlock,The following statement contains a magic number: return ((long) key[blockOffset + 0] & 0xff) + (((long) key[blockOffset + 1] & 0xff) << 8) +                     (((long) key[blockOffset + 2] & 0xff) << 16) + (((long) key[blockOffset + 3] & 0xff) << 24) +                     (((long) key[blockOffset + 4] & 0xff) << 32) + (((long) key[blockOffset + 5] & 0xff) << 40) +                     (((long) key[blockOffset + 6] & 0xff) << 48) + (((long) key[blockOffset + 7] & 0xff) << 56);
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,GetBlock,The following statement contains a magic number: return ((long) key[blockOffset + 0] & 0xff) + (((long) key[blockOffset + 1] & 0xff) << 8) +                     (((long) key[blockOffset + 2] & 0xff) << 16) + (((long) key[blockOffset + 3] & 0xff) << 24) +                     (((long) key[blockOffset + 4] & 0xff) << 32) + (((long) key[blockOffset + 5] & 0xff) << 40) +                     (((long) key[blockOffset + 6] & 0xff) << 48) + (((long) key[blockOffset + 7] & 0xff) << 56);
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,GetBlock,The following statement contains a magic number: return ((long) key[blockOffset + 0] & 0xff) + (((long) key[blockOffset + 1] & 0xff) << 8) +                     (((long) key[blockOffset + 2] & 0xff) << 16) + (((long) key[blockOffset + 3] & 0xff) << 24) +                     (((long) key[blockOffset + 4] & 0xff) << 32) + (((long) key[blockOffset + 5] & 0xff) << 40) +                     (((long) key[blockOffset + 6] & 0xff) << 48) + (((long) key[blockOffset + 7] & 0xff) << 56);
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Rotl64,The following statement contains a magic number: return ((v << n) | ((long) ((ulong) v >> (64 - n))));
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Fmix,The following statement contains a magic number: k ^= (long) ((ulong) k >> 33);
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Fmix,The following statement contains a magic number: k ^= (long) ((ulong) k >> 33);
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Fmix,The following statement contains a magic number: k ^= (long) ((ulong) k >> 33);
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: int nblocks = length >> 4;
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: for (int i = 0; i < nblocks; i++)              {                  long k1 = GetBlock(key' offset' i * 2 + 0);                  long k2 = GetBlock(key' offset' i * 2 + 1);                    k1 *= c1;                  k1 = Rotl64(k1' 31);                  k1 *= c2;                  h1 ^= k1;                    h1 = Rotl64(h1' 27);                  h1 += h2;                  h1 = h1 * 5 + 0x52dce729;                    k2 *= c2;                  k2 = Rotl64(k2' 33);                  k2 *= c1;                  h2 ^= k2;                    h2 = Rotl64(h2' 31);                  h2 += h1;                  h2 = h2 * 5 + 0x38495ab5;              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: for (int i = 0; i < nblocks; i++)              {                  long k1 = GetBlock(key' offset' i * 2 + 0);                  long k2 = GetBlock(key' offset' i * 2 + 1);                    k1 *= c1;                  k1 = Rotl64(k1' 31);                  k1 *= c2;                  h1 ^= k1;                    h1 = Rotl64(h1' 27);                  h1 += h2;                  h1 = h1 * 5 + 0x52dce729;                    k2 *= c2;                  k2 = Rotl64(k2' 33);                  k2 *= c1;                  h2 ^= k2;                    h2 = Rotl64(h2' 31);                  h2 += h1;                  h2 = h2 * 5 + 0x38495ab5;              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: for (int i = 0; i < nblocks; i++)              {                  long k1 = GetBlock(key' offset' i * 2 + 0);                  long k2 = GetBlock(key' offset' i * 2 + 1);                    k1 *= c1;                  k1 = Rotl64(k1' 31);                  k1 *= c2;                  h1 ^= k1;                    h1 = Rotl64(h1' 27);                  h1 += h2;                  h1 = h1 * 5 + 0x52dce729;                    k2 *= c2;                  k2 = Rotl64(k2' 33);                  k2 *= c1;                  h2 ^= k2;                    h2 = Rotl64(h2' 31);                  h2 += h1;                  h2 = h2 * 5 + 0x38495ab5;              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: for (int i = 0; i < nblocks; i++)              {                  long k1 = GetBlock(key' offset' i * 2 + 0);                  long k2 = GetBlock(key' offset' i * 2 + 1);                    k1 *= c1;                  k1 = Rotl64(k1' 31);                  k1 *= c2;                  h1 ^= k1;                    h1 = Rotl64(h1' 27);                  h1 += h2;                  h1 = h1 * 5 + 0x52dce729;                    k2 *= c2;                  k2 = Rotl64(k2' 33);                  k2 *= c1;                  h2 ^= k2;                    h2 = Rotl64(h2' 31);                  h2 += h1;                  h2 = h2 * 5 + 0x38495ab5;              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: for (int i = 0; i < nblocks; i++)              {                  long k1 = GetBlock(key' offset' i * 2 + 0);                  long k2 = GetBlock(key' offset' i * 2 + 1);                    k1 *= c1;                  k1 = Rotl64(k1' 31);                  k1 *= c2;                  h1 ^= k1;                    h1 = Rotl64(h1' 27);                  h1 += h2;                  h1 = h1 * 5 + 0x52dce729;                    k2 *= c2;                  k2 = Rotl64(k2' 33);                  k2 *= c1;                  h2 ^= k2;                    h2 = Rotl64(h2' 31);                  h2 += h1;                  h2 = h2 * 5 + 0x38495ab5;              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: for (int i = 0; i < nblocks; i++)              {                  long k1 = GetBlock(key' offset' i * 2 + 0);                  long k2 = GetBlock(key' offset' i * 2 + 1);                    k1 *= c1;                  k1 = Rotl64(k1' 31);                  k1 *= c2;                  h1 ^= k1;                    h1 = Rotl64(h1' 27);                  h1 += h2;                  h1 = h1 * 5 + 0x52dce729;                    k2 *= c2;                  k2 = Rotl64(k2' 33);                  k2 *= c1;                  h2 ^= k2;                    h2 = Rotl64(h2' 31);                  h2 += h1;                  h2 = h2 * 5 + 0x38495ab5;              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: for (int i = 0; i < nblocks; i++)              {                  long k1 = GetBlock(key' offset' i * 2 + 0);                  long k2 = GetBlock(key' offset' i * 2 + 1);                    k1 *= c1;                  k1 = Rotl64(k1' 31);                  k1 *= c2;                  h1 ^= k1;                    h1 = Rotl64(h1' 27);                  h1 += h2;                  h1 = h1 * 5 + 0x52dce729;                    k2 *= c2;                  k2 = Rotl64(k2' 33);                  k2 *= c1;                  h2 ^= k2;                    h2 = Rotl64(h2' 31);                  h2 += h1;                  h2 = h2 * 5 + 0x38495ab5;              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: for (int i = 0; i < nblocks; i++)              {                  long k1 = GetBlock(key' offset' i * 2 + 0);                  long k2 = GetBlock(key' offset' i * 2 + 1);                    k1 *= c1;                  k1 = Rotl64(k1' 31);                  k1 *= c2;                  h1 ^= k1;                    h1 = Rotl64(h1' 27);                  h1 += h2;                  h1 = h1 * 5 + 0x52dce729;                    k2 *= c2;                  k2 = Rotl64(k2' 33);                  k2 *= c1;                  h2 ^= k2;                    h2 = Rotl64(h2' 31);                  h2 += h1;                  h2 = h2 * 5 + 0x38495ab5;              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: offset += nblocks * 16;
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following statement contains a magic number: {                  long k1 = 0;                  long k2 = 0;                    switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }              }
Magic Number,CassandraSharp.Utils.Stream,BigEndianStreamExtensions,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Stream\BigEndianStreamExtensions.cs,ReadUShort,The following statement contains a magic number: byte[] buffer = new byte[2];
Magic Number,CassandraSharp.Utils.Stream,BigEndianStreamExtensions,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Stream\BigEndianStreamExtensions.cs,ReadInt,The following statement contains a magic number: byte[] buffer = new byte[4];
Magic Number,CassandraSharp.Utils.Stream,PrimitiveOnWireExtensions,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Stream\PrimitiveOnWireExtensions.cs,GetBytes,The following statement contains a magic number: buffer.ReverseIfLittleEndian(0' 4);
Magic Number,CassandraSharp.Utils.Stream,PrimitiveOnWireExtensions,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Stream\PrimitiveOnWireExtensions.cs,GetBytes,The following statement contains a magic number: buffer.ReverseIfLittleEndian(4' 2);
Magic Number,CassandraSharp.Utils.Stream,PrimitiveOnWireExtensions,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Stream\PrimitiveOnWireExtensions.cs,GetBytes,The following statement contains a magic number: buffer.ReverseIfLittleEndian(4' 2);
Magic Number,CassandraSharp.Utils.Stream,PrimitiveOnWireExtensions,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Stream\PrimitiveOnWireExtensions.cs,GetBytes,The following statement contains a magic number: buffer.ReverseIfLittleEndian(6' 2);
Magic Number,CassandraSharp.Utils.Stream,PrimitiveOnWireExtensions,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Stream\PrimitiveOnWireExtensions.cs,GetBytes,The following statement contains a magic number: buffer.ReverseIfLittleEndian(6' 2);
Magic Number,CassandraSharp.Utils.Stream,PrimitiveOnWireExtensions,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Stream\PrimitiveOnWireExtensions.cs,ToGuid,The following statement contains a magic number: buffer.ReverseIfLittleEndian(0' 4);
Magic Number,CassandraSharp.Utils.Stream,PrimitiveOnWireExtensions,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Stream\PrimitiveOnWireExtensions.cs,ToGuid,The following statement contains a magic number: buffer.ReverseIfLittleEndian(4' 2);
Magic Number,CassandraSharp.Utils.Stream,PrimitiveOnWireExtensions,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Stream\PrimitiveOnWireExtensions.cs,ToGuid,The following statement contains a magic number: buffer.ReverseIfLittleEndian(4' 2);
Magic Number,CassandraSharp.Utils.Stream,PrimitiveOnWireExtensions,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Stream\PrimitiveOnWireExtensions.cs,ToGuid,The following statement contains a magic number: buffer.ReverseIfLittleEndian(6' 2);
Magic Number,CassandraSharp.Utils.Stream,PrimitiveOnWireExtensions,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Stream\PrimitiveOnWireExtensions.cs,ToGuid,The following statement contains a magic number: buffer.ReverseIfLittleEndian(6' 2);
Missing Default,CassandraSharp.CQLBinaryProtocol.Queries,CqlQuery<T>,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\CQLBinaryProtocol\Queries\CqlQuery.cs,ReadColumnSpecs,The following switch statement is missing a default case: switch (colType)                  {                      case ColumnType.Custom:                          colCustom = stream.ReadString();                          break;                        case ColumnType.List:                      case ColumnType.Set:                          colValueType = (ColumnType)stream.ReadUShort();                          break;                        case ColumnType.Map:                          colKeyType = (ColumnType)stream.ReadUShort();                          colValueType = (ColumnType)stream.ReadUShort();                          break;                  }
Missing Default,CassandraSharp.EndpointStrategy,RoundRobinEndpointStrategy,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\EndpointStrategy\RoundRobinEndpointStrategy.cs,Update,The following switch statement is missing a default case: switch (kind)                  {                      case NotificationKind.Add:                      case NotificationKind.Update:                          if (!_healthyEndpoints.Contains(endpoint) && !_bannedEndpoints.Contains(endpoint))                          {                              _healthyEndpoints.Add(endpoint);                          }                          break;                      case NotificationKind.Remove:                          if (_healthyEndpoints.Contains(endpoint))                          {                              _healthyEndpoints.Remove(endpoint);                          }                          break;                  }
Missing Default,CassandraSharp.EndpointStrategy,TokenRingEndpointStrategy,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\EndpointStrategy\TokenRingEndpointStrategy.cs,Update,The following switch statement is missing a default case: switch (kind)                  {                      case NotificationKind.Add:                          if (!_healthyEndpoints.Contains(endpoint))                          {                              _healthyEndpoints.Add(endpoint);                              _ring.AddOrUpdateNode(peer);                          }                          break;                        case NotificationKind.Update:                          _ring.AddOrUpdateNode(peer);                          break;                        case NotificationKind.Remove:                          if (_healthyEndpoints.Contains(endpoint))                          {                              _healthyEndpoints.Remove(endpoint);                              _ring.RemoveNode(endpoint);                          }                          break;                  }
Missing Default,CassandraSharp.Utils.Cryptography,MurmurHash,C:\repos\pchalamet_cassandra-sharp\CassandraSharp\Utils\Cryptography\MurmurHash3.cs,Hash3_x64_128,The following switch statement is missing a default case: switch (length & 15)                  {                      case 15:                          k2 ^= ((long) key[offset + 14]) << 48;                          goto case 14;                      case 14:                          k2 ^= ((long) key[offset + 13]) << 40;                          goto case 13;                      case 13:                          k2 ^= ((long) key[offset + 12]) << 32;                          goto case 12;                      case 12:                          k2 ^= ((long) key[offset + 11]) << 24;                          goto case 11;                      case 11:                          k2 ^= ((long) key[offset + 10]) << 16;                          goto case 10;                      case 10:                          k2 ^= ((long) key[offset + 9]) << 8;                          goto case 9;                      case 9:                          k2 ^= ((long) key[offset + 8]) << 0;                          k2 *= c2;                          k2 = Rotl64(k2' 33);                          k2 *= c1;                          h2 ^= k2;                          goto case 8;                        case 8:                          k1 ^= ((long) key[offset + 7]) << 56;                          goto case 7;                      case 7:                          k1 ^= ((long) key[offset + 6]) << 48;                          goto case 6;                      case 6:                          k1 ^= ((long) key[offset + 5]) << 40;                          goto case 5;                      case 5:                          k1 ^= ((long) key[offset + 4]) << 32;                          goto case 4;                      case 4:                          k1 ^= ((long) key[offset + 3]) << 24;                          goto case 3;                      case 3:                          k1 ^= ((long) key[offset + 2]) << 16;                          goto case 2;                      case 2:                          k1 ^= ((long) key[offset + 1]) << 8;                          goto case 1;                      case 1:                          k1 ^= (key[offset]);                          k1 *= c1;                          k1 = Rotl64(k1' 31);                          k1 *= c2;                          h1 ^= k1;                          break;                  }
